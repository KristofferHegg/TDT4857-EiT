[
  {
    "text": "TWI init conflicting with BLE initialisation calls Hello. I've used the design template that initialises everything for Bluetooth communication. These are the initialisation calls made in main():\r\n\r\n\n\n```\n// Initialize\r\nleds_init();\r\ntimers_init();\r\ngpiote_init();\r\nbuttons_init();\r\nble_stack_init();\r\nscheduler_init();\r\ngap_params_init();\r\nadvertising_init();\r\nservices_init();\r\nconn_params_init();\r\nsec_params_init();\r\n    \r\n// Start execution\r\ntimers_start();\r\nadvertising_start();\n```\n\r\n\r\nI then add a TWI init call from the \"TWI master\" example, but that hangs the chip (nRF51822) during the execution of the TWI initialisation routine. If I comment out some of the other initialisation calls, like so\r\n\r\n\n\n```\n// Initialize\r\nleds_init();\r\ntimers_init();\r\ngpiote_init();\r\nbuttons_init();\r\n//ble_stack_init();\r\nscheduler_init();\r\n//gap_params_init();\r\n//advertising_init();\r\nservices_init();\r\n//conn_params_init();\r\nsec_params_init();\r\n    \r\n// Start execution\r\ntimers_start();\r\n//advertising_start();\n```\n\r\n\r\ntwi_init() does not hang, and I'm able to talk to my peripheral over the TWI bus. Before I go investigate more closely why this happens, I was wondering if anyone else has experienced this before, and what might be a possible solution. I'm using the pin assignment from the example code if that's relevant:\r\n\r\n\n\n```\n\r\n#define TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER (24U)\r\n#define TWI_MASTER_CONFIG_DATA_PIN_NUMBER (25U)\n```\n",
    "tag": "twi"
  },
  {
    "text": "Services initialisation and setup template? Now that I have TWI and the BLE stack initialising, I'd like to create services. The Server (peripheral) sends out a few bytes to the client when a local trigger happens, and also needs to be able to accept bytes from the client whenever they are sent. Which is the best service template I should start out with? I'm looking at the heart rate service, but that seems too complicated to start out with. Any other pointers? Thanks!\r\n\r\nEDIT: I'm a bit confused about \"services\". The general recommendation on the forum seems to be to use the battery services as a template, but Nordic people also strongly state that the API cannot change. How then is this considered a template? My understanding is that I have to create a new service, but I cannot find a resource that shows me how to do that. Pretty frustrating.",
    "tag": "twi"
  },
  {
    "text": "Triggering a task when a TIMER event I'm looking at the led.c example in the heart rate monitor example. What this shows is how to tie a TIMER event to toggling an LED. I understand most of the mechanism there. The novice that I am, it is not clear to me, however, how I'd connect that event to trigger a custom task (in my case, reading data from a TWI peripheral). Any code examples, documentation, or sample code out there?\r\n\r\nThanks!",
    "tag": "twi"
  },
  {
    "text": "Triggering a task when a TIMER event I'm looking at the led.c example in the heart rate monitor example. What this shows is how to tie a TIMER event to toggling an LED. I understand most of the mechanism there. The novice that I am, it is not clear to me, however, how I'd connect that event to trigger a custom task (in my case, reading data from a TWI peripheral). Any code examples, documentation, or sample code out there?\r\n\r\nThanks!",
    "tag": "timer"
  },
  {
    "text": "Timer configuration with Softdevice Hi,\r\n\r\nmi question is about how to configure in a good and complete way Timer1 and Timer2, so trying to be more specific with my Question:\r\n     I need timers with a Tick of 250ns, and as far as i know is that i could it make with Timer1 or 2 but not Timer0 (because of the Soft-device), but with the HFCLK ( the RTC use the internal and couldn\u00b4t achieve my 250ns tick).\r\n      One of them i will use for making delays, and the other to count how many ticks till a change in one pin happens. \r\n       \r\n(I\u00b4m working with the nRF6310 with PCA10004 and PCA10000)",
    "tag": "timer"
  },
  {
    "text": "comprehension question Timer Hi,\r\n\r\nmaybe i have a silly question, but i didn't programm timers before.  I know how they work. But how is it possible that there are only three Timers in the 51822 and so many parts of the programm part (PWM,BLE,GPIOTE...) which need a timer? How can i organize my timers? \r\n\r\nand is it possible to run one timer and write a function like \"get_actual_time\" which gives me the time in the moment i call the function?\r\n\r\nBest reagards, Nils :)",
    "tag": "timer"
  },
  {
    "text": "nRF51822 timer problems Hi, I've been trying to use the timers on nRF51822 but I just can't get them to work in my code. When debugging (with GDB and Eclipse), the execution always stops with the following error:\r\nNo source available for \"\"\r\n\r\ntimer_test [GDB Hardware Debugging]\t\r\n\tGDB Hardware Debugger (31.07.13 12:41) (Suspended)\t\r\n\t\tThread [1] (Suspended: Signal 'SIGTRAP' received. Description: Trace/breakpoint trap.)\t\r\n\t\t\t10 <symbol is not available> 0xfffffffe\t\r\n\t\t\t9 <signal handler called>()  0xfffffff1\t\r\n\t\t\t8 <symbol is not available> 0x00011488\t\r\n\t\t\t7 <signal handler called>()  0xfffffff9\t\r\n\t\t\t6 NVIC_SetPendingIRQ() core_cm0.h:558 0x00014810\t\r\n\t\t\t5 timer_list_handler_sched() app_timer.c:324 0x00014ec6\t\r\n\t\t\t4 timer_start_op_schedule() app_timer.c:786 0x00015610\t\r\n\t\t\t3 app_timer_start() app_timer.c:1026 0x000159e0\t\r\n\t\t\t2 timers_start() main.c:86 0x00014690\t\r\n\t\t\t1 main() main.c:124 0x0001477c\t\r\n\tarm-none-eabi-gdb (31.07.13 12:41)\t\r\n\tC:\\workspace\\Nordic Semiconductor\\nRF51 SDK_v4.3.0.27417\\Nordic\\nrf51822\\Board\\pca10001\\ble\\timer_test\\gcc\\_build\\timer_test_bin_s110_xxaa.out (31.07.13 12:41)\t\r\n\r\nIt seems to happen right when the function app_timer_start is called. It doesn't happen in any of the examples which use timers, but anytime I try to use them i get this error, so I must be doing something wrong but I have no idea what.\r\nAttached is a small project, which I modified from ble_app_template example, where I tried to get the timers working - maybe somebody can look at it and tell me what's wrong.\n\n[timer_test.zip](/attachment/c2a9b2892dc00293a5a51bdaf5e1cc67)",
    "tag": "timer"
  },
  {
    "text": "More PWM Channels? Hi,\r\n\r\ni get the example for using PWM to run and modfied it to use it in my application. My Prolem is that i only have one PWM Output toggle Pin. How can i build a second PWM output, i read that i can build 4 PWM Outputs. I only want to use one timer for my two pwm outputs but how?\r\n\r\nbest regards Nils",
    "tag": "timer"
  },
  {
    "text": "Function address as PPI \"Task End-Point\" Hi,\r\n\r\nIs it possible to give a function address to the \"Task End-Point\" of a PPI channel?\r\n\r\nLike :\r\n\r\n\n\n```\n    err_code = sd_ppi_channel_assign(PPI_CHAN0_TO_TOGGLE_LED,\r\n                           &(NRF_TIMER1->EVENTS_COMPARE[0]),\r\n                           &(myTestFunction));\n```\n\r\n\r\nOr the only accepted TEP are timer and GPIOTE tasks?\r\n\r\nThanks",
    "tag": "timer"
  },
  {
    "text": "Soft Device app_timer lib : what is the maximum number of timers Dear Nordic support team, \r\n\r\nWhat is the maximum number of timers that I can create (and use) using the app_timer lib?\r\n\r\n\n\n```\n    err_code = app_timer_create(&m_timer_m_1_0,\r\n                                APP_TIMER_MODE_REPEATED,\r\n                                timer_m_1_0_timeout_handler);\n```\n\t\r\n\r\nI have tried to initializate 10 timers this morning which are not all involved at the same times. It seems to work, but I can't find the limitation in the source code app_timer.c or in the documentation.\r\n\r\nAnd same question for the maximum number of the \"operation queues size\".\r\n\r\nBest regards",
    "tag": "timer"
  },
  {
    "text": "How to redefine PPI tasks inside a TIMER interrupt ??? Dear Nordic Developer Zone,\r\n\r\nI am working on a BLE application using nrf51822 with **softDevice**.\r\n\r\nMy aim is to be able to redefine which GPIOTE channel my PPI is using inside the TIMER1 interrupt under logical conditions. \r\n\r\nUnfortunately, all softdevice calls to modify the PPI (sd_ppi_X) in the TIMER1 interrupt doesn't work and crash the app ?!\r\n\r\n\r\nIt should be trivial, but I can't figure it out by myself... I am able to redefine the PPI tasks in my app functions, but not inside interrupt.\r\n\r\nIs there someone to help me? Here is my code.\r\n\r\n\n\n```\n\r\nstatic uint32_t                               m_counter = 0; \r\n\r\nvoid TIMER1_IRQHandler(void)\r\n{\r\n\tuint32_t err_code;\r\n\t\r\n  if ((NRF_TIMER1->EVENTS_COMPARE[0] != 0) && ((NRF_TIMER1->INTENSET & TIMER_INTENSET_COMPARE0_Msk) != 0))\r\n  {\r\n\t//Reinit comparator\t\r\n        NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n\t\r\n        m_counter = m_counter +1;\r\n\r\n        if(m_counter == 5)\r\n        {\r\n\t     //-->PPI call here crash the app\r\n             //! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n    \t    sd_ppi_channel_assign(0, &(NRF_TIMER1->EVENTS_COMPARE[0]), &(NRF_GPIOTE->TASKS_OUT[1]));\r\n        }\r\n\r\n\t//Toggle led to have a visual feedback that the application didn't crash\r\n\tnrf_gpio_pin_toggle(17);//Devkit\r\n  }\r\n}\r\n\r\n/**\r\n * main function\r\n * \\return 0. int return type required by ANSI/ISO standard.\r\n */\r\nvoid rtc_test(void)\r\n{\r\n\tuint32_t err_code;\r\n\t\r\n\tnrf_gpio_cfg_output(M1_A0_PIN);\r\n\tnrf_gpio_cfg_output(M1_B0_PIN);\r\n\tnrf_gpio_cfg_output(M1_C0_PIN);\r\n\t\r\n\t// Configure timer\r\n\tNRF_TIMER1->MODE = TIMER_MODE_MODE_Timer;\r\n\tNRF_TIMER1->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n\tNRF_TIMER1->PRESCALER = 9;   // 31.25kHz ? 32us tick \r\n\tNRF_TIMER1->TASKS_CLEAR = 1;  // Clear the timer\r\n\tNRF_TIMER1->CC[0] = 0x1E84;  // CC[0] occurs at 250ms from START\r\n\t\r\n\t// Configure the shortcut to clear and restart on Compare[0]\r\n\tNRF_TIMER1->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos); \r\n\t\r\n\tNRF_TIMER1->INTENSET = (1UL << TIMER_INTENSET_COMPARE0_Pos);\r\n\tNVIC_EnableIRQ(TIMER1_IRQn);\r\n\t\r\n\t// Configure the GPIOTE Task to toggle the LED state. \r\n\tnrf_gpiote_task_config(0,  // GPIOTE Channel\r\n\t\t\t\t\tM1_A0_PIN, // GPIO pin\r\n\t\t\t\t\tNRF_GPIOTE_POLARITY_TOGGLE,\r\n\t\t\t\t\tNRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n\r\n\t// Configure the GPIOTE Task to toggle the LED state. \r\n\tnrf_gpiote_task_config(1,  // GPIOTE Channel\r\n\t\t\t\t\tM1_B0_PIN, // GPIO pin\r\n\t\t\t\t\tNRF_GPIOTE_POLARITY_TOGGLE,\r\n\t\t\t\t\tNRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t//Configure PPI\r\n\terr_code = sd_ppi_channel_assign(0, &(NRF_TIMER1->EVENTS_COMPARE[0]), &(NRF_GPIOTE->TASKS_OUT[0]));\r\n\t// Enable PPI channel 0\r\n\terr_code = sd_ppi_channel_enable_set(PPI_CHEN_CH0_Msk);\r\n\r\n\tNRF_TIMER1->TASKS_START = 1;\r\n}\n```\n",
    "tag": "timer"
  },
  {
    "text": "What to do with APP_UART_COMMUNICATION_ERROR? Hi, I am working with app_uart module and during the reception process sometimes there will be APP_UART_COMMUNICATION_ERROR event generated,  my question is why there is such errors? And is it possible for us to do some error recovery?\r\n\r\nBTW, if we have both BLE and UART running on the nRF51822 chip, what is the highest Baud Rate the chip can offer?",
    "tag": "uart"
  },
  {
    "text": "Ho to change power off mode? Hi,\r\n\r\nhow can i change that my programm doesen't go to power off mode?\r\nI use the ble templete.\r\n\r\nBest regards Nils",
    "tag": "timer"
  },
  {
    "text": "How to use app_button and wake up? Hi,\r\n\r\ni need to start my application while pressing two seconds  a button. For this i use an gpiote event like here --> https://devzone.nordicsemi.com/index.php/how-to-use-app_timer_cnt_diff_compute.\r\nBut when i want to start my application i first have to push the button and than hold it for 2 seconds, then the application starts. If i hold the button for 2 seconds without push it before the system doesen't wake up. How can i configure that my app_button is a wakeup button?\r\n\r\nbest regards Nils",
    "tag": "timer"
  },
  {
    "text": "What's the maximum of baud rate supported of UART? Hi, I have been trying to maximize the baud rate of my uart module, I am using the app_uart layer to control the uart and I have noticed that in your implementation of HCI you have set the baud rate to be 38400, and it is with hardware flow control. So I am guessing that's pretty much the max baud rate you can get without affecting the performance and robustness of the UART and without flow control the expected baud rate should be lower? Since mine UART constantly run into OVERRUN error so I am guessing the baud rate I set is too high?",
    "tag": "uart"
  },
  {
    "text": " TWI SHORTS register. Hello,\r\n\r\nAbout TWI in \"nRF51_Reference_manual_v1.1.pdf\",there is a register called \"SHORTS\".\r\nI have a few question about this register:\r\n1. Can I use SHORTS register to replace PPI function at \"twi_hw_master.c\".\r\n2. Is there any thing I should do before changing SHORTS register from BB_SUSPEND enable to BB_STOP enable .\r\n\r\nThank you for your attention!\r\nKate",
    "tag": "twi"
  },
  {
    "text": "sd_ppi_channel_xxx funtions Hello,\r\n\r\n    I made a PWM with the TIMER2 of my nRF51822 (with the SoftDevice) and was working fine, till I read that I should not use the \"NRF_PPI\"\tfunctions and use the \"sd_ppi_XXX\". I change them in my code and the PWM doesn\u00b4t work. If I use my old configuration it still work.\r\n\r\nSo my question is if I\u00b4m making something wrong, or I should continue using my old configuration?\r\n\r\n**************************************\r\n// Configure PPI channel 0 to toggle PWM_OUTPUT_PIN on every TIMER2 COMPARE[0] match\r\n err_code = sd_ppi_channel_assign( 0 , &NRF_TIMER2->EVENTS_COMPARE[1], &NRF_GPIOTE->TASKS_OUT[0]);\r\n\r\n//  old  //  NRF_PPI->CH[0].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[1];\r\n//  old  //  NRF_PPI->CH[0].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n\r\n// Configure PPI channel 1 to toggle PWM_OUTPUT_PIN on every TIMER2 COMPARE[1] match\r\n\terr_code = sd_ppi_channel_assign( 1 , &NRF_TIMER2->EVENTS_COMPARE[2], &NRF_GPIOTE->TASKS_OUT[0]);\r\n\r\n//  old  //  NRF_PPI->CH[1].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[2];\r\n//  old  //  NRF_PPI->CH[1].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n\r\n// Enable PPI channels 0-2\r\n\terr_code = sd_ppi_channel_enable_set((PPI_CHEN_CH0_Enabled << PPI_CHEN_CH0_Pos)\r\n                                                                      | (PPI_CHEN_CH1_Enabled << PPI_CHEN_CH1_Pos));\r\n\r\n//  old  //  NRF_PPI->CHEN = (PPI_CHEN_CH0_Enabled << PPI_CHEN_CH0_Pos)\r\n//  old  //                               | (PPI_CHEN_CH1_Enabled << PPI_CHEN_CH1_Pos);\r\n*****************************************\r\n\r\nThanks.",
    "tag": "timer"
  },
  {
    "text": "I2C data interrupt lines I am trying to figure out how interrupts are set up for say a sensor with an interrupt line which signals when new data is ready.\r\n\r\nI am assuming you set up a GPIOTE somehow to trigger an interrupt routine which you can then use to setup the I2C connection, connect to the device, and get the data, after that you could go to sleep again. Is there a simple example for this?\r\n\r\nMuch Thanks!",
    "tag": "twi"
  },
  {
    "text": "I2C data interrupt lines I am trying to figure out how interrupts are set up for say a sensor with an interrupt line which signals when new data is ready.\r\n\r\nI am assuming you set up a GPIOTE somehow to trigger an interrupt routine which you can then use to setup the I2C connection, connect to the device, and get the data, after that you could go to sleep again. Is there a simple example for this?\r\n\r\nMuch Thanks!",
    "tag": "i2c"
  },
  {
    "text": "ADC for higher voltages than VCC? So i am using a LiPo battery at 4.2V and running my nRF51822 at 2.0V. Is it safe to connect the battery to one of the I/O pins to read off the battery voltage (as to calculate battery percentage)?\r\n\r\nMuch Thanks!",
    "tag": "adc"
  },
  {
    "text": "How to get uart_example to work on NRF51822? I am unable to see any uart print output when running the uart_example with NRF51822.  I am able to see the program execute via the debugger, but have not seen any output.  I have tried using it with and without the SoftDevice flashed, using the appropriate build target as required.  I am using the nRF51822 development kit with the nRF6700 starter kit and have it setup following the quick start guidelines.\r\n\r\nAre there additional steps I need to perform to get UART output enabled?  From what I can tell from other posts on this forum, the output is expected to come across on the \"JLink CDC UART Port\"?\r\n\r\nWhat are the exact settings I should be using in my serial terminal application?  I have been using:\r\n\r\nBaud rate: 38400\r\nData: 8 bit\r\nParity: none\r\nStop: 1 bit\r\nFlow Control: none (and also tried Xon/Xoff)\r\n\r\nIf it helps, I am using Tera Term on Windows 7 (x64).",
    "tag": "uart"
  },
  {
    "text": "RTC timer is shiffting after connection/disconnetion Dear Nordic Devloper Zone,\r\n\r\nI am facing a problem with RTC timer.\r\n\r\nHere is a scenario : \r\n\r\nI have an IOS application which is able to set the current time on the nRF51822.\r\n\r\nIn the nRF51822 application, I am using a timer on RTC1 (32kHz) which is triggered every seconds to manage time.\r\n\r\nIn the RTC1 timer interrupt, my application sends a notification to the connected device (IOS app) with the current time (posix format). This time is compared with the IOS app time and the difference must be obviously equal to 0.\r\n\r\nIt is always true when the device is connected to the device. I have tested during 1 day (connected non-stop), and the difference between nRF51822 time sent to the IOS app and the real time (from iPhone) is always 0.\r\n\r\nBut, each time a connection/disconnection occurred, the my RTC timer take 0.5 second late : the posix time sent to the IOS app has several seconds late depending on the number of connection/disconnection that I have done.\r\n\r\nThe RTC interrupt cannot be called to late and miss a second because the next event is planned in the interrupt itself. Therefore, if it is occurred, the interrupt will never be called.\r\n\r\n\n\n```\nvoid RTC1_IRQHandler(void)\r\n{\r\n    NRF_RTC1->CC[3] += TICKS_1_SEC;\t\r\n    //Some code here ....\r\n}\n```\n\r\n\r\nIt is like the RTC1 timer is in \"pause\" during the BLE connection.\r\n\r\nCould you tell me if the RTC timer is stopped during BLE connections?\r\n\r\nBest regards",
    "tag": "timer"
  },
  {
    "text": "LFCLK (32kHz) on a GPIO pin for precision measurement? Dear Nordic Developer Zone,\r\n\r\nIs there a way to set the LFCLK (32kHz) on a GPIO for precision measurement?\r\n\r\nBest regards",
    "tag": "timer"
  },
  {
    "text": "Using NRF51X22 as TWI Slave I am trying to figure out what is the best way to implement a TWI Slave functionality on the Nordic chips. The HW seems only to support the TWI Master.\r\nIs the only way to implement the bus drivers with default GPIO and GPIOTE?\r\nSomebody know if there is already some example code somewhere for this?\r\nThanks for your advice.",
    "tag": "twi"
  },
  {
    "text": "Using NRF51X22 as TWI Slave I am trying to figure out what is the best way to implement a TWI Slave functionality on the Nordic chips. The HW seems only to support the TWI Master.\r\nIs the only way to implement the bus drivers with default GPIO and GPIOTE?\r\nSomebody know if there is already some example code somewhere for this?\r\nThanks for your advice.",
    "tag": "i2c"
  },
  {
    "text": "How to read the value from ADC Hi,\r\n\r\ni want to use the adc, i use the code from here https://devzone.nordicsemi.com/index.php/is-there-an-example-code-for-using-pwm-on-the-nrf51822-with-a-softdevice and it works fine. But i don#t know how to handle the ->Result when i got 5 ADC Channels to use. It would be great if some one can tell me how to use ->Result and how to confert it to some variables\r\n\r\nbest regards Nils",
    "tag": "adc"
  },
  {
    "text": "TWI with Softdevice Enabled So there seems to be a conflict between the TWI and the Softdevice. My I2C communication works over TWI fine in isolation but when i try to send data over ble the TWI doesnt seem to do anything. Are there any examples that use both? Maybe a procedure for initialization orders and wait times for things to work well?\r\n\r\nMuch Thanks",
    "tag": "twi"
  },
  {
    "text": "TWI with Softdevice Enabled So there seems to be a conflict between the TWI and the Softdevice. My I2C communication works over TWI fine in isolation but when i try to send data over ble the TWI doesnt seem to do anything. Are there any examples that use both? Maybe a procedure for initialization orders and wait times for things to work well?\r\n\r\nMuch Thanks",
    "tag": "i2c"
  },
  {
    "text": "Wakeup device with app button Hi,\r\n\r\nis it possible to handle a 2 second button press and wake up the device with the app button modul?\r\nOr should i handle the button without the app button modul to wake up the device after a 2 second press .\r\n\r\nbest regards Nils",
    "tag": "timer"
  },
  {
    "text": "app_timer has crashed on running Hello,\r\n\r\nMy code( I add a source code lower ) has error on bold line printing NRF_ERROR_INVALID_STATE. The program uses three timers and init by \"MAX_TIMERS = 6\" and \"OP_QUEUE_SIZE = 5\". \r\n\r\nBecause of NRF_ERROR_INVALID_STATE, I create new timer before start timer(bold line!) but in that case, app_timer_create() is crashed by NRF_ERROR_NO_MEM. Before I said, the program not use timers over \"MAX_TIMERS = 6\". Even I increase values of \"APP_TIMER_MAX_TIMERS\" and \"APP_TIMER_OP_QUEUE_SIZE\" but same problem occurs.\r\n\r\nI don't know that what is wrong on my code.\r\n\r\nThanks.\r\n\r\n\r\n\n\n```\n\r\nint main() {\r\ntimers_init();\r\nble_start();\r\n\r\nfor (;;)\r\n    {\r\n        uint8_t CurFrm[MAX_BLE_DATA_LENGTH] = {0,};\r\n        \r\n        NVIC_DisableIRQ(UART0_IRQn);\r\n        popFrmQueue(CurFrm);\r\n        NVIC_EnableIRQ(UART0_IRQn);\r\n        \r\n        if ( CurFrm[RF_TYPE_IND] == RFTYPE_RF) {\r\n            ble_stop();\r\n            RF_init(addr); \r\n            memcpy(packet,(CurFrm+1), MAX_BLE_DATA_LENGTH-1);\r\n            RF_send();\r\n            ble_start();\r\n            \r\n        } else if ( CurFrm[RF_TYPE_IND] == RFTYPE_BLE ) {\r\n            \r\n            if ( BLE_CONN_FLAG == true ) {\r\n                err_code = app_timer_start(m_data_send_timer_id, DATA_SEND_INTERVAL, NULL);\r\n                APP_ERROR_CHECK(err_code);\r\n            }\r\n            \r\n            \r\n            TIMEOUT_FLAG = false; // timeout flag init\r\n            **err_code = app_timer_start(m_wait_timer_id, BLE_TX_COMPLTE_WAIT_INTERVAL, NULL);**\r\n            APP_ERROR_CHECK(err_code);\r\n            \r\n            while (BLE_TX_COMPLETE_FLAG != true && BLE_CONN_FLAG == true && TIMEOUT_FLAG != true) { \r\n                err_code = sd_app_event_wait();\r\n                APP_ERROR_CHECK(err_code);\r\n            }\r\n            err_code = app_timer_stop(m_wait_timer_id);\r\n            APP_ERROR_CHECK(err_code);\r\n            \r\n            TIMEOUT_FLAG = false; // timeout flag init\r\n            simple_uart_putstring((const uint8_t *)\"ble tx complete end\\r\\n\");\r\n            if ( BLE_TX_COMPLETE_FLAG == true ) {\r\n                err_code = app_timer_stop(m_data_send_timer_id);\r\n                APP_ERROR_CHECK(err_code);\r\n                BLE_TX_COMPLETE_FLAG = false;\r\n            }\r\n        }\r\nreturn 0;\r\n}\r\n\n```\n",
    "tag": "timer"
  },
  {
    "text": "UART-Gateway Usecase: Custom service? Hi guys,\r\n\r\nI want to use the nRF51822 as a gateway to send uart-commands from the \u00b5C to my iPhone and vice versa.\r\n\r\n\u00b5C---|uart|--->nRF51822 ) ) ) )         BLE        ( ( ( ( iPhone\r\n\r\nDo I need a custom service for that? Or is it sufficient to simply take the BLE_RX Event and put the data into the UART buffer?\r\n\r\nIs there any recommendation on what template to start with?\r\n\r\nThanks for your kind help. This forum is becoming a bigger and bigger help for developing!\r\n\r\nStephan",
    "tag": "uart"
  },
  {
    "text": "Is there any describe about NVIC or Interrupt? I can't find registers about NVIC in REFERENCE MANUAL for nRF51822. Is there any other document?\r\n\r\npls, tell me.",
    "tag": "i2c"
  },
  {
    "text": "What is the current when running ble_app_uart? Do anyone ever measured current consumption of ble_app_uart?\r\n\r\nWhat is current when connected and uart idle, transmitting, receiving, and transmitting while receiving?\r\nPlease provide LEDs status and their current draw. Best to get result without any LED on.",
    "tag": "uart"
  },
  {
    "text": "nRF51822 uart flow control Hello,\r\n\r\nI am using nrf starter kit and nRF51822 DK modules atached. I'm using external usb-com uart modules (based on FT232 chips) for communication with PC (Win7) and hyper terminal clients for data send/receive. Currently I'm experimenting with modified gazell example project to include data received from uart and to transfer between modules as in com cable replacement setup. If I connect usb-com modules directly with each other (thus error free communication) and set baudrate 921600bps, I can transfer data at aproximately 890kpbs transfer rate (using zmodem file transfer). Now i'm trying to include radio transfer in data path. Uart is configured with hardware flow control, uart module on nrf51 is configured on high priority with extended buffering (fifo like size of 1kB) and aditional checking for receive buffer usage to stop and start RX transfers. Uart Error interrupt is enabled and i'm getting several errors representing Buffer overflow during large data chunk receive (3-15kB in size). I'm guessing that hardware flow control is not quick enough to prevent RX register overwriting. Another issue is stopping RX transfer without data loss. I'm thinking that it could be possible to use aditional I/O for RTS/CTS manual control together with uart hardware to pause Rx transfers correctly. What solutions could be usable to correct flow control not lowering baudrate? as this is the basis of transportation layer for later tasks.",
    "tag": "uart"
  },
  {
    "text": "nRF51822 how many UARTS It sounds like the nRF51822 has 1 UART, or possibly several can be defined from GPIO. Which is it?  Can I get 2?",
    "tag": "uart"
  },
  {
    "text": "How to stopp uart? Hi,\r\n\r\nhow is it possible to stop the uart modul after it was running?\r\n\r\nWhich perepherie is running after init the uart modul?\r\n\r\nbest regards Nils",
    "tag": "timer"
  },
  {
    "text": "nRF51422 communicating with SAA1064 via TWI/I2C The last few weeks I'm working with the nRF51422 and run in to several TWI/I2C issues. All of them I could solve except an issue with a SAA1064 7segment display driver from NXP.\r\n\r\nDepending the device selection the I2C address of the SAA1064 should be 0x70, 0x72,0x74 or 0x76. When communicating non of these address will return an ACK. I'm using sd_twi_hw_master.c. \r\n\r\nI do have TWI/I2C running because I can communicate with the MPU-9150 and an other sensor. But it fails on the SAA1064.\r\n\r\nIs there maybe a small difference/issue with TWI and I2C?\r\n\r\nDoes anybody know where to look to solve this issue?",
    "tag": "twi"
  },
  {
    "text": "nRF51422 communicating with SAA1064 via TWI/I2C The last few weeks I'm working with the nRF51422 and run in to several TWI/I2C issues. All of them I could solve except an issue with a SAA1064 7segment display driver from NXP.\r\n\r\nDepending the device selection the I2C address of the SAA1064 should be 0x70, 0x72,0x74 or 0x76. When communicating non of these address will return an ACK. I'm using sd_twi_hw_master.c. \r\n\r\nI do have TWI/I2C running because I can communicate with the MPU-9150 and an other sensor. But it fails on the SAA1064.\r\n\r\nIs there maybe a small difference/issue with TWI and I2C?\r\n\r\nDoes anybody know where to look to solve this issue?",
    "tag": "i2c"
  },
  {
    "text": "Is app_timer incompatible with Gazell? Both app_timer.c and gzll_gcc.a seem to have a reference to \"SWI0_IRQHandler\".",
    "tag": "timer"
  },
  {
    "text": "PWM Modul crash after start advertising. Hi all,\r\n\r\ni have a problem with my pwm modul, if i use my setPWM Function before i start advertising it works fine. But if if i use PWM after starting advertising it doesn't work anymore. I use Timer 2 ang gpiote chanel 0 and 1. What could be a reason for crashing my pwm modul? \r\n\r\nBest regards Nils :)",
    "tag": "timer"
  },
  {
    "text": "Analog prescale question I'm using a nRF51844\r\n\r\nI'm writing my own ADC reading routines because I can't find any examples, but I know how to code so that's not a problem. I just want to confirm something:\r\n\r\nIf the analog reference is selected to be ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling , then does that mean to get a one-to-one reading, I should be using ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling as well? If I do this, I assume that if my VDD is 3.3V and input is 3.3V, I get a 10 bit reading of 1023, correct?\r\n\r\nWhat are the tolerances on the two prescalers?",
    "tag": "adc"
  },
  {
    "text": "TWI error recovery I am developing a power aware TWI driver for 51822/422.  All appears to work properly except when I simulate a bus fault by shorting SCL to ground or shorting SCL and SDA together.  My timeout timer properly detects a failure and software sets about to re-initialize the TWI interface.  After the fault, I disable TWI, and then go through all the same initialization routines that were used to make TWI work in the first place.  After the fault it never issues a clock pulse or changes the status of anything in any of the TWI registers or events, GPIO config is all as it should be and both pins are high and stay that way.  It appears as if the TWI hardware on the chip has locked up and can not be reset by software.  Is there some way to reset TWI hardware to its reset state via software so we can recover from faults?",
    "tag": "twi"
  },
  {
    "text": "UART Application Problem Hello all,\r\n\r\nI'm stuck in the use of the UART. \r\n\r\nI have used the code from the UART example and the UART application for iPhone. I'm using eclipse because I don't want to pay licences to KEIL if I can do it for free. So I have configure the makefile and the UART code is compiling and is executing in the nRF6310. I use for uploading the program nRF Studio with SoftDevice S110.\r\n\r\nI have added some messages for traceability through the UART port at the init and it works. LED 0 gets ON. Then I connect the Ipod and LED 0 -> OFF and LED 1 -> ON. Then I send a message from the Iphone and the nRF get stuck and the app disconnects. \r\n\r\nWhen using the debugging with Eclipse, most of the times it blocks at the call BLE_STACK_HANDLER_INIT from ble_stack_init.\r\n\r\nWhat I'm doing wrong? Could anyone that has encountered similar problems give me some hints?\r\n\r\nThanks in advance.\r\nM.",
    "tag": "uart"
  },
  {
    "text": "Is there any reason why I wouldn't want to start the ADC from within it's IRQ? I have 3 inputs I need to sample every n minutes.  I have an n-minute timer that can kick off the first one, but I need to run the second and third samplings in succession after that.\r\n\r\nIs there any reason why I can't have my IRQ handler set up the 2nd and 3rd conversions, and call the final handler after the 3rd?\r\n\r\nSpecifically, I'm asking if there's any kind of race condition or order of operations I should worry about.",
    "tag": "adc"
  },
  {
    "text": "How to write GPIOTE interrupt? Hi,\r\n\r\ni need to stop one of my Timer at the falling edge of a Pin. So i need a gpiote_interrupt, is this right? Can someone help me how i can do this? if i write something like GPIOTE_IRQHandler ( ) it doesn't work.\r\n\r\nbest regards Nils",
    "tag": "i2c"
  },
  {
    "text": "Problem with software, need help Hi,\r\n\r\ni have some troubles with my software which i doesn't understand maybe some one with more microcontroller Experience cann tell me how to solve this Problem.\r\n\r\nI have a method which waits for a Time, its like the nrf_delay but instead of this i use my own method wait_ms (TimeToWait). If i use this method in the main loop it works fine, it waits for the \"TimeToWait\" and then the programm is going on. But if i use this method int an timertimeout-method like my systemOff( )- method it doesn't work and i don#t understand why. \r\n\r\nThe same is if i use a method to run pwm on one pin. If i use this method in the main loop, the pwm method works but if i use it in an timeouthandler or in the SystemOff () method it does not work.\r\n\r\nAnd i don't know what a reason for this could be, it would bee great if some one have an idea beacouse its a realy silly problem but it hang up the hole microcontroller.\r\n\r\nThanks and best regards Nils :)",
    "tag": "i2c"
  },
  {
    "text": "Showing UART strings in Keil Hello,\r\n\r\nI am using an nRF51822 Development Kit.  I am trying to run pca10001/board/uart_example (with simple_uart) using the UART serial viewer built into the Keil programming software (in debugging mode).  So far, I cannot get these UART windows to display anything.  Is there a way to do this?  Shouldn't they just display whatever an attached UART would?  I have not found any way to configure Keil for this purpose.  \r\n\r\nAlso, I have my pins designated appropriately but they are not connected to anything.\r\n\r\nThank you!",
    "tag": "uart"
  },
  {
    "text": "Is there a place to store a pointer that I can pick up in an interrupt handler? In my ADC interrupt service routine (ADC_IRQHandler), I'd like to have a pointer available that I could use to carry some state from the main app thread to the IRQ handler.\r\n\r\nYes, I could do this by declaring a global, but I go to great lengths to avoid using globals so if there's an existing place to stash a pointer I'd be much happier.",
    "tag": "i2c"
  },
  {
    "text": "Is there a place to store a pointer that I can pick up in an interrupt handler? In my ADC interrupt service routine (ADC_IRQHandler), I'd like to have a pointer available that I could use to carry some state from the main app thread to the IRQ handler.\r\n\r\nYes, I could do this by declaring a global, but I go to great lengths to avoid using globals so if there's an existing place to stash a pointer I'd be much happier.",
    "tag": "adc"
  },
  {
    "text": "Start Timer in other Timer Timeout Handler Hi,\r\n\r\nIs it possible to start a Timer in an other Timeouht Handler?\r\nOr Do i have to use something other to do that?\r\ni use app_timer and Softdeive on the 51822.\r\n\r\nbest regards Nils.",
    "tag": "timer"
  },
  {
    "text": "Start Timer in other Timer Timeout Handler Hi,\r\n\r\nIs it possible to start a Timer in an other Timeouht Handler?\r\nOr Do i have to use something other to do that?\r\ni use app_timer and Softdeive on the 51822.\r\n\r\nbest regards Nils.",
    "tag": "i2c"
  },
  {
    "text": "Any ideas on how to decrease SPI overhead time? With the maximum SPI speed of 8 Mbps, I was expecting to be able to send 2 bytes in just a little over 2 us, but it takes a lot longer.  It appears that the mandatory event wait time between bytes (to avoid overwriting the first one) is about 4 us and, if I include the time it takes to toggle the slave device CE line on and off, the total transmission time is about 10 us.  This gives me a throughput of only about 1.6 Mbps.\r\n\r\nIs there any way to speed that up?  I'm even using some \"INLINE\" instructions (see below):\r\n\r\nNRF_GPIO->OUTCLR = CE_BIT_POS;\r\n\t\r\n dac_spi_base_address->TXD = (uint32_t)(tx_data[0]);\r\n\r\nwhile (dac_spi_base_address->EVENTS_READY == 0U)\r\n{\r\n}\r\ndac_spi_base_address->EVENTS_READY = 0U;\r\nrx_data[0] = (uint8_t)dac_spi_base_address->RXD;\r\n\r\ndac_spi_base_address->TXD = (uint32_t)(tx_data[1]);\r\n\r\nwhile ((dac_spi_base_address->EVENTS_READY == 0U) /*&& (counter < DAC_TIMEOUT_COUNTER)*/)\r\n{\r\n}\r\ndac_spi_base_address->EVENTS_READY = 0U;\r\nrx_data[1] = (uint8_t)dac_spi_base_address->RXD;\r\n\r\nNRF_GPIO->OUTSET = CE_BIT_POS;\r\n\r\n\r\nThank you for any ideas!\r\n\r\nGil",
    "tag": "spi"
  },
  {
    "text": "Are short sleeps useful? I'm working on a product that integrates an nrF51822 talking over SPI to an external display.  The display protocol involves a series of alternating 10 us sleeps and SPI sends at 16Mhz of small numbers of bytes (usually 2 but always < about 40).  I'm currently implementing this via spinning for waits (NOPs as in nrf_delay_us) and for SPI_READY.  I'm observing (not surprisingly) 4.4 mA current consumption during this process which takes a few seconds. \r\n\r\nI'm trying to reduce current consumption. \r\n\r\nI could perhaps use the TIMER to generate an interrupt for the 10 us delay and put the processor to sleep (WFE) for 160 cycles.  And then similarly with the SPI_READY.  I could maybe even use the PPI to link the SPI_READY and the TIMER_START events.  I understand that the 16 Mhz oscillator has to run to drive the SPI and TIMER.  But, according to the datasheet this is ~400 uA for the osc, and then 178 for the TIMER and 200 for SPI.  This is about a 7x reduction...\r\n\r\nThe question is: would it be worth it to try?  I'm not sure how to tell what the overhead of WFE is?\r\n\r\nThanks!\r\n\r\n-c",
    "tag": "timer"
  },
  {
    "text": "Are short sleeps useful? I'm working on a product that integrates an nrF51822 talking over SPI to an external display.  The display protocol involves a series of alternating 10 us sleeps and SPI sends at 16Mhz of small numbers of bytes (usually 2 but always < about 40).  I'm currently implementing this via spinning for waits (NOPs as in nrf_delay_us) and for SPI_READY.  I'm observing (not surprisingly) 4.4 mA current consumption during this process which takes a few seconds. \r\n\r\nI'm trying to reduce current consumption. \r\n\r\nI could perhaps use the TIMER to generate an interrupt for the 10 us delay and put the processor to sleep (WFE) for 160 cycles.  And then similarly with the SPI_READY.  I could maybe even use the PPI to link the SPI_READY and the TIMER_START events.  I understand that the 16 Mhz oscillator has to run to drive the SPI and TIMER.  But, according to the datasheet this is ~400 uA for the osc, and then 178 for the TIMER and 200 for SPI.  This is about a 7x reduction...\r\n\r\nThe question is: would it be worth it to try?  I'm not sure how to tell what the overhead of WFE is?\r\n\r\nThanks!\r\n\r\n-c",
    "tag": "spi"
  },
  {
    "text": "Two timers on RTC1 Hi,\r\nThis is loosely related to the other question I asked a few weeks ago (https://devzone.nordicsemi.com/index.php/two-interrupt-events-on-timer0) but this time I want to have two timers on RTC1 generating interrupt events. I'm using the internal RC clock.\r\nI'm trying the following code:\r\n\n\n```\n\r\nvoid lfclk_config()\r\n{\r\n  NRF_CLOCK->LFCLKSRC = (CLOCK_LFCLKSRC_SRC_RC << CLOCK_LFCLKSRC_SRC_Pos);\r\n  NRF_CLOCK->TASKS_LFCLKSTART = 1;\r\n  while (NRF_CLOCK->EVENTS_LFCLKSTARTED == 0) {}\r\n  NRF_RTC1->PRESCALER = 32; //1kHz frequency\r\n  NRF_RTC1->CC[0] = 9 * 1000;\r\n  NRF_RTC1->CC[1] = 2 * 1000;\r\n\r\n  NRF_RTC1->EVTENSET = RTC_EVTENSET_COMPARE0_Msk;\r\n  NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;\r\n  NRF_RTC1->EVTENSET = RTC_EVTENSET_COMPARE1_Msk;\r\n  NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE1_Msk;\r\n  NRF_RTC1->TASKS_START = 1;\r\n  NVIC_EnableIRQ(RTC1_IRQn);\r\n}\r\n\r\nvoid RTC1_IRQHandler()\r\n{\r\n  if (NRF_RTC1->EVENTS_COMPARE[0] != 0)\r\n  {\r\n    NRF_RTC1->EVENTS_COMPARE[0] = 0;\r\n  }\r\n  if (NRF_RTC1->EVENTS_COMPARE[1] != 0)\r\n  {\r\n    NRF_RTC1->EVENTS_COMPARE[1] = 0;\r\n  }\r\n}\r\n\r\nint main(void) {\r\n\r\n  lfclk_config();\r\n  while(1) {\r\n  }\r\n}\r\n\n```\n\r\n\r\nHere I want to setup two comparators, a 9sec and a 2sec one. Each should generate a periodic interrupt on their respective interval which is then handled by RTC1_IRQHandler.\r\nThe behaviour I see is that it seems that both comparators fire on time once but afterwards there's no interrupt generated. My intention is to have periodic interrupts, not a single one.\r\n\r\nWhat am I doing wrong?\r\n\r\nThanks!\r\nflorin",
    "tag": "timer"
  },
  {
    "text": "High Sample Rate with ADC and SoftDevice I am trying to sample the ADC every 2ms.  I notice lots of slowness with BLE advertising and typically can't connect to device over BLE when sampling.  I am using PPI, configuring, and starting before the softdevice is enabled.\r\n\r\n 1. Should nRF51822 be capable of reading ADC every 1ms to 2ms reliably?\r\n\r\n 2. Should I move all the PPI configuration to after the softdevice is enabled and be using the sd_ppi functions?\r\n\r\nThanks!\r\n\r\nEdit: Headline, format, added tags.",
    "tag": "adc"
  },
  {
    "text": "how to make a Pulse with Timer1 Hi,\r\n\r\ni need to make pulse with one of my Timers. Timer0 is used by the softdevice, and Timer2 is used to make PWM. I need to make a Pulse wich is 100us long, every 250ms (4hz). If i use Timer0 in my configuration i only can make this Pulse every 50ms not longer but how can i change that? Do i overflow the CC-Register with a big value ? Maybe someone can have a look at my Code. \r\n\r\n\n\n```\n\r\nvoid Timer1Init (void)\r\n{\r\n\tuint32_t Pulsweite = 25000;   //3s\r\n\tuint32_t Periode = 80000;    //5s\r\n\r\n\t\r\n\tNRF_TIMER1->TASKS_STOP = 1;\r\n\t// Create an Event-Task shortcut to clear TIMER0 on COMPARE[0] event\r\n\tNRF_TIMER1->MODE        = TIMER_MODE_MODE_Timer;\r\n\tNRF_TIMER1->BITMODE     = (TIMER_BITMODE_BITMODE_24Bit << TIMER_BITMODE_BITMODE_Pos);\r\n\tNRF_TIMER1->PRESCALER   = 4;  // 1us resolution\r\n\r\n\tNRF_TIMER1->TASKS_CLEAR = 1;               \t// clear the task first to be usable for later\r\n\t\r\n\tNRF_TIMER1->CC[0] = 100;   \t\t\t//second timeout\r\n\tNRF_TIMER1->CC[1] = 50000; \t\t\t\t//first timeout\r\n\t\r\n\tNRF_TIMER1->INTENSET    = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n\tNRF_TIMER1->INTENSET    = TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos;\r\n\t/* Create an Event-Task shortcut to clear TIMER1 on COMPARE[0] event. */\r\n\tNRF_TIMER1->SHORTS      = (TIMER_SHORTS_COMPARE1_CLEAR_Enabled << TIMER_SHORTS_COMPARE1_CLEAR_Pos);\r\n\t\t\r\n\tsd_nvic_SetPriority (TIMER1_IRQn, APP_IRQ_PRIORITY_HIGH);\t\t// Setzt die Prioroit\u00e4t auf HIGH\r\n  sd_nvic_EnableIRQ \t(TIMER1_IRQn);\t\t\t\t\t\t\t\t\t\t\t\t\t// Aktiviert den Interrupt\r\n\r\n\tNRF_TIMER1->TASKS_START = 1;\r\n}\r\n\r\n\r\nvoid TIMER1_IRQHandler(void) \r\n{\r\n    if (NRF_TIMER1->EVENTS_COMPARE[0] != 0)\r\n    {\r\n      NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n\t\t\tswitch_intensi(1);\r\n    }\r\n    if (NRF_TIMER1->EVENTS_COMPARE[1] != 0)\r\n    {\r\n      NRF_TIMER1->EVENTS_COMPARE[1] = 0;\r\n\t\t\tswitch_intensi(0);\r\n    }\r\n\r\n}\r\n\r\n\n```\n\r\n\r\nThank you for your help, Nils ;)",
    "tag": "timer"
  },
  {
    "text": "BLE Soft Device + SPI  Hi,\r\n\r\nI've noticed that when using SPI without a Soft Device or BLE function calls, the SPI peripheral is easy to control and operates correctly.\r\n\r\nThis nice operation stops when we try to put in the Soft Device + BLE API calls. I have cut+pasted code from a non-BLE project--for which SPI works--to one with BLE, and SPI no longer works. In fact, I wind up in the hardfault handler.\r\n\r\nAny advice on any conflicts to be aware of, or how to treat SPI with BLE added in, would be much appreciated.\r\n\r\nThanks,\r\nJamie",
    "tag": "spi"
  },
  {
    "text": "Enabling the UART through the J-Link Lite interface I have been successfully communicating with the PCA10001 evaluation kit using the virtual serial port that is exposed by the J-Link interface on the board.\r\n\r\nI've now moved to my own hardware, and I'm using the J-Link Lite interface.  I am able to download firmware and use the NRFGo Studio to install the Soft device, so I know my board is working and the interface is functioning.\r\n\r\nHowever, there are no COM ports exposed by the J-Link Lite, so I can't see console output from my device.\r\n\r\nHas anyone had trouble getting the COM port to work on the J-Link Lite?  Has anyone managed to do it?",
    "tag": "uart"
  },
  {
    "text": "TWI pull-up enable/disable I'm using the TWI module. Where can I set whether the DSA SCL pins have the internal pull-up enabled or disabled? I can't even find where to see if they are enabled at all.",
    "tag": "twi"
  },
  {
    "text": "PAN #32. TIMER: One CC register is not able to generate an event for the second of two subsequent counter/ timer values. Hi everone!\r\n\r\nI need to get a timer setup which repeatly fires 2 IRQs. The first i.e. after a timer count cc0=500 and the 2nd count cc0=700. After 700 ticks the timer value (count) should become cleared and then cc0=500 -> 700 -> 500 ... \r\n\r\nI could achieve this \"timeframe\" by using 2 ccs (cc0 = 500, cc1 = 700.... short cc1->clear timer0 activated)\r\nTo save cc1 I tried to use cc0 for both values instead, unfortunatly i couldnt get it to work this way.\r\n\r\nNow I am wondering if this got to do with PAN32 (nrf51822)or if i missed something in my code.\r\n\r\n\r\nCould someone please clarify if PAN 32 means that the 2nd event using only 1 cc register is only NOT fired if ie. cc0 = 500 and next it becomes set to cc0=501 or if it would also my case (cc0 = 500 and then cc0 = 700).\r\n\r\n\r\nThanks in advance!\r\nRGDS Dominik",
    "tag": "timer"
  },
  {
    "text": "2-wire communication between two nrf24le1 coding problem. i want to use 2-wire to do the communication of two nrf24le1. one is the master, another is slave.\r\nI don't know how to set up the master and slave.\r\nIs it the code shown below correct? P0.1 and P0.2 connect with two LED.\r\n\r\nmaster\r\n\r\n\n\n```\nvoid I2C_ISP(void)\tinterrupt INTERRUPT_SERIAL\r\n{\r\n\tP02 = !P02;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n        uint8_t a[1];\r\n\thal_w2_configure_master(HAL_W2_400KHZ);\r\n\tIEN1 |= 0x04;\r\n\tINTEXP |= 0x04;\r\n\tdelay_ms(1);\r\n\tEA = 1U;\r\n\tP0DIR = 0x00;\r\n        a[0] = 0xff;\r\n\twhile(1)\r\n\t{\t\r\n\t\thal_w2_write(0x20,a,1);\r\n\t\tdelay_ms(1000);\r\n\t\ta[0] = !a[0];\r\n\t\tP01 = !P01;\r\n  \t}\r\n}\n```\n\r\n\r\n\r\nslave\r\n\r\n\n\n```\nvoid I2C_ISP(void)\tinterrupt INTERRUPT_SERIAL\r\n{\r\n\tP02 = !P02;\r\n\ti2c_recive = HAL_W2_READ();\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\thal_w2_enable(true);\r\n\thal_w2_set_clk_freq(HAL_W2_400KHZ);\r\n\thal_w2_set_op_mode(HAL_W2_SLAVE);\r\n\thal_w2_all_irq_enable(true);\r\n\thal_w2_set_slave_address(0x20);\r\n\thal_w2_alter_clock(true);\r\n\tIEN1 |= 0x04;\r\n\tINTEXP |= 0x04;\r\n\tdelay_ms(1);\r\n\r\n\tEA = 1U;\r\n\tP0DIR = 0x00;\r\n\twhile(1)\r\n\t{\t\r\n\t\tdelay_ms(1000);\r\n\t\tP01 = !P01;\r\n  \t}\r\n}\n```\n",
    "tag": "twi"
  },
  {
    "text": "2-wire communication between two nrf24le1 coding problem. i want to use 2-wire to do the communication of two nrf24le1. one is the master, another is slave.\r\nI don't know how to set up the master and slave.\r\nIs it the code shown below correct? P0.1 and P0.2 connect with two LED.\r\n\r\nmaster\r\n\r\n\n\n```\nvoid I2C_ISP(void)\tinterrupt INTERRUPT_SERIAL\r\n{\r\n\tP02 = !P02;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n        uint8_t a[1];\r\n\thal_w2_configure_master(HAL_W2_400KHZ);\r\n\tIEN1 |= 0x04;\r\n\tINTEXP |= 0x04;\r\n\tdelay_ms(1);\r\n\tEA = 1U;\r\n\tP0DIR = 0x00;\r\n        a[0] = 0xff;\r\n\twhile(1)\r\n\t{\t\r\n\t\thal_w2_write(0x20,a,1);\r\n\t\tdelay_ms(1000);\r\n\t\ta[0] = !a[0];\r\n\t\tP01 = !P01;\r\n  \t}\r\n}\n```\n\r\n\r\n\r\nslave\r\n\r\n\n\n```\nvoid I2C_ISP(void)\tinterrupt INTERRUPT_SERIAL\r\n{\r\n\tP02 = !P02;\r\n\ti2c_recive = HAL_W2_READ();\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\thal_w2_enable(true);\r\n\thal_w2_set_clk_freq(HAL_W2_400KHZ);\r\n\thal_w2_set_op_mode(HAL_W2_SLAVE);\r\n\thal_w2_all_irq_enable(true);\r\n\thal_w2_set_slave_address(0x20);\r\n\thal_w2_alter_clock(true);\r\n\tIEN1 |= 0x04;\r\n\tINTEXP |= 0x04;\r\n\tdelay_ms(1);\r\n\r\n\tEA = 1U;\r\n\tP0DIR = 0x00;\r\n\twhile(1)\r\n\t{\t\r\n\t\tdelay_ms(1000);\r\n\t\tP01 = !P01;\r\n  \t}\r\n}\n```\n",
    "tag": "i2c"
  },
  {
    "text": "Hardfault on sd_softdevice_disable Hi,\r\n\r\nI am trying to run several applications sequentially on the nRF51822.\r\nI have another microcontroller controlling the nRF51822 by SPI.\r\nI init the stack, the services, advertise and my first application works well.\r\nThen the microcontroller tells the nRF51822 to disable the stack and I get an Hardfault before asking to init it again and to init then my new services for my second application.\r\nHow could disabling the soft device cause an hard fault ?",
    "tag": "spi"
  },
  {
    "text": "How to handle voltage mismatch on I2C/TWI bus as battery voltage drops? I need to connect an I2C/TWI device to the nRF51822. The I2C device is running at a fixed 3.3V (from a boost DC/DC), but the nRF51822 is powered directly from a CR2032 battery (starting at around 3.0V).\r\n\r\nAs the battery voltage drops to 2V, now the I2C bus is running at 3.3V but VDD for the nRF51822 is 2V. I know technically the input should never be more than VDD, but does the open collector of the I2C bus give a bit of leeway here? This is my first battery-powered design and it seems like a pretty typical situation - how are these I2C bus voltage mismatches typically handled?\r\n\r\nI know I could run both devices off the same VDD but I really don't want to power the nRF51822 using the 3.3V DC/DC because I only need to turn it on occasionally.",
    "tag": "twi"
  },
  {
    "text": "How to handle voltage mismatch on I2C/TWI bus as battery voltage drops? I need to connect an I2C/TWI device to the nRF51822. The I2C device is running at a fixed 3.3V (from a boost DC/DC), but the nRF51822 is powered directly from a CR2032 battery (starting at around 3.0V).\r\n\r\nAs the battery voltage drops to 2V, now the I2C bus is running at 3.3V but VDD for the nRF51822 is 2V. I know technically the input should never be more than VDD, but does the open collector of the I2C bus give a bit of leeway here? This is my first battery-powered design and it seems like a pretty typical situation - how are these I2C bus voltage mismatches typically handled?\r\n\r\nI know I could run both devices off the same VDD but I really don't want to power the nRF51822 using the 3.3V DC/DC because I only need to turn it on occasionally.",
    "tag": "i2c"
  },
  {
    "text": "Audio using the nRF51822 Hi, I'm working on a project where I'm trying to make an nRF51822 play a basic sound (such as a beep). Is there a recommended DAC that should be used with this particular SoC? Does anyone know in general how to get the chip to play sound?\r\n\r\nAlso- I'm relatively new to projects like this so any tips you have are helpful.",
    "tag": "adc"
  },
  {
    "text": "Audio using the nRF51822 Hi, I'm working on a project where I'm trying to make an nRF51822 play a basic sound (such as a beep). Is there a recommended DAC that should be used with this particular SoC? Does anyone know in general how to get the chip to play sound?\r\n\r\nAlso- I'm relatively new to projects like this so any tips you have are helpful.",
    "tag": "spi"
  },
  {
    "text": "nRF51822 SPI Module RX Hello,\r\n\r\nI've been working on the SPI module for the nRF51822.  I used the sample spi .c file as a starting point, but I got rid of the timeout (not sure why there is a timeout in a SPI module).  I'm sending out the data just fine, and I'm waiting for the EVENTS_READY to be non-zero before reading from the RXD register, but when I read from the RXD register, I just get 0xFF.  For test purposes, I'm connecting the MOSI to the MISO.  I've used a logic analyzer to verify that the data is being sent out and picked up by the MISO pin.  However, I still only see 0xFF.  I've tried various pins as well.  Does anyone have any suggestions?  I'm using the PCA10001 development board.\r\n\r\nThanks.",
    "tag": "spi"
  },
  {
    "text": "How to disable a timer IRQ Hi!\r\n\r\nI know this might be a stupid question to you but still... I am not able to disable i.e. a timer0 cc(3) IRQ.\r\n\r\nMy way to enable it in first place:\r\n\r\n\t\tNRF_TIMER0->INTENSET = (TIMER_INTENSET_COMPARE3_Enabled << TIMER_INTENSET_COMPARE3_Pos);\r\n\r\nand how i thought to disable it again:\r\n\r\n\t\t\tNRF_TIMER0->INTENCLR = (TIMER_INTENCLR_COMPARE3_Enabled << TIMER_INTENCLR_COMPARE3_Pos);\r\n\r\n\r\nUnfortunatly this wont work.\r\n\r\nI also played around with online (JTAG) with those 2 registers and i could not really figure out how this clear register is supposed to work :( \r\n\r\nRGDS",
    "tag": "timer"
  },
  {
    "text": "using ANT with RTC timers - softdevice conflicting with LFClk We are trying to get the ANT feature to run based on RTC as follows:\r\n\r\na. Timer RTC0 or 1 (1 for this example - tick is disabled, compare is on.)\r\nb. Timer initialized (all works very well).\r\nc. Start timer - go for 10-second IRQ in compart cc[0] - works great.\r\n\r\nThe Clock startup works ok and IRQ for RTC1 enables ok (taken from the example codes)..\r\n\r\nNRF_CLOCK->LFCLKSRC = \r\n(CLOCK_LFCLKSRC_LFCLKSRC_Xtal << CLOCK_LFCLKSRC_LFCLKSRC_Pos);\r\nNRF_CLOCK->EVENTS_LFCLKSTARTED = 0;\r\nNRF_CLOCK->TASKS_LFCLKSTART = 1;\r\nwhile (NRF_CLOCK->EVENTS_LFCLKSTARTED == 0)    {}\r\n\r\nNRF_POWER->PERPOWER |= (POWER_PERPOWER_RTC1_Power << POWER_PERPOWER_RTC1_Pos);\r\n\r\nwhile ((NRF_POWER->PERRDY & POWER_PERRDY_RTC1_Msk)!= (POWER_PERRDY_RTC1_Ready << POWER_PERRDY_RTC1_Pos))  { }\r\n\r\nNVIC_EnableIRQ(RTC1_IRQn);\r\nNRF_RTC1->PRESCALER = COUNTER_PRESCALER;  \r\nNRF_RTC1->CC[0] = COMPARE_COUNTERTIME * RTC_FREQUENCY;    \r\n\r\n\r\nThe problems lies where we try to initialize the ANT - particularly on the softdevice.. We consistently get a hard fault when the softdevice enable is attempted.\r\n\r\n\r\nreturn_value = nrf_softdevice_enable(NRF_CLOCK_LFCLKSRC_XTAL_50_PPM, softdevice_assert_callback);\r\n\r\nif (return_value != NRF_SUCCESS) yellow_error(); \t\t\r\n\t\t\t\t\r\n\r\nreturn_value = nrf_nvic_SetPriority(PROTOCOL_EVENT_IRQn, NRF_APP_PRIORITY_LOW);\r\nif  (return_value != NRF_SUCCESS) yellow_error();\r\n\r\nreturn_value = nrf_nvic_EnableIRQ(PROTOCOL_EVENT_IRQn); \r\nif (return_value != NRF_SUCCESS) purple_error();\t\t\r\n\r\nreturn_value != ant_channel_assign(CHANNEL_0,  \r\n\t\t\tCHANNEL_TYPE_SHARED_MASTER,\t\r\n\t\t\tANT_CHANNEL_DEFAULT_NETWORK, \r\n\t\t\tEXT_PARAM_FAST_START_MODE);\t\r\nif (return_value != NRF_SUCCESS) purple_error();\r\nreturn_value != ant_channel_id_set(CHANNEL_0, \t\t\t\t\t\t\t\t\tCHANNEL_0_CHAN_ID_DEV_NUM, \t\t\t\t\t\t\tCHANNEL_0_CHAN_ID_DEV_TYPE, \r\n\t\t\tCHANNEL_0_CHAN_ID_TRANS_TYPE); \t\t\tif (return_value != NRF_SUCCESS) purple_error();\r\n\t\t\r\nreturn_value = ant_channel_open(CHANNEL_0); \r\n\r\nWE NOTE THE FOLLOWING IN THE .SDM.H FILE. REGARDING\r\nnrf_softdevice_enable ROUTINE - SPECIFICALLY, THE NOTE REGARDING THE LfClk \"already running.\"\r\n    \r\n\r\n@brief Enables the softdevice and by extension the protocol stack.\r\n *\r\n * Idempotent function to enable the softdevice.\r\n *\r\n * @note Some care must be taken if a low frequency clock source is already running when calling this function: If the LF clock has a different source then the one currently running, it will be stopped. Then, the new clock source will be started.\r\n *\r\n * @note This function has no effect when returning with an error.\r\n *\r\n * @post If return code is ::NRF_SUCCESS \r\n *       - SoC library and protocol stack APIs are made available\r\n *       - A portion of RAM will be unavailable (see the relevant SDS documentation)\r\n *       - Some peripherals will be unavailable or available only through the SoC API (see the relevant SDS documentation)\r\n *       - Interrupts will not arrive from protected peripherals or interrupts\r\n *       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the softdevice.\r\n *       - Interrupt latency may be affected by the softdevice  (see your device's documentation)\r\n *       - Chosen LF clock source will be running\r\n *\r\n * @param clock_source Low frequency clock source and accuracy. (Note: In the case of XTAL source, the PPM accuracy of the chosen clock source must be greater than or equal to the actual characteristics of your XTAL clock).\r\n * @param assertion_handler Callback for softdevice assertions.\r\n\r\nWe've used both of the features (independently) with no problems, but when they are both enabled, one runs over the other...\r\n\r\nWhat is the correct way to use the RTC (or other) timer to time execution cycles which include ANT involvement?\r\n\r\nCan they both be enabled at the same time? Examples!!???\r\n\r\nIf not: how can one use a Timer -and-/-or- ANT interrupt to wake momma back up?\r\n\r\nThank you!!!\r\nroger",
    "tag": "timer"
  },
  {
    "text": "TWI of nRF51822 is having internal twi engine or not? hi guys, i am writing a code for reading data from a sensor using twi interface, the twi is not working properly,  here in SDK i found two examples of twi - sw_ nd hw_ is sw_ one is bit-banging one? or what?\r\n\r\nis the nrf51822 has internal twi engine or not i didn't found out any in the data sheet, help me to resolve these...",
    "tag": "twi"
  },
  {
    "text": "TWI of nRF51822 is having internal twi engine or not? hi guys, i am writing a code for reading data from a sensor using twi interface, the twi is not working properly,  here in SDK i found two examples of twi - sw_ nd hw_ is sw_ one is bit-banging one? or what?\r\n\r\nis the nrf51822 has internal twi engine or not i didn't found out any in the data sheet, help me to resolve these...",
    "tag": "i2c"
  },
  {
    "text": "Using SPI to interface an omnivision camera? Hello,\r\n\r\nI would like to develop an application that makes photos using a small camera from the omnivsion series and send the data via Bluetooht, using the nRF51822. These cameras use the SCCB (Seria Control Camera Bus) interface, which is similar to the I2C. So I would like to know if I could use one of the SPI interfaces to implement the SCCB. Or Maybe Are there any other easier way to contol the camera?\r\nI would like to know too, if you have any SPI library or any example code that could help me to program the camera control bus.\r\n\r\nThanks for your help",
    "tag": "spi"
  },
  {
    "text": "5350 lcd running w/ rtc / ant Does the lcd clobber the tmr0 and/or ANT ???\r\nWe just went through several days of working w/ ns on running ANT w/ RTC with a resolution of using sd_ calls.\r\n\r\nIs the LCD the same story? Are there sd_ calls for the 6350??\r\n\r\ntks!",
    "tag": "i2c"
  },
  {
    "text": "is twi is compatible with SMBUS or not? hi,\r\n\r\n    i am using a light sensor which is SMBUS serial interface, i tried to interface twi of nrf51822 with the sensor, but i am not able to get acknowledgement from the sensor, i want to know whether the twi of nrf51822 is compatible with SMBUS or not?  i tried both the s/w and h/w twi of nrf51822",
    "tag": "twi"
  },
  {
    "text": "is twi is compatible with SMBUS or not? hi,\r\n\r\n    i am using a light sensor which is SMBUS serial interface, i tried to interface twi of nrf51822 with the sensor, but i am not able to get acknowledgement from the sensor, i want to know whether the twi of nrf51822 is compatible with SMBUS or not?  i tried both the s/w and h/w twi of nrf51822",
    "tag": "i2c"
  },
  {
    "text": "nRF51822 UART modes Dear Nordic, \r\n\r\nis it possible to build a simple data bridge at speed of 115200 and up based on nRF51822 with CTS/RTS support and a fixed pin code for nRF51822 pairing?",
    "tag": "uart"
  },
  {
    "text": "Minimalistic schema I am looking for a minimalistic schema design using BLE for collecting data from i2c (twi) sensor and sending them over blue-tooth to the receiver. I need the following features:\r\n1. blue-tooth data transfer\r\n2. i2c support\r\n3. reliable time measurement (knowing the time that passed since start in seconds). Precision +-3 minutes within 10 hours is fine. I would like to avoid any external crystal if possible.\r\n\r\nAny suggestions for the minimalistic schema? Ideally i need it to fit on 7x10mm double-side PCB (the sensor is 4x4mm large). The blue-tooth distance range is not so important. If it will communicate in 5 cm distance it is okay (do I need any antenna?) I was thinking about nRF51822 but typical schema shown in data-sheet is still a bit complex (I believe it is possible to shrink number of components further).\r\n\r\nSorry for the novice questions, I am starting with that and need to know if it is feasible to design such a tiny PCBs with these chips before I dive into it.\r\n\r\nThanks",
    "tag": "twi"
  },
  {
    "text": "Sending HF Clock directly to gpio We are trying to find a way to send the High Frequency Clock directly out to a gpio pin. The reference manuals don't seem to have anything obvious.\r\n\r\nIs there a way to do this on a nordic board? Thanks in advance.",
    "tag": "timer"
  },
  {
    "text": "what is the proper sequence of open and reopen a ANT+ Channel ? HI Everybody,\r\n\r\nI am developing firmware for handling multiple ANT+ Sensors. i am able to collect data from 3 different sensors, but in below scenario am getting  channel in wrong state error. \r\nA) I opened 2 sensor channel 0 and channel 1 and started collecting data . working fine.\r\nB) Now i close the channel 1 and get success in it. \r\nC) Channel 0 still working. \r\n4) after this , i tried to open the channel 1 again, but find out the channel 1 in wrong state on the belwo line of code.\r\n\r\n  /* Set Channel Number */\r\n    return_value = sd_ant_channel_assign(SDM_CHANNEL_1, \r\n                                      CHANNEL_TYPE_SLAVE, \r\n                                      SDM_NETWORK_0, \r\n                                      SDM_CHANNEL_0_ANT_EXT_ASSIGN);\r\n\r\n\r\n5) here i get the \"NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE\" issue. this also stop my channel 0 as well. \r\n\r\nHere is the steps , which i follow for channel close .\r\n                         1. close channel. \r\n                          2) unassign channel .\r\n\r\n                        retrunvalue =sd_ant_channel_close(chan);\r\n\t                         if (NRF_SUCCESS == retrunvalue){\r\n\t\t\t   \r\n\t\t\t                    for(k=0;k<100;k++);\r\n\t\t\t                            retrunvalue = sd_ant_channel_unassign(chan); \r\n\t                                     if (NRF_SUCCESS == retrunvalue){\r\n\t\t\t                       -----\r\n\t\t\t\t\t\t\t\t\t\t\t\t  \r\n\t\t                             }else{\r\n\t\t\t\t\t\t---\r\n\t\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\treturn NRF_SUCCESS;\t\t\t\t\t\t\t\t  \r\n\t\t}\r\n\r\nis this the proper way to close a channel or i have to do any extra step ? \r\nor any specific document or reference which explain this procedure ? \r\n\r\nNote : I am using Channel 0 for HRM and channel 1 for SDM sensor fixed in my firmware.\r\n\r\nthanks in advance\r\nRobin Singh",
    "tag": "uart"
  },
  {
    "text": "app_uart getting started I've modified the simple_uart example to use app_uart instead but I cannot get any data transmitting.  I know the connections are correct because it works fine under normal simple_uart testing.\r\n\r\nHere is my init code which also sends a character and a string.  When I debug it always makes it through to NRF_SUCCESS case, but never transmits 'T'\r\n\r\n\tuart_buffers.rx_buf = rx_buffer;\r\n\tuart_buffers.rx_buf_size = sizeof(rx_buffer);\r\n\tuart_buffers.tx_buf = tx_buffer;\r\n\tuart_buffers.tx_buf_size = sizeof(tx_buffer);\r\n\t\r\n\tcomm_params.rx_pin_no = rxd_pin_number;\r\n\tcomm_params.tx_pin_no = txd_pin_number;\r\n\tcomm_params.cts_pin_no = cts_pin_number;\r\n\tcomm_params.rts_pin_no = rts_pin_number;\r\n\tcomm_params.baud_rate = 9600;\r\n\tcomm_params.use_parity = false;\r\n\tcomm_params.flow_control = APP_UART_FLOW_CONTROL_DISABLED;\r\n\t\r\n\tuint32_t res = app_uart_init(&comm_params, &uart_buffers, &app_uart_handler, APP_IRQ_PRIORITY_HIGH, comm_uuid);\r\n\t\r\n\tif(res == NRF_SUCCESS)\r\n\t{\r\n\t\tapp_uart_put('T');\r\n\t\tsimple_uart_putstring(\"Test 1\\r\\n\");\r\n\t\treturn;\r\n\t}",
    "tag": "uart"
  },
  {
    "text": "NRF24LU1 es spi slave How do I use the nRF24LU1+ in SPI communication as SLAVE? do the SDK SPI libraries support that or only for nRF24LE1?",
    "tag": "spi"
  },
  {
    "text": "Problem using UART and radio in ESB mode on nRF24LE01. Hi\r\n\r\nfor few days I seem to got stack in using together UART and radio on nRF21LE01 in ESB mode \r\nand I suspect irq_flags = hal_nrf_get_clear_irq_flags(); to be cause of my problem. \r\n\r\nWhat I want to achieve is to communicate to terminal via UART messages every time my\r\nreceiver gets message from transmitter (nRF51822). The radio part works flawlessly and\r\non the TXs side i.e nRF51822 which works also in ESB mode the radio and UART work happily \r\ntogether. \r\n\r\nOn RX side the UART also works anywhere in the program but in the NRF_ISR() code section which \r\nservices received packets. I suspect that irq_flags = hal_nrf_get_clear_irq_flags(); function \r\nwhich supposed to read and clear radio interrupts messes up all interrupts including UARTs. \r\n\r\n\r\nAm I making some fundamental mistake here? Despite searching web for answers, Nordic FAQ and \r\nreading extensively nrf24LE01 related docs I am unable to make this work. \r\nCan anyone put me on the right path with this please?\r\n\r\nRegards\r\n\r\nAdam\r\n//-----------------------------------------------------------------------------------\r\nThe code structure is simple.\r\n\r\nmain()\r\n// Initializes the UART\r\n  hal_uart_init(UART_BAUD_9K6);\r\n\t\r\n// Wait for XOSC to start to ensure proper UART baudrate\r\n  while(hal_clk_get_16m_source() != HAL_CLK_XOSC16M)\r\n  {}\r\n  Blink(3); //<- just tests that anything happens\r\n\r\n // Enable global interrupt\r\n  EA = 1;\r\n\r\n // Enable the radio clock\r\n  RFCKEN = 1;\r\n  // Enable RF interrupt\r\n  RF = 1;\r\n  \r\n// Print \"Hello World\" at start-up\r\n  putstring(\"\\r\\nXOSC has started!\\r\\n\"); //<- works!\r\n\r\n// Configure radio as primary receiver (PTX)\r\n  hal_nrf_set_operation_mode(HAL_NRF_PRX);\r\n\r\n//This has to be here for nrf24LE01 to receive from nrf51... in ESB\r\n  hal_nrf_setup_dynamic_payload(0xFF);\r\n  hal_nrf_enable_dynamic_payload(true);\r\n  hal_nrf_enable_ack_payload(true);\r\n  hal_nrf_set_rf_channel(10);\r\n\r\n// Power up radio\r\n  hal_nrf_set_power_mode(HAL_NRF_PWR_UP);\r\n\r\n// Enable receiver\r\n  CE_HIGH();\r\n\r\n// Print \"Hello World\" at start-up\r\n  putstring(\"\\r\\nHaha!\\r\\n\"); //<- works!\r\n\r\n  for(;;){}\r\n}\r\n\r\n// Radio interrupt\r\nNRF_ISR()\r\n{\r\n  uint8_t irq_flags;\r\n\r\n  // Read and clear IRQ flags from radio\r\n  irq_flags = hal_nrf_get_clear_irq_flags(); //<-- Is this my problem?\r\n\r\n  // If data received\r\n  if((irq_flags & (1<<(uint8_t)HAL_NRF_RX_DR)) > 0)\r\n  {\r\n    // Read payload\r\n    while(!hal_nrf_rx_fifo_empty())\r\n    {\r\n      hal_nrf_read_rx_payload(payload);\r\n    }\r\n  }\r\n  putstring(\"\\r\\nPacket received!\\r\\n\"); //<- DOES NOT WORK!\r\n  Blink(1); //<- works!\r\n}",
    "tag": "uart"
  },
  {
    "text": "Bootloader for nRF51422 ?  Hello Everybody,\r\n\r\nI need to write a boot loader for nRF51422. Any suggestion for it, reference site ,sample code for quick reference ?\r\n\r\nthanks and regards\r\nRobin Singh",
    "tag": "uart"
  },
  {
    "text": "twi_hw_master and gzll not working together Hi\r\n\r\ni'm using nRF51822 with twi_hw_master from gzll library from SDK v4.4.2.33551. Code is compiling and linking, but not working. Gazell transmissions don't work when twi_hw_master is active. When using twi_sw_master the application is working. It might be a problem with concurrent access to the PPI system. \r\n\r\nWhich ppi resources gzll are using?",
    "tag": "twi"
  },
  {
    "text": "SPI Master Example for nRF6310 I've had good luck running the examples such as the blinky and the basic BLE examples. Now, I'm trying to get the SPI Master example to run, but it does not seem to work out of box. The error LEDs light up showing that the RX buffer did not equal the TX buffer. I haven't started probing the evaluation board, but I'm wondering if this example be working out of box or if there is some configuration setting that I'm overlooking? I'm using the SDK v5_0_0_34603. Thanks",
    "tag": "spi"
  },
  {
    "text": "Connect two nRF8001 First, I'm just beginning bluetooth solutions, so I apologize if my question is dumb :)\r\n\r\nI have 2 Arduino boards, with 2 nRF8001 shields.\r\nI want to connect them. After that I want to send some chars from A to B, and than B to send some response. So this is the BIG idea :)\r\n\r\nFor device B I,m using ble_uart_project_template, and for A - ble_my_proj_template.\r\n\r\nThe problem is how to connect the devices???\r\nB is advertising. But can't find the \"right\" way to connect A with B.\r\nShould I bond them or not ?\r\n\r\nThanks in advance,\r\nStefan",
    "tag": "uart"
  },
  {
    "text": "About the device_firmware_updates project  Hi,\r\n\r\nI'm knowing the device_firmware_updates project in SDK and I want to know whether I need to program the softdevice when I do the device firmware updates over UART?\r\n\r\nI have read the help document of nRFgo Studio  and do as the serial bootloader say,but I can update the firmware over the UART.Could I just use the nRFgo Studio to do it?\r\n\r\nMust I do it by the command line?If it does,could you tell me how to do it?I cann't understand well by reading the readme.txt in hci_dfu_send_hex folder.\r\n\r\nthanks\r\n\r\n\r\nIs there anyone master that can answer my question?Or give me some advice?It seems that the DFU cann't be done by UART",
    "tag": "uart"
  },
  {
    "text": "ADC Reference Selection nRF51822 I am completing a schematic using the nRF51822 part.  I will be supplying the part with a 3.3V supply.  I will use one of the ADC inputs to sense battery voltage (up to 10v max and 4v min).  A voltage divider circuit will obviously be needed on the AIN pin.  \r\n\r\n1.  From the datasheet, it looks like VREF_EXT should be 1.2V and no greater than 1.3V.  So does this mean if I am using an external voltage reference (my 3.3V supply) that I need a voltage divider on the AREF0 pin to decrease the voltage from 3.3V to 1.2V?  \r\n\r\n2.  Is there any data on the accuracy of the internal reference voltage over temperature?  Are there benefits to using the internal reference vs the external reference other than gaining an additional GPIO?\r\n\r\n3.  Would a capacitor  in parallel to my AIN pin help with the accuracy of the ADC readings?  If so, what would be an appropriate value?",
    "tag": "adc"
  },
  {
    "text": " I want to pause the radio in a short time\uff0cbecause i want the uart receive data without error\u3002 Hi\uff0c\r\n\r\nI want to use the BLE SoftDevice without any flow control and the baud rate higher than 9600.\r\nIn [this question](https://devzone.nordicsemi.com/index.php/what-s-the-maximum-of-baud-rate-supported-of-uart) say this  could lead to lost bytes from the UART peer to the nRF51822. \r\n\r\nbut ,can i pause the interrupt from the S110 stack when i receive data?\r\n\r\nlike this \r\n\r\n\n\n```\n\r\nvoid UART0_IRQHandler(void)\r\n{\r\n\t__disable_irq();\r\n\r\n        while( have data  )\r\n        {\r\n       // receive data\r\n        ......\r\n        }\r\n\t__enable_irq();\r\n\t\r\n}\r\n\n```\n",
    "tag": "uart"
  },
  {
    "text": "Application halts on softdevice initialize in ble_stack_handler  I have a custom board that uses the nrf51822. I have been using the sample application ble_app_uart with only one minor change, I use the internal clock (NRF_CLOCK_LFCLKSRC_RC_250_PPM_4000MS_CALIBRATION) instead of an external 32.768kHz crystal. \r\n\r\nThis application works great on the dev kit from Nordic. I can connect it to my iPhone no problem. \r\nHowever if I try to run this on my custom hardware it does not work. I run a debug session on my hardware using keil and J-Link LITE CortexM and find that it appears to halt on the line: \r\n\n\n```\n// Initialise SoftDevice\r\n    err_code = sd_softdevice_enable(clock_source, softdevice_assertion_handler);\n```\n\r\nIn the file ble_stack_handler.c\r\n\r\nSo for some reason the softdevice is not initializing. I have tried this on a few modules, both ones of my design and some designed by others and available commercially. On all of them except the Nordic Dev kit I get this same issue. I am using softdevice: s110_nrf51822_6.0.0_softdevice.hex but have also tried the version that was 6.0.0 alpha as well as 5.2.1. All with the same results.\r\n\r\nDoes anyone know what it is that I am doing wrong?\r\n\r\nThanks\r\nTanner",
    "tag": "uart"
  },
  {
    "text": "Looking to hire a consultant that can help with a development issue for a few hours Hello,\r\n\r\nWe are having some problems with a board that we developed using the NRF51822, see this post: https://devzone.nordicsemi.com/index.php/application-halts-on-softdevice-initialize-in-ble_stack_handler\r\n\r\nI am looking to hire someone to consult with us over skype and help us solve this problem. If you are interested please post here or send me a message. \r\n\r\nThank you for your time.",
    "tag": "uart"
  },
  {
    "text": "can we use other pins as SDA and SCL for TWI other than 24 and 25? hello everyone,\r\n\r\n i am trying to use SDA and SCL pins of TWI other than 24 and 25, is it possible? i want to know before using other pins for twi other than 24 nd 25 with hardware not with software twi!\r\n\r\nregards,\r\nrangineni balu",
    "tag": "twi"
  },
  {
    "text": "I think I have found a bug in TWI_hw_master for nRF51822 The attached test program and logic analyzer displays shows that the function twi_master_transfer() returns to the calling program before the transfer is complete, if TWI_hw_master.c is used. Specifically, it returns before the STOP code has been transmitted. If the calling program makes another call to this function, the STOP code is never sent. The problem does not occur with the software version of the TWI interface: TWI_sw_master.c\r\n\r\nIn the attached images, the green dots are START codes, and the red dots are STOP codes.\r\n\r\nReviewing TWI_SW_no_extra_delay.jpg , the pulse on Diag 4 shows that the return from twi_master_transfer() occurs after the STOP has been sent. This is line 40 of the test program.\r\n\r\nReviewing TWI_HW_no_extra_delay.jpg (the only change is replacing the TWI_sw_master.c with TWI_hw_master.c) the same pulse on Diag 4 shows that  twi_master_transfer() has returned before the STOP has been sent. The following call to  twi_master_transfer() on line 52 is reached before the STOP occurs, and its start then looks like a RepeatedStart , which is incorrect.\r\n\r\nAdding an additional delay of 35 us (could be less, but I didn't try and figure out the minimum) after line\r\n40 , is shown in TWI_HW_with_extra_delay.jpg  . This shows a stretched pulse on Diag 4 , and the STOP now occurs correctly.\r\n\r\nIt looks like the code at line 158 in TWI_hw_master.c is where the problem is.  (see below, it is at line 81 per Hung Bui's response)\r\n\r\nCould someone please confirm this bug, or correct me if I have not understood something.\r\nThanks.\n\n![TWI_SW_no_extra_delay.jpg](/attachment/3f9814610ff892ee90e081d41944d1f9)\n\n![TWI_HW_no_extra_delay.jpg](/attachment/19187d4825736717ff5782b03cd656b6)\n\n![TWI_HW_with_extra_delay.jpg](/attachment/8c972512dab6fe7689caa99e39b8a57d)\n\n[TWI_hw_test.c](/attachment/5d2e52575adb67e5e9ed93eb853061d8)",
    "tag": "twi"
  },
  {
    "text": "Best SDK+SoftDevice combination for nRF51822-EK v2.0.0 Hi,\r\n\r\nI have version 2.0.0 of Evaluation Kit. I was waiting for the new SDK and SD 6.0.0 but I have seen the warning about hardware versions. I have to finish a SoftDevice+SPI example quickly.\r\n\r\nWhat is the best combination of SDK and SoftDevice for v2.0.0 EK for such a proof-of-concept?\r\n\r\nI have versions 4.4.0, 4.4.2 and 4.2.0 of SDK and SoftDevice 5.1.0, 5.2.1 and 6.0.0 . Which ones goes best on v2.0.0 EK?\r\n\r\nThanks,",
    "tag": "spi"
  },
  {
    "text": "nRF51822 SPI Master example on PCA10001 Hi,\r\n\r\nI have Keil 5.1, SDK 4.4.2, SD 5.2.1, PCA10001 from EK v2.0.0 and I am trying to make SPI example from nRF6310 work.\r\n\r\nI have changed below lines as:\r\n\r\n#define ERROR_PIN_SPI0   18UL\r\n#define ERROR_PIN_SPI1   19UL\r\n\r\nNo other software change. Nothing is connected to board.\r\n\r\nNow I have both error LEDs are glowing yet I could not achive loop back and turn LEDs off. I have tried various shortings of 20-21-22-23 thinking they are mapped to P0.20 P0.21 P0.22 P0.23 is that right?\r\n\r\nShould I also make any hardware change? 32 KHz crsytal and UART pins seem unused by SPI configuration. I don't need to change pin map at this stage.\r\n\r\nI only need to send data over SPI to a passive output device. One SPI Master is enough for now.",
    "tag": "spi"
  },
  {
    "text": "Wireless sensor network with nRF24LE1 and nRF24L01+ Does anyone use nRF24LE1 and nRF24L01+ to creat a small size wireless sensor network? Could you give me some advices?\r\nThanks a lot!",
    "tag": "i2c"
  },
  {
    "text": "How to output 32768Hz external crystal LFCLK at a GPIO pin? For synchronizing an external sensor i need to output a 32768Hz clock at a GPIO pin. For this case i want to use LFCLK from the external cyrstal. \r\n\r\n<u>**My setup:**</u>\r\nI use RTC0 to generate a tick event with prescaler set to \"0\". The tick event is connected to PPI Event End Point EEP, the PPI Task End Point TEP is connected to a GPIOTE Task Out which toggles the GPIO pin polarity.\r\n\r\nThis setup works for me except in one point. The output clock is 16384Hz and not 32768Hz as desired.\r\n\r\nDue to the tick event occurs only on the rising edge on LFLCLK and so the pin toggles only at one edge and not at both edges of LFCLK the clock out is only half of LFCLK. (as seen in the attached picture)\r\n\r\n<u>**My question:**</u>\r\nIs there a way to get LFCLK as clock output at a GPIO pin with 32768Hz? Preferred is a hardware only solution. I want to use the 32768Hz crystal due to better accuracy and lower power.\n\n![2014-01-10_172045.png](/attachment/c977c80946a30172c91f1890d3c0276e)",
    "tag": "timer"
  },
  {
    "text": "How do I send data from an Arduino to my laptop using BLE shield?  I'm trying to set up a network where 1 - 4 BLE devices wirelessly talk to a computer. I'm using an arduino connected to the BLE shield.\r\nThe computer is a Winows 7 laptop with a bluetooth 4.0 dongle attached to it.\r\n\r\nI want data from the sensors connected to the arduino to be sent to the computer, for example, when a button is pressed etc.\r\n\r\nHow would I go about doing this?",
    "tag": "uart"
  },
  {
    "text": "some question of nrf51822 timer I am developing using a nrf51822.I need delay timer\r\nthat can be substitued for nrf_delay_ms().\r\nin other words,need a task delay that can be taken some event from another side during delay time.\r\nIs nrf_timer_delay_ms() possible ?\r\nIf so,please tell me how to use and attention point regarding\r\nsw side and hw side.\r\nBR",
    "tag": "timer"
  },
  {
    "text": "Using ADC to measure battery voltage I am attempting to measure battery voltage through the ADC, but am getting inaccurate results.  In my setup, I have a 4.2 V battery divided down to the bandgap range using a 274k and 100k resistors, so the voltage at the ADC input is 4.2 * (100/374) = 1.12 V.\r\n\r\nI've configured the ADC to convert at 8 bits, to use no prescaler, and to use the bandgap as reference.  Additionally, I am not concerned with polling the battery voltage at a high frequency.\r\n\r\nThe result i get is 0xc4, or 196, which translates to a measured battery voltage of:\r\n(196/255) * 1.2 * (374 / 100) = 3.45 V\r\n\r\nMy questions:\r\n1) Is my ADC result to battery voltage equation incorrect (i.e. I am not compensating for something)?\r\n\r\n2) I see in the other examples that larger resistors are suggested--how important is this?\r\n\r\n3) I've scoped the ADC conversion, but did not notice a significant voltage dip.  The voltage moved approximately 20 mV, but nothing near the amount that would result in this sort of error.\r\n\r\nThanks in advance.",
    "tag": "adc"
  },
  {
    "text": "NRF_BLE_UART Problem Hello!\r\n\r\n1)There is  problem with nrf_ble_uart. On sdk 4.4 work well, but sdk 5.1 the same code is not working.\r\nWhat changes were made in the sdk or maybe there is a ready example nrf_uart under the new sdk?\r\n1.1) Why not install sdk 4.4 on win8.1 (nRF51 SDK Wizard ended prematurely)?\r\n\r\n2) What is the maximum speed of the uart in nrf51822?",
    "tag": "uart"
  },
  {
    "text": "nrf51822 uart issue I explain my hardware, An MCU + NRF51822, Communication is done via the UART TX RX between them, baud rate is 9600.\r\nMCU through UART transmit data to NRF51822, then NRF51822 passes the data to USB dongle.\r\nWhen mcu continuously sent data ( 11Byte/15ms ), data error rate of about 0.15~0.2% whether there are other way to be able to reduce the error rate.",
    "tag": "uart"
  },
  {
    "text": "Is it possible to create a GPIO button interrupt without GPIOTE? Hello \r\nI'm using nrf51822 EK board. This is my first time to develop application in ARM system.\r\nI want to develop a ble application.\r\nThis application can be shut down (system off) by pressing the button for 5 seconds.\r\n\r\nSince I read this \" https://devzone.nordicsemi.com/index.php/power-use-with-gpiote-is-too-high \"\r\nThe power source in our application is coin battery, it is important to reduce our power consumption.\r\n\r\nIs this possible to create any method to \"callback/interrupt\" a specific function while the button is pressed without GPIOTE? \r\n\r\nThanks!!:)",
    "tag": "i2c"
  },
  {
    "text": "point to multipoint with UART (multilink on the S120) I'm interested in using BT LE to collect data from a number of serial based devices -- a point-to-multipoint configuration.  I'm familiar with the UART examples and have seen the multilink example.\r\n\r\nThe \"devices\" would be connected to a BT \"remote\" via the UART (+ level shifter etc), any serial traffic needs to be sent over the BT LE link to a *single* master BT device connected to a PC which can read the data (probably via the UART again).\r\n\r\nHowever, I'm not 100% sure of the model, maybe it's just the terminology.  In the multipoint example, there is a central (Softdevice 120) and peripheral (Softdevice 110).  The central connects to the peripheral(s) to collect data, which is the opposite to how I need it to work (or is this just convention and can either end initiate the xfer?).\r\n\r\nFinally, what are the limitations, I think the multipoint allows up to 8 simultaneous connections, can I have more \"parked\" connections? i.e. how many device+BTLE \"remotes\" combinations can I associate with a single BT LE master? (even if only 8 can communicate concurrently).\r\n\r\n\r\nThanks!",
    "tag": "uart"
  },
  {
    "text": "How to synchronize receivers? Hello everyone,\r\n\r\nI want to create a real-time wireless sensor network. There are 8 sensors in the net. I use two nRF24LE1 as receivers to recieve the datas stimultaneously,  so I have to use the MultiCeiver function. So how can I synchronize these two receivers?\r\n\r\nThanks a lot!",
    "tag": "i2c"
  },
  {
    "text": "Why does nRF51822 spi_master.c have timeout code? The provided module spi_master.c has timeout code and error returns from spi_master_tx_rx(...)\r\n\r\nGiven that there are no external control signals to the SPI block, only a data input, it should be impossible for this hardware to timeout. I checked the current PAN V2.0 and there are no problems listed for the SPI section.\r\n\r\nPlease explain why there is timeout code.\r\n\r\nMy research:\r\n\r\nIn my application, I am not using PPI or interrupts with SPI.\r\n\r\nIn using the SPI hardware, I do indeed see timeout problems. My research seems to show that the problems are related to faster rather than slower SPI frequency (I see a problem if it is 2 MHz, but not if 250 KHz), and also seems to be related to the double buffer on the TX path.\r\n\r\nIf I send the first two bytes one immediately after the other (as shown on page 131 Ref Manual V1.1 (matches my silicon rev), or page 138 on Ref Manual V2.1) it times out on EVERY transfer at 2 MHz.\r\n\r\nIf I only TX another byte after the prior data has been completed, and the received byte read, it does not time out. While this works, it is much slower than what should be possible.  My application is an AD7680 ADC, and I need to read 3 bytes, preferably at 2 MHz.\r\n\r\nPlease explain what is really going on.",
    "tag": "spi"
  },
  {
    "text": "Question about ADC power consumption Hello, I am trying to develop a low power application by using nrf51822 EK board.\r\n\r\nIn \" Reference manual v2.0, 11.1.3 System ON mode \",\r\nit says there is a mechanisms can automatically switch on and off \r\nthe appropriate power sources depending on how many peripherals are active.\r\n\r\nOne of my application needs to detect the coin battery voltage\r\nI use ADC  with TIMER2 to detect it.\r\nThe detection period is relatively long (60~120 sec perhaps)\r\nI want to know when I enabled the ADC's interrupt (Avoiding interfere realtime application),\r\n**Will the ADC is always \"power on\" even in IDLE state?**\r\n\r\nTo reduce power consumption\r\nIf the answer is yes, I think I can change my code by enabling ADC interrupt after the TIMER comparing event happens...\r\n\r\nThanks!",
    "tag": "adc"
  },
  {
    "text": "Max SPI Slave Clock Frequency?  Any idea what the max SPI slave clock frequency is on the nRF51822?  The product specification (page 46, v2.0) says the max SCK frequency is 2MHz, but I was wondering if any of you were able to go faster than this reliably.  2MHz is the bare minimum frequency I'd need, but it'd be better to go faster, so I thought I'd check before ordering an eval kit.\r\n\r\nThanks!",
    "tag": "spi"
  },
  {
    "text": "Can't compile UART app I downloaded the source for the Android UART app, hoping to hack it into something I can use to test my gadget. But it's incomplete: it fails with the message:\r\n\r\nMissing required library: 'C:/Nordic Semiconductor/Android/adt-bundle-windows-x86_64-20130729/sdk/extras/android/support/v4/android-support-v4.jar'\r\n\r\nWhat's with all the Windows nonsense? Isn't this an Android app? I don't even own a Windows machine. Is this really a normal JAR file, and if so, can I get it from somewhere that doesn't require me to go visit my 75-year-old mom to borrow her laptop? Or can the UART app really not be built using the normal Android SDK, but requires Windows for some reason I can't imagine? Why would any sane developer write Android apps on Windows?",
    "tag": "uart"
  },
  {
    "text": "SPI/SPIS power consumption Hi, I am developing an BLE application using nRF51822.\r\n\r\nThis question is from my previous question:\r\nhttps://devzone.nordicsemi.com/index.php/question-about-adc-power-consumption\r\n\r\nFor my application, it will communicate with other device through SPIS all the time.\r\nSince other device (SPI master) will transmit 256 bytes data uniformly per second,\r\nthat is, CSN pin will be setting low every 4ms.\r\n\r\nAs the product specification 8.3 says,\r\nSPIS need \"HFCLK + 1V2\" and this will consume more 1 mA of current.\r\n\r\nI want to know about the power consupmtion of SPIS\r\n**When CSN is high, will the \"HFCLK + 1V2\" always active and consume 1mA of current?**\r\n\r\nIf yes, is there any suggestion to reduce the power consumption? Thanks.",
    "tag": "spi"
  },
  {
    "text": "NRF24L01+ PIPE SETTINGS Hello,\r\n\r\n i just want setup 1Tx and 1 RX using NRF24L01+ chips. but i am confused what should be Transmitter side Tx & Rx and what should be in Rx Tx & RX ? in order to use auto-ack feature.\r\n\r\n\r\nwhich addresses sould be kept in Transmitter and Receiver side ? could you please explain with some example as i am not able to understand...\r\n\r\nPlease help\r\n\r\nThanks",
    "tag": "spi"
  },
  {
    "text": "how to use the UART interrupt to wake up the chip Hi,\r\n    I have a problem is that I use the 51822  as a reader to read the 24l01's radio data.Now,I use the UART to read the instruction from the PC. If the instruction is \"ON\",the 51822 should start the radio and read the data from the 24l01, however, If the instruction if \"OFF\",the radio should enter the sleep mode. But the UART should  be always to prepare to read the instrution from the PC.\r\n   I want to konw how can I deal with it? If I can use the UART interrupt by the _WFI() to control it?\r\ncan you give me an explanation?",
    "tag": "uart"
  },
  {
    "text": "ADC not converting properly Hello,\r\nI'm using a code posted on this forum to read ADC input and fill an array with the ADC values but I always get values between 166 and 174, (even if I connect the ADC input: AIN2 -> P0.01 to Vcc) anyone knows the reason or the solution.\r\n\r\nI'm using the Nordic Nrf51822 EK and here is my code : \r\n\r\nthank you for the help\n\n[adc_exp.rar](/attachment/e80fef24d6edf366d35a8ecbce4602d1)\n\n![keil debug session.png](/attachment/a87da79530207bd76dae2507c38bd0f0)",
    "tag": "adc"
  },
  {
    "text": "I2C can't work properly when running BLE protocol 1. Device: NRF51822; BMA250E\r\n2. Description: \r\nWhen I read BMA250E via I2C without BLE protocol, commnucation run well.\r\nAnd if there is no I2C commnucation, BLE protocol can also work properly.\r\nHowever if they work together, both of them will be abnormal.\r\n\r\nCould anyone kindly give me some introduction or suggestion about <u>**how to do I2C commnucation under BLE**</u>?\r\nBetter to provide some demo code.\r\nThanks so much.",
    "tag": "i2c"
  },
  {
    "text": "I2C/TWI slave with nRF51822 Hi\r\n\r\nI need to implement I2C slave side (up to 100kBit/s) on a nRF51822 chip. As far as i see the inegrated TWI peripherial only supportes the master side. Any ideas how to do it? The following ways came to my mind, but all seam not the way to go.\r\n\r\nSoftware I2C\r\nThere are some code segments around to implement a software I2C solution by bitbanging. These solutions often are unstable and probably not fast enough to reach 100kBit/s. Additionally it may be a problem to run it beside the active S110 softdevice, because the softdevice may block the CPU in low stack for multiple milliseconds.\r\n\r\nExternal Peripherial\r\nAnother possible way is to use an external chip to do the I2C, but to be honest i didn't find a simple solution there. The only way to do it this way is the connect a PIC or something similar to the Nordic and implement the I2C on the PIC. The Nordic could communicate with the PIC over UART or SPI. Are the fix programmed chips that can be used as external peripherial?\r\n\r\nAny other thought about this?\r\n\r\nRegards Adrian",
    "tag": "twi"
  },
  {
    "text": "I2C/TWI slave with nRF51822 Hi\r\n\r\nI need to implement I2C slave side (up to 100kBit/s) on a nRF51822 chip. As far as i see the inegrated TWI peripherial only supportes the master side. Any ideas how to do it? The following ways came to my mind, but all seam not the way to go.\r\n\r\nSoftware I2C\r\nThere are some code segments around to implement a software I2C solution by bitbanging. These solutions often are unstable and probably not fast enough to reach 100kBit/s. Additionally it may be a problem to run it beside the active S110 softdevice, because the softdevice may block the CPU in low stack for multiple milliseconds.\r\n\r\nExternal Peripherial\r\nAnother possible way is to use an external chip to do the I2C, but to be honest i didn't find a simple solution there. The only way to do it this way is the connect a PIC or something similar to the Nordic and implement the I2C on the PIC. The Nordic could communicate with the PIC over UART or SPI. Are the fix programmed chips that can be used as external peripherial?\r\n\r\nAny other thought about this?\r\n\r\nRegards Adrian",
    "tag": "i2c"
  },
  {
    "text": "Re-program MAC ID Hi guys, \r\nIs there any way that I can re program the MAC ID of the nRF51822 devices through the SWD interface? I was able to do this using the UART interface with the BL600 (Laird) module which is based on the nRF51822 SOC so I am thinking there has to be a way to do this.\r\nAny ideas if this is possible?\r\nThanks!",
    "tag": "uart"
  },
  {
    "text": "ble proximity and simple uart problem Hello community, first time posting a question so please try and forgive any future mistakes.\r\n\r\nanyways im new to using the keil IDE and am have some problems. I have dug through a lot of the demo software available for the PCA10001 board and have decided to branch off to do something a little different to get my feet wet in dealing with the compiler. I decided to take the s110 stack and choose the BLE Proximity demo and add in the simple uart. my plan was to include the simple_uart.h and all functions to it would work but that does not seem to be the case. the compiler seems to have and undefined symbol with the use of the simple_uart_config() function and im not sure why since in the simple uart demo all that was included was the header file, which I have done.. am I missing something??\r\n\r\n\r\nany help would be appreciated. and again sorry for such a dumb question.\r\nthanks in advanced.\r\n\r\nps. im using      S1106.0.0 and SDK5.1.0    if that helps at all...",
    "tag": "uart"
  },
  {
    "text": "Throughput with nRF UART example Hi,\r\n\r\nI have set up the UART example with PCA10000 and PCA10001. Everything works fine but one strange thing is the time to send 100kB of data. See my times below:\r\n\r\n38 seconds\r\n57 seconds\r\n57 seconds\r\n58 seconds\r\n\r\nThen I made a reset of the PCA10001, connected again and start sending more data.\r\n\r\n39 seconds\r\n57 seconds\r\n57 seconds\r\n\r\nA new reset...\r\n\r\n38 seconds\r\n57 seconds\r\n.\r\n.\r\n.\r\n\r\nSo my question is if someone have noticed the same thing, or if someone have a clue why it get faster to transfer data the first time after a reset? I have not changed anything in the code for the example.\r\n\r\nBR\r\nmarru",
    "tag": "uart"
  },
  {
    "text": "CAN I MODIFY UART TXD INTERRUPT FLAG? (SET NRF_UART0->EVENTS_TXDRDY to 1 in software) Hello:\r\n    I am using NRF51822 to design somethings. And I want to use interrupt send method instead of polling send method.\r\n    NRF51822's UART0 provides TXDRDY interrupt. After serial output one frame, Hardware set TXDRDY to 1, and then program goes into INTERRUPT. \r\n    My question is: TXDRDY only can be set by HW? Can I modify this flag in software? Besides, in nRF51_Reference_manual v1.1.pdf, page 30th, Figure 4, status of EVENT m can be modified by both peripheral core and  CPU write. Whether \"CPU write\" means that we can change it manully?\r\n\r\n    If this flag can be modified, when we want to transmitting a frame, process like below, advantage is that when and How the contents will be transfered I do not care, interrupt program will complete it. what I need to do is put data.\r\n\r\nExample 1:\r\n    char sendc(u8 c)\r\n    {\r\n\tCLEAR_WDT();\r\n\t\r\n\t// if sending buffer is full,  suspend and wait.\r\n\twhile (UART_SEND_BUF_SIZE == g_uart_param.send.bytes);\r\n\r\n\t__disable_irq(); \r\n\r\n\tg_uart_param.send.buf[g_uart_param.send.write_index++] = c;\r\n\tg_uart_param.send.bytes++;\r\n\tif (g_uart_param.send.write_index >= UART_SEND_BUF_SIZE){\r\n\t\tg_uart_param.send.write_index = 0;\r\n\t}\r\n\r\n\tif (1 == g_uart_param.send.bytes && g_uart_param.tx_transmited){\r\n\t\t\r\n                // set sending buffer flag to 1, then goes into interrupt after enable irq.\r\n\t\tNRF_UART0->EVENTS_TXDRDY = 1;\r\n\t}\r\n\r\n\t__enable_irq();\r\n\r\n\treturn c;\r\n    }\r\n\r\n    Similiar usage is 51 sending interrupt, flag TI in SCON means transmitting over, but we can set TI to 1 manully, then program goes into interrupt.\r\n\r\n    I've test example 1, it can not goes into interrupt. If you have not understand my words, I can upload my UART code in reply.",
    "tag": "uart"
  },
  {
    "text": "nrf51822 UART Lost bit Hi, \r\n    I have a serious problem, when I use uart of NRF51822 QFAAC0 to receive data from another MCU, I found that it will lost one bit at same position everytime. my SDK is 4.4.2, and SD is 5.2.1 and in my application, i used two service bas(ADC is used in bas), nus(nordic uart service). what will cause the problem?\r\nBTW, uart setting: 9600bps, 1 start bit, 8 data bits, no parity bit and 1 stop bit.",
    "tag": "uart"
  },
  {
    "text": "nRF51822 - wired communication In my current project, I have to develop a board with 2 mcu:\r\n-  nRF51822\r\n-  STM32F2/F4\rThe nRF51822 should running S110 SoftDevice and act as a kind of \u00bbover the air\u00ab modem, where the STM32 contains the main application business logic.\r\n\r\nThe question is now: What is the best way to communicate between nRF51822 and STM32?\r\nSome alternatives:\r\n-  RS232\r\n-  I\u00b2C\r\n-  SPI\r\n-  any other?\rThe data rate should be at least 10 kbyte/s (e.g. 115.200 baud).\r\nRegardless which of the above approaches I choose, the lower communication SW driver should be implemented interrupt driven to avoid data loss at the receiving side and unnecessary blocking at the transmitting side. E.g. for RS232 I could use app_uart for that.\r\n\r\n<u>**For the case I choose RS232**</u>\r\n\r\nI'm a bit alarmed because of [this post](https://devzone.nordicsemi.com/index.php/what-s-the-maximum-of-baud-rate-supported-of-uart#reply-889):\r\n> \u2026 Use flow control (preferred) and a low baudrate, 9600 baud or less \u2026\n\r\nAnd this was confirmed by [this post](https://devzone.nordicsemi.com/index.php/cpu-overhead-consumed-by-s110-softdevice#reply-5209);\r\n> \u2026 The CPU will be suspended when there is radio activity, to avoid disrupting the radio in any way. As long as the CPU is suspended, no application level interrupts will be processed \u2026\n\r\nBut in [this post](https://devzone.nordicsemi.com/index.php/does-simple_uart-example-buffer#reply-2830), I read about the \u00bb6-byte buffer on latest chip revision\u00ab. How can I determine if my chip has a 2-byte or 6-byte buffer and what possible SW-modifications are needed to use the 6-byte buffer?\r\n\r\nCan I use much higher baud rates with the 6-byte buffer (any limit) without loosing rx bytes?\r\n(Yes, I'll use HWFC, even though that there was a \u00bb#define HWFC false\u00ab within boards/nrf6310.h)\r\n\r\nRelated posts:\r\n-  https://devzone.nordicsemi.com/index.php/can-i-modify-uart-txd-interrupt-flag-set-nrf_uart0-events_txdrdy-to-1-in-software#reply-5686\r\n-  https://devzone.nordicsemi.com/index.php/nrf51822-pca10001-uart-rx-interrupt-does-not-trigger\r\n-  https://devzone.nordicsemi.com/index.php/does-simple_uart-example-buffer\r\r\n\r\nEdit: My eval hardware is \u00bbN51822 QFAAG0 1342AA\u00ab, so the revision seems to be \u00bbQFAAG0\u00ab",
    "tag": "uart"
  },
  {
    "text": "I2C example with NRF51822 Are there any I2C examples for the nRF51822 ( write/ read functions) ?\r\nIf not, can anyone suggest a good starting point for I2C? \r\nI am using Eclipse kepler for development. \r\nThank you for all suggests.",
    "tag": "twi"
  },
  {
    "text": "RTC get count, App Timer Hi, \r\nI am trying to understand how can I have a running counter based on the low power 32.768 KHz oscilator that does not trigger any timeout interrupts (I am using the soft device). I am thinking there should be some way by which I can start the counter and then just get count ticks from somewhere else later in the code. I am trying to find a way I can do this using the app timer examples that I have seen in the forums but it seems all of them rely on an interrupt triggered after some timeout. \r\nIt seems this should be possible as mentioned in the nRF51 reference manual.\r\nAny help would be appreciated.",
    "tag": "timer"
  },
  {
    "text": "Ready to development TWI application while using softdevice  Hi, I am developing a BLE application using SPI and TWI. (Using nRF51822)\r\nThis discussion is about my survey in development zone for future develop the TWI part.\r\nI want to discuss... not just ask some specific question ;) \r\n\r\nI've used SPI slave to read another chip's information, and transmit these information through BLE.\r\nAnd I want to read another chip's information (through TWI) and also try to send other relatively few and less important information through BLE.\r\n\r\nSince I've not found the TWI hw sample code.\r\nAnd I read this:\r\nhttps://devzone.nordicsemi.com/index.php/twi-of-nrf51822-is-having-internal-twi-engine-or-not\r\nAnd know I can just use GPIO to simulate the TWI behavior.\r\nBut is any shortcoming using TWI sw module? \r\nThe SPI part is a real-time data flow application (SPI->BLE).\r\nI am not sure using TWI sw will causing more CPU computation thus loss some interrupt from SPIs?\r\nEven I've setting SPI MATRX 255.\r\n\r\n**Is TWI hw more recommand?**\r\n\r\nThe other thing I thought is the Peripheral ID.\r\nAs reference manual says, ID:4 is used by SPI slave so I've to use ID:3 (TWI0) as my application.\r\nI think I can just modify the code in the library NRF_TWI1 => NRF_TWI0\r\n\r\n**Is that enough?**\r\n\r\nAnd I've read more about the confilct between TWI and the softdevice.\r\nThe reason is using the restricted PPI for shortcut BB-suspend and BB-stop when softdevice is enabled.\r\n\r\nAnd I read this:\r\nhttps://devzone.nordicsemi.com/index.php/using-i2c-gpiote-interrupt-with-soft-device-enabled\r\nAs Ole says, the new version chip can simply enable these shortcut without PPI configuration.\r\nThe sample code in [sdk 5.1.0 36092] is also using PPI.\r\n\r\nIf I want to modify these below without using PPI:\r\nsd_ppi_channel_assign(0, &(NRF_TWI1->EVENTS_BB), &(NRF_TWI1->TASKS_STOP));\r\nsd_ppi_channel_assign(0, &(NRF_TWI1->EVENTS_BB), &(NRF_TWI1->TASKS_SUSPEND));\r\nsd_ppi_channel_enable_set(PPI_CHEN_CH0_Msk);\r\nsd_ppi_channel_enable_clr(PPI_CHEN_CH0_Msk);\r\n\r\nas I thought I've to enable these shortcut first:\r\n\r\nNRF_TWI0->SHORT = TWI_SHORTS_BB_STOP_Msk | TWI_SHORTS_BB_SUSPEND_Msk;\r\n\r\nAnd then I don't know how to modify these tasks start.....\r\nI guess \"channel_enable_set\" can transfer as setting the task = 1\r\n(Example: NRF_TWI0->TASKS_SUSPEND = 1)\r\nAnd the channel_enable_clr can transfer as the setting task = 0\r\n\r\n**Is that correct?**\r\n\r\nFinally, as I've read the PAN and know TWI will consume more power when enabled.\r\nTo reduce power consumption, It is recommend to disabled when not used.\r\nSince the NVIC interrupt is not set in the sample code (twi_xx_master.c)\r\nI think disable TWI only use a function with below code is enough.\r\n\r\nNRF_TWI1->ENABLE = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos; \r\nNRF_TWI1->POWER = 0; \r\n\r\n**Is that correct?**\r\nAnd I know while enabled it again, it must needs to initialize first.\r\n\r\n\r\nIf something I didn't notice, please tell me.\r\nThanks a lot!",
    "tag": "twi"
  },
  {
    "text": "Ready to development TWI application while using softdevice  Hi, I am developing a BLE application using SPI and TWI. (Using nRF51822)\r\nThis discussion is about my survey in development zone for future develop the TWI part.\r\nI want to discuss... not just ask some specific question ;) \r\n\r\nI've used SPI slave to read another chip's information, and transmit these information through BLE.\r\nAnd I want to read another chip's information (through TWI) and also try to send other relatively few and less important information through BLE.\r\n\r\nSince I've not found the TWI hw sample code.\r\nAnd I read this:\r\nhttps://devzone.nordicsemi.com/index.php/twi-of-nrf51822-is-having-internal-twi-engine-or-not\r\nAnd know I can just use GPIO to simulate the TWI behavior.\r\nBut is any shortcoming using TWI sw module? \r\nThe SPI part is a real-time data flow application (SPI->BLE).\r\nI am not sure using TWI sw will causing more CPU computation thus loss some interrupt from SPIs?\r\nEven I've setting SPI MATRX 255.\r\n\r\n**Is TWI hw more recommand?**\r\n\r\nThe other thing I thought is the Peripheral ID.\r\nAs reference manual says, ID:4 is used by SPI slave so I've to use ID:3 (TWI0) as my application.\r\nI think I can just modify the code in the library NRF_TWI1 => NRF_TWI0\r\n\r\n**Is that enough?**\r\n\r\nAnd I've read more about the confilct between TWI and the softdevice.\r\nThe reason is using the restricted PPI for shortcut BB-suspend and BB-stop when softdevice is enabled.\r\n\r\nAnd I read this:\r\nhttps://devzone.nordicsemi.com/index.php/using-i2c-gpiote-interrupt-with-soft-device-enabled\r\nAs Ole says, the new version chip can simply enable these shortcut without PPI configuration.\r\nThe sample code in [sdk 5.1.0 36092] is also using PPI.\r\n\r\nIf I want to modify these below without using PPI:\r\nsd_ppi_channel_assign(0, &(NRF_TWI1->EVENTS_BB), &(NRF_TWI1->TASKS_STOP));\r\nsd_ppi_channel_assign(0, &(NRF_TWI1->EVENTS_BB), &(NRF_TWI1->TASKS_SUSPEND));\r\nsd_ppi_channel_enable_set(PPI_CHEN_CH0_Msk);\r\nsd_ppi_channel_enable_clr(PPI_CHEN_CH0_Msk);\r\n\r\nas I thought I've to enable these shortcut first:\r\n\r\nNRF_TWI0->SHORT = TWI_SHORTS_BB_STOP_Msk | TWI_SHORTS_BB_SUSPEND_Msk;\r\n\r\nAnd then I don't know how to modify these tasks start.....\r\nI guess \"channel_enable_set\" can transfer as setting the task = 1\r\n(Example: NRF_TWI0->TASKS_SUSPEND = 1)\r\nAnd the channel_enable_clr can transfer as the setting task = 0\r\n\r\n**Is that correct?**\r\n\r\nFinally, as I've read the PAN and know TWI will consume more power when enabled.\r\nTo reduce power consumption, It is recommend to disabled when not used.\r\nSince the NVIC interrupt is not set in the sample code (twi_xx_master.c)\r\nI think disable TWI only use a function with below code is enough.\r\n\r\nNRF_TWI1->ENABLE = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos; \r\nNRF_TWI1->POWER = 0; \r\n\r\n**Is that correct?**\r\nAnd I know while enabled it again, it must needs to initialize first.\r\n\r\n\r\nIf something I didn't notice, please tell me.\r\nThanks a lot!",
    "tag": "i2c"
  },
  {
    "text": "Ready to development TWI application while using softdevice  Hi, I am developing a BLE application using SPI and TWI. (Using nRF51822)\r\nThis discussion is about my survey in development zone for future develop the TWI part.\r\nI want to discuss... not just ask some specific question ;) \r\n\r\nI've used SPI slave to read another chip's information, and transmit these information through BLE.\r\nAnd I want to read another chip's information (through TWI) and also try to send other relatively few and less important information through BLE.\r\n\r\nSince I've not found the TWI hw sample code.\r\nAnd I read this:\r\nhttps://devzone.nordicsemi.com/index.php/twi-of-nrf51822-is-having-internal-twi-engine-or-not\r\nAnd know I can just use GPIO to simulate the TWI behavior.\r\nBut is any shortcoming using TWI sw module? \r\nThe SPI part is a real-time data flow application (SPI->BLE).\r\nI am not sure using TWI sw will causing more CPU computation thus loss some interrupt from SPIs?\r\nEven I've setting SPI MATRX 255.\r\n\r\n**Is TWI hw more recommand?**\r\n\r\nThe other thing I thought is the Peripheral ID.\r\nAs reference manual says, ID:4 is used by SPI slave so I've to use ID:3 (TWI0) as my application.\r\nI think I can just modify the code in the library NRF_TWI1 => NRF_TWI0\r\n\r\n**Is that enough?**\r\n\r\nAnd I've read more about the confilct between TWI and the softdevice.\r\nThe reason is using the restricted PPI for shortcut BB-suspend and BB-stop when softdevice is enabled.\r\n\r\nAnd I read this:\r\nhttps://devzone.nordicsemi.com/index.php/using-i2c-gpiote-interrupt-with-soft-device-enabled\r\nAs Ole says, the new version chip can simply enable these shortcut without PPI configuration.\r\nThe sample code in [sdk 5.1.0 36092] is also using PPI.\r\n\r\nIf I want to modify these below without using PPI:\r\nsd_ppi_channel_assign(0, &(NRF_TWI1->EVENTS_BB), &(NRF_TWI1->TASKS_STOP));\r\nsd_ppi_channel_assign(0, &(NRF_TWI1->EVENTS_BB), &(NRF_TWI1->TASKS_SUSPEND));\r\nsd_ppi_channel_enable_set(PPI_CHEN_CH0_Msk);\r\nsd_ppi_channel_enable_clr(PPI_CHEN_CH0_Msk);\r\n\r\nas I thought I've to enable these shortcut first:\r\n\r\nNRF_TWI0->SHORT = TWI_SHORTS_BB_STOP_Msk | TWI_SHORTS_BB_SUSPEND_Msk;\r\n\r\nAnd then I don't know how to modify these tasks start.....\r\nI guess \"channel_enable_set\" can transfer as setting the task = 1\r\n(Example: NRF_TWI0->TASKS_SUSPEND = 1)\r\nAnd the channel_enable_clr can transfer as the setting task = 0\r\n\r\n**Is that correct?**\r\n\r\nFinally, as I've read the PAN and know TWI will consume more power when enabled.\r\nTo reduce power consumption, It is recommend to disabled when not used.\r\nSince the NVIC interrupt is not set in the sample code (twi_xx_master.c)\r\nI think disable TWI only use a function with below code is enough.\r\n\r\nNRF_TWI1->ENABLE = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos; \r\nNRF_TWI1->POWER = 0; \r\n\r\n**Is that correct?**\r\nAnd I know while enabled it again, it must needs to initialize first.\r\n\r\n\r\nIf something I didn't notice, please tell me.\r\nThanks a lot!",
    "tag": "spi"
  },
  {
    "text": "Two-wire interface does not work together with Bluetooth Hi!\r\n\r\nI am using nRF51822 evaluation kit and connecting it as a master to a pair of I2C-devices (using twi_hw_master.c). Everything works well, but when I integrated the TWI (I2C) example code with the Nordic example ble_app_hrs (hear rate monitor) the TWI stops working. The initialization function just blocks (twi_master_init()). However, if I remove ble_stack_init() and other BT-initializations it starts working. Adding back only the ble_stack_init() is enough to make the TWI to block again.\r\n\r\nWhen debugging, the twi_hw_master initialization function twi_master_init() seems to block on this line:\r\n\r\n    NRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n\r\nQuestions:\r\nQ1: Is there some configuration issue in the examples so that TWI and BLE won't work together?\r\nQ2: Is there even some hardware related problem for that combination?\r\nQ3: In any case, do you have any ideas to solve the problem?",
    "tag": "twi"
  },
  {
    "text": "How to use 16Mhz NRF_TIMER1 with softdevice? Source Code to review Sorry for the silly question, but as it is mandatory to use sd_X function when it is possible to avoid collision, could you tell me if this code is the right way to use the 16MHz Timer 1?\r\n\r\nBest regards\r\n\r\n\r\n\n\n```\n/** @brief Function for handling the Timer 1 interrupt.\r\n */\r\nvoid TIMER1_IRQHandler(void)\r\n{\r\n    NRF_TIMER1->CC[0] += TIMER_INTERVAL;\r\n  \r\n    // Clear interrupt.\r\n    if ((NRF_TIMER1->EVENTS_COMPARE[0] == 1) && \r\n        (NRF_TIMER1->INTENSET & TIMER_INTENSET_COMPARE0_Msk))\r\n    {\r\n        NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n    }\r\n    \r\n    if(toggle)\r\n      kernel_led_test_on();\r\n    else\r\n      kernel_led_test_off();      \r\n    \r\n    toggle = !toggle;\r\n}\r\n\r\nstatic void timer1_init(void)\r\n{\r\n    uint32_t p_is_running;\r\n    uint32_t err_code;\r\n  \r\n    // Configure timer\r\n    NRF_TIMER1->MODE      = TIMER_MODE_MODE_Timer;\r\n    NRF_TIMER1->BITMODE   = TIMER_BITMODE_BITMODE_16Bit;\r\n    NRF_TIMER1->PRESCALER = 9;\r\n\r\n    // Clear the timer\r\n    NRF_TIMER1->TASKS_CLEAR = 1;\r\n\r\n    NRF_TIMER1->CC[0] = TIMER_INTERVAL;\r\n\r\n    NRF_TIMER1->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n    NRF_TIMER1->TASKS_START = 1;\r\n\r\n    err_code = sd_nvic_SetPriority(TIMER1_IRQn,APP_IRQ_PRIORITY_LOW);\r\n    APP_ERROR_CHECK(err_code);\t\r\n    err_code = sd_nvic_ClearPendingIRQ(TIMER1_IRQn);\r\n    APP_ERROR_CHECK(err_code);\t\r\n    err_code = sd_nvic_EnableIRQ(TIMER1_IRQn);  \r\n    APP_ERROR_CHECK(err_code);\t\r\n}\n```\n",
    "tag": "timer"
  },
  {
    "text": "nRF6310 - is the RS232 specified for 1 MBaud I'm using the nRFgo motherboard (nRF6310 together with the PCA10004 Cpu board. I'd configured the nRF51822's Uart to 1\u202fMBaud).\r\nIs the RS232 level shifter (which is part of the nRF6310 Motherboard) specified for 1\u202fMBaud?",
    "tag": "uart"
  },
  {
    "text": "nRF51822 - Is it possible to use hardware flowcontrol half a way? That means, that the nRF51822 is always allowed to send, but on it's receiving side, he could slow down the opponent side by using it's Rts line?\r\nI now, I could archive that by just fixing the nRF51822's Cts input to Gnd. The question is, if it is also possible at software level (without using a physical Cts pin).",
    "tag": "uart"
  },
  {
    "text": "nrf51822 ADC pin internal resistance Hi. \r\nI am looking for the internal resistance of the ADC pin of my nrf51822. I have looked at the Product Specifications (as well as the Reference Manual and other documents just in case...) but didn't manage to find it :( . I saw typical values for other boards (Pi, STM32, etc.) but I need the exact value in the case of my Nordic nrf51822 board since I need to compute a precise value based on this resistance. \r\nDoes anyone know where (or how) I can find (or determine) this value? \r\nThanks in advance.",
    "tag": "adc"
  },
  {
    "text": "questions on how to implement the current time service I'm working on an implementation of the Current Time Service specified by the Bluetooth SIG (I'm happy to share it).\r\n\r\nwhere I am so far:\r\n- The service and the caracteristics are set up and working correctly.\r\n- I can initialise the value attribute with a static date_time\r\n- I can increment the time using a timer created with the timer lib and update the value in the softdevice\r\n\r\nMy questions:\r\n- where do I get the time from? The timer lib uses the RTC but can I still set and read the absolute value of the RTC and read the time-value from there? Or will it interfere? I later want to be able to go into a power saving mode where the device doesn't do anything until the user wakes it up by the press of a button. Of course the RTC should continue to run during that time. Or will I anyway not save a significant amount of energy compared to waking up every secound to run the timer lib?\r\n\r\n- the time gets read from the device very seldomly. Do I really need to update the time value in the softdevice every secound even though it is almost never read? Is there a possibility to get an event from the softdevice when the time is read, so the application can than read the RTC value, write it to the softdevice and tell the softdevice that the value is now ready to be delivered to the peer device?\r\n\r\nP.S. Im using your ble_date_time.h file for the date_time format definition. Could it be that there is the include #include \"app_util.h\" missing? the definitions for __INLINE and the datatypes are missing. I was unable to compile without adding it.",
    "tag": "timer"
  },
  {
    "text": "how to get UART example using nRF24LU1+ I have a example using nRF24LE1.\r\nSo. I want know what can I change that example. or how to I get nRF24LU1+ example.\r\n\r\nnRF24LE1 example is this.\r\n\r\n/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.\r\n *\r\n * The information contained herein is confidential property of Nordic\r\n * Semiconductor ASA.Terms and conditions of usage are described in detail\r\n * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.\r\n *\r\n * Licensees are granted free, non-transferable use of the information. NO\r\n * WARRENTY of ANY KIND is provided. This heading must NOT be removed from\r\n * the file.\r\n *\r\n * $LastChangedRevision: 133 $\r\n */\r\n\r\n/** @file\r\n * @brief UART example\r\n * @defgroup uart_example UART \"Hello World\" example\r\n * @{\r\n * @ingroup nrf_examples\r\n *\r\n * @brief This example writes the string \"Hello World\" on start-up. After this all\r\n * characters received on the RXD input are echoed to the TXD output.\r\n *\r\n * The example implements the low level stdio functions putchar() and getchar() so that standard\r\n * IO functions such as printf() and gets() can be used by the application.\r\n *\r\n*/\r\n\r\n//lint -e732\r\n//lint -e713\r\n//lint -e640\r\n\r\n#include <stdio.h>\r\n#include \"nrf24le1.h\"\r\n#include \"hal_uart.h\"\r\n#include \"hal_clk.h\"\r\n\r\n// Cusomization of low level stdio function. Used by for example printf().\r\n#ifdef __ICC8051__\r\nint putchar(int c)\r\n#else /*presume C51 or other accepting compilator*/\r\nchar putchar(char c)\r\n#endif\r\n{\r\n  hal_uart_putchar(c);\r\n  return c;\r\n}\r\n\r\n// Cusomization of low level stdio function. Used by for example gets().\r\n#ifdef __ICC8051__\r\nint getchar(void)\r\n#else /*presume C51 or other accepting compilator*/\r\nchar getchar(void)\r\n#endif\r\n{\r\n  return hal_uart_getchar();\r\n}\r\n\r\n// Repeated putchar to print a string\r\nvoid putstring(char *s)\r\n{\r\n  while(*s != 0)\r\n    putchar(*s++);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n  // Configure TXD pin as output.\r\n  // P0.5, P0.3 and P1.0 are configured as outputs to make the example run on\r\n  // either 24-pin, 32-pin or 48-pin nRF24LE1 variants.\r\n  P0DIR = 0xD7;\r\n  P1DIR = 0xFE;\r\n\r\n   // Initializes the UART\r\n  hal_uart_init(UART_BAUD_9K6);\r\n\r\n  // Wait for XOSC to start to ensure proper UART baudrate\r\n  while(hal_clk_get_16m_source() != HAL_CLK_XOSC16M)\r\n  {}\r\n\r\n  // Enable global interrupts\r\n  EA = 1;\r\n\r\n  // Print \"Hello World\" at start-up\r\n  putstring(\"\\r\\nHello World!\\r\\n\");\r\n\r\n  for(;;)\r\n  {\r\n    // If any characters received\r\n    if( hal_uart_chars_available() )\r\n    {\r\n\t\t\tP3 = 0x11;\r\n      // Echo received characters\r\n      putchar(getchar());\r\n    }\r\n  }\r\n}\r\n/** @} */",
    "tag": "uart"
  },
  {
    "text": "S110 Soft Device and wired UART I am using UART0 for wired communication and S110 for Bluetooth LE communication at the same time, using HRM profile. System seems to work as expected, I get log output from UART and heart rate is delivered via BTLE. However, after about three minutes the system blocks i.e. stops logging into the UART and BTLE also goes down. This happens regularly every time.\r\n\r\nI have no idea what could be the reason, but if I do not use simple_uart.c -functions, the blocking doesn't happen (my led keeps blinking and BTLE stays working). I would appreciate any idea that would help me on this issue.",
    "tag": "uart"
  },
  {
    "text": "Setting TIMER2 interval How do I set TIMER2 to interrupt every 1 ms? \r\n\r\nSounds like a very basic question, but I haven't succeed. For TIMER1 I can get it working, but for TIMER2 the highest frequecy I have achieved is about 100 Hz. \r\n\r\nThe code is as follows:\r\n\r\n    void init_timer2(void)\r\n    {\r\n    \t// Start 32 MHz crystal oscillator\r\n    \tNRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n    \tNRF_CLOCK->TASKS_HFCLKSTART = 1;\r\n    \t// Wait for the external oscillator to start up\r\n    \twhile (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0) {\r\n    \t\t// Do nothing.\r\n    \t}\r\n    \tNRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;\r\n    \tNRF_TIMER2->PRESCALER = 4; // what should be here?\r\n    \tNVIC_EnableIRQ(TIMER2_IRQn);\r\n            NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n            NRF_TIMER2->CC[0] = ???;\r\n            NRF_TIMER2->CC[1] = ???;\r\n            NRF_TIMER2->CC[2] = ???;\r\n            NRF_TIMER2->CC[3] = ???; \r\n    \tNRF_TIMER2->INTENSET = TIMER_INTENSET_COMPARE2_Enabled\r\n    \t<< TIMER_INTENSET_COMPARE2_Pos;\r\n    \tsd_softdevice_forward_to_application();\r\n    \tNRF_TIMER2->TASKS_START = 1;\r\n    }\r\n\r\nI don't know what should be put into the place of '???'s above. I guess there is a good documentation somewhere, so I would be happy to get a pointer there, too. Indeed, a working code would be best.\r\n\r\nEdit: Format (please use preformatted text button when inserting code)",
    "tag": "timer"
  },
  {
    "text": "Can anybody provide me a linear section of rechargable LiIon battery I'm using nRF51822 for development. and I want to use ADC to measure the electricity of battery, but I don't know the discharge characteristic, i couldn't get that on internet. and DEMO in the SDK only shows the CR2032's linear section. Can anybody show me  the rechargable LiIon's linear section?",
    "tag": "adc"
  },
  {
    "text": "Advertising Battery levels on a beacon Hey folks,\r\n\r\nI am currently trying to use my nrf51822 evaluation board as a beacon. This is working pretty well but I need to have it broadcast its current battery level as well. From what I have seen this means I need to make some kind of interrupt to tell the chip to update the advertising message. Could anyone point me in the direction of some information on this topic? \r\n\r\nIf it helps I am currently basing everything off of the ble_app_beacon example code and that works just fine. \r\n\r\n-Chris",
    "tag": "adc"
  },
  {
    "text": "UART0_IRQHandler doesn't called in UART sample I am running 5.2 sdk's UART  under experimenta\\ble_app_uart,\r\nI assume it works with http://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF-UART-2.0-for-Android-4.3\r\n\r\nwhen Android app sends data to device, it is able to received in\r\nvoid nus_data_handler(ble_nus_t * p_nus, uint8_t * p_data, uint16_t length)\r\n{\r\n    for (int i = 0; i < length; i++)\r\n    {\r\n        simple_uart_put(p_data[i]);\r\n    }\r\n    simple_uart_put('\\n');\r\n}\r\n\r\nhowever, nothing was sent to APP side, no notification sent to app side too.\r\n\r\nalso void UART0_IRQHandler(void) did not get called\r\n\r\nwhat did I do wrong? wrong device example code used?\r\n\r\nUART0_IRQHandler seems very strange,\r\ndata_array[index] = simple_uart_get();  it return some pointer to data_array[index];\r\nhow ever, later it use index+1 as the length, and use the wrong way:(index >= (BLE_NUS_MAX_DATA_LEN - 1)\r\n\r\nseems this is an example that all went wrong? \r\n\r\n\r\nvoid UART0_IRQHandler(void)\r\n{\r\n    static uint8_t data_array[BLE_NUS_MAX_DATA_LEN];\r\n    static uint8_t index = 0;\r\n    uint32_t err_code;\r\n\r\n    /**@snippet [Handling the data received over UART] */\r\n\r\n    data_array[index] = simple_uart_get();\r\n    index++;\r\n\r\n    if ((data_array[index - 1] == '\\n') || (index >= (BLE_NUS_MAX_DATA_LEN - 1)))\r\n    {\r\n        err_code = ble_nus_send_string(&m_nus, data_array, index + 1);\r\n        if (err_code != NRF_ERROR_INVALID_STATE)\r\n        {\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n        \r\n        index = 0;\r\n    }\r\n\r\n    /**@snippet [Handling the data received over UART] */\r\n}",
    "tag": "uart"
  },
  {
    "text": "S110 Soft Device and Analog Inputs I have an application that reads an nRF51822 pin configured as analog input and then sends that value using \"ble uart\" (included in Nordic's sdk). Analog input is read in an interrupt 250 times per second, but only a few of those values are sent from my main loop (not from interrupt). However, when the connection is established, the analog input stops working but just gives a fixed value (218).\r\n\r\nThe problem can be solved by initializing analog input in my main loop all the time as follows:\t\t\t\r\n\r\nnrf_adc_init(ADC_RES_10bit, ADC_INPUT_AIN3_P02, ADC_INT_DISABLED);\r\n\r\nBut if I do so, then the BTLE connection hangs up within a half a minute, and actually the whole system probably crashes.\r\n\r\nHow should I handle ADC when using soft device? Is the soft device using ADC in some way?",
    "tag": "adc"
  },
  {
    "text": "nRF51 UART baud rate accuracy I am using a nRF51822 at 16 MHz\r\n\r\nWhat is the math formula behind the BAUDRATE register?\r\n\r\nWhat is the timing error for each of the standard baud rate setting? This is not in the reference manual.\r\n\r\nThanks",
    "tag": "uart"
  },
  {
    "text": "nRF51822 Long Time Timekeeping I want to measure the time between some different events in my application (using SoftDevice S110).\r\nMy idea is, to collect some timestamps and calculate the elapsed duration by just subtract them (like app_timer.c do).\r\n\r\nBut the problem is, that the nRF51822's Rtc0 and Rtc1 are limited to 24 bit, so I'm limited to a measurable duration of 511 seconds.\r\n\r\nPossible solution: I could create a app_timer driven task which triggers on each Rtc overflow to emulate some more Rtc bits.\r\n\r\nMay there be a better solution?",
    "tag": "timer"
  },
  {
    "text": "I2C bus with no external pull up Hi,\r\n\r\nWe are using nRF51422 in our project and we observe a strange thing, that even there is no external pull up resistors, the I2C communication using the built-in TWI port is still working fine, I would like to check with you whether this is the case that the mcu will activate the internal pull up while in I2C mode.\r\n\r\nThank you!\r\nJoseph",
    "tag": "twi"
  },
  {
    "text": "Can you use two GPIOTE channels for the same pin? I'm trying to output a relatively high frequency PWM (300kHz). I'll need to adjust the duty cycle on the fly, without glitches and minimal time spent in IRQ handlers.\r\n\r\nCurrently, I have 2 compare matches setup on a timer. Each event triggers the same GPIOTE task which toggles the output. I also have the timer clear short setup. This works fine for a constant duty cycle.\r\n\r\nHowever, when I want to change the duty cycle, and I do regularly, I need to wait until the right time in the timer cycle so that an extra compare event doesn't trigger an extra toggle and invert my duty cycle. It's difficult for me to afford to spend time sitting around for the right time in the timer cycle to set things.\r\n\r\nMy question lies in trying to fix this. I noticed that the GPIOTE can be configured to only toggle high-to-low or vice versa. My hope was to use two GPIOTE channels for the same IOpin each with a dedicated timer compare and PPI channel and one setup to \"set\" the output with the other setup to \"clear\". I know this uses an extra of the precious 4 GPIOTE channels, but that cost is worth it for me if I can then make duty cycle corrections faster.\r\n\r\nHowever, when I tried to do this, the GPIOTE hardware would only let one control each IOpin. My question is, is it possible to configure GPIOTE differently so that I can do what I want? Did I miss some configuration? If you are using GPIOTE in set/clear mode, is it only meant for one shot? Would you need to reconfigure the GPIOTE channel for the next transition? Seems like a very silly mode with only a couple use cases.",
    "tag": "timer"
  },
  {
    "text": "Can you use two GPIOTE channels for the same pin? I'm trying to output a relatively high frequency PWM (300kHz). I'll need to adjust the duty cycle on the fly, without glitches and minimal time spent in IRQ handlers.\r\n\r\nCurrently, I have 2 compare matches setup on a timer. Each event triggers the same GPIOTE task which toggles the output. I also have the timer clear short setup. This works fine for a constant duty cycle.\r\n\r\nHowever, when I want to change the duty cycle, and I do regularly, I need to wait until the right time in the timer cycle so that an extra compare event doesn't trigger an extra toggle and invert my duty cycle. It's difficult for me to afford to spend time sitting around for the right time in the timer cycle to set things.\r\n\r\nMy question lies in trying to fix this. I noticed that the GPIOTE can be configured to only toggle high-to-low or vice versa. My hope was to use two GPIOTE channels for the same IOpin each with a dedicated timer compare and PPI channel and one setup to \"set\" the output with the other setup to \"clear\". I know this uses an extra of the precious 4 GPIOTE channels, but that cost is worth it for me if I can then make duty cycle corrections faster.\r\n\r\nHowever, when I tried to do this, the GPIOTE hardware would only let one control each IOpin. My question is, is it possible to configure GPIOTE differently so that I can do what I want? Did I miss some configuration? If you are using GPIOTE in set/clear mode, is it only meant for one shot? Would you need to reconfigure the GPIOTE channel for the next transition? Seems like a very silly mode with only a couple use cases.",
    "tag": "pwm"
  },
  {
    "text": "Performance of GATT Is there a way to recieve more than one write callback for a given characteristic, per radio session?  It seems like I can rx 1 time per attribute per radio session and tx up to 8 times per attribute per radio session.  Is that correct?\r\n\r\nI'm trying to optomize throughput in both directions for an application and I'm just not seeing a reasonable throughput.  I'm sending 1K from the PC and it takes about 1 second to get sent back to the PC (Rx 1K, then TX 1K).\r\n\r\nI'm also having several issues with the UART not receiving characters, or receiving wrong characters.  I'm using the radio activity and UART FIFO full to block the uart transmitter from transmitting during these times, but I still have issues.  I have the older generation of NRF51822.  Is it possible that is the entire issue?",
    "tag": "uart"
  },
  {
    "text": "nrf51822 SPI Slave not working I have two custom boards with nrf51822 QFAAG0 1348AC chip. I use 16 MHz crystal. Bluetooth functionality is working fine but SPI does not work. SPI pins are P0.00 ( MISO ), P0.01 ( MOSI ), P0.02 ( SCK ), P0.03 ( SS1 ). I use spi master and slave example code ( spi_master_example, spi_slave_example ) from sdk folder \"nrf51822/Board/nrf6310/\". All pins are configure according to my SPI pins in code (SPI, LEDS). From master side I see that everything is changing in registers but from client side I dont get any action.\r\n\r\nIs there something more what I need to configure or change?",
    "tag": "spi"
  },
  {
    "text": "Pre/Post Advertise Hook Hi all, \r\n\r\nMy application gathers sensor data and uses the advertisement packet to broadcast the values (much the same as the nordic temp sensor example). Rather than having to have a separate timer which aligns with the advertise interval (which is what the example does), is there a pre-transmit hook i can use which will synchronise my sensor reads with the advertisement transmission?\r\n\r\nOr, is the advertisement interval handled (via the SD) through an application timer? in which case is there a way i could identify which timer it is and somehow run a pre-transmit function?\r\n\r\nThanks for your help..",
    "tag": "timer"
  },
  {
    "text": "Timers with Keil RTX-RTOS on NRF51822 Hello!\r\n\r\nI'm trying to make timers run in my application on NRF51822, with Keil RTX-RTOS.\r\n\r\nRTX-RTOS seems to be correctly configured in my project: tasks run without any problem.\r\nHowever, timers don't seem to work and I noticed that the function os_time_get() always returns 0. What I don't understand is that the task scheduler \u2013 which uses clock if I'm right \u2013 goes right: tasks all run.\r\n\r\nCould you help me undertand what's going wrong please? Thanks.",
    "tag": "timer"
  },
  {
    "text": "S110 ADC Example Hi. I've never asked a question here, and I'm a complete beginner to embedded programming, so I apologize if I break protocol in anything I do on here. \r\n\r\nMy setup: \r\nnrfgo Motherboard (nRF6310) and nrf51822 module\r\nEnvironment: nrfStudio in conjunction with Keil Lite v5.10 in Windows 32-bit. \r\nFlashing with J-Link Lite.\r\n\r\nI had been following the nrf51822 devlopment kit User Guide v1.4 to try out my nrf6310 and nrf51822 module. I followed the instructions in the guide and got the ble_app_hrs example working. Then, I searched for something to try that would involve the ADC and s110. I found an example project (called \"ble_app_hrs_with_adc_sample_ain\") from Stefan at this page: https://devzone.nordicsemi.com/index.php/s110-soft-device-and-analog-inputs \r\n\r\nI put this project in C:\\Keilv5\\ARM\\Device\\Nordic\\nrf51822\\Board\\nrf6310\\s110\r\n\r\nAfter trying to build the project, I was getting these error:\r\n--------------------------\r\n\r\nBuild target 'nrf51822_xxaa_s110 (256K)'\r\ncompiling main.c...\r\ncompiling ble_error_log.c...\r\ncompiling ble_bondmngr.c...\r\ncompiling pstorage.c...\r\n..\\..\\..\\..\\..\\Source\\app_common\\pstorage.c(571): error:  #20: identifier \"PSTORAGE_SWAP_ADDR\" is undefined\r\n              retval = sd_flash_write((uint32_t *)(PSTORAGE_SWAP_ADDR),\r\n..\\..\\..\\..\\..\\Source\\app_common\\pstorage.c(845): error:  #20: identifier \"PSTORAGE_SWAP_ADDR\" is undefined\r\n      retval = sd_flash_page_erase(PSTORAGE_SWAP_ADDR / PSTORAGE_FLASH_PAGE_SIZE);\r\n..\\..\\..\\..\\..\\Source\\app_common\\pstorage.c(868): error:  #20: identifier \"PSTORAGE_SWAP_ADDR\" is undefined\r\n      BLOCK_COUNT_CHECK(p_module_param->block_count, p_module_param->block_size);\r\n..\\..\\..\\..\\..\\Source\\app_common\\pstorage.c: 0 warnings, 3 errors\r\n\".\\_build\\ble_app_hrs.axf\" - 3 Error(s), 0 Warning(s).\r\nTarget not created\r\n \r\n---------------------------\r\n\r\nSo I compared the two pstorage_platform.h files from ble_app_hrs and ble_app_hrs_with_adc_sample_ain. The only difference as far as I can tell, is that the h file for ble_app_hrs does define PSTORAGE_SWAP_ADDR and it doesn't for the adc example. So, I tried adding the line in question into the adc example h file. The project compiled successfully and the program now runs. However, no LEDs are lighting up, so the board is not advertising. I've stepped through the program to find that the problem is occuring in a call to pstorage_init() from bond_manager_init(). \r\n\r\nIt seems to me that PSTORAGE_RAW_MODE_ENABLE is not defined, because I come to this line each time.\r\n\r\nretval = sd_flash_page_erase(PSTORAGE_SWAP_ADDR / PSTORAGE_FLASH_PAGE_SIZE);\r\n\r\nThis isn't returning NRF_SUCCESS, so was I wrong to add in the definition of PSTORAGE_SWAP_ADDR in pstorage_platform.h?\r\n\r\nI'm an absolute beginner, so ground-level answers would be appreciated.\r\n\r\nThanks very much for any help!",
    "tag": "adc"
  },
  {
    "text": "PWM Duty Cycle update best practices Because of the limitation in the GPIOTE hardware that [only one channel can be connected per GPIO](https://devzone.nordicsemi.com/index.php/can-you-use-two-gpiote-channels-for-the-same-pin), care must be taken when changing a PWM duty cycle. If for instance the compare events that each trigger a GPIOTE toggle happen in the same clock cycle, the task is only triggered once and suddenly the output duty cycle is inverted.\r\n\r\nMy question is: What is the best practice for changing a PWM value?\r\n\r\nStopping the timer, updating compare matches, and restarting it kinda works. Unfortunately it \"pauses\" the output waveform during the update. If the update is not done in an IRQ handler, there is a good chance an interrupt will inflate the \"pause\" which could have disastrous effect on certain hardware. This method has been implemented in the Simple PWM library that has been [floating around](https://devzone.nordicsemi.com/index.php/is-there-an-example-code-for-using-pwm-on-the-nrf51822-with-a-softdevice) here.\r\n\r\nThe other solution I've found is to use an unsued CC register to trigger an interrupt at exactly the right time in the overall timer period. With careful control of the IRQ Handler, and choice of the extra CC, the update of the CC which's event is mapped to the GPIOTE can happen at a predictable time in the timer cycle and thus you should be able to ensure glitch free output.\r\n\r\nI have had both systems mostly working, with the major exception that I've still noticed some glitches or unintended output inversions, which has blown up some of the other components on my board. This is surely because I haven't quite fully taken care of the edge cases.\r\n\r\nSo, to ask a different way, does anyone else out there have any other ways of doing this?",
    "tag": "pwm"
  },
  {
    "text": "UART DFU, with SoftDevice 7 Is there a UART version of the DFU example that is provided with the new SoftDevice 7.0?\r\n\r\nIf not how to go about modifying the BLE DFU example to be able to handle UART (it is okay if the HCI slip/protocol layer is utilized)?",
    "tag": "uart"
  },
  {
    "text": "how to obtain output on serial port (P0.11,P0.09)pca10001 uart_example? Hi,\r\n\r\nI used uart_example from SDK v4.4.1 where I continuously transmitted a character 'A' to the serial port\r\n\r\nAs from the discussions I found in devzone the output will be obtained **JLink CDC Uart Port**, but that is the serial output from the debugger. When I tried to open a serial port (for my USB-serial converter) I couldn't find any output on the Teraterm software. But when I opened the JLink CDC Uart port I obtained the output.\r\n\r\nSo Is there anything to be done in the hardware so as to get output on pin P0.09 & P0.011.\r\nThis is required since I have to debug in this manner only.\r\n\r\n\r\nRegards\r\nHPC",
    "tag": "uart"
  },
  {
    "text": "nrf51822 simple_uart.c source file Hello everyone,\r\n\r\nI studied firmware for the first time,\r\nI lost nrf51822 simple_uart.c source file..\r\nI can not work in progress now.\r\nI would appreciate anyone upload T.T\r\n\r\nThank you.",
    "tag": "uart"
  },
  {
    "text": "nrf51822 + temp sensor problem spi rx Hello.\r\n\r\nI use nrf51822 EK and TN-901 temp sensor.\r\nMy plan is nrf51822 slave,  TN-901 is master\r\n or considering the roles reverse.\r\nGetting value is spi and output is uart.\r\nBut i don't know how to get value in spi.\r\nUpload my source and sheet. \r\n\r\nPlease advise.\r\n\r\nThank you.\n\n[TN-901_Datasheet.pdf](/attachment/6a3cba7e2ff311bf7089a1375499bfde)\n\n[spi_master.zip](/attachment/9b34852961f4e09c0b83e9477751e9a0)",
    "tag": "uart"
  },
  {
    "text": "nrf51822 + temp sensor problem spi rx Hello.\r\n\r\nI use nrf51822 EK and TN-901 temp sensor.\r\nMy plan is nrf51822 slave,  TN-901 is master\r\n or considering the roles reverse.\r\nGetting value is spi and output is uart.\r\nBut i don't know how to get value in spi.\r\nUpload my source and sheet. \r\n\r\nPlease advise.\r\n\r\nThank you.\n\n[TN-901_Datasheet.pdf](/attachment/6a3cba7e2ff311bf7089a1375499bfde)\n\n[spi_master.zip](/attachment/9b34852961f4e09c0b83e9477751e9a0)",
    "tag": "spi"
  },
  {
    "text": "I2C- SCL & SDA pin change!! Hi\r\n\r\nIn my custom project I'm using pins P0.14 as SCL and P0.15 as SDA .\r\nI know the pins selection #define is in twi_master_config.h. But the question is whether I have to use **twi_hw_master.c** or **twi_hw_master.c** for this pin configuration?\r\n\r\nDo I have to do any extra configurations other than this?\r\n\r\nRegards\r\nHPC",
    "tag": "twi"
  },
  {
    "text": "I2C- SCL & SDA pin change!! Hi\r\n\r\nIn my custom project I'm using pins P0.14 as SCL and P0.15 as SDA .\r\nI know the pins selection #define is in twi_master_config.h. But the question is whether I have to use **twi_hw_master.c** or **twi_hw_master.c** for this pin configuration?\r\n\r\nDo I have to do any extra configurations other than this?\r\n\r\nRegards\r\nHPC",
    "tag": "i2c"
  },
  {
    "text": "Issues with app_uart.c/.h setup and interrupt handling on nRF51822 Folks,\r\n\r\n*Simple* UART communication shouldn't be this difficult.  Embarrassed to admit it, but I'm having problems setting up and using the app_uart.c/.h module from the SDK version 4.4.2 (limited to that version because I have 'C0' version devices right now).  Am trying to use this module (with no flow control) in the radio_test_example project (also contained in the same SDK), substituting for the non-interrupt-driven UART code there.  (Don't ask me why I made the change, but I will need the interrupt version later anyway :)\r\n\r\nBTW, the hardware on my boardfrom the chip out to the comm port in the FET works.  I verified that with simple_uart in an earlier test app.\r\n\r\nProblem appears to be that the app hangs on transmitting the first character of the welcome message \"RF Test....\", presumably waiting for an interrupt on TXRDY that never arrives.  My uart-event-handler routine is certainly never called.  (Have to check again whether the IRQ routine inside app_uart.c is ever called. Don't remember.)\r\n\r\nI won't bother you with code details (at least until I finish my line-by-line review, with product spec, PCN and PAN docs in hand, to make sure I'm not doing something stupid :-) Rather, I'll just ask the following general questions:  Anybody else ever see this sort of thing?  Is there a complete app that uses app_uart.c available that I can use as a template?  (None was found in the SDK.)\r\n\r\nTIA,\r\n\r\nMike\r\n\r\nPS: The Keil MDK shows a \"Power\" enable/disable register in the UART register block, which is not described in product spec.or anywhere else in the docs that I can find :)  Suspect this register is supposed to be hidden and part of the internal logic to power down the UART when HW flow control is used and based on the RTS line.  Comments?  Does this have any bearing on the issues I see?",
    "tag": "uart"
  },
  {
    "text": "NRF_ERROR_NO_MEM error with enough APP_TIMER_MAX_TIMERS Hi,\r\n\r\nI have 2 timers and APP_TIMER_MAX_TIMERS = 3. I am getting NRF_ERROR_NO_MEM error.\r\n\r\nIf I increase to 6 it works. Is it 3 APP_TIMER_MAX_TIMERS per timer?\r\n\r\nThanks,",
    "tag": "timer"
  },
  {
    "text": "What does NRF_TIMER0->TASKS_SHUTDOWN do? The NRF_TIMER's have a TASKS_SHUTDOWN register that isn't mentioned in the documentation anywhere. What does it do?",
    "tag": "timer"
  },
  {
    "text": "Conceptual questions regarding SPI master for nRF51822 I have successfully tested the SPI master loopback example on pca10001 eval board. I have a few questions regarding a real-world scenario when there is a slave SPI present. \r\nIn the loop-back test the RXD byte is immediately available when TXD is written. In a non-loopback scenario, SPI master needs to wait for a valid RX byte. I don't know how to implement this wait. Should I keep reading RXD and clear EVENTS_READY till I get a valid RX byte or is \"spi_master_tx_rx\" smart enough to throw away blank RX bytes until it receives  a real RX byte and put it in the RXD?  \r\nWhat triggers receiving a new RX byte? Clearing EVENTS_READY or reading the RXD? or both?\r\nCould you please point me to a simple example of how this is done?",
    "tag": "spi"
  },
  {
    "text": "Timer value not accurate using app_timer.c in nRF51822? Hi All\r\n\r\nI am facing one issue using app_timer.c, When I put the PRESCALER value as 327 and started timer as app_timer_start(timer_ID, 100, NULL);, It was giving only 920ms instead of 1s? why is this so?\r\n\r\nHere is my code\r\n\r\n\n\n```\n#include <stdint.h>\r\n#include \"nrf.h\"\r\n#include \"app_timer.h\"\r\n#include \"app_error.h\"\r\n#include \"nrf_gpio.h\"\r\n\r\n//\tTimer settings\r\n#define APP_TIMER_PRESCALER             327\t\t\r\n#define APP_TIMER_MAX_TIMERS            1     \t\r\n#define APP_TIMER_OP_QUEUE_SIZE         1     \r\n\r\nstatic app_timer_id_t         timer_ID;\r\n\r\n\r\nvoid app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name)\r\n{\r\n}\r\n\r\n\r\nvoid timeOut(void * p_context)\r\n{\r\n\tnrf_gpio_pin_toggle(4);\r\n\t\r\n}\r\n\r\n\r\nint main(void)\r\n{  \r\n  \t nrf_gpio_cfg_output(4);\r\n\r\n\r\n\t//\tTIMER init\t\r\n\tAPP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n\tNRF_CLOCK->TASKS_LFCLKSTART = 1;\r\n\t\r\n\twhile (NRF_CLOCK->EVENTS_LFCLKSTARTED == 0);\r\n\r\n\tapp_timer_create(&timer_ID, APP_TIMER_MODE_REPEATED, timeOut);\r\n\r\n\tapp_timer_start(timer_ID, 100, NULL);\r\n\t\r\n  while(true)\r\n  {\r\n\t\t\r\n  }\r\n\r\n}\n```\n\r\n\r\nPlease help me on this,\r\nMo",
    "tag": "timer"
  },
  {
    "text": "Use timer2 to generate 1K Hz square waveform, but can not get a continuously 1K Hz square waveform Hi\r\n\r\nI want a 1K Hz square waveform to drive a peripheral device, but I can not get a continuously square waveform on GPIO 19, pls have a look at the picture I attached, the following is the timer initialization and interrupt routine, pls help check why this happened, thanks.\r\n\r\n////////////////////////////////////////////////////////////////////////////Timer2 init\r\nstatic void timer2_init (void)\r\n{\t\r\n\tNRF_TIMER2->TASKS_STOP = 1;\r\n\t// Create an Event-Task shortcut to clear TIMER0 on COMPARE[0] event\r\n\tNRF_TIMER2->MODE        = TIMER_MODE_MODE_Timer;\r\n\tNRF_TIMER2->BITMODE     = TIMER_BITMODE_BITMODE_16Bit;\r\n\tNRF_TIMER2->PRESCALER   = timer2_prescaler_set;       // timer2_prescaler_set = 4\r\n\r\n\tNRF_TIMER2->TASKS_CLEAR = 1;               \t// clear the task first to be usable for later\r\n\t\r\n\tNRF_TIMER2->CC[0] = timer2_interval;   //timer2_interval = 500\t\t\t\r\n\t\r\n\tNRF_TIMER2->INTENSET    = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n\t/* Create an Event-Task shortcut to clear TIMER1 on COMPARE[0] event. */\r\n//\tNRF_TIMER2->SHORTS      = (TIMER_SHORTS_COMPARE1_CLEAR_Enabled << TIMER_SHORTS_COMPARE1_CLEAR_Pos);\r\n\t\t\r\n\tsd_nvic_SetPriority (TIMER2_IRQn, APP_IRQ_PRIORITY_LOW);\t\t// Setzt die Prioroit\u00e4t auf HIGH\r\n  sd_nvic_EnableIRQ \t(TIMER2_IRQn);\t\t\t\t\t\t\t\t\t\t\t\t\t// Aktiviert den Interrupt\r\n\r\n\tNRF_TIMER2->TASKS_START = 1;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nvoid TIMER2_IRQHandler(void) \r\n{\r\n\tuint16_t i;\r\n\t\r\n    if ((NRF_TIMER2->EVENTS_COMPARE[0] != 0) && \\\r\n        ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE0_Msk) != 0))\r\n    {\r\n\t\t\tNRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n\t\t\tNRF_TIMER2->CC[0] += timer2_interval;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tnrf_gpio_pin_toggle(19);\r\n    }\r\n}\n\n![1k_waveform.jpg](/attachment/a0de96f6b109d84141c3f4014bee6174)",
    "tag": "timer"
  },
  {
    "text": "Connect another board over UART from nRF51822 mKit board I am using mbed library to get leg up on development. \r\nThis is the first time I am writing any MCU application and it sure makes things a lot easier. \r\n\r\nI am using nRF51822 mKit board. https://mbed.org/platforms/Nordic-nRF51822/\r\n\r\nI was able to compile and run BLE_API examples without any problem. \r\nI was also able to use pc UART to print debug messages.\r\n\r\nNow I want to control/connect to  another board. The other board also has UART.\r\nI am following the code from this page. https://mbed.org/handbook/SerialPC\r\n\r\nIf I am not wrong, nRF51822 allows to use any pair of GPIO to be used as UART. The thing I am not clear is, can I have two active UART.\r\nSerial pc(USBTX, USBRX); //This goes to PC virtual port.\r\nSerial uart(p27, p28); \r\n\r\nI tried this and I could not communicate with other board. \r\nI am connecting TX -> RX and RX->TX. It doesn't seem to be working. \r\nFor hypothesis testing, I want to use nRF51822 mKit board as transparent bridge to control other device. \r\n\r\n\r\n#include \"mbed.h\"\r\n \r\nSerial pc(USBTX, USBRX); //pin 9, pin 11\r\nSerial uart(p27, p28);\r\n \r\nDigitalOut pc_activity(LED1);\r\nDigitalOut uart_activity(LED2);\r\n \r\nint main() {\r\n    while(1) {\r\n        if(pc.readable()) {\r\n            uart.putc(pc.getc());\r\n            pc_activity = !pc_activity;\r\n        }\r\n        if(uart.readable()) {\r\n            pc.putc(uart.getc());\r\n            uart_activity = !uart_activity;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nAny help is appreciated.",
    "tag": "uart"
  },
  {
    "text": "Functions and libraries Hi everyone, I don't have the nRF51822 yet, but still want to get familiar with it as much as possible before I get to buy it. I was looking for a description of the functions or libraries used in programming and developing the nRF51822 but so far didn't find anything (specially the ones used with the ADC). I will be really thankful if you help me and tell me where to find them.\r\nThanks in advance :)",
    "tag": "adc"
  },
  {
    "text": "SPI using PCA10001 issues Hi\r\n\r\nI used the example from  *nrf51822_v4.4.1.31827\\Board\\nrf6310\\spi_master_example* for my PCA10001 board, as I know the pins configured in this example are for nrf6310 board I modified the section as follows for the PCA10001 board in spi_master_config.h for SPI0\r\n\r\n#define SPI_PSELSCK0              42   /**< Pin P0.22 for clock */   \r\n#define SPI_PSELMOSI0             43   /**< Pin P0.23 for MOSI */\r\n#define SPI_PSELMISO0             44   /**< Pin P0.24 for MISO */\r\n#define SPI_PSELSS0                 45  /**<  Pin P0.25 for Slave select*/\r\n\r\n(the values for pin assignment are selected as per *nRF51822 PS v 1.3* ,pg no:9)\r\n\r\nand I shorted the  MOSI and MISO together for loop back\r\n\r\nBut When I monitored using CRO no clock was seen on the pins P0.22\r\nWhat might be the reason?\r\n\r\nRegards\r\nHPC",
    "tag": "spi"
  },
  {
    "text": "TWI not working on the NRF51422 with ANT soft device It's possible this is a hardware problem, but what I'm seeing is this...\r\n\r\nThe clock is enabled on pin 0, data on pin 4. With both enabled in exactly the same way, drive mode S0D1, and with an internal pullup, the clock pin works as intended, but the data pin is pulled low. This happens even with no other devices on the TWI lines, only a logic analyzer.\r\n\r\nI can set the data pin to S0H1 and it goes high; if I set it to D0S1 it also goes high, but seems to change state at random when the clock pin is toggling in the twi_master_clear_bus() function.\r\n\r\nI'm wondering if it's the same problem as [this](https://devzone.nordicsemi.com/index.php/problem-with-twi-and-mpu9150-mpu6050), or whether that's only a problem for the BTLE soft device?\r\n\r\nAny other ideas?",
    "tag": "twi"
  },
  {
    "text": "UART TASKS_SUSPEND and sending a break Hello everybody,\r\n\r\nI have a few questions about the built-in UART (UART0) in the nRF51822.\r\n\r\n1. I've noticed some registers that aren't fully documented in nrf51.h of the sdk. I'd like to know what TASKS_SUSPEND does. I'm also curious about SHORTS and if there's anything to know about POWER.\r\n\r\n2. The UART can interrupt on a break (http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter#Break_condition), which is great for my application (two UARTs, one on each chip, go to sleep as often as possible and wake each other with a break). Does the UART have the capability to send a break using a simple command, or must I bit-bang a break of the pin by switching the crossbar to GPIO?\r\n\r\nThank you!",
    "tag": "uart"
  },
  {
    "text": "PWM analyzer / Pulse counter Is it possible to count pulses with the 51822 from an external device in the range of 250-15.000 pulses pr. second, while the CPU is powered down (softdevice sleep)?\r\n\r\nI've had a look at the pwm_analyzer sample, which might do the trick. But I'm not familiar with all the GPIOTE events and tasks. and I'm a little unsure that the resolution is high enough for this purpose. As far as I can tell the example measures both the low and high duty cycles, and firing an interrupt after right after it has measured the high cycle. \r\n\r\nI'm not particular interested in generating an interrupt for this reading, as I would rather read the results while the BLE stack is executing to avoid extra wake-up cycles. But according to the example, it seems there is no specific code that restarts the events/task. So I guess it means that they will continuously provide the result to the registers.\r\n\r\nAm I totally off here or is there an easier way to simply count the number of pulses from an external device?\r\n\r\nLooking at the Timer description in the reference manual, it can also operate in a counter mode triggered by a COUNT task. Is it possible to setup a GPIO pin to trigger that task by a lo-hi transition?\r\nThis way I can simply read the register whenever the SD is awake and do the frequency calculation based on the time elapsed since last read.",
    "tag": "timer"
  },
  {
    "text": "PWM analyzer / Pulse counter Is it possible to count pulses with the 51822 from an external device in the range of 250-15.000 pulses pr. second, while the CPU is powered down (softdevice sleep)?\r\n\r\nI've had a look at the pwm_analyzer sample, which might do the trick. But I'm not familiar with all the GPIOTE events and tasks. and I'm a little unsure that the resolution is high enough for this purpose. As far as I can tell the example measures both the low and high duty cycles, and firing an interrupt after right after it has measured the high cycle. \r\n\r\nI'm not particular interested in generating an interrupt for this reading, as I would rather read the results while the BLE stack is executing to avoid extra wake-up cycles. But according to the example, it seems there is no specific code that restarts the events/task. So I guess it means that they will continuously provide the result to the registers.\r\n\r\nAm I totally off here or is there an easier way to simply count the number of pulses from an external device?\r\n\r\nLooking at the Timer description in the reference manual, it can also operate in a counter mode triggered by a COUNT task. Is it possible to setup a GPIO pin to trigger that task by a lo-hi transition?\r\nThis way I can simply read the register whenever the SD is awake and do the frequency calculation based on the time elapsed since last read.",
    "tag": "pwm"
  },
  {
    "text": "app_timer on app_evt_wait - fails / failing / bugging out / cancelling In moving to the \"rev-2 51422 silicon, we find that the app_timer inevitably fails after minutes to several hours.  Power requirement moves from about .002ma to 4.5ma then stays there. Prior silicon did not have this problem. \r\n\r\nThe same routine is called via the handler on every interval. As discovered, we removed ALL instructions in the handler routine - the event timer still fails. \r\n\r\nNo other instructions are contained in the main where the app_timer is called.\r\n\r\nwhile (forever)\r\napp_evt_wait();\r\n\r\na. Is this a known problem?\r\nb. why is it not noted in the PAN\r\nc. is there a solid fix that will keep it from failing?\r\n\r\ntks!",
    "tag": "timer"
  },
  {
    "text": "Multiple serial \"ports\" on nRF51822, e.g., using app_uart module from SDK with UIDs? Folks,\r\nI'd like to use the single UART peripheral in the nRF51822 in *interleaved* fashion to support two serial \"ports\", e.g., sets of GPIO pins dedicated to separate serial channels.\r\n\r\nIs the version of the app_uart module in SDK 4.4.2 (because I have \"C0\" chips right now) which assigns UIDs designed for this purpose?  I *infer* that it is from the SDK documentation, but could clearly be wrong here :) \r\n\r\nIf so, is there a state machine diagram, etc., for this scenario?  For example, do I call app_uart_init (the version that issues UIDs repeatedly) to assign all the ports I want?  But then how do I switch between them?  Or do I bracket each port's usage of the peripheral with an app_uart_init/app_uart_close pair?  If so, what happens when I open a specific port the second time?  Do I supply the former UID and it gets reused?  Or do I set the UID parameter to 0 and it gets a new value (which seems to be useless then)?\r\n\r\nHaven't been able to answer these questions myself from the SDK docs and haven't found an example use of the app_uart module with UIDs in sample code.  Am I missing something?\r\n\r\nTIA,\r\n\r\nMike",
    "tag": "uart"
  },
  {
    "text": "sd_ble_gatts_hvx() and extra data Hello,\r\n\r\nI'm using Win 8.1 BT LE stack to communicate with the NORDIC.  I am using soft device s110.  I use notifications to send data to windows which assembles a message based on it.  I am seeing that every so often (and it is not every time), data gets sent over BT that is extra data. \r\n\r\nFor example, I am meaning to send a 60 bytes of data and instead, windows receives an extra 27 bytes (87) of data.  This is not the exact situation, but is pretty close.  Also, these 27 bytes seem to be random. The bytes also seem to come in the middle of the stream, so I get something like 40 good bytes, 27 garbage bytes, then the remaining 20 good bytes.\r\n\r\nI'm 90% sure it's not my code because the code is just reading from the SPI bus and then sending the data.  I've verified the SPI bus data with the logic analyzer is correct (60 bytes) and that the data Windows gets is the 87 bytes as described before.\r\n\r\nIs this a know issue?  Is there a workaround?  Am I missing something?\r\n\r\nThanks.",
    "tag": "spi"
  },
  {
    "text": "Android UART app does not load properly into Eclipse  We downloaded your nRFUART_Android4.3 source code from your site and tried to launch it in Eclipse. It came up with \"nRFUART_GoggleV2 unable to resolve target 'android-18' error. The source shows many errors. Do you have an updated version or do I need to use another development environment? Your nRFToolBox launched correctly.\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "frequency counter Hi all,\r\n\r\nI've been trying to use the RFduino (nrf51822) to implement frequency counter for a light-to-frequency photodiode. The output frequency from the photodiode can be anywhere from 0 Hz to 10k Hz.\r\n\r\nI tried to set a gpio pin as input, then attach interrupt to detect lowToHi edge. increment a timer in counter mode in each of the gpio interrupt by calling COUNT task. then use another timer to generate the gate time. By doing this, I'm able to get numbers of counts but they are much smaller than they should be. \r\n\r\nI'm new to the nrf51 series chips. I think the problem i have might be the redundant use of gpio interrupt for counter. I'm wondering if there is some other way to implement this kind of external pulse train frequency counting?\r\n\r\nThanks!",
    "tag": "timer"
  },
  {
    "text": "nRFUART_Android4.3 source code Errors In Latest ADT In the latest version of ADT (Android development tools Build iV22.6.2-1085508 Eclipse), nRFUart source code will not run. It says \"errors must be fixed before running this...\" There are no errors listed but a big exclamation point shows up on the file name.",
    "tag": "uart"
  },
  {
    "text": "SPI hangs waiting for EVENTS_READY Hi,\r\n\r\nI'm trying to get SPI (master) to work (nRF51822) for communicating with a quadrature counter (LS7366R).\r\nI've read several implementations of SPI master, such as the one in RFduino and the mbed library, and I've read the reference manual.\r\n\r\nAfter a few bytes of exchange, the communication hangs waiting for EVENTS_READY to turn 1. See the while loop below in my code. Sometimes it happens on the first byte, and sometimes after a few more. The data I get back is all 0xFF, which isn't correct, but that might be unrelated.\r\n\r\nHere's the code. device->module is set to NRF_SPI0.\r\n\r\n    uint8_t tfspi_transmit(tfspi_device_t *device, uint8_t byte) {\r\n\tdevice->module->TXD = byte;\r\n\twhile (device->module->EVENTS_READY == 0); // Infinite loop here\r\n\tdevice->module->EVENTS_READY = 0;\r\n\tuint8_t readByte = device->module->RXD;\r\n\treturn readByte;\r\n}\r\n\r\n![SPI0 as shown by Keil when hang occurs](http://i.imgur.com/PzTpC4U.png)\r\n\r\nMaybe this is something someone has seen before?\r\nThanks for your help!",
    "tag": "spi"
  },
  {
    "text": "Available ADC code plz. I search for adc simple code.\r\n\r\nBut all reference codes are not properly linked.\r\n\r\nWould you upload codes again to download.\r\n\r\nRegards..",
    "tag": "adc"
  },
  {
    "text": "Transmitting data from ADC over pipe I'm trying to send data acquired from the ADC and monitor it using the master emulator. \r\n\r\nThe values I'm getting do not appear to make sense though. \r\n\r\nI'm using the BLE_HRS with ADC example discussed [here](https://devzone.nordicsemi.com/question/6976/s110-adc-example/) but from looking at the code it only outputs the adc reading on the GPIO port 2. \r\n\r\nI've changed the code so that heart_rate is 0 \r\n\r\n      err_code = ble_hrs_heart_rate_measurement_send(&m_hrs, 0);\r\n\r\nLooking at the master emulator the value still seems to jump around:\r\n\r\n> [00:23:05.4] Received a HandleValueNotification on handle 000E with value 0400\r\n \r\n> [00:23:06.4] Received a HandleValueNotification on handle 000E with value 1400E942E942E942\r\n\r\n> [00:23:07.4] Received a HandleValueNotification on handle 000E with value 1400E942E942E942E942\r\n\r\nThe code appears to be updating the hex file and I've disabled all the usages of sensorsim. Is there something I'm misunderstanding about how the send function works? \r\n",
    "tag": "adc"
  },
  {
    "text": "TWI with S110 on nRF51822 Dear  H\u00e5kon Alseth,\r\n\r\nyou posted twi source code which took care of all SD/PPI stuff [here](https://devzone.nordicsemi.com/question/309/best-place-to-get-started/?answer=12222#post-id-12222) and it was also linked [here](https://devzone.nordicsemi.com/question/5311/problem-with-twi-and-mpu9150mpu6050/?answer=12223#post-id-12223) , but it is no longer available. The whole forum seams to be broken. Could you please upload a example fpr twi hw master with enabled sd to your github page? Thanks in advance.\r\n\r\nRegards,\r\nMarius\r\n",
    "tag": "twi"
  },
  {
    "text": "TWI with S110 on nRF51822 Dear  H\u00e5kon Alseth,\r\n\r\nyou posted twi source code which took care of all SD/PPI stuff [here](https://devzone.nordicsemi.com/question/309/best-place-to-get-started/?answer=12222#post-id-12222) and it was also linked [here](https://devzone.nordicsemi.com/question/5311/problem-with-twi-and-mpu9150mpu6050/?answer=12223#post-id-12223) , but it is no longer available. The whole forum seams to be broken. Could you please upload a example fpr twi hw master with enabled sd to your github page? Thanks in advance.\r\n\r\nRegards,\r\nMarius\r\n",
    "tag": "i2c"
  },
  {
    "text": "How to send data from Pic controller to nrf51822 using UART? Hello all,\r\n\r\nI want to send some sensor data( collected by Pic controller) to other BLE client(may be a phone) using nrf51822 via UART. Can somebody suggest how to communicate using UART? Do I need to run UART program on both the controller and the nrf51822 chip using Pic and BLE apis respectively?\r\n\r\nIn all, I want get data from Pic controller to my nrf51822 chip(using UART) and then want to send that data to another BLE device such as Phone(using UART).",
    "tag": "uart"
  },
  {
    "text": "S120 UART communication Hi, I'm trying to make BLE hardwares on both s110 and s120.\r\nThere are two devicees one for S110 peripheral and the other for s120 central.\r\n\r\nS110 pheriperal device has to functions.\r\n 1. Using general profile, communicate with phone, something like heart beat profile.\r\n 2. With custom profile, communicate with the s120 device.\r\n\r\nS120 central device scans for the s110 pheriperal device.\r\nwhen connection made, they communicate like zigbee or other communication protocol.\r\nS120 device is connected to pc with usb, so PC can send UART message to the S120 device, and\r\nit send the data to S110 device. \r\n\r\nI want to communicate with two nRF chips. \r\nThere are many examples on S110, but there is very few examples on S120..\r\nit look like Nordic is also work on it. \r\n\r\nSo the question is:\r\n 1. Can i make UART ble app (like SPP profile) on S120 device?\r\n   (if i can, is there any examples or documents?)\r\n\r\nI think i can handle S110 part, there is an example of UART ble app, but S120 don't. \r\nI'm first on bluetooth, so please help me.",
    "tag": "uart"
  },
  {
    "text": "What is the difference between \"uart_example\" and \"ble_app_uart\"(under path S110/experimental) for PCA10001? Hello all,\r\n\r\nI little confused with these two examples as mentioned in my question. Both examples are different and their use case is also different. Can somebody please suggest which one to use when?",
    "tag": "uart"
  },
  {
    "text": "Unaccurate battery level measurment on Beacon device Hi,\r\n\r\nI know that a lot of question exists on that subject, but I can't manage to have an accurate battery measure on [Nordic Beacon device] (battery CR1632 3V) (https://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF51822-Bluetooth-Smart-Beacon-Kit). The measure is always -100mV-300mv to low and I can't understand why.\r\n\r\nFirst of all, I read the [Nordic GitHub project](https://github.com/NordicSemiconductor/nrf51-ADC-examples/blob/master/adc-example-with-softdevice/main.c) to inpired me and then modify the configuration to fit my need, but I certainly did a mistake.\r\n\r\nThe battery measurment is done before any bluetooth stack is involved (before starting the advertisment) : in summary no advertising and device not connected.\r\n\r\nHere is my code : \r\n\r\n    #define ADC_REF_VOLTAGE_IN_MILLIVOLTS        1200                                       /**< Reference voltage (in milli volts) used by ADC while doing conversion. */\r\n    #define ADC_PRE_SCALING_COMPENSATION         3                                          /**< The ADC is configured to use VDD with 1/3 prescaling as input. And hence the result of conversion is to be multiplied by 3 to get the actual value of the battery voltage.*/\r\n    #define DIODE_FWD_VOLT_DROP_MILLIVOLTS       270                                        /**< Typical forward voltage drop of the diode (Part no: SD103ATW-7-F) that is connected in series with the voltage supply. \r\n                                                                                                 This is the voltage drop when the forward current is 1mA. Source: Data sheet of 'SURFACE MOUNT SCHOTTKY BARRIER DIODE ARRAY' available at www.diodes.com. */\r\n    #define ADC_RESULT_IN_MILLI_VOLTS(ADC_VALUE)\\\r\n            ((((ADC_VALUE) * ADC_REF_VOLTAGE_IN_MILLIVOLTS) / 255) * ADC_PRE_SCALING_COMPENSATION)  \r\n                  \r\n    //ADC initialization\r\n    static void adc_init(void)\r\n    {\t\r\n    \t/* Enable interrupt on ADC sample ready event*/\t\t\r\n    \tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n    \tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n    \tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    \r\n      // Configure ADC\r\n      NRF_ADC->CONFIG     = (ADC_CONFIG_RES_8bit                        << ADC_CONFIG_RES_Pos)     |  /*!< 8bit ADC resolution. */ \r\n                            (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)  |\r\n                            (ADC_CONFIG_REFSEL_VBG                      << ADC_CONFIG_REFSEL_Pos)  |  /*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n                            (ADC_CONFIG_PSEL_Disabled                   << ADC_CONFIG_PSEL_Pos)    |\r\n                            (ADC_CONFIG_EXTREFSEL_None                  << ADC_CONFIG_EXTREFSEL_Pos); /* Bits 17..16 : ADC external reference pin selection. */\r\n    \t\r\n    \t/* Enable ADC*/\r\n    \tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n    }\r\n\r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \tif (NRF_ADC->EVENTS_END != 0)\r\n    \t{\r\n    \t\tuint8_t   adc_result;\r\n            uint16_t  batt_lvl_in_milli_volts;\r\n    \t\t\r\n    \t\tNRF_ADC->EVENTS_END = 0;\r\n    \t\tadc_result  = NRF_ADC->RESULT;\r\n    \t\tNRF_ADC->TASKS_STOP = 1;\r\n    \r\n    \t\t//Release the external crystal\r\n    \t\tsd_clock_hfclk_release();\r\n    \r\n    \t\tbatt_lvl_in_milli_volts = ADC_RESULT_IN_MILLI_VOLTS(adc_result);\r\n    \t\t\r\n    \t\tm_bat_level  = (batt_lvl_in_milli_volts / 10) - 100;\r\n    \t\tkernel_setSignal(SIGNAL_BATTERY_CHECK);\r\n    \t}\r\n\r\n\r\n    void kernel_battery_check(void)\r\n    {\r\n        uint32_t p_is_running = 0;\r\n    \r\n    \tsd_clock_hfclk_request();\r\n    \twhile(! p_is_running) {  \t\t\t\t\t\t\t//wait for the hfclk to be available\r\n    \t\tsd_clock_hfclk_is_running((&p_is_running));\r\n    \t}            \r\n        NRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.\t\r\n    \tNRF_ADC->TASKS_START = 1;\r\n    }\r\n",
    "tag": "adc"
  },
  {
    "text": "Problem with TWI (SD) and nrf51[48]22 eval \r\nI am using hw TWI with the s110_nrf51822_6.0 softdevice, nrf51_sdk_v5_2_0\r\nI am using pin 3 scl and pin4 sda of the nrf51[48]22 eval boards. \r\nI am able to drive these pins high, \r\n\r\nI have done the test with both nrf51822 and nrf51422 eval boards. There does not appear to be a hardware problem. \r\nWhen I simulate data, both of these work eval boards work correctly with the nordic ble uart apps. \r\n\r\n\r\nI am using gcc, make and eclipse. \r\nI have tried two code sources \r\nhttps://github.com/seattlezhu/W1FW https://github.com/tdwebste/W1FW\r\nand\r\nhttps://github.com/tdwebste/W1FW\r\nThe second repository requires the nrf51 sdk installed at the same level \r\n\r\n\r\n\r\nI am not sure if my problem is the same as\r\nhttps://devzone.nordicsemi.com/question/5311/problem-with-twi-and-mpu9150mpu6050/\r\n\r\nI have verified that twi_master_init() returns success. \r\n\r\n--------------------------\r\nInteresting results for software/hardware twi_master\r\n\r\nunplug the scl the twi_master_init() fails as it should, DEVICE does not hang\r\nplug in the scl the twi_master_init() successes, but read fails.\r\nrepeat with hardware twi_master\r\n\r\nunplug the scl the twi_master_init() DEVICE hangs, If I\r\nplug in the scl the twi_master_init() successes, but read fails.\r\nIn both cases no return from the read function called from the timed event\r\n\r\n\r\n \r\n",
    "tag": "twi"
  },
  {
    "text": "How can I download example of this form I need link of [this](https://devzone.nordicsemi.com/question/1159/how-to-read-the-value-from-adc/)   \r\n\r\nBut I can't download adc_example_from_AIN_8bit_10bit.zip of this link\r\n\r\nHow can I get all this kinds of example?",
    "tag": "adc"
  },
  {
    "text": "RX_DR interrupt doesn't fire when ACK payload is in FIFO part 2 Hi,\r\n\r\nI asked the same question but it was a long time ago and still I don't know how to solve this issue. I got a reply but It wasn't help so now I'm writing again with more details.\r\n\r\nWell, I have some problem with NRF24L01+. I'm trying to make bidirectional connection between two devices with this chip. When I'm sending payload with ACK, TX_DS interrupt on PRX fire but RX_DR on PTX doesn't. I know that i have got this data because FIFO RX isn't empty. What condition should be fulfilled to RX_DR interrupt fire on ongoing data with ACK?\r\n\r\nMy routine on PTX side looks like: \r\n\r\n1. Go to PTX mode. \r\n2. Send payload. \r\n3. While TX_DS or MAX_RT doesn't fire, do nothing. \r\n4. If MAX_RT fire, set (clear ;)) this interrupt and send packet again. \r\n    Else if TX_DS fire, wait ~100ms then check RX_DR - in this moment, I know i get acknowledge packet because FIFO isn't empty and i'm printing it to console without problem. But RX_DR doesn't fire. \r\n\r\nAs I know, I don't have to enable this interrupt in CONFIG register because it just set reflect on physical pin, and I don't need this. Of course I enabled it but it doesn't help. Also I was trying to set PRX mode after sending the packet, but it doesn't help too.\r\n\r\nMy NRF is configured like this:\r\n\r\nPRX side:\r\nSTATUS: 0x0E\r\nCONFIG: 0x7F\r\nEN_AA: 0x3F\r\nEN_RXADDR: 0x03\r\nSETUP_AW: 0x03\r\nRF_CH: 0x6E\r\nRF_SETUP: 0x06\r\nRX_PW_P0: 0x00\r\nDYNPD: 0x03\r\nFEATURE: 0x06\r\nRX_ADDR_P0: 0xE7|0xE7|0xE7|0xE7|0xE7|\r\nTX_ADDR: 0x0F|0x0F|0x0F|0x0F|0x0F|\r\n\r\nPTX side:\r\nSTATUS: 0x0E\r\nCONFIG: 0x0E\r\nEN_AA: 0x3F\r\nEN_RXADDR: 0x03\r\nSETUP_AW: 0x03\r\nRF_CH: 0x6E\r\nRF_SETUP: 0x07\r\nRX_PW_P0: 0x20\r\nFEATURE: 0x06\r\nDYNPD: 0x03",
    "tag": "interrupt"
  },
  {
    "text": "questions about nRF9E5 Hi.\r\n\r\nI would like to konw some ditails aboute nRF9E5 device:\r\n\r\n1. What is the rang between 2 devices using 433 mhz.\r\n2. do you have any samples codes ? i need to trasmitt 2 a/d  data.\r\n3. the developping board comes with the option to use 2 devices ( 1 for tx 1 fo rx)?\r\nMany thanks\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "configure UART signal levels Hi all,<br/>\r\nwe are using the nRF51822 together with another module that provides an 1.8V UART only (LO = 0V, HI = 1.8V). Other IC\u00b4s on the device are using 3V Vdd and are connected by I2C.\r\n\r\nThe current design would make us of an voltage-translator like TI SN74AVC8T245 to connect that module by UART.\r\n\r\nFrom the PS I assume the UART levels (in/out HI/LO) of the nRF51 are as specified in the GPIO section (as the UART can be switched to any IO).<br/>\r\nIs there any way to configure the UARTs signal level to work without the voltage translation IC? \r\n\r\nThanks a lot and best regards",
    "tag": "uart"
  },
  {
    "text": "ADC + Softdevice Hi,\r\n\r\nIm trying to monitor the high voltage im generating with PWN using ADC. I also need to run BLE at the same time to provide results.\r\nSo far I dont have any luck and it seems with Keil you cant even debug this things (please correct me if Im wrong, but when i start stepping through it gets hang on the first BLE command).\r\n\r\nIm using ble_hrs example. And thats what i added:\r\n\r\n    //ADC initialization\r\n    static void adc_init(void)\r\n    {\t\r\n    \t/* Enable interrupt on ADC sample ready event*/\t\t\r\n    \tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n    \tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n    \tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    \r\n    \tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput1 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< Use analog input 2 as analog input. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n    \r\n    \t/* Enable ADC*/\r\n    \tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n    }\r\n    \r\n    /* Interrupt handler for ADC data ready event */\r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n    \r\n      /* Write ADC result to port 2 */\r\n     \t//nrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT2, NRF_ADC->RESULT); \r\n    \t//nrf_gpio_pin_toggle(LED_3);\r\n    \t\r\n    \tADCLEVEL=NRF_ADC->RESULT;\r\n    \r\n    \t//Use the STOP task to save current. Workaround for PAN_028 rev1.5 anomaly 1.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n    \r\n    \t//Release the external crystal\r\n    \t//sd_clock_hfclk_release();\r\n    }\r\n\r\n\r\nI also enable conversion on every battery timer expiration \r\n\r\n    NRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.\r\n     NRF_ADC->TASKS_START = 1;\r\n\r\nand eventually write the ADCLEVEL value in the battery level on ble.\r\n\r\n    battery_level=ADCLEVEL;\r\n        err_code = ble_bas_battery_level_update(&m_bas, battery_level);\r\n\r\n\t\r\n\r\nAny idea what am i doing wrong and how i can test/debug this?\r\n\r\nThanks!\r\n\t\r\n ",
    "tag": "adc"
  },
  {
    "text": "UART and arduino uno communication I have a nRF51822 and arduino uno board. Is it possible to connect my nRF51822 uart to the arduino rx/tx, so that i can use it for communication to PC through arduino. The voltage levels in UNO works on 5V p-p and nRF51822 is 3.3 p-p. Will it destroy the nRF51822 if we connect the pins?\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "nrf51822 spi slave problems Hi,\r\n\r\nI'm trying to communicate between a stm32f4 (spi master) and a nrf51822 (spi slave). I have configured the MISO, MOSI, CS and SCLK of the nrf. I use the spi_slave_example for testing the communication.\r\n\r\nFirst question is : why the MISO pin is configured as input?\r\n\r\nThe stm32f4 can well communicate with my other sensors through spi, but with the nrf nothing append. The callback method is never call. I don't understand why.\r\n\r\nI don't really understand what is the goal of the spi_slave_buffers_set method.\r\n\r\nIs there a special address or sequence to send to the nrf for start slave communication?\r\n\r\nThank you already for your help",
    "tag": "spi"
  },
  {
    "text": "nrf51822 spi slave problems Hi,\r\n\r\nI'm trying to communicate between a stm32f4 (spi master) and a nrf51822 (spi slave). I have configured the MISO, MOSI, CS and SCLK of the nrf. I use the spi_slave_example for testing the communication.\r\n\r\nFirst question is : why the MISO pin is configured as input?\r\n\r\nThe stm32f4 can well communicate with my other sensors through spi, but with the nrf nothing append. The callback method is never call. I don't understand why.\r\n\r\nI don't really understand what is the goal of the spi_slave_buffers_set method.\r\n\r\nIs there a special address or sequence to send to the nrf for start slave communication?\r\n\r\nThank you already for your help",
    "tag": "spi"
  },
  {
    "text": "SPI clock frequencies in Hz I see that we can specify the SPI frequency in bps, I was just wondering how fast the SCK line was oscillating for these values. Does it use the 32.768 kHz crystal oscillator that is in the spec sheet for the clock?\r\n\r\nThanks,\r\nMatt ",
    "tag": "spi"
  },
  {
    "text": "ADC_IRQHandler not called when using RTC \r\nI've modified the button press example from nAN-36 using the ADC examples from the git repository. \r\n\r\nWhat I'm trying to do is send the data sampled via the ADC using the real time clock via a notify as is used on the button in the application note. I've added the notify (using the on_button_change function in the ADC_IRQHandler.\r\n\r\nI've also copied over the timing functions from the rtc example. \r\n\r\nI've added breakpoints on the IRQHandler but it is never called. Am I wrong in assuming that the ppi will not trigger the interrupt via channel 0? It seems that outputting the result is also handled the same way in the example. Or will I need to make some modifications to the on_button_change function\r\n\r\n\r\n        static void ppi_init(void)\r\n    {\r\n      // Configure PPI channel 0 to start ADC task\r\n      NRF_PPI->CH[0].EEP = (uint32_t)&NRF_RTC0->EVENTS_TICK;\r\n      NRF_PPI->CH[0].TEP = (uint32_t)&NRF_ADC->TASKS_START;\r\n    \r\n      // Enable PPI channel 0\r\n      NRF_PPI->CHEN = (PPI_CHEN_CH0_Enabled << PPI_CHEN_CH0_Pos);\r\n    }\r\n\r\n\r\n\r\n        void ADC_IRQHandler(void)\r\n    {\r\n    \t uint8_t     adc_result;\t    \r\n    \t uint32_t err_code;\r\n    \t\r\n    \t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n    \t\r\n    \tadc_result              = NRF_ADC->RESULT;\r\n    \t\r\n    \t//Use the STOP task to save current. Workaround for PAN_028 rev1.5 anomaly 1.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n    \t\r\n    \t//Release the external crystal\r\n    \tsd_clock_hfclk_release();\r\n    \t\r\n    \r\n    // Notify ADC property    \r\n                err_code = ble_lbs_on_button_change(&m_lbs, adc_result);\r\n                if (err_code != NRF_SUCCESS &&\r\n                    err_code != BLE_ERROR_INVALID_CONN_HANDLE &&\r\n                    err_code != NRF_ERROR_INVALID_STATE)\r\n                {\r\n                    APP_ERROR_CHECK(err_code);\r\n                }\r\n       \r\n    }\t\r\n",
    "tag": "adc"
  },
  {
    "text": "nRF24L01+ Enhanced ShockBurst problem Hi,\r\n\r\nI have two types of nRF24 equipped devices, let's call it a BaseStation and a Slave. BaseStation is configured as PTX, whereas Slave is configured as PRX. Both use Enhanced ShockBurst with auto-ACK and retransmissions.\r\nCommunication works as a charm for 3 Slaves connected to BaseStation. Every 300ms the BaseStation sends ping to each Slave device on the list, utilizing auto-ACK feature to figure out if the Slave responded. The problem appears when there is 4'th Slave device connected to the BaseStation. In this case the BaseStation immediately looses connection to all Slaves.\r\n\r\nIt looks even worse - the BaseStation sends pings and receives ACKs, but the Slaves don't get anything (no Data Ready IRQ,STATUS and FIFO_STATUS registers indicate nothing was received).\r\n\r\nConfiguration should be OK (DPL_P0 = 1 ENAA_P0 =1 EN_DPL = 1 EN_ACK_PAY=1 TX_ADDR and RX_ADDR_P0 for PTX and RX_ADDR_P0 for PRX), since for 3 Slave devices it works as designed, for some reason it doesn't work for 4 and more devices. What could be difference between handling 3 and 4 devices? \r\nFirst thing that comes to my mind is that there are 3 TX and RX FIFOs, but before every transmission I flush them both.\r\n\r\nOne more remark: in PRX I set RX_PW_P0 to 2 bytes, since that's the size of ACK payload I use.\r\n\r\nBest Regards\r\nMichal Frynas.",
    "tag": "interrupt"
  },
  {
    "text": "Hello, where can I find the BLE_GAP.h file or how is it generated and used by nRF8001? Thanks I am trying to use nRF UART app and nRF8001 chip. But I cannot change the device name. I intend to change the device name after nRF UART app detects the device. Plus when I program the chip, I should be able to put a writeable Device Name.",
    "tag": "uart"
  },
  {
    "text": "LM35DZ and NRF51822 Any experiences about analog sensor LM35DZ? I used this example: [main.c](/attachment/2e49600661bbcefe47a00c138ca9e155)\r\n\r\nThe LM35 data sheet says it will operate from +4V to 30 V supply. I'm use supply only Vcc pretty low exactly cca 2.6 V. It is necessary to use external power supply for a sensor?\r\n\r\nI used formula:\r\nVoltage at pin in mV = (reading from ADC) * (3300/1024)\r\nThis formula converts the number 0-1023 from the ADC into 0-3300mV (= 3.3V)\r\nThen, to convert mV into temperature,\r\nuse this formula:\r\nCentigrade temperature = [(analog voltage in mV) - 500] / 10\r\n\r\nConnection:  LM35DZ, R-C: 75G + 1 uF, to pin: AIN2\r\n\r\nThe sensor is slightly heated and the resulting value is 248 Celsius. Any solution?\r\nThanks",
    "tag": "adc"
  },
  {
    "text": "nRF Sniffer on linux host - uart connection I'd tried some first steps using nRF Sniffer on a linux host.\r\n\r\nWithin sniffer_uart_protocol.xlsx I read something about the Uart packet format et cetera.\r\n\r\nI'd programmed my PCA10000 V2.2.0 with the current sniffer version 0.9.7 while succesfully trying out nRF Sniffer on a Windows host machine.\r\n\r\nWhen I plug the PCA10000 to my linux machine, I'd expected a new /dev/ttyUSBx but it isn't. Using `lsusb`, I just see a new usb device: `Bus 002 Device 012: ID 1366:0105 SEGGER`. And in `/dev`, I see a `ttyACM3`.\r\n\r\n- Did anybody know if the `/dev/ttyACMx` is related to the nRF Sniffer uart interface?\r\n- And what about the connection parameters?\r\n  - Baudrate?\r\n  - Rts / Cts hardware handshake?\r\n\r\nI'd performed some tests with 38.400\u202fbd and 115.200\u202fbd. On my `/dev/ttyACM3` I see lots of incoming data, but never the pattern `0xBE 0xEF` as described in sniffer_uart_protocol.xlsx.\r\n",
    "tag": "uart"
  },
  {
    "text": "TWI SHORTS not working Device: nRF51822 Rev G0\r\n\r\nSDK: v5.2.0\r\n\r\nCode: https://raw.githubusercontent.com/NordicSemiconductor/nrf51-ble-app-lbs/twi-display-5.1.0/twi_hw_master.c\r\n\r\nBasically, the TWI driver which uses PPI channels (sd_ppi_*) works perfectly - however, the driver which utilises the newly fixed (in Rev G0 devices) shortcuts DOES NOT.\r\n\r\nI've narrowed down the issue to TWI read transactions only (writes seem to work fine) - see attached screenshot.\r\n\r\nHas this new code been tested by Nordic with READ transactions? I only ask as the supplied example (https://github.com/NordicSemiconductor/nrf51-ble-app-lbs/tree/twi-display-5.1.0) only seems to issues writes to the LCD device.\r\n\r\nMany thanks.\r\n\r\n![image description](/attachment/e560772191fb958502082749c8d06df0)",
    "tag": "twi"
  },
  {
    "text": "nRF Uart v2.0 not Receiving I am using the eval board, sdk v5.2.0, s110 v5.0 and a galaxy nexus with the UART Nordic app. I have not been able to receive any data on the android end. After\r\n\r\n    void nus_data_handler(ble_nus_t * p_nus, uint8_t * p_data, uint16_t length)\r\n\r\nis called i turn toggle an led. I can verifty that when i type something in my android device that it receives the message because the led will toggle. However i never get any messages back.\r\n\r\nMuch Thanks,\r\n\r\nNick",
    "tag": "uart"
  },
  {
    "text": "Interrupt driven TWI master? I see there have been some issues with TWI in early revs of silicon, but looking at SDK 6 I see the twi_master_hw uses the silicon hardware to read/write the I2C device, but no example of an interrupt driven version is provided.  I want to use a cheap eeprom to save key values but with I2C being so slow I don't want to waste time waiting for the process.  I understand that typically the data is needed in a timely manner but I'd prefer to setup a string of data to write to the eeprom and let the interrupt system take care of the necessary handshaking.  Is there something preventing me from doing that?  I know that pstorage is designed to do this, but I need to update values frequently and I'm afraid I'll wear out the flash.  EEPROMs have 50 times the write cycles of the flash.",
    "tag": "i2c"
  },
  {
    "text": "Interrupt driven TWI master? I see there have been some issues with TWI in early revs of silicon, but looking at SDK 6 I see the twi_master_hw uses the silicon hardware to read/write the I2C device, but no example of an interrupt driven version is provided.  I want to use a cheap eeprom to save key values but with I2C being so slow I don't want to waste time waiting for the process.  I understand that typically the data is needed in a timely manner but I'd prefer to setup a string of data to write to the eeprom and let the interrupt system take care of the necessary handshaking.  Is there something preventing me from doing that?  I know that pstorage is designed to do this, but I need to update values frequently and I'm afraid I'll wear out the flash.  EEPROMs have 50 times the write cycles of the flash.",
    "tag": "twi"
  },
  {
    "text": "Best way to reload an app timer with a new value? Currently, I'm using the following:\r\n\r\n    if((err_code = app_timer_stop(m_timer_id)) == NRF_SUCCESS)\r\n    {\r\n        err_code = app_timer_start(m_timer_id, APP_TIMER_TICKS(g_timer_val*1000, APP_TIMER_PRESCALER), NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    else\r\n    {\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\nThe problem is that most of the time, the above code is called from various handlers and ISRs which have a higher priority than SWI0 (which is used to update the timer task list). So the timer list update actually occurs after the ISR calling the above code returns.\r\n\r\nDue to all this, the new timer value doesn't actually get loaded into the timer. I'm pretty sure this is because the stop timer action doesn't get performed.\r\n\r\nIn short, does anyone have any ideas on how a app timer value can be updated while it is running?\r\n\r\nThanks. ",
    "tag": "timer"
  },
  {
    "text": "nRF8001 sends ACI packets but can't receive them I've used the nRF8001 on several projects with good success, so I'm generally familiar with the chip's operation. But I'm seeing an issue on a new (custom) board that I'm not sure how to interpret. I wonder if anyone else has seen something similar.\r\n\r\nThe nRF8001 sends a DeviceStartedEvent after reset that indicates Setup mode, no hardware errors, and two data credits - all perfectly normal. It also accepts any packet sent by the MCU with proper handshaking, sending back a debug byte of 1 and then a stream of zeros during the exchange. Again, perfectly normal.\r\n\r\nHowever, I can't get the chip to actually respond to any packet. Sending the first setup data packet yields no response. I also tried sending a Test packet to put the device in ACI test mode, but that generates no response either. \r\n\r\nIt's as if the MOSI line were tied to GND, so that the nRF8001 sees only empty ACI packets. But there's no short - I can see the outbound data on the nRF8001's MOSI pin, and setting the MOSI line high does not increase the system's current consumption, as it would if there were some hidden short to ground. \r\n\r\nOne thing I'm doing differently on this board is putting the 16 MHz crystal on the MCU and feeding the clock signal through to XC1 via an MCU output pin. XC2 is unconnected. I can see the clock running, but there's nothing else on the line - it just runs right from the MCU to XC1. That should be fine, shouldn't it? Is the 16MHz clock even used during basic ACI communication, before the radio is activated?\r\n\r\nAnother possible issue is that the solder joint on the balun (the matching Johansson chip) looks a bit questionable. Is it possible that a short or open circuit on ANT1 and ANT2 might cause this kind of misbehavior?\r\n\r\nAt this point, I'm pretty much stuck for other things to try. I'm more or less resigned to rebuilding another copy of the board to rule out some kind of construction issue or hardware defect.\r\n\r\nIf any of this rings a bell, I'd appreciate any comments.",
    "tag": "spi"
  },
  {
    "text": "nRF51422 SPI issue - Checking for MISO state outside of the SPI library Hi,\r\n\r\nI am developing a multi-protocol communication device using BLE, ANT and 868Mhz \"long-range\" communication. I am using MRF49XA chip for sub-ghz communication. I have all libraries already done and working for STM32 microcontrollers and I am just porting them to nRF51422 (with S310 stack). One of the characteristics of the MRF49XA is that during packet transmission, the uC needs to wait until the SDI (MISO) line is put high by the MRF49XA until it sends the next byte (then the MISO is low until the radio transmits the byte). No clock cycles nor SS pin transition can be done during this wait. How to implement this on nRF51 the cleaniest and most reliable way? Can I read the logic state of MISO directly without severing the SPI communication?\r\n\r\nThank you in advance,\r\nBest Regards,\r\nMarek Novak.",
    "tag": "spi"
  },
  {
    "text": "SPI Slave DMA Hi, \r\nI am currently trying to use PCA10001 board as master and slave at the same time. Trying to send data from master(SPI0) and receive it using slave (SPIS1).\r\nI have set appropriate pins, and I was able to receive data and store them in RAM manually.\r\n\r\nHowever, SPIS support DMA according to the product specification. But I could not find how to use DMA anywhere.\r\n\r\nIt would be really helpful If you could help me\r\n\r\nFaithfully,",
    "tag": "spi"
  },
  {
    "text": "SPI Slave DMA Hi, \r\nI am currently trying to use PCA10001 board as master and slave at the same time. Trying to send data from master(SPI0) and receive it using slave (SPIS1).\r\nI have set appropriate pins, and I was able to receive data and store them in RAM manually.\r\n\r\nHowever, SPIS support DMA according to the product specification. But I could not find how to use DMA anywhere.\r\n\r\nIt would be really helpful If you could help me\r\n\r\nFaithfully,",
    "tag": "spi"
  },
  {
    "text": "adc shockburst I am trying to send continuously sampled analog input using NRF24LE1 using Shock burst,The transmitter is not working while trying sample continuously.please help.\r\ncode included.\r\nADC part\r\n***********************************************************************\r\nhal_adc_set_input_channel(HAL_ADC_INP_AIN0);\r\n  hal_adc_set_reference(HAL_ADC_REF_INT);\r\n  hal_adc_set_input_mode(HAL_ADC_SINGLE);\r\n  hal_adc_set_conversion_mode(HAL_ADC_CONTINOUS);\r\n  hal_adc_set_sampling_rate(HAL_ADC_2KSPS);\r\n  hal_adc_set_resolution(HAL_ADC_RES_8BIT);\r\n  hal_adc_set_data_just(HAL_ADC_JUST_RIGHT);\r\n\r\n  // Enable MISC interrupts to enable ADC interrupt\r\n  MISC = 1;\r\n  // Enable global interrupts\r\n  EA = 1;\r\n  // Start ADC conversion\r\n  hal_adc_start();\r\n***********************************************************\r\nTX part\r\n***********************************************************\r\n\r\nADC_ISR()\r\n{\r\n buff[0]= hal_adc_read_LSB();\r\n\t L01_Init( );\r\n                                    \tL01_SetTXMode( );   \r\n\t\t L01_WriteTXPayload_Ack(buff, 1 );\r\n     \r\n\t\tRFCE=1;\r\n\t\t\r\n  \t\t\r\n       \r\n}\r\n ",
    "tag": "adc"
  },
  {
    "text": "nRF UART App error Hi,\r\n\r\ni use anRF51822 with soft device 7.\r\n\r\nI run the UART app on my iPhone 4s with ios7 and on the nrf51822 board the ble_app_uart with keil uVision5.\r\n\r\nBoth devices connected but when i try to send a massage via ios APP this is not works :\r\n\r\n> No write property on TX\r\n> characteristic, 0.\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "9bit SPI interface Hi,\r\n\r\nIs it possible to use SPI master on nrf51822 in 9bit mode or shall I use bitbanging?\r\nI have a slave (SSD1306) that accepts only 9bit words.\r\n\r\nThanks,\r\nSergey",
    "tag": "spi"
  },
  {
    "text": "NRF24L01+ IRQ Issue Hi All,\r\n\r\nI am testing the functionality of NRF24L01+ and for my purposes I have configured it as PTX, No Auto ACK.\r\n\r\nI am able to communicate with the chip just fine and able to configure all the registers (confirmed with a logic analyzer).\r\n\r\nHowever when I try to send data, the IRQ pin never goes low.\r\n\r\nbelow is the configuration I used for NRF24L01+\r\n\r\n\t_delay_ms(1000); \t//allow radio to stabilize after power on\r\n\t\r\n\tuint8_t val[5];\r\n\r\n\tval[0]=0x00;\t\t//disable AA(auto acknowledgements)\r\n\tRADIO_READWRITE(W, EN_AA, val, 1);\r\n\r\n\tval[0]=0x01;\t\t//number of enabled pipes. enable only daya pipe0\r\n\tRADIO_READWRITE(W, EN_RXADDR, val, 1);\r\n\r\n\tval[0]=0x03; \t\t//ADDRESS width setup. 5 bytes\r\n\tRADIO_READWRITE(W, SETUP_AW, val, 1);\r\n\r\n\tval[0]=0x01; \t\t//RF channel setup. 2401 Mhz\r\n\tRADIO_READWRITE(W, RF_CH, val, 1);\r\n\r\n\tval[0] = 0x07; \t\t//RF setup. 0DB max power. 1 mbps max range\r\n\tRADIO_READWRITE(W, RF_SETUP, val, 1);\r\n\r\n\tval[0] = 0x12; \t\t//Tx RF_ADDRESS setup. address of the PRX device\r\n\tval[1] = 0x12; \r\n\tval[2] = 0x12; \r\n\tval[3] = 0x12; \r\n\tval[4] = 0x12; \r\n\tRADIO_READWRITE(W, TX_ADDR, val, 5);\r\n\t\r\n\tval[0]=0x01;\t\t//payload width setup. 1 bytes\r\n\tRADIO_READWRITE(W, RX_PW_P0, val, 1);\r\n\r\n\tval[0]=0x0E;\t\t// Config register. PTX + POWER UP + 2BYTE CRC\r\n\tRADIO_READWRITE(W, CONFIG, val, 1);\r\n\r\n\t_delay_ms(100); //give radio time to reach STANDBY mode (CE=low);\r\n\r\nAs suggested in a similar post here, i even tried adding a 22pf capacitor between the power and ground of NRF24L01+ but with no success.\r\n\r\nPlease help.\r\n\r\n**UPDATE:**\r\n\r\nI checked using polling as well (bit 5 on STATUS register) using the command\r\n\r\n    while((RADIO_GETSTATUS()&(1<<5))==0){}\r\n    PORTB |= (1<<PB0); //light GREEN LED\r\n\r\nThe LED does not light up ... so even the TX_DS bit is not getting set in the STATUS register.\r\n\r\nOn probing with logic analyzer,I get this \r\n\r\n![image description](http://s27.postimg.org/ws74miiyr/untitled.png) \r\n\r\nafter the toggle on CE line to TX the payload, I am continuously polling the status register (0x07) and continuously getting 0x0E\r\n",
    "tag": "interrupt"
  },
  {
    "text": "ADC channels and port pins I am developing a device converting adc input  into data and transmitting them and receiving them at other  place,I cant figure  out between analog input eg:AIN0 and the port pins please help\r\nI have included the code here using NRF24LE1 Keil\r\n\r\nrelation between AIN0 and POO  and how to connect\r\n\r\nvoid adc_init(void)\r\n{\r\n    hal_adc_set_input_channel(HAL_ADC_INP_AIN0);\r\n    hal_adc_set_reference(HAL_ADC_REF_INT);\r\n    hal_adc_set_input_mode(HAL_ADC_SINGLE);\r\n    hal_adc_set_conversion_mode(HAL_ADC_SINGLE_STEP);\r\n    hal_adc_set_power_down_delay(HAL_ADC_PDD_0US);\r\n    hal_adc_set_acq_window(HAL_ADC_AQW_075US);\r\n    hal_adc_set_resolution(HAL_ADC_RES_8BIT);\r\n    hal_adc_set_data_just(HAL_ADC_JUST_RIGHT);\r\n}\r\n\r\n\r\n\r\nport pins\r\n*****************************************************************************\r\n\tP0DIR =0x03;\r\n   \r\n\tP0=0;\r\n\r\n   P0CON = 0x70;\r\n    P0CON = 0x71;",
    "tag": "adc"
  },
  {
    "text": "Using ADC to measure voltage of battery I've looked over all the previous posts but none of them seem to work but the most useful one I can find is this one:\r\n\r\nhttps://devzone.nordicsemi.com/question/990/how-to-measure-lithium-battery-voltage/\r\n\r\nThe code compiles fine but seems to stop with the console saying \"Starting target CPU...\" at the loop in \"static void lfclk_config(void)\" so I changed it so that the function is now: \r\n\r\n    static void lfclk_config(void)\r\n    {\r\n      NRF_CLOCK->LFCLKSRC = (CLOCK_LFCLKSRC_SRC_Xtal << CLOCK_LFCLKSRC_SRC_Pos);\r\n      NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;\r\n      NRF_CLOCK->TASKS_LFCLKSTART = 1;\r\n    \r\n    \t// Wait for the low frequency clock to start\r\n      while (NRF_CLOCK->EVENTS_LFCLKSTARTED == 1) {}\r\n      NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;\r\n    }\r\n\r\nand now it will run to the end so it seems to work but I was wondering where do I see the outputted value of the voltage reading assuming what I changed works?\r\n",
    "tag": "adc"
  },
  {
    "text": "Wireless Printf using BLE UART We are developing a custom ble service and profile however having printf makes our lives that much easier so we are trying to incorporate it purely for testing purposes. \r\n\r\nThe idea is to send debug messages to an Android device via the nRF UART App. I am using [pure-gcc](https://github.com/hlnd/nrf51-pure-gcc-setup), Linux/Eclipse, and a custom PCB without UART-USB capability.\r\n\r\nI noticed there is a [printf-gcc](https://github.com/hlnd/printf-gcc) which works with the over wire UART on the evaluation boards. Is there an example of how to do something similar with the BLE UART?\r\n\r\nCurrently what i have working is sending and receiving text strings over UART using a modified ble_app_uart and an the Android UART App. What i cannot figure out is how to utilize all the nice features of printf with UART to print more than just strings. I see there are examples for over the wire UART and printf but not for BLE UART.\r\n\r\nMuch Thanks!\r\n\r\nNick",
    "tag": "uart"
  },
  {
    "text": "Error: Identifier Undefined, but keil can find I'm getting an error which says the identifier ble_temperature_t is undefined, and it is showing as an error in the keil (unkown type name). However when I click on the variable and select go to declaration keil can find it under ble_temperature.h which is already included in main.c and in the project. \r\n\r\nI'm guessing this is something simple but i can't see it can't find the identifier if the linking in the IDE is working fine. \r\n\r\nFrom ble_temperature.h: \r\n   \r\n \r\n\r\n        // Forward declaration of the ble_temperature_t type. \r\n            typedef struct ble_temperature_s ble_temperature_t;\r\n    \r\n        /**@brief Battery Service event handler type. */\r\n    typedef void (*ble_temperature_evt_handler_t) (ble_temperature_t * p_bas, ble_temperature_evt_t * p_evt);\r\n    \r\n    /**@brief Battery Service init structure. This contains all options and data needed for\r\n     *        initialization of the service.*/\r\n    typedef struct\r\n    {\r\n        ble_temperature_evt_handler_t         evt_handler;            /**< Event handler to be called for handling events in the Battery Service. */\r\n        bool                          support_notification;           /**< TRUE if notification of Battery Level measurement is supported. */\r\n        ble_srv_report_ref_t *        p_report_ref;                   /**< If not NULL, a Report Reference descriptor with the specified value will be added to the Battery Level characteristic */\r\n        uint8_t                       initial_batt_level;             /**< Initial battery level */\r\n        ble_srv_cccd_security_mode_t  temperature_char_attr_md;     /**< Initial security level for battery characteristics attribute */\r\n        ble_gap_conn_sec_mode_t       temperature_report_read_perm; /**< Initial security level for battery report read attribute */\r\n    } ble_temperature_init_t;\r\n    \r\n    /**@brief Battery Service structure. This contains various status information for the service. */\r\n    typedef struct ble_temperature_s\r\n    {\r\n        ble_temperature_evt_handler_t         evt_handler;   \r\n    \t\tuint16_t service_handle;\r\n    \t\tble_gatts_char_handles_t temperature_char_handles;\r\n    \t\tuint8_t uuid_type;\r\n    \t\tuint16_t conn_handle;\r\n    } ble_temperature_t;\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "openlog with nrf51 over UART after several attempts to debug and understand what goes in my handlers in the BLE callbacks, I thought to give a UART logger a try.\r\n\r\nthis is what I'm trying to use: [OpenLog](https://www.sparkfun.com/products/9530)\r\n\r\nWith a simple uart setup, even with 9600 baud rate I get no input on the other side ( files are created with NULLs ). \r\n\r\nIs there any special setup required? Any idea what might be the issue?\r\n\r\nRegards",
    "tag": "uart"
  },
  {
    "text": "How can I get 4 PWM channels using 4 capture compare regiters of timer2 I have already made code of 3 pwm channels using c[0],cc[1],cc[2],cc[3]. I want 4 PWM channels but I dont have more cc registers left so how can i code it. plz help me.\r\nALso I want to run it with softdevice so what changes do i need to make.\r\n\r\ncode done so far is:\r\n\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n#include \"nrf.h\"\r\n#include \"nrf_gpiote.h\"\r\n#include \"nrf_gpio.h\"\r\n\r\n\r\n#define RED_LED (21)  /**< Pin number for PWM output. */\r\n#define GREEN_LED (22)\r\n#define BLUE_LED (23)\r\n\r\n\r\n#define TIMER_PRESCALERS 6U           /**< Prescaler setting for timer. */\r\n\r\n\r\n\r\nstatic void timer2_init(void)\r\n{\r\n    // Start 16 MHz crystal oscillator .\r\n    NRF_CLOCK->EVENTS_HFCLKSTARTED  = 0;\r\n    NRF_CLOCK->TASKS_HFCLKSTART     = 1;\r\n\r\n    // Wait for the external oscillator to start up.\r\n    while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0)\r\n    {\r\n        //Do nothing.\r\n    }\r\n\r\n    NRF_TIMER2->MODE        = TIMER_MODE_MODE_Timer;\r\n    NRF_TIMER2->BITMODE     = TIMER_BITMODE_BITMODE_08Bit << TIMER_BITMODE_BITMODE_Pos;\r\n    NRF_TIMER2->PRESCALER   = TIMER_PRESCALERS;\r\n\r\n    // Clears the timer, sets it to 0.\r\n    NRF_TIMER2->TASKS_CLEAR = 1;\r\n\r\n    // Load the initial values to TIMER2 CC registers.\r\n    NRF_TIMER2->CC[0] = 0;\r\n\r\n    NRF_TIMER2->CC[1] = 1;\r\n\r\n    NRF_TIMER2->CC[2] = 255;\r\n\r\n    NRF_TIMER2->CC[3] =1;\r\n\r\n    \r\n}\r\n\r\n\r\n/** @brief Function for initializing the GPIO Tasks/Events peripheral.\r\n */\r\nstatic void gpiote_init(void)\r\n{\r\n    // Connect GPIO input buffers and configure PWM_OUTPUT_PIN_NUMBER as an output.\r\n    //nrf_gpio_range_cfg_input(BUTTON_START, BUTTON_STOP, BUTTON_PULL);\r\n\tnrf_gpio_port_clear(NRF_GPIO_PORT_SELECT_PORT2, 0xFF);\r\n\r\n    nrf_gpio_cfg_output(RED_LED);\r\n    nrf_gpiote_task_config(0, RED_LED, \\\r\n                           NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n\r\n    nrf_gpio_cfg_output(GREEN_LED);\r\n    nrf_gpiote_task_config(1, GREEN_LED, \\\r\n                               NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n\r\n    nrf_gpio_cfg_output(BLUE_LED);\r\n    nrf_gpiote_task_config(2, BLUE_LED, \\\r\n                                   NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n}\r\n\r\n\r\n/** @brief Function for initializing the Programmable Peripheral Interconnect peripheral.\r\n */\r\nstatic void ppi_init(void)\r\n{\r\n    // Configure PPI channel 0 to toggle PWM_OUTPUT_PIN on every TIMER2 COMPARE[0] match.\r\n    NRF_PPI->CH[0].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[0];\r\n    NRF_PPI->CH[0].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n\r\n    // Configure PPI channel 1 to toggle PWM_OUTPUT_PIN on every TIMER2 COMPARE[1] match.\r\n    NRF_PPI->CH[1].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[1];\r\n    NRF_PPI->CH[1].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n\r\n    NRF_PPI->CH[2].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[0];\r\n    NRF_PPI->CH[2].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[1];\r\n\r\n    NRF_PPI->CH[3].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[2];\r\n    NRF_PPI->CH[3].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[1];\r\n\r\n    NRF_PPI->CH[4].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[0];\r\n    NRF_PPI->CH[4].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[2];\r\n\r\n    NRF_PPI->CH[5].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[3];\r\n    NRF_PPI->CH[5].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[2];\r\n    // Enable PPI channels 0-2.\r\n    NRF_PPI->CHEN = (PPI_CHEN_CH0_Enabled << PPI_CHEN_CH0_Pos)\r\n                    | (PPI_CHEN_CH1_Enabled << PPI_CHEN_CH1_Pos)\r\n                    | (PPI_CHEN_CH2_Enabled << PPI_CHEN_CH2_Pos)\r\n                    | (PPI_CHEN_CH3_Enabled << PPI_CHEN_CH3_Pos)\r\n                    | (PPI_CHEN_CH4_Enabled << PPI_CHEN_CH4_Pos)\r\n                    | (PPI_CHEN_CH5_Enabled << PPI_CHEN_CH5_Pos);\r\n}\r\n\r\n\r\n/**\r\n * @brief Function for application main entry.\r\n */\r\nint main(void)\r\n{\r\n    gpiote_init();\r\n    ppi_init();\r\n    timer2_init();\r\n\r\n    \r\n    NRF_TIMER2->TASKS_START = 1; // Start the timer.\r\n\r\n    while (true)\r\n    {\r\n        // Do nothing.\r\n    }\r\n}\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "i2c application Hi, \r\nFirst I'm new to these devices and BLE in general.\r\nI am however very experienced at embedded design and Keil tools and ARM processors.\r\nI have got the demo heart beat demo going.\r\nI have seen the twi demo code.\r\n\r\nApplication: \r\nI want to read an i2c device at 100hz 8 bytes at a time.\r\nI don't think that should be too difficult.\r\n\r\nBut I want to transmit it to a custom PC application.\r\nAre there any demos I can see/modify?\r\nCan the BLE transmission be picked up by a PC (2014 Macbook pro) or does it need the dongle?\r\nHow can I get the data read into an application (planning on using MS VS C#).\r\n\r\nThanks\r\n\r\nIan\r\n ",
    "tag": "i2c"
  },
  {
    "text": "Microusb-UART on NRF51822 Custom Board Hi All,\r\n\r\nI am working a custom board for 51822. We have wired the UART RX/TX pins to a microusb connector (No RXD/TXD pins wired). The problem is once we connect it to PC, it doesn't seem to be recognized as a valid USB device. My guess is i need a special driver for it. I've tried several different drivers (CP210X, profilic) but none of them works. In other posts, I saw people were talking about using special adapter chips. Since the board has been made (difficult to fit a new chip on). Is their any other solution that I probably can try? \r\n\r\nMany thanks for your advices.\r\n\r\nCheers\r\n\r\nL.",
    "tag": "uart"
  },
  {
    "text": "nRF51822 SPI slave CSN I'm using the nRF51822 as SPI slave. My CSN is of wrong polarity (active high). Is it possible to change the settings in spi_slave.c to make it work anyway?",
    "tag": "spi"
  },
  {
    "text": "Uart delay problem \r\n Iam trying to display the uart data as a scanned response.nRF51822 receives the data from PIC and it is displayed as scanned response during advertising.the problem is nrf51822 takes nearly 9 secs to get 3 bytes of the data from PIC(data is ready in PIC within a few ms) and display during advertising .If i reduce the delay it is transmitting 00 !!! ",
    "tag": "uart"
  },
  {
    "text": "SPI slave Rx Buffer read Hi,\r\nI'm using the nRF51822 and pCA10001 as SPI slave.\r\nFor reasons beyond my control I have to read the Rx Buffer before the CSN is released.\r\nYes, I know I shouldn\u00b4t do it this way, but I have no option (as far as I know).\r\n\r\nI have the shortest while-loop running to check for incoming data on the first byte in the receive buffer. As soon as it finds the correct data there it continues to look for the next byte.\r\n\r\nMy problem is that if I put a break-point on the first loop then the receive fails. I guess the reason is that the break-point stops all execution including SPI. Is this true and if so, is there any way to get around it?\r\n\r\nBest regards\r\n/H\u00e5kan",
    "tag": "spi"
  },
  {
    "text": "External signal convert Digital signal on nRF51822. static void button_event_handler(uint8_t pin_no, uint8_t button_action)\r\n{\r\n    if (button_action == APP_BUTTON_PUSH)\r\n    {\r\n        switch (pin_no)\r\n        {\r\n            case HR_INC_BUTTON_PIN_NO:\t//push button 0\r\n                // Increase Heart Rate measurement\r\n                m_cur_heart_rate += HEART_RATE_CHANGE;\r\n                if (m_cur_heart_rate > MAX_HEART_RATE)\r\n                {\r\n                    m_cur_heart_rate = MIN_HEART_RATE; // Loop back\r\n                }\r\n                break;\r\n                \r\n            case HR_DEC_BUTTON_PIN_NO: //push button 1\r\n                // Decrease Heart Rate measurement\r\n                m_cur_heart_rate -= HEART_RATE_CHANGE;\r\n                if (m_cur_heart_rate < MIN_HEART_RATE)\r\n                {\r\n                    m_cur_heart_rate = MAX_HEART_RATE; // Loop back\r\n                }\r\n                break;\r\n                \r\n            default:\r\n                APP_ERROR_HANDLER(pin_no);\r\n                break;\r\n        }\r\n    }    \r\n}\r\nthis example is ble_app_hrs 's button part.\r\nI want change this part. \r\n( if I push button 0 , ADC enabling, if I push button 1 , ADC disenabling )\r\nthen  digital data is transmitted to DK Kit through bluetooth.\r\n\r\nI have some questions for solving this problem. \r\n\r\n\r\n1. where input 3-axis sensor's x-axis values?   ( ADC pin? or other pin? )  \r\n\r\n2. How  convert sensor values to digital data? \r\n\r\n**3. How write/read this data?**\r\n",
    "tag": "adc"
  },
  {
    "text": "External sensor data convert digital data on nRF51822 static void button_event_handler(uint8_t pin_no, uint8_t button_action)\r\n{\r\n    if (button_action == APP_BUTTON_PUSH)\r\n    {\r\n        switch (pin_no)\r\n        {\r\n            case HR_INC_BUTTON_PIN_NO:\t//push button 0\r\n                // Increase Heart Rate measurement\r\n                m_cur_heart_rate += HEART_RATE_CHANGE;\r\n                if (m_cur_heart_rate > MAX_HEART_RATE)\r\n                {\r\n                    m_cur_heart_rate = MIN_HEART_RATE; // Loop back\r\n                }\r\n                break;\r\n                \r\n            case HR_DEC_BUTTON_PIN_NO: //push button 1\r\n                // Decrease Heart Rate measurement\r\n                m_cur_heart_rate -= HEART_RATE_CHANGE;\r\n                if (m_cur_heart_rate < MIN_HEART_RATE)\r\n                {\r\n                    m_cur_heart_rate = MAX_HEART_RATE; // Loop back\r\n                }\r\n                break;\r\n                \r\n            default:\r\n                APP_ERROR_HANDLER(pin_no);\r\n                break;\r\n        }\r\n    }    \r\n}\r\n\r\n\r\nthis example is ble_app_hrs 's button part.\r\nI want change this part. \r\n( if I push button 0 , ADC enabling, if I push button 1 , ADC disenabling )\r\nthen digital data is transmitted to DK Kit through bluetooth.\r\n\r\nI have some questions for solving this problem. \r\n\r\n\r\n1. where input 3-axis sensor's x-axis values?   ( ADC pin? or other pin? )  \r\n\r\n2. How  convert sensor values to digital data? \r\n\r\n3. How write/read this data?\r\n",
    "tag": "adc"
  },
  {
    "text": "faster TWI on nrf51822 I've been working on an interrupt driven I2C driver. I have the basic driver working, but I'm hoping to squeeze a bit more speed out of it.\r\n\r\nI'm mostly doing fairly long transactions, ~10-100 bytes. For one device I do mostly writes and for the other I do mostly reads.\r\n\r\nAt 400khz a byte takes around 20us and there is a ~4us delay before next byte. The interrupt handler takes about 6us (timed using a gpio) and starts slightly before the falling edge of the the ack clock.\r\n\r\nI might be able to shave the interrupt handler down a bit, but it is mostly reading/writing to EVENTS_*, reading from TXD and writing to RXD, there is very little other code in the middle of a transaction. I'm using BB_STOP and BB_SUSPEND shorts to save a PPI channel.\r\n\r\nMost I2C devices will happily run faster, so I tried increasing the FREQUENCY register.\r\n\r\n100khz is 0x01980000, 250 is 0x04000000, 400 is 0x06680000.\r\n\r\n0x07800000 gave me a ~480khz clock some of the time, but other times the clock is more like 240khz with som 480khz clocks mixed in. 0x08000000 should be about ~500khz, but I see mostly a 250khz output.\r\n\r\nThe part I'm testing with doesn't seem to support clock stretching. I'd imagine what I'm seeing is some sort of weirdness with how the nrf51 synthesizes the I2C clock. Are there any frequency values that will result in a clock that is >400khz?\r\n\r\nAny suggestions on how to speed up the TWI interface?",
    "tag": "twi"
  },
  {
    "text": "faster TWI on nrf51822 I've been working on an interrupt driven I2C driver. I have the basic driver working, but I'm hoping to squeeze a bit more speed out of it.\r\n\r\nI'm mostly doing fairly long transactions, ~10-100 bytes. For one device I do mostly writes and for the other I do mostly reads.\r\n\r\nAt 400khz a byte takes around 20us and there is a ~4us delay before next byte. The interrupt handler takes about 6us (timed using a gpio) and starts slightly before the falling edge of the the ack clock.\r\n\r\nI might be able to shave the interrupt handler down a bit, but it is mostly reading/writing to EVENTS_*, reading from TXD and writing to RXD, there is very little other code in the middle of a transaction. I'm using BB_STOP and BB_SUSPEND shorts to save a PPI channel.\r\n\r\nMost I2C devices will happily run faster, so I tried increasing the FREQUENCY register.\r\n\r\n100khz is 0x01980000, 250 is 0x04000000, 400 is 0x06680000.\r\n\r\n0x07800000 gave me a ~480khz clock some of the time, but other times the clock is more like 240khz with som 480khz clocks mixed in. 0x08000000 should be about ~500khz, but I see mostly a 250khz output.\r\n\r\nThe part I'm testing with doesn't seem to support clock stretching. I'd imagine what I'm seeing is some sort of weirdness with how the nrf51 synthesizes the I2C clock. Are there any frequency values that will result in a clock that is >400khz?\r\n\r\nAny suggestions on how to speed up the TWI interface?",
    "tag": "interrupt"
  },
  {
    "text": "Redbear BLE v2 shield + Arduino DUE I am trying to get the Arduino DUE up and running with the Redbear v2 BLE shield, and SDK 0.9.3.\r\n\r\nIt was a pretty trivial operation with Arduino YUN, but I not so much for DUE. I can get everything to run on YUN, including the basic communication ECHO sketch (confirming YUN <--> BLE communication) and Hello World (confirming YUN <--> external BLE Central device communication).\r\n\r\nHowever none of them are working for me on DUE (my platform of choice). I suspect that I have the <b>SPI divisor</b> set incorrectly, and do not have a scope to directly check the clock rates. On the YUN, I am using the SDKs supplied SPI_CLOCK_DIV8, but this is not #def'd for SAM based hw platforms, which leaves me to try to guess. And I'm nearly positive that the YUN has a different master clock from DUE anyway.\r\n\r\nI've seen other questions here about DUE and the RB BLE shield, so I assume it is possible? Any other pitfalls besides the SPI clock?",
    "tag": "spi"
  },
  {
    "text": "nrf gpio config my led connect whit a pin like this:\r\n the led positive connect whit VCC and the negative connect whit a pin through a resistors.\r\n\r\nwhen I config the pin as a output like this nrf_gpio_cfg_output(GREEN_LED_PIN_NO);\r\nbut sometime s the program will dies, I do not kown why?\r\nAt this case the pin will Into the current, this will cause the  nrf51822 die???\r\n\r\nIf i use the the UART,the program will not die.but if i close the UART the problem may be die.\r\n\r\nWe use CR3032 battary as power,whe the CR2032 is low power,the problem die times will add.",
    "tag": "adc"
  },
  {
    "text": "SPIS on nRF51822 Hello,\r\n\r\nWhile I was making SPIS part, I got several issues.\r\n\r\nI am using STM32L151CB for SPI Master and nRF51822 for SPI Slave.\r\nIt seems many people had issues with SPIS.\r\n\r\nSPIS Setting Code is here.\r\n\r\n/**************************************************************************************************/\r\n\r\n![image description](/attachment/2e8672bd67a609383d81f2f33d1bf2ed)\r\n\r\n    err_code = spi_slave_evt_handler_register(spi_slave_event_handle);\r\n    APP_ERROR_CHECK(err_code);    \r\n\r\n    spi_slave_config.pin_miso      \t\t= SPI1_MISO_PIN;\r\n    spi_slave_config.pin_mosi       \t= SPI1_MOSI_PIN;\r\n    spi_slave_config.pin_sck\t\t\t= SPI1_SCK_PIN;\r\n    spi_slave_config.pin_csn          \t= SPI1_CSN_PIN;\r\n    spi_slave_config.mode             \t= SPI_MODE_1;\t\t\t// CPOL : 0  / CPHA : 1    From Cortex-M3\r\n    spi_slave_config.bit_order        \t= SPIM_MSB_FIRST;            \r\n    spi_slave_config.def_tx_character\t= DEF_CHARACTER;      \t// 0xAA\r\n    spi_slave_config.orc_tx_character\t= ORC_CHARACTER;      \t// 0x55\r\n    \r\n    err_code = spi_slave_init(&spi_slave_config);\r\n    APP_ERROR_CHECK(err_code);\r\n       \r\n    err_code = spi_slave_buffers_set(m_tx_buf, m_rx_buf, sizeof(m_tx_buf), sizeof(m_rx_buf));\r\n    APP_ERROR_CHECK(err_code);            \r\n\r\n    return NRF_SUCCESS;\r\n\r\n/**************************************************************************************************/\r\n\r\nSTM32L151 is using CPOL as 0 and CPHA as 0, so I set SPI_MODE as SPI_MODE_1, and it uses MSB_First.\r\n\r\nIs there any problem?\r\n\r\n1. Are initial values of MAXRX and MAXTX registers right values?\r\n\r\n![image description](/attachment/10bcf04328364e8627c708602d4c35ec)\r\n\r\n2. After setting NRF_SPIS1->DEF register, I found something strange on register values.\r\n\r\n2.1 NRF_SPIS1->ORC = 0x55 doesn't work at all. See below 2 capture images.\r\n![image description](/attachment/50b26b054906e2d32bc6db6c61801da3)\r\n![image description](/attachment/d2fb15f2af48e781180c42640dc3aa24)\r\n\r\n2.2 NRF_SPIS1->SHORTS register is not able to change. See below 2 capture images. Of course, I checked SPIS_SHORTS_END_ACQUIRE_Enabled is 0x01.\r\n![image description](/attachment/c12d7be1f78ad2962fada134d40c6c74)\r\n![image description](/attachment/a5ac486952ec0fd3d020e040caeea968)\r\n\r\n3. NRF_SPIS1->INTENCLR is set automatically when NRF_SPIS1->INTENSET is set. See below 2 images.\r\n![image description](/attachment/abcaea5860b9faa413ce25b3d736921c)\r\n![image description](/attachment/6cfcf4662ebefbd08e63ba44c911f702)\r\n\r\n\r\nBecause my code can't jump into spi_slave_event_handle(SPIS handler), so I have been struggling with codes, and I want to know whether I made any mistakes for SPIS setting.\r\n\r\nThank you for reading, and I hope to see your answer.\r\nThanks.\r\n\r\nRyan",
    "tag": "spi"
  },
  {
    "text": "SPIS on nRF51822 Hello,\r\n\r\nWhile I was making SPIS part, I got several issues.\r\n\r\nI am using STM32L151CB for SPI Master and nRF51822 for SPI Slave.\r\nIt seems many people had issues with SPIS.\r\n\r\nSPIS Setting Code is here.\r\n\r\n/**************************************************************************************************/\r\n\r\n![image description](/attachment/2e8672bd67a609383d81f2f33d1bf2ed)\r\n\r\n    err_code = spi_slave_evt_handler_register(spi_slave_event_handle);\r\n    APP_ERROR_CHECK(err_code);    \r\n\r\n    spi_slave_config.pin_miso      \t\t= SPI1_MISO_PIN;\r\n    spi_slave_config.pin_mosi       \t= SPI1_MOSI_PIN;\r\n    spi_slave_config.pin_sck\t\t\t= SPI1_SCK_PIN;\r\n    spi_slave_config.pin_csn          \t= SPI1_CSN_PIN;\r\n    spi_slave_config.mode             \t= SPI_MODE_1;\t\t\t// CPOL : 0  / CPHA : 1    From Cortex-M3\r\n    spi_slave_config.bit_order        \t= SPIM_MSB_FIRST;            \r\n    spi_slave_config.def_tx_character\t= DEF_CHARACTER;      \t// 0xAA\r\n    spi_slave_config.orc_tx_character\t= ORC_CHARACTER;      \t// 0x55\r\n    \r\n    err_code = spi_slave_init(&spi_slave_config);\r\n    APP_ERROR_CHECK(err_code);\r\n       \r\n    err_code = spi_slave_buffers_set(m_tx_buf, m_rx_buf, sizeof(m_tx_buf), sizeof(m_rx_buf));\r\n    APP_ERROR_CHECK(err_code);            \r\n\r\n    return NRF_SUCCESS;\r\n\r\n/**************************************************************************************************/\r\n\r\nSTM32L151 is using CPOL as 0 and CPHA as 0, so I set SPI_MODE as SPI_MODE_1, and it uses MSB_First.\r\n\r\nIs there any problem?\r\n\r\n1. Are initial values of MAXRX and MAXTX registers right values?\r\n\r\n![image description](/attachment/10bcf04328364e8627c708602d4c35ec)\r\n\r\n2. After setting NRF_SPIS1->DEF register, I found something strange on register values.\r\n\r\n2.1 NRF_SPIS1->ORC = 0x55 doesn't work at all. See below 2 capture images.\r\n![image description](/attachment/50b26b054906e2d32bc6db6c61801da3)\r\n![image description](/attachment/d2fb15f2af48e781180c42640dc3aa24)\r\n\r\n2.2 NRF_SPIS1->SHORTS register is not able to change. See below 2 capture images. Of course, I checked SPIS_SHORTS_END_ACQUIRE_Enabled is 0x01.\r\n![image description](/attachment/c12d7be1f78ad2962fada134d40c6c74)\r\n![image description](/attachment/a5ac486952ec0fd3d020e040caeea968)\r\n\r\n3. NRF_SPIS1->INTENCLR is set automatically when NRF_SPIS1->INTENSET is set. See below 2 images.\r\n![image description](/attachment/abcaea5860b9faa413ce25b3d736921c)\r\n![image description](/attachment/6cfcf4662ebefbd08e63ba44c911f702)\r\n\r\n\r\nBecause my code can't jump into spi_slave_event_handle(SPIS handler), so I have been struggling with codes, and I want to know whether I made any mistakes for SPIS setting.\r\n\r\nThank you for reading, and I hope to see your answer.\r\nThanks.\r\n\r\nRyan",
    "tag": "spi"
  },
  {
    "text": "app_timer_start error code 4 What does error code 4 mean?\r\nI am looking through the documentation for the error code number to string translation.\r\n\r\nWhy is starting a timer causing the error code 4?\r\n\r\n\r\nThe timer is setup as follows, it was previous 10, which should have been more than enough.\r\n\r\n    #define APP_TIMER_PRESCALER             0                                           \r\n    #define APP_TIMER_MAX_TIMERS           13\r\n    #define APP_TIMER_OP_QUEUE_SIZE        13\r\n\r\n\r\nAPP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS,\r\n        APP_TIMER_OP_QUEUE_SIZE, false);\r\n\r\nerr_code = app_timer_create(&m_led_on_timer_id,\r\n        APP_TIMER_MODE_SINGLE_SHOT, led_on_timeout_handler);\r\n\r\n \r\n\r\n\r\n\r\nError code 4, occurs trying to start the led timer.\r\n    void led_on_start(void)\r\n    {\r\n        uint32_t err_code;\r\n        // Start led timers.\r\n        err_code = app_timer_start(m_led_on_timer_id, led_t_on, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    }",
    "tag": "timer"
  },
  {
    "text": "NRF51822 Uart Print Stops **[Update 8/15]**\r\nHere's the file for the main part of my code: [sensors.c](/attachment/7b38ecabfc947f0af6078f3ee8cdb4c1). The sensors_start() function at the bottom is where the while loop and the print statements are located. If there are any questions about the code, please let me know.\r\n\r\n\r\nHello,\r\nI'm currently using the nrf51822 and I'm trying to constantly send the accelerometer data to the nRF UART v2.0 Android Application. The application is able to print the data without any problems, however when I try to constantly print the data in a while loop, it will stop printing data statements a certain number of times.\r\n\r\n\r\nHere is a sample of what is in my while loop:\r\n\r\n    while(true)\r\n\t{\r\n\t\tif(twi_master_init())\r\n\t\t{\r\n\t\t\tacc_read_register(ACC_F_SETUP, 1, &acc_f_setup);\t\t//read FIFO Setup Register to check current FIFO buffer mode and Watermark Level\r\n\t\t\tacc_read_register(ACC_INT_SOURCE, 1, &acc_int_source);\t//read Interrupt Status Register to check Bit 6 for FIFO Interrupt Event (Overflow or Watermark)\r\n\t\t\tacc_read_register(ACC_F_STATUS, 1, &acc_status);\t\t//read FIFO Status for Buffer Overflow Info and Watermark Sample Count\r\n\t\t\tmodifiedRead(ACC_OUT_X_MSB, &acc_X_MSB, 18);\t\t\t//store data in acc_X/Y/Z_MSB and acc_X/Y/Z_LSB\r\n\r\n\t\t\tacc_X_result=convert_accData(acc_X_MSB, acc_X_LSB, &acc_X_sign);\t//convert data to gs\r\n\t\t\tacc_Y_result=convert_accData(acc_Y_MSB, acc_Y_LSB, &acc_Y_sign);\r\n\t\t\tacc_Z_result=convert_accData(acc_Z_MSB, acc_Z_LSB, &acc_Z_sign);\r\n\r\n\t\t\tprintf(\"ACC X: %d\", acc_X_result);\t\t\t\t\t\t//print results\r\n\t\t\tprintf(\"ACC X Sign: %d\", acc_X_sign);\r\n\t\t\tprintf(\"ACC Y: %d\", acc_Y_result);\r\n\t\t\tprintf(\"ACC Y Sign: %d\", acc_Y_sign);\r\n\t\t\tprintf(\"ACC Z: %d\", acc_Z_result);\r\n\t\t\tprintf(\"ACC Z Sign: %d\\n\", acc_Z_sign);\r\n\t\t\tnrf_delay_ms(1250);\r\n\t\t}\r\n\t}\r\nAnd the code will iterate through the loop only twice, rather than constantly, and it will print 12 statements and disconnect as seen in the screenshot below:\r\n\r\n![image description](/attachment/50ff4f3924ff39e04c4babf643855f45)\r\n\r\nSome things I've tried are: \r\n\r\n - increasing the delay with the nrf_delay_ms function\r\n - using the ble_nus_send_string function to print instead of printf; causes the same result\r\n - repeating the same printf statement 12+ times within the while loop, however it always stops at 12 print statements and disconnects\r\n - flashing the onboard leds without the print statements results in the while loop to continue without any disconnections or problems\r\n\r\nAre there any suggestions to try to get a constant flow of data to print out?\r\n\r\nThanks for the help,\r\n\r\nKenneth",
    "tag": "uart"
  },
  {
    "text": "NRF51822 Uart Print Stops **[Update 8/15]**\r\nHere's the file for the main part of my code: [sensors.c](/attachment/7b38ecabfc947f0af6078f3ee8cdb4c1). The sensors_start() function at the bottom is where the while loop and the print statements are located. If there are any questions about the code, please let me know.\r\n\r\n\r\nHello,\r\nI'm currently using the nrf51822 and I'm trying to constantly send the accelerometer data to the nRF UART v2.0 Android Application. The application is able to print the data without any problems, however when I try to constantly print the data in a while loop, it will stop printing data statements a certain number of times.\r\n\r\n\r\nHere is a sample of what is in my while loop:\r\n\r\n    while(true)\r\n\t{\r\n\t\tif(twi_master_init())\r\n\t\t{\r\n\t\t\tacc_read_register(ACC_F_SETUP, 1, &acc_f_setup);\t\t//read FIFO Setup Register to check current FIFO buffer mode and Watermark Level\r\n\t\t\tacc_read_register(ACC_INT_SOURCE, 1, &acc_int_source);\t//read Interrupt Status Register to check Bit 6 for FIFO Interrupt Event (Overflow or Watermark)\r\n\t\t\tacc_read_register(ACC_F_STATUS, 1, &acc_status);\t\t//read FIFO Status for Buffer Overflow Info and Watermark Sample Count\r\n\t\t\tmodifiedRead(ACC_OUT_X_MSB, &acc_X_MSB, 18);\t\t\t//store data in acc_X/Y/Z_MSB and acc_X/Y/Z_LSB\r\n\r\n\t\t\tacc_X_result=convert_accData(acc_X_MSB, acc_X_LSB, &acc_X_sign);\t//convert data to gs\r\n\t\t\tacc_Y_result=convert_accData(acc_Y_MSB, acc_Y_LSB, &acc_Y_sign);\r\n\t\t\tacc_Z_result=convert_accData(acc_Z_MSB, acc_Z_LSB, &acc_Z_sign);\r\n\r\n\t\t\tprintf(\"ACC X: %d\", acc_X_result);\t\t\t\t\t\t//print results\r\n\t\t\tprintf(\"ACC X Sign: %d\", acc_X_sign);\r\n\t\t\tprintf(\"ACC Y: %d\", acc_Y_result);\r\n\t\t\tprintf(\"ACC Y Sign: %d\", acc_Y_sign);\r\n\t\t\tprintf(\"ACC Z: %d\", acc_Z_result);\r\n\t\t\tprintf(\"ACC Z Sign: %d\\n\", acc_Z_sign);\r\n\t\t\tnrf_delay_ms(1250);\r\n\t\t}\r\n\t}\r\nAnd the code will iterate through the loop only twice, rather than constantly, and it will print 12 statements and disconnect as seen in the screenshot below:\r\n\r\n![image description](/attachment/50ff4f3924ff39e04c4babf643855f45)\r\n\r\nSome things I've tried are: \r\n\r\n - increasing the delay with the nrf_delay_ms function\r\n - using the ble_nus_send_string function to print instead of printf; causes the same result\r\n - repeating the same printf statement 12+ times within the while loop, however it always stops at 12 print statements and disconnects\r\n - flashing the onboard leds without the print statements results in the while loop to continue without any disconnections or problems\r\n\r\nAre there any suggestions to try to get a constant flow of data to print out?\r\n\r\nThanks for the help,\r\n\r\nKenneth",
    "tag": "uart"
  },
  {
    "text": "RTC1 Timer - Counter in IRQ handler Hello,\r\n\r\nI'm using: nRF51422-QFAA E00 and SDK - nRF51 5.2.0\r\n\r\nRight now I'm running without softdevice enabled. I'm trying to use RTC1 Timer for my own delay_ms() function. I know you have app_timer and scheduler for that but I don't want to use it now.\r\n\r\nMy 1st question is about init of RTC1 with IRQ. I'm not using PPI at all so I don't need to have enabled EVENT, right? But in your examples before you set INTENSET you always set coresponding EVTENSET. Is it necessary in my case too? I don't want event for that, just jump to IRQ handler. As I tried it works even without EVTENSET line but I'm not sure if it's safe. My code for that is:\r\n\r\n    void V_hw_rtc_init(void)\r\n    {\t\r\n      NRF_RTC1->PRESCALER = RTC1_PRESCALER; \r\n      NRF_RTC1->CC[0] = RTC1_CC0;  \r\n      NVIC_SetPriority(RTC1_IRQn, APP_IRQ_PRIORITY_LOW);\r\n    \t\r\n      //NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk; \t\t// Event has to be enabled for IRQ generation?\r\n      NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;\r\n    \t\r\n      NVIC_ClearPendingIRQ(RTC1_IRQn);\r\n      NVIC_EnableIRQ(RTC1_IRQn);\r\n    }\r\n\r\n2nd question: Counter is incrementing during IRQ handler is proceed (at least uLINK2 debuger says). My CC[0] has value only 6. Even if update of CC[0] is last line at IRQ handler the counter will be bigger before it will quit IRQ handler, so Compare Event was not generated and my code stucked - was waiting to counter overflow. I tried even calling TASK_CLEAR but again counter increased much more than CC[0] before IRQ handler quit, but at least it set compare flag and IRQ was called again in this case.\r\n\r\n\r\n    void RTC1_IRQHandler(void)\r\n    {\r\n      if (NRF_RTC1->EVENTS_COMPARE[0] != 0)\r\n      {\r\n        if(U32_delay_ms) U32_delay_ms--; // used in V_hw_delay_ms()\r\n        NRF_RTC1->EVENTS_COMPARE[0] = 0;\r\n        NRF_RTC1->TASKS_CLEAR = 1;  // Clear Counter\r\n        //NRF_RTC1->CC[0] += RTC1_CC0;\r\n      }\r\n\r\n    }\r\n\r\n\r\nIs there some workaround different than setting lower prescaler and higher CC ?\r\n",
    "tag": "timer"
  },
  {
    "text": "RTC1 Timer - Counter in IRQ handler Hello,\r\n\r\nI'm using: nRF51422-QFAA E00 and SDK - nRF51 5.2.0\r\n\r\nRight now I'm running without softdevice enabled. I'm trying to use RTC1 Timer for my own delay_ms() function. I know you have app_timer and scheduler for that but I don't want to use it now.\r\n\r\nMy 1st question is about init of RTC1 with IRQ. I'm not using PPI at all so I don't need to have enabled EVENT, right? But in your examples before you set INTENSET you always set coresponding EVTENSET. Is it necessary in my case too? I don't want event for that, just jump to IRQ handler. As I tried it works even without EVTENSET line but I'm not sure if it's safe. My code for that is:\r\n\r\n    void V_hw_rtc_init(void)\r\n    {\t\r\n      NRF_RTC1->PRESCALER = RTC1_PRESCALER; \r\n      NRF_RTC1->CC[0] = RTC1_CC0;  \r\n      NVIC_SetPriority(RTC1_IRQn, APP_IRQ_PRIORITY_LOW);\r\n    \t\r\n      //NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk; \t\t// Event has to be enabled for IRQ generation?\r\n      NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;\r\n    \t\r\n      NVIC_ClearPendingIRQ(RTC1_IRQn);\r\n      NVIC_EnableIRQ(RTC1_IRQn);\r\n    }\r\n\r\n2nd question: Counter is incrementing during IRQ handler is proceed (at least uLINK2 debuger says). My CC[0] has value only 6. Even if update of CC[0] is last line at IRQ handler the counter will be bigger before it will quit IRQ handler, so Compare Event was not generated and my code stucked - was waiting to counter overflow. I tried even calling TASK_CLEAR but again counter increased much more than CC[0] before IRQ handler quit, but at least it set compare flag and IRQ was called again in this case.\r\n\r\n\r\n    void RTC1_IRQHandler(void)\r\n    {\r\n      if (NRF_RTC1->EVENTS_COMPARE[0] != 0)\r\n      {\r\n        if(U32_delay_ms) U32_delay_ms--; // used in V_hw_delay_ms()\r\n        NRF_RTC1->EVENTS_COMPARE[0] = 0;\r\n        NRF_RTC1->TASKS_CLEAR = 1;  // Clear Counter\r\n        //NRF_RTC1->CC[0] += RTC1_CC0;\r\n      }\r\n\r\n    }\r\n\r\n\r\nIs there some workaround different than setting lower prescaler and higher CC ?\r\n",
    "tag": "interrupt"
  },
  {
    "text": "nRF51822 problems with spi slave Hi, i'm trying to communicate between a msp-430f5529 (spi master) and a nrf51822 (spi slave). I have configured the MISO, MOSI, CS and SCLK of the nrf. I use the spi_slave_example for testing the communication.\r\n\r\nWhen the spi transfer is completed it calls to the handle \"static void spi_slave_event_handle(spi_slave_evt_t event)\". As you know to the end of this function you have to set the buffer again (after you process the data that arrived) with \"spi_slave_buffers_set\" .I want set the new buffer data depending of the last transfer data, then i use a switch case for the first byte that arrives but this fails, i need to set the bufffer to the end of function spi_slave_event_handle(). \r\nI'm doing this:\r\n\r\n\r\n         if (event.evt_type == SPI_SLAVE_XFER_DONE) \r\n         { \t\t\t\r\n          SpiCommand = m_rx_buf[0];\t\t\t\r\n\t\t\tswitch (SpiCommand)\r\n\t\t\t{\r\n\t\t\t\tcase 0x01:\r\n\t\t\t\t\tnrf_gpio_port_set(NRF_GPIO_PORT_SELECT_PORT1, 1);\r\n                     spi_slave_buffers_set(m_tx_buf, m_rx_buf, sizeof(m_tx_buf), sizeof(m_rx_buf));\r\n                     break;\r\n                case 0x02: ...\r\n                     break;\r\n                default:\r\n                     break;\r\n            }             \r\n           }\r\n\r\nit doesn't work, the led doesn't turn on.\r\nBut if i try this:\r\n\r\n  \r\n      if (event.evt_type == SPI_SLAVE_XFER_DONE) \r\n         { \t\t\t\r\n          SpiCommand = m_rx_buf[0];\t\t\t\r\n\t\t\tswitch (SpiCommand)\r\n\t\t\t{\r\n\t\t\t\tcase 0x01:\r\n\t\t\t\t\tnrf_gpio_port_set(NRF_GPIO_PORT_SELECT_PORT1, 1);\r\n                     break;\r\n                case 0x02: ...\r\n                     break;\r\n                default:\r\n                     break;\r\n            }             \r\n             spi_slave_buffers_set(m_tx_buf, m_rx_buf, sizeof(m_tx_buf), sizeof(m_rx_buf));\r\n           }\r\n       \r\n\r\nIt works great, the led turn on. I have to put  spi_slave_buffers_set() out of the switch at the end.\r\nWhy?\r\nAny idea?",
    "tag": "spi"
  },
  {
    "text": "Error uart example on nrf6310. Hi\r\n\r\nI'm trying to run uart example on nrf6310.\r\nI followed following link. \r\nhttps://devzone.nordicsemi.com/question/7208/nrf51822-uart-example/\r\nand I defined ENABLE_LOOPBACK_TEST.\r\n\r\nit was resulted in blinking led0. it means error.\r\nwhere is it wrong?\r\n\r\nEdited:\r\n![image description](/attachment/eadb82ee5c00a5eae221d641aec03fae)\r\n![image description](/attachment/ac46b3b080d2cc936a775967670556d5)",
    "tag": "uart"
  },
  {
    "text": "How to receive an unknown amount of data on SPI? Hi everybody!\r\n\r\nI've plugged my NRF51422 as a slave on a STM32 through a SPI bus. I would like to be able to send to the NRF an unknown amount of data. I also need to read the bytes as they arrived in order to know how to handle the next ones and finally, I need to detect the end of a frame. I firstly thought using the CSN to detect the end of a frame, but it seems that the spi_slave_event_handle method is triggered only on that signal. So I need it to read each byte. My answer is: Is there an interrupt called for each byte received not using the CSN? Or is there an other way to read an unknown amount of data?\r\n\r\nHere is the code I use for the moment. I didn't test everything, but the idea is here:\r\n\r\n    static void spi_slave_event_handle(spi_slave_evt_t event)\r\n    {\r\n\tstatic int state = 0;\r\n\tstatic int address;\r\n\tstatic bool dataEnd = 0;\r\n\tuint32_t err_code;\r\n\r\n\tm_rx_buf[0] = m_rx_buf[1] = 0x00;\r\n\t\r\n\tif (event.evt_type == SPI_SLAVE_BUFFERS_SET_DONE )\r\n\t{\r\n\t\terr_code = spi_slave_buffers_set(m_tx_buf, m_rx_buf, 1, 1);\r\n\t\tswitch(state)\r\n\t\t{\r\n\t\tcase 0:\t// Basic state: send data\r\n\t\t\tif(!m_rx_buf[0] == 0)\r\n\t\t\t{\r\n\t\t\t\tswitch((m_rx_buf[0]&0x80) >> 7)\t// We read the R/W bit\r\n\t\t\t\t{\r\n\t\t\t\tcase 0: \t// The STM32 need to read some data\r\n\t\t\t\t\taddress = m_rx_buf[0]&0x3F;\t// We read which data is needed\r\n\t\t\t\t\terr_code = spi_slave_buffers_set(&m_registres[address], m_rx_buf, 1, 1);// We prepare the data\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 1:\t\t// The STM32 will send us data\r\n\t\t\t\t\tstate = 1;\t// We go in the receive state for the next data\r\n\t\t\t\t\taddress = m_rx_buf[0]&0x3F;\r\n\t\t\t\t\terr_code = spi_slave_buffers_set(m_tx_buf, m_rx_buf, 1, 1);// We prepare the data\r\n\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\t\t// STM32 wait for data\r\n\t\t\t{\t\r\n\t\t\t\taddress++;\t// We take the next data in our table\r\n\t\t\t\terr_code = spi_slave_buffers_set(&m_registres[address], m_rx_buf, 1, 1);\t// We send it\r\n\t\t\t}\r\n\t\tbreak;\r\n\t\tcase 1:\t\t// Second state: receive data\r\n\t\t\tif(!dataEnd)\t// dataEnd changing state when CSN is rised\r\n\t\t\t{\r\n\t\t\t\tm_registres[address] = m_rx_buf[0];\r\n\t\t\t\taddress++;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstate = 0;\r\n\t\t\t\tdataEnd = 0;\r\n\t\t\t}\r\n\t\tbreak;\r\n\t\t}\r\n\t}\r\n    }\r\n\r\nThanks a lot! :)",
    "tag": "spi"
  },
  {
    "text": "PWM and Softdevice Hi,\r\n\r\nI am trying to get the PWM example (https://github.com/NordicSemiconductor/nrf51-pwm-library) to work with a Softdevice (S110) that advertises.\r\n\r\nThere have been several Questions on the topic, but I still don't understand how I make sure that the timer used to trigger the PWM is placed through the sd_ppi event management.\r\n\r\nTwo different setups:\r\n\r\n 1. Only using the example code quoted\r\n    above works fine, as long as I keep\r\n    <code>#define USE_WITH_SOFTDEVICE   \r\n    0</code> When set this to 1, the PWM\r\n    doesn't work anymore. As far as I\r\n    understand (following [this\r\n    question](https://devzone.nordicsemi.com/question/14423/how-to-make-pwm-code-using-softdevice/)),\r\n    this is due to the SD not being\r\n    initialised. Thus, I moved to the\r\n    second setup:\r\n 2. I copied all of the PWM example\r\n    into the\r\n    nrf6310\\s110\\ble_app_template\r\n    example. Now the SD works fine, but\r\n    the PWM does still not trigger. I\r\n    then increased <code>#define\r\n    APP_TIMER_MAX_TIMERS</code> by one\r\n    (as I thought would be the\r\n    additional timer for the PWM and\r\n    then uncommented <code>    err_code\r\n    = app_timer_start(m_pwm_timer_id, PWM_INTERVAL, NULL);</code> in the\r\n    function\r\n    <code>timers_start(void)</code>.\r\n\r\nBut that still does not work. I am still missing something, could you please help me, what?\r\n\r\nThanks!\r\n\r\nEdit: To make things clearer, please see my [main.c](/attachment/c507c3c069718a4d336cff76e43c9a5d), where I tried to put together the BLE_template and the PWM example. It advertises, but the PIN20 is not toggled by the PWM.\r\n\r\nAnybody can help?",
    "tag": "pwm"
  },
  {
    "text": "NRF51822 - Uart Rx problem Hi,\r\n\r\nI'm getting problems on the pca10001 uart example. I get the \"Start:\" string on the terminal but it can't echo what I type on the keyboard. Another thing is that I couldn't find in the reference manual information about how many stop bits it use.\r\n\r\nWhy is this happening?\r\n\r\nThank you",
    "tag": "uart"
  },
  {
    "text": "s130 example on NRF6310 with PCA 10005 I tried to run s130 example. \r\nFor using with pca 10005 on nrf6310 I changed settings like following.\r\n1. In symbol set from PCA10001 to PCA10005.\r\n2. In board_config.h\r\n\r\n    //#define BOARD_TYPE BOARD_PCA10001\r\n    #define BOARD_TYPE BOARD_PCA10005 \r\n\r\nAnd then I flashed s130 and application image by nRFGo.\r\nI checked uart log from terminal. but no one printed.\r\n\r\nIs there what I should change another settings? \r\n\r\nanother weird thing is like below.\r\nI flashed s130. but softdevice firmware in region0 indicates s310. what is this?\r\n![image description](/attachment/411fa1b34f0a2a0c3149c2b361c338ab)",
    "tag": "uart"
  },
  {
    "text": "Clock source for SPI slave EAsyDMA Hi \r\nI've been using the PCA10001-board to develop my SPI slave application. \r\nI use the functions in spi_slave.c without any modifications. Works brilliant.\r\n\r\nNow when I have moved to my own circuit-board something is lost. I can see with the scope that I have both MOSI, ChipSelect and Clock at the processor.\r\nInside the processor it is completely silent and MISO doesn't send anything, not from the TX_Buf neither any default characters.\r\n\r\nThere is one change in the hardware design which gives me bad feelings. I have switched to synthesized LFCLK (NRF_CLOCK_LFCLKSRC_SYNTH_250_PPM).\r\nIt looks to me as if the EasyDMA doesn't get any clock input. Is there any settings for DMA I need to do when using the synthesized LFCLK? On the PCA10001 I didn't do anything and it worked anyway. :-)\r\n\r\nBest regards\r\n/H\u00e5kan\r\n\r\n\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "ADC EVENTS_END failed Hello,\r\n\r\nI'm using: nRF51422-QFAA E00 and SDK - nRF51 5.2.0\r\n\r\nMy problem with ADC is that I stucked when waiting for event - end of conversion.\r\nI used the code from Nordic examples called \"simultaneous-adc-sampling-from-two-inputs\".\r\n\r\nFirts strange thing in this code is configuration. Unlike the other examples here they are not using IRQ handler at all and config is:\r\n\r\n    NRF_ADC->INTENSET = (ADC_INTENSET_END_Disabled << ADC_INTENSET_END_Pos);\r\n\r\nLater they force conversion and wait for event (even when it's disabled by config - or event will appear even if interupt for this is disabled?):\r\n\r\n    // enable ADC\t\t\r\n    \tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\t\t\t\t\t  \t\t\t\t\t\t\t\t\t\t\t\t\t/* Bit 0 : ADC enable. */\t\t\r\n    \t\r\n    \t// start ADC conversion\r\n    \tNRF_ADC->TASKS_START = 1;\r\n    \t\r\n    \t// wait for conversion to end\r\n    \twhile (!NRF_ADC->EVENTS_END)\r\n    \t{}\r\n    \tNRF_ADC->EVENTS_END\t= 0; \r\n\r\nI always stucked waiting for EVENTS_END. I changed the config to use IRQ and defined IRQ handler but that doesn't help. Finally I found a trick:  **put 1ms delay between NRF_ADC->ENABLE and TASK_START**. But it's not described in Ref. manual or PAN so I don't know if this will help always (I'm working on critical app).\r\n",
    "tag": "adc"
  },
  {
    "text": "ADC + ble connection I am using nrf51_sdk_v6_0_0_43681 and  s110_nrf51822_7.0.01 wiht nrf51822, and I modifiy code based on ble_app_uart.\r\n\r\nHere I am trying to launch a continous ADC sample with a repeated mode timer, the timer interval is 1ms or 2ms or 4ms. Meanwhile I  disconnect and conect my cellphone(Samsumg Notes 3) with nrf51822 board. Serval times later, I found that the nrf51822 system should be crashed,because my local uart can not be input and ble has no advertising.\r\n        \r\nWhat is the problem?\r\n\r\nThanks\r\n\r\nFrank\r\n\r\nEdit: Format + Added commas between tags",
    "tag": "timer"
  },
  {
    "text": "ADC + ble connection I am using nrf51_sdk_v6_0_0_43681 and  s110_nrf51822_7.0.01 wiht nrf51822, and I modifiy code based on ble_app_uart.\r\n\r\nHere I am trying to launch a continous ADC sample with a repeated mode timer, the timer interval is 1ms or 2ms or 4ms. Meanwhile I  disconnect and conect my cellphone(Samsumg Notes 3) with nrf51822 board. Serval times later, I found that the nrf51822 system should be crashed,because my local uart can not be input and ble has no advertising.\r\n        \r\nWhat is the problem?\r\n\r\nThanks\r\n\r\nFrank\r\n\r\nEdit: Format + Added commas between tags",
    "tag": "adc"
  },
  {
    "text": "s110 LPCOMP Interrupt not working I have scoured the internet for solutions, and documentation. Everything that I've found has to do with ADC, so I thought that I would just convert it to the LPCOMP(they're intrinsically linked). \r\nI have initialised the IRQ correctly. I have also verified that the down event triggers, i have attached my code and a screen shot of the registers. Setting a breakpoint in the IRQ handler never breaks. The LEDs do not ever turn on/flash. This code is setup for GCC, but compiles in ARM and has the same issue(You need to change the name of the IRQ handler from LPCOMP_IRQHandler to LPCOMP_COMP_IRQHandler). Neither compiler nor debugger fixes the issue. Using SDK V6, S110 V7.\r\n\r\n\r\n    static void lpcomp_init(void){\r\n        NRF_LPCOMP->INTENSET = LPCOMP_INTENSET_DOWN_Enabled << LPCOMP_INTENSET_DOWN_Pos ;\r\n        sd_nvic_SetPriority(LPCOMP_IRQn, NRF_APP_PRIORITY_LOW);\r\n    \tsd_nvic_EnableIRQ(LPCOMP_IRQn);\r\n    \tNRF_LPCOMP->REFSEL = LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling << LPCOMP_REFSEL_REFSEL_Pos;\r\n    \tNRF_LPCOMP->PSEL = LPCOMP_PSEL_PSEL_AnalogInput6 << LPCOMP_PSEL_PSEL_Pos;\r\n    \tNRF_LPCOMP->ENABLE = LPCOMP_ENABLE_ENABLE_Enabled;\r\n    \tNRF_LPCOMP->POWER = 1;\r\n    \tNRF_LPCOMP->TASKS_START = 1;\r\n    }\r\n\r\n    void LPCOMP_IRQHandler(void){\r\n    ///get the time since the measurement was started\r\n\tuint8_t time_elapsed = read_sensor_timer();\r\n\tstatic uint8_t switcher = 0;\r\n\tif(switcher){\r\n\t\tnrf_gpio_pin_set(CONNECTED_LED_PIN_NO);\r\n\t\tnrf_gpio_pin_clear(ADVERTISING_LED_PIN_NO);\r\n\t}else{\r\n\t\tnrf_gpio_pin_set(ADVERTISING_LED_PIN_NO);\r\n\t\tnrf_gpio_pin_clear(CONNECTED_LED_PIN_NO);\r\n\r\n\t}\r\n\tswitcher ^= 1;\r\n\r\n\tsensor_data[sensor_data_ptr++] = time_elapsed;\r\n\r\n\t//Release the external crystal\r\n\t\tsd_clock_hfclk_release();\r\n    }\r\n![image description](/attachment/c823fc279d4761079e8fbce8772f4e54)",
    "tag": "interrupt"
  },
  {
    "text": "Custom point to multipoint protocol for up to 32 nRF51822 nodes? I'm renewing my search for a point-to-multipoint radio system, preferably based on the nRF51822.  Basically, I need to be able to connect up to 32 (or more!) nodes to a master hub.  The nodes each pass requests to via the master hub out to the internet and a response is delivered back within a second or so.  Requests/responses are typically no more than 128 bytes.\r\n\r\nAdditionally, I need the master hub to be able to send unsolicited (reverse!) requests to any given node (addressed by BT/MAC addr). The master hub should be able to handle up to 7-8 concurrent connections and for both the nodes and the master hub, the interface to the nRF51822 module would be via the UART. \r\n\r\nI'm particularly attracted to Bluetooth's spread spectrum frequency hopping design and range of up to 100ft for it's robustness in radio noisy environments (eg. vs wifi).\r\n\r\nI've asked this same question about BLE before on this site and the conclusion was that it was quite difficult.  I've looked at Gazelle, but it doesn't seem clear on how to make it scale beyond 8 nodes (and I don't think it can handle the unsolicited requests initiated by the master hub back to a node).\r\n\r\nI have seen several posts on this forum regarding custom protocols, so my question is, is this really the way to go?  Or am I really re-inventing the wheel here.  The application level protocol already handles encryption as well as retries/timeouts.  I'm prepared to roll up my sleeves and dig into designing a protocol if necessary.\r\n\r\nFinally, are there any examples/samples of implementing a custom radio protocol on the nRF51822?\r\n",
    "tag": "uart"
  },
  {
    "text": "Is the SPIS TXDPTR register unable to point to Flash above 0xFFFF? I have written some code that uses the SPIS to transmit data. One of the bursts is constant, for example I have a fixed sequence to send using the SPIS and so if I define it as a static const array. The compiler/linker places at 0x2xxxx, i.e. above the SoftDevice in flash. It appears though that the TXDPTR register only has the bottom 16 bits and a top bit that can be set in this register. This means that I cannot use fixed buffers, and that I must maintain these buffers in ram so that the TXDPTR register can contain a pointer to them. \r\n\r\nIs this correct?\r\n\r\nI have tried in the debugger writing 0xFFFFFFFF to the TXDPTR register and I get 0x2000FFFF, implying I can only point to 0x00000000 - 0x0000FFFF, and 0x20000000 - 0x2000FFFF. Is this correct?\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "SPI Slave CLK Hi \r\n\r\nI'm using two different designs using nRF51822 as SPI Slave.\r\nOne is using p0.07 as CLK input and the other is using p0.06 as CLK input. \r\nI'm using the code from spi_slave.c/h without any changes.\r\n\r\nThe one using p0.07 works like a charm. \r\n\r\nUsing p0.06 adds a 90Mhz oscillating signal to the clock-pulses and consequently the SPI Slave doesn't understand it.\r\n\r\nAre there any default-settings on p0.06 I have to shut off? \r\nI'm not using any analog stuff whatsoever.",
    "tag": "spi"
  },
  {
    "text": "nRF51822 EK + S110 SoftDevice hangs when using spi_slave.c. Hi everyone,\r\n\r\nI know that this is a very little amount of information, but I wanted to get the question out there before I leave for the night.  Basically, I'm communicating as an SPI Slave when using the S110 SoftDevice.  If I don't initialize the SoftDevice - i.e. never init, advertise, etc., I can do whatever I want over SPI.  Once I init / advertise / connect, I get timeouts on the SPI interface - mainly when doing writes to SPI while updating values in another device. \r\n\r\nI did find one conflict already - GPIO was being initialized twice.  I've looked for other conflicts (time handlers, etc.), but I haven't found anything.  I've also tried to access SPI in both the main loop and in a timer handler and I don't see any difference in behavior. My next attempt will be to remove all services and characteristics in order to see if maybe memory or the stack is being overwritten somewhere in my setup. \r\n\r\nI read that other people have had similar problems, but I haven't found a solution yet.  Any help would be appreciated!\r\n\r\nThanks,\r\nJohn\r\n",
    "tag": "spi"
  },
  {
    "text": "Does the nrf51822 ADC support bipolar inputs? Hello,\r\n\r\nI am currently working on a project that requires my analog signal to swing below and above ground. I was wondering if the ADC of the nrf51822 would be able to support such an input?\r\n\r\nThanks,\r\n\r\nAlfredo",
    "tag": "adc"
  },
  {
    "text": "Having problems developing a code for data acquisition with 12-bit adc using nrf24le1 I have a fully functional code for 8-bit data acquisition using nrf24le1. Now i want to upgrade it to 12-bit resolution ,but i have problems in doing so .\r\n\r\nIn my project i am trying to read electrical signals through 7 channels using nrf24le1,  this acquired data is sent wireless through a radio with a channel frequency of  2.4GHz and finally the signal is read in a computer.\r\n**This is my code for 12-bit resolution and my errors**:\r\ntransmitter code:\r\n\r\n\r\n\t/* Code for the transmitter: contains 2 continuous A/D conversion and transmit to base station, 2 bytes per packet.\r\n*/\r\n#include <Nordic\\reg24le1.h>\r\n#include <stdint.h>\r\n#include \"hal_nrf_hw.h\"\r\n//#include \"MyCustom.h\"\r\n#include \"hal_nrf.h\"\r\n#include \"hal_adc.h\"\r\n\r\n\r\n#define SAMPLING_INTERVAL_US 10000\t//sampling rate is 10^6 / 10000\r\n#define CHANNEL_NUMBER 7\r\n#define PAYLOAD_LUMPS 3\r\n\r\n\r\n\r\n#define TIMER_RELOAD_LSB (uint8_t)(0x10000-((SAMPLING_INTERVAL_US/3)*4))\r\n#define TIMER_RELOAD_MSB (uint8_t)((0x10000 -((SAMPLING_INTERVAL_US/3)*4))>>8)\r\n\r\nuint8_t adc_data_lsb;  \r\nuint16_t rf_payload[CHANNEL_NUMBER * PAYLOAD_LUMPS];//changing the Channel_number to payload_size\r\nuint16_t dummy[CHANNEL_NUMBER * PAYLOAD_LUMPS];\r\nuint8_t i, timer_set;   \r\nuint8_t timerSet = 0;\r\n\r\n\r\n// ADC initialization\r\nvoid adc_init()\r\n{\r\n  hal_adc_set_input_channel(HAL_ADC_INP_AIN0);    \r\n  hal_adc_set_reference(HAL_ADC_REF_VDD);         \r\n  hal_adc_set_input_mode(HAL_ADC_SINGLE);         // can be changed to differential\r\n  hal_adc_set_conversion_mode(HAL_ADC_SINGLE_STEP); \r\n  hal_adc_set_resolution(HAL_ADC_RES_12BIT);       \r\n  hal_adc_set_data_just(HAL_ADC_JUST_RIGHT);      \r\n}\r\n\r\nvoid main()\r\n{  \r\n\tuint8_t i, j;\r\n\t// Variable declarations.\r\n\r\n\t//P3DIR = 0x00;\r\n\t\r\n\t// Initialize the ADC.\r\n\tadc_init();\r\n\t\r\n\t// 1. To use the radio the radio clock must be enabled.\r\n\tRFCKEN = 1;\r\n\t\r\n\tTMOD = 0x01;  // Timer 0 mode 1, 16-bit mode\r\n\tTR0 = 1;      // Start timer 0\r\n\tET0 = 1;      // Enable timer 0 interrupt\r\n\t\r\n\t// 2. If the RF interrupt should be used, remember to set both the global interrupt enable flag and the RF interrupt enable flag.\r\n\tRF = 1;  \r\n\tEA = 1;\r\n\t\r\n\t\r\n\t\r\n\t// 3. By default the radio will be in PTX mode, and powered down. The last thing needed is to power it up before it is ready for use. \r\n\thal_nrf_set_power_mode(HAL_NRF_PWR_UP);\r\n\t//hal_nrf_enable_continious_wave (1)\t;\r\n//\tP0DIR = 0x00;\r\n//\tP0DIR = 0xFF;\r\n\t\r\n\t\r\n\twhile(1)\r\n\t{\r\n\t\tfor( i =0; i < PAYLOAD_LUMPS; i++ )\r\n\t\t{\r\n\t\t\twhile(!timerSet);\r\n\t\t\ttimerSet = 0;\r\n\t\t\t//Main ADC sampling code\r\n\t\t\tfor( j = 0; j < CHANNEL_NUMBER; j++ )\r\n\t\t\t{\r\n\t\t\t\thal_adc_set_input_channel(i);\r\n\t\t\t\thal_adc_start();\r\n\t\t\t\twhile( hal_adc_busy() );\r\n\t\t\t\t  \r\n\t\t\t\trf_payload[j+i*CHANNEL_NUMBER] = hal_adc_read_LSB();\r\n       // rf_payload[j+i*CHANNEL_NUMBER] +=((unit16_t)hal_adc_read_MSB()) << 8;\t\t\t\t\r\n        dummy[j+i*CHANNEL_NUMBER] = (((uint16_t)hal_adc_read_MSB())<<8);\r\n        \trf_payload[j+i*CHANNEL_NUMBER] = rf_payload[j+i*CHANNEL_NUMBER] + dummy[j+i*CHANNEL_NUMBER];\t\t\r\n       }\r\n\t\r\n}\r\n\t\thal_nrf_write_tx_payload(rf_payload, CHANNEL_NUMBER * PAYLOAD_LUMPS);\r\n\t\tCE_PULSE();\r\n\t}                                           \r\n} \r\nvoid timer0_irq() interrupt INTERRUPT_T0\r\n{\r\n\tTL0 = TIMER_RELOAD_LSB;\r\n\tTH0 = TIMER_RELOAD_MSB;\r\n\ttimerSet = 1;\r\n}\r\n\r\n// It is recommended to use an interrupt to receive data sent (TX_DS), \r\n// data received (RX_DR) or max retransmit (MAX_RT) messages from the radio. \r\nvoid rf_irq() interrupt INTERRUPT_RFIRQ\r\n{\r\n  // Read and clear IRQ flags from radio\r\n  uint8_t irq_flags = hal_nrf_get_clear_irq_flags(); \r\n  switch(irq_flags)\r\n  {\r\n    // Transmission success\r\n    case (1 << HAL_NRF_TX_DS):\r\n      //radio_busy = false;\r\n      // Data has been sent\r\n      break;\r\n    // Transmission failed (maximum re-transmits)\r\n    case (1 << HAL_NRF_MAX_RT):\r\n      // When a MAX_RT interrupt occurs the TX payload will not be removed from the TX FIFO. \r\n      // If the packet is to be discarded this must be done manually by flushing the TX FIFO.\r\n      // Alternatively, CE_PULSE() can be called re-starting transmission of the payload.\r\n      // (Will only be possible after the radio irq flags are cleared) \r\n      hal_nrf_flush_tx();\r\n      //radio_busy = false;\r\n      break;\r\n  }\r\n} \r\n\r\nERRORS:\r\n\r\n    SEGMENT: ?DT?_HAL_NRF_SET_RF_CHANNEL?HAL_NRF\r\n    LENGTH:  0001H\r\n*** ERROR L107: ADDRESS SPACE OVERFLOW\r\n    SPACE:   DATA    \r\n    SEGMENT: ?DT?_HAL_NRF_SETUP_DYNAMIC_PAYLOAD?HAL_NRF\r\n    LENGTH:  0001H\r\nProgram Size: data=164.0 xdata=0 code=2301\r\nTarget not created\r\n\r\n\r\nRECEIVER CODE:\r\n\r\n/* Code for the receiver: should be a continuous receiver that transmit the received packets to a PC through a UART communication. */\r\n#include <stdio.h> \r\n#include <Nordic\\reg24le1.h>\r\n#include <stdint.h>\r\n#include \"hal_nrf_hw.h\"\r\n//#include \"MyCustom.h\"\r\n#include \"hal_uart.h\"\r\n#include \"hal_nrf.h\"\r\n\r\n\r\n#define CHANNEL_NUMBER 7\r\n#define PAYLOAD_LUMPS 3 \r\n//#define PAYLOAD_SIZE 8     // difining a payload size different than channel_number\r\n\r\n// Variable declarations.\r\nuint8_t rf_status;\r\nuint8_t rf_payload[CHANNEL_NUMBER * PAYLOAD_LUMPS];\r\nuint8_t dataready = 0;\r\nbit data_received = 0;\r\n\r\n\r\nvoid main()\r\n{ \r\n\tuint8_t i;\r\n//\tuint8_t cnt, i\t = 0;\r\n\t// Enable RF interrupt and activate the global interrupt flag.\r\n\tRF = 1;  \r\n\tEA = 1;\r\n\t\r\n\tRFCKEN = 1;\r\n\t\r\n\t// 1. By default the radio will be in PTX mode. This means we need to active PRX mode to use it as a receiver.\r\n\thal_nrf_set_operation_mode(HAL_NRF_PRX);\r\n\t\r\n\t// 2. With the default settings Pipe 0 will be used to receive incomming packets. For the radio to receive the packets sent by\r\n\t// project 03 it is important to configure the Pipe 0 with the right payload length (3 bytes).\r\n\thal_nrf_set_rx_payload_width(0, CHANNEL_NUMBER * PAYLOAD_LUMPS);\r\n\t\r\n\t\r\n\t// Power up the radio.\r\n\thal_nrf_set_power_mode(HAL_NRF_PWR_UP);\r\n//\thal_nrf_enable_continious_wave (1)\t;\r\n\t\r\n\t// 3. To enable the receiver the Chip Enable signal should be set high permantently. \r\n\tRFCE = 1;\r\n\t\r\n\t//Setup the UART pins as outputs\r\n//\tP0DIR = 0xDF;\r\n//\tP0DIR = 0xDF;\r\n\tP0DIR = 0x00;\r\n\t\r\n\t// Init UART\r\n\t//hal_uart_init();\r\n\thal_uart_init(UART_BAUD_38K4);\r\n\r\n\r\n\twhile(1)\r\n\t{\r\n \tif( data_received )\r\n    {\r\n      for( i = 0; i < CHANNEL_NUMBER * PAYLOAD_LUMPS; i++)\r\n        hal_uart_putchar(rf_payload[i]);\r\n\r\n      data_received = 0;\r\n    }   \r\n  }\r\n}\r\n\r\n\r\n//\t\tif(cnt = hal_uart_chars_available())\r\n//\t\t{\r\n//\t\t\tfor( i = 0; i < cnt; i++)\r\n//\t\t\t\thal_uart_putchar( i );\r\n//\t\t}\r\n\r\n//\t}\r\n//}\r\n  \r\n// It is recommended to use an interrupt to receive data sent (TX_DS), \r\n// data received (RX_DR) or max retransmit (MAX_RT) messages from the radio. \r\nvoid rf_irq() interrupt INTERRUPT_RFIRQ\r\n{\r\n\t//uint8_t i;\r\n\t//payload_counter = (payload_counter+1)%2; \r\n\t// 4. The status of the interrupt flags should be read out and stored in the \"rf_status\" variable.   \r\n\trf_status = hal_nrf_get_clear_irq_flags(); \r\n\t\r\n\t// It is common to use a switch to check which of the RF status bits were set. \r\n\t// Since this example will only be used as a receiver we should only expect RX_DR interrupts, but the other interrupts\r\n\t// are included for reference.\r\n\tswitch( rf_status ) \r\n\t{\r\n\t\tcase (1<<HAL_NRF_RX_DR):\r\n\t\t\t// 5. The RF payload must be read out and put in a buffer.\r\n\t\t\thal_nrf_read_rx_payload(rf_payload);\r\n//\t\t\tfor( i = 0; i < CHANNEL_NUMBER * PAYLOAD_LUMPS; i++)\r\n\t\t//\tfor( i = 0; i < CHANNEL_NUMBER * PAYLOAD_LUMPS; i++)\r\n\t\t//\t\thal_uart_putchar(rf_payload[i]);\r\n\t\tdata_received = 1;\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t\r\n\t\t// A packet was sent.\r\n\t\tcase (1<<HAL_NRF_TX_DS):\r\n\t\t\tbreak;\r\n\t\t\r\n\t\t// A packet was sent, but no acknowledge was received. \r\n\t\tcase (1<<HAL_NRF_MAX_RT):\r\n\t\t\tbreak;\r\n\t}\r\n}        \r\n",
    "tag": "adc"
  },
  {
    "text": "How to not send 0x0A at the end of data in nrf Uart v2.0 app Hi,\r\nI am using nrf51822(128k), SD 6.0, SDK 5.2.\r\n\r\nI found that nrf uart v2.0 app will add a \"0x0A\" at the end of data that I want to send.\r\nHow can I remove this?\r\n\r\nThank you",
    "tag": "uart"
  },
  {
    "text": "nrf_pwm signal glitches (\"flickering\") on nrf_pwm_set_value() Hi!\r\n\r\nI use nrf51-pwm-library ( https://github.com/NordicSemiconductor/nrf51-pwm-library/) to control brightness of LED RGB light source and it works ok till I don't want to adjust brightness slowly (dimming function).\r\n\r\nWhen I use \r\n\r\nnrf_pwm_set_value(channel->pwmChannel, channel->currentBrightness);\r\n\r\nfunction - no matter using scheduler or simple in for loop\r\n\r\n    \t\tint counter = 0;\r\n\t\tint brightnessChangeDelay = 2000;\r\n    for (;;)\r\n    {\r\n\t\t\tif(counter++ >= brightnessChangeDelay)\r\n\t\t\t{\r\n\t\t\t\t\t\tnrf_pwm_set_value(channel->pwmChannel, channel->currentBrightness);\r\n\t\t\t\tcounter = 0;\r\n\t\t\t}\r\n    }\r\n\r\nLed flickers.\r\n\r\nI though that the problem is caused by updating compare register to fast, but looking at nrf_pwm.c I see that it's updated via naxt_pwm_val after timer interrupt. \r\n\r\nWhat else can cause the glitches? I think that reason is not in the communication, because when it's dimming very slowly and device is already disconnected for a long time it also happens.\r\n\r\n__\r\n\r\nit look's like that:\r\n\r\n![image description](http://i.imgur.com/lsubveN.png)\r\n\r\nin the middle is the moment, when I update the value... ;/",
    "tag": "pwm"
  },
  {
    "text": "APP stucks in simple_uart.c Hi Guys,\r\n\r\ni've a problem with the simple_uart.c module.\r\nI print some intermediate values with app_trace_log -> simple_uart.c and sometimes, the application stucks at:\r\n\r\n    void simple_uart_put(uint8_t cr)\r\n    {\r\n        NRF_UART0->TXD = (uint8_t)cr;\r\n          \r\n        while (NRF_UART0->EVENTS_TXDRDY != 1) //<<<< in this line\r\n        {\r\n            // Wait for TXD data to be sent.\r\n        }\r\n\r\n        NRF_UART0->EVENTS_TXDRDY = 0;\r\n    }\r\n\r\nDoes anybody know, how i can avoid this or continue without resetting the device?\r\n\r\nThanks in advance,\r\ncheers",
    "tag": "uart"
  },
  {
    "text": "[nRF51822] SENSE pin in PORT mode doesn't solve the GPIOTE overconsumption in EVENT mode The hardware bug #39 on the GPIOTE in EVENT mode which gives a overconsumption of ~1mA even in idle mode on,  kills the interest of having a low power chip, because the [solution](https://devzone.nordicsemi.com/question/279/nrf51422-sense-mechanism-detect-more-than-one-pin/?answer=286#post-id-286 ) gived by Nordic which is to use the PORT interrupt mode on a pin with SENSE mode enabled, doesn't works when I use multiple interrupts with short transition signals. When I read the  NRF_GPIO->IN, the signal may have has already gone down because I have lost some interrupts occurences. \r\n\r\nCould you please recommend another way to deal with interrupts, still staying in low power  ?\r\nThanks,",
    "tag": "interrupt"
  },
  {
    "text": "BLE SPI Master - SPI Slave -Nor flash Hi, \r\n\r\nI am trying to test an external nor flash(as SPI slave) with the mKit dev board (as SPI master).\r\n\r\nI was looking at the SPI examples and a bit confused about them.\r\nI am trying to figure out, how a byte is transmitted or received.\r\nDoes assigning a value to NRF_SPI_TYPE->TXD cause the data  to be \r\nphysically sent?  How are the chip select pins set low and high in this process.\r\n\r\nAlso, in case of interrupts does, what happens to the chip select pin.\r\n(I would guess, the state of the chip select pin would determine the \r\ncompleteness or incompleteness of the SPI commands to the external flash) \r\n\r\nBased on how these work, I think I would need to implement a flash memory read, write & erase operations for the external SPI nor flash. They would be mostly a bunch of SPI byte_reads or byte_writes with some glue code. But I am stuck at understanding, how the basic SPI byte read or write happens. \r\n \r\ncan anybody who has interfaced nrf51822 with external SPI flash comment about their experience or pointer to any such information or example code.\r\n\r\nThank You,\r\nMurali",
    "tag": "spi"
  },
  {
    "text": "BLE SPI Master - SPI Slave -Nor flash Hi, \r\n\r\nI am trying to test an external nor flash(as SPI slave) with the mKit dev board (as SPI master).\r\n\r\nI was looking at the SPI examples and a bit confused about them.\r\nI am trying to figure out, how a byte is transmitted or received.\r\nDoes assigning a value to NRF_SPI_TYPE->TXD cause the data  to be \r\nphysically sent?  How are the chip select pins set low and high in this process.\r\n\r\nAlso, in case of interrupts does, what happens to the chip select pin.\r\n(I would guess, the state of the chip select pin would determine the \r\ncompleteness or incompleteness of the SPI commands to the external flash) \r\n\r\nBased on how these work, I think I would need to implement a flash memory read, write & erase operations for the external SPI nor flash. They would be mostly a bunch of SPI byte_reads or byte_writes with some glue code. But I am stuck at understanding, how the basic SPI byte read or write happens. \r\n \r\ncan anybody who has interfaced nrf51822 with external SPI flash comment about their experience or pointer to any such information or example code.\r\n\r\nThank You,\r\nMurali",
    "tag": "spi"
  },
  {
    "text": "Analog-to-digital converter type in nRF 51822 We would need to know the type of Nordic 51822's anaog-to-digital converter. Is it making use of so called successive approximation, or some other technology such as sigma-delta?\r\n\r\nhttp://en.wikipedia.org/wiki/Successive_approximation_ADC\r\n",
    "tag": "adc"
  },
  {
    "text": "NRF51822 + S110 problem with I2C to (MPU9150) Hi,\r\nI recently started working with the NRF51822 and PCA1001 \r\nI need to read data from MPU9150 accelerometer via I2C and transmit the results over BLE. \r\n\r\nI connected the MPU wires SCL to P0.24 and SDA to P0.25 \r\nI added \"sd_twi_hw_master.c\" as a library file \r\n\r\nI am trying to read data from the sensor on a timed event in this manner : \r\nin the main() function I call \r\n\"twi_master_init()\" after the advertising starts \r\nand it returns that it was successfull(true) \r\n\r\nhowever when I try to read some data, the problems begin. \r\n\r\nI previously tried to use this sensor with an RFduino, \r\nin order to test the connection I used to use this function : \r\n\r\n> accelgyro.testConnection()\r\nIt actually uses this command : \r\n> I2Cdev::readBits(devAddr,\r\n> 0x75,\r\n> 6,\r\n> 6, buffer);\r\n\r\nand compares it with 0x34\r\n\r\nI tried to implement something like that on the NRF51822, \r\nthis is my code : \r\n\r\n>     bool transfer_succeeded = true; \t\t\r\n>     uint8_t register_address = 0x75;\r\n>     transfer_succeeded &= twi_master_transfer((m_device_address<<1) | 0x01, &register_address, 1, false);\r\n> \t\tnrf_delay_us(400); \r\n>     if (transfer_succeeded) \r\n>     {\r\n>         transfer_succeeded &= twi_master_transfer(m_device_address<<1, value, 1, true);\r\n>         nrf_delay_us(400); \r\n>     }\r\n\r\nnow it seems that the first transfer always returns false. \r\n\r\nwhat is the problem, how should I implement it? \r\n\r\nthanks\r\n",
    "tag": "i2c"
  },
  {
    "text": "NRF51822 + S110 problem with I2C to (MPU9150) Hi,\r\nI recently started working with the NRF51822 and PCA1001 \r\nI need to read data from MPU9150 accelerometer via I2C and transmit the results over BLE. \r\n\r\nI connected the MPU wires SCL to P0.24 and SDA to P0.25 \r\nI added \"sd_twi_hw_master.c\" as a library file \r\n\r\nI am trying to read data from the sensor on a timed event in this manner : \r\nin the main() function I call \r\n\"twi_master_init()\" after the advertising starts \r\nand it returns that it was successfull(true) \r\n\r\nhowever when I try to read some data, the problems begin. \r\n\r\nI previously tried to use this sensor with an RFduino, \r\nin order to test the connection I used to use this function : \r\n\r\n> accelgyro.testConnection()\r\nIt actually uses this command : \r\n> I2Cdev::readBits(devAddr,\r\n> 0x75,\r\n> 6,\r\n> 6, buffer);\r\n\r\nand compares it with 0x34\r\n\r\nI tried to implement something like that on the NRF51822, \r\nthis is my code : \r\n\r\n>     bool transfer_succeeded = true; \t\t\r\n>     uint8_t register_address = 0x75;\r\n>     transfer_succeeded &= twi_master_transfer((m_device_address<<1) | 0x01, &register_address, 1, false);\r\n> \t\tnrf_delay_us(400); \r\n>     if (transfer_succeeded) \r\n>     {\r\n>         transfer_succeeded &= twi_master_transfer(m_device_address<<1, value, 1, true);\r\n>         nrf_delay_us(400); \r\n>     }\r\n\r\nnow it seems that the first transfer always returns false. \r\n\r\nwhat is the problem, how should I implement it? \r\n\r\nthanks\r\n",
    "tag": "twi"
  },
  {
    "text": "Button interrupt not triggeering Hi, \r\nI am using nRF 511822.I have edited the sample code ble_app_uart and tried to interface the button interrupt handler.But the interrupt is not triggering. I have added the functions                                                  \r\ngpiote_init();\r\nand \r\nbuttons_init();\r\n\r\n    static void gpiote_init(void)                                                                                                       \r\n    {\r\n        APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS);\r\n    }\r\n\r\nand \r\n\r\n    static void buttons_init(void)\r\n    {\r\n    \r\n    \t    static app_button_cfg_t buttons[] =\r\n        {\r\n    \t\t\t  {SWITCH1, false, BUTTON_PULL, button_event_handler}\r\n     \r\n        };\r\n        \r\n        APP_BUTTON_INIT(buttons, sizeof(buttons) / sizeof(buttons[0]), BUTTON_DETECTION_DELAY, true);\r\n    }\r\n\r\nand my button interrupt handler is\r\n\r\n\r\n    static void button_event_handler(uint8_t pin_no, uint8_t button_action)                                       \r\n    {\r\n        if (button_action == APP_BUTTON_PUSH)                                                                                 \r\n        {\r\n            switch (pin_no)                                                                                                               \r\n            {\r\n    \t\t\t\t\t\t//call function to send the characters \r\n                case SWITCH1:                                                                                                                \r\n                temp_flag=1;                                                                                                               \r\n                    break;            \r\n    \r\n                default:                                                                                                                      \r\n                  APP_ERROR_HANDLER(pin_no);\r\n                  break;\r\n            }\r\n        }    \r\n    }\r\n\r\nHere \r\n\r\n      #define SWITCH1        BUTTON_1  \r\n\r\nafter running the code, the device can connect to the master control panel and also enable the services. But the button interrupt is not triggering.\r\n\r\nCan anybody suggest a solution ?                       \r\n\r\n\r\nThanks \r\nrahul\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Changing SPI frequency Hi,\r\nWe're using the SPI to communicate with a device that, when powered up, supports only up to 3Mbps SPI frequency , but after a while can work with higher frequencies.\r\nIs it possible to change the SPI Master frequency on the fly with the nRF51822?\r\nI've tried changing the FREQUENCY field in the struct (from 2Mbps to 4Mbps), but it seems to have no effect.\r\n\r\nThanks!",
    "tag": "spi"
  },
  {
    "text": "SPI Pin assignment problem Hello,\r\n\r\nI am trying to use SPI on a mbed nRF51822 and am following the documentation suggestion. We've deleted all code except the minimum to try and track down the problem.\r\n\r\n    #include \"mbed.h\"\r\n    int main() {\r\n        SPI device(p5, p6, p7);\r\n    }\r\n\r\nAs soon as it runs, LED1 and LED2 start flashing back and forth. The code is based on the SPI.h documentation and the pins are allowed according to the reference manual. \r\n\r\nWhat am I missing?\r\n\r\nEdit: format.",
    "tag": "spi"
  },
  {
    "text": "\"inverted\" pwm output problem when changing CC Nrf Timer register Hi!\r\n\r\nI've quite wired problem with PWM based on NRF_TIMER. \r\n\r\nWhen I modify CC value to adjust current value to desired value slowly (function is fired from outside event) sometimes output signal get inverted, eg. if 35% of period output should be HI state, at 34 % (decreasing brightness) it goes to LO state for 34%, 33%, .... And at the end it switches off normally.\r\n\r\nHave you got any idea what can be the reason?\r\n\r\n    \r\n    void adjust_brightness(brightness_t * channel) {\r\n        \r\n        if(channel->currentBrightness\t< channel->desiredBrightness) // it's to dark, increase brightness\r\n        {\r\n            if(channel->currentBrightness == 0 && channel->desiredBrightness != 0)\r\n            {\r\n                nrf_gpiote_task_config(pwm_gpiote_channel[channel->pwmChannel], pwm_io_ch[channel->pwmChannel], NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_LOW);  \r\n            }\r\n                \r\n            channel->currentBrightness++;\r\n        \r\n            PWM_TIMER->CC[channel->pwmChannel] = channel->currentBrightness;\r\n            \r\n            if(channel->currentBrightness == pwm_max_value)\r\n            {\r\n                    nrf_gpiote_unconfig(pwm_gpiote_channel[channel->pwmChannel]);\r\n                    nrf_gpio_pin_write(pwm_io_ch[channel->pwmChannel], 1);\r\n            }\r\n\r\n        }\r\n        else if(channel->currentBrightness > channel->desiredBrightness) // to bright, decrease\r\n        {\r\n            \r\n                if(channel->currentBrightness == pwm_max_value && channel->desiredBrightness != pwm_max_value)\r\n                {\r\n                    nrf_gpiote_task_config(pwm_gpiote_channel[channel->pwmChannel], pwm_io_ch[channel->pwmChannel], NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);  \r\n                }\t\r\n                \r\n                channel->currentBrightness--;\r\n            \r\n                if(channel->currentBrightness == 0)\r\n                {\r\n                    nrf_gpiote_unconfig(pwm_gpiote_channel[channel->pwmChannel]);\r\n                    nrf_gpio_pin_write(pwm_io_ch[channel->pwmChannel], 0);\r\n                }\r\n                \r\n\r\n                PWM_TIMER->CC[channel->pwmChannel] = channel->currentBrightness;\r\n        }\r\n    }\r\n\r\nThanks,\r\nPatriko",
    "tag": "pwm"
  },
  {
    "text": "PWM breaks softdevice Hi,\r\n\r\n  http://members.efn.org/~rick/pub/main.c works fine but http://members.efn.org/~rick/pub/main.c.pwm seems to break the softdevice.  The big difference in my mind is that there is a Timer2 interrupt running at about 300 Hz.  Any help greatly appreciated.\r\n\r\n  Thanks,\r\n\r\n  Rick\r\n",
    "tag": "pwm"
  },
  {
    "text": "Why simple_uart can't work in ble project? My board is nrf51822.\r\nSimple_uart works fine in uart_example, but once I copy it to my ble project which can work, it stuck.\r\nPart of my code :\r\n\r\n    advertising_init();\r\n    services_init();\r\n    conn_params_init();\r\n    sec_params_init();\r\n\r\n\t\tsimple_uart_config(RTS_PIN_NUMBER, TX_PIN_NUMBER, CTS_PIN_NUMBER, RX_PIN_NUMBER, HWFC);\r\n    \r\n\t\tsimple_uart_putstring((const uint8_t *)\" \\n\\rStart: \");\r\n    while(true)\r\n    {\r\n        uint8_t cr = simple_uart_get();\r\n        simple_uart_put(cr);\r\n\r\n        if(cr == 'q' || cr == 'Q')\r\n        {\r\n            while(true)\r\n            {\r\n                // Do nothing.\r\n            }\r\n        }\r\n    }\r\n\r\n    // Enter main loop.\r\n    for (;;)\r\n    {\r\n        power_manage();\r\n    }\r\nProblem in a while loop for waiting uart ready:\r\n\r\n    while (NRF_UART0->EVENTS_TXDRDY!=1)\r\n Same code in uart_example, it works fine, but in my ble project or a ble example, none of rx and tx can be done.",
    "tag": "uart"
  },
  {
    "text": "Can I use TWI master SW and HW together ? Hi,\r\n\r\nI need to use 2 TWI bus (hardware constraint) so I wish to drive one bus with twi_hw_master.c and an other with twi_sw_master.c. \r\n\r\nEach bus have their own GPIO.\r\n\r\nAlex",
    "tag": "twi"
  },
  {
    "text": "inital uart data always show bad data (via JLink CDC) my code shows here: https://github.com/sprhawk/nrf51822-first-fw/blob/5f2726c3194670befa68d5c112f73529f8c36cfe/main.c\r\n\r\n    uart_init();\r\n    printf(\"\\r\\n\\r\\n\");\r\n    printf(\"\\r\\n __DEBUGGING__\\r\\n\");\r\n\r\nevery time my app started, it always shows corrupted data ( how to name the data ? ) like this\r\n   \r\n\r\n>  \ufffdH\ufffdHX\ufffdE U%9}}5\r\n\r\nwhat's the workaround ?\r\n",
    "tag": "uart"
  },
  {
    "text": "Can I maintain a timer active during off (sleep) state in nRF51822? Hi all,\r\n\r\nI'm using the nRF51822-EK (PCA10001) and I'm going to develop a bluetooth cadence (and speed) sensor for MTBs. \r\nI desire low power consumption and i though to put the nRF in \"system off mode\" during inactivity time. The nRF51822 woke up by an analog signal (sensed by LPCOMP) whenever the bicycle's wheel perform an entire revolution. So, I must measure time between two consecutive wheel's revolution.\r\nIt's possible to have a timer active during the \"system off mode\" ?\r\n\r\nThank you all!!!",
    "tag": "timer"
  },
  {
    "text": "software TWI 1.3mA OFF MODE \r\nUsing twi_sw_master have discovered that the nrf51422 E00 draws 1.3mA in off mode. \r\n\r\nWhen the twi device is removed from the bus, the nrf51422 draws under 5uA in off mode. \r\n\r\nI have created twi_hw_master.c correctly using SHORTS\r\nhttps://github.com/tdwebste/nRF51SDK/blob/v5/Nordic/nrf51422/Source/twi_master/twi_hw_master.c\r\n\r\nI turn hardware twi off using\r\n\r\n    NRF_TWI1->POWER  = 1;\r\n    NRF_TWI1->ENABLE = TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos;\r\n    \r\n    \r\n    // do your I2C stuff here\r\n    \r\n    NRF_TWI1->ENABLE = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos;\r\n    NRF_TWI1->POWER  = 0;\r\n\r\nThis works fine with the mpu6500, but does not with the hmc5983. I suspect the hmc5983 is some how keeping the nrf51422 twi active.\r\n\r\nThe solution could be to upmap the twi pins disconnecting the nrf51422 from the twi bus, so that the twi bus does not keep the nrf51422 active. \r\n\r\nHOW should I unmap the twi pins? So that the nrf51422 is not effected by the twi bus?\r\n\r\nRemapping twi pins or anything that may cause twi communication problems, causes the softdevice to HANG or not function correctly. This includes Advertising timeout not functioning,  or hanging the nrf51422 on ble bonding. \r\n\r\nSimple disabling pullups does not allow working around twi communication issues.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Timer 1ms with SD enabled Hi\r\n\r\nI'm trying to set up a 1ms tick timer using TIMER_1. In other words: every 1ms, I have to increment a tick counter, and to perform several operations. When SD is not enabled, the tick timer is working perfectly. The problems appear when the SD is enabled.\r\n\r\nIn my current example, I'm using a GPIO to measure the frequency of the interrupt. Here below is my code, maybe you could indicate me where is my issue:\r\n\r\nInitialization:\r\n\r\n    \tTIMER_BASE_Tick = 0;\r\n    \r\n    \tTIMER_BASE_TIMER->PRESCALER = 5;\r\n    \r\n    \tTIMER_BASE_TIMER->TASKS_STOP = 1;\t/* Stop timer */\r\n    \tTIMER_BASE_TIMER->MODE = TIMER_MODE_MODE_Timer;  /* taken from Nordic dev zone */\r\n    \tTIMER_BASE_TIMER->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n    \tTIMER_BASE_TIMER->CC[0] = 500;\r\n    \tTIMER_BASE_TIMER->TASKS_CLEAR = 1; /* Clear timer */\r\n    \tTIMER_BASE_TIMER->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n    \tTIMER_BASE_TIMER->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\r\n    \r\n        sd_nvic_SetPriority(TIMER_BASE_TIMER_IRQ, 3);\r\n        sd_nvic_EnableIRQ(TIMER_BASE_TIMER_IRQ);\r\n\r\n        TIMER_BASE_TIMER->TASKS_START = 1;\r\n\r\nWhere TIMER_BASE_TIMER is TIMER_1, and TIMER_BASE_TIMER_IRQ is TIMER1_IRQn\r\n\r\nOn the other hand, in the IRQ, I have set up the followint code:\r\n\r\n    void TIMER_BASE_IRQHandler(void)\r\n    {\r\n        if (TIMER_BASE_TIMER->EVENTS_COMPARE[0] != 0)\r\n        {\r\n        \tTIMER_BASE_TIMER->EVENTS_COMPARE[0] = 0;\r\n    \r\n        \t/* Increment tick */\r\n        \tTIMER_BASE_Tick++;\r\n        \tTIMER_BASE_ElapsedTicks++;\r\n    \r\n        \t/* Your functions here  *********** */\r\n        \tPINS_Toggle(APP_LED_OF_LIFE);\r\n        \t/* End of your functions ********** */\r\n    \r\n        \tTIMER_BASE_TIMER->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk;\r\n        }\r\n    }\r\n\r\nMeasuring frequency of toggling pin, I've verified the frequency is perfectly 1ms when the SD is not enabled. But when enabling it, considerable jitters appears.\r\n\r\nWhat am I doing wrong?",
    "tag": "timer"
  },
  {
    "text": "problem using timer interrupts with softdevice S310 v1.0.0 Hello to all,\r\n\r\nSince a couple of weeks I have a problem in a program which consist of three parts:\r\n\r\n1.- a Timer to make a pulse train by interrupts\r\n2.- a program to control a LCD display\r\n3.- a program to set and clear a led and to read a button via bluetooth.\r\n\r\nAll works fine while the part of the timer to generate a pulse train is disabled, but when I enable it, all my signals in the output pins from the another parts of the program go to zero, and I have no idea what it's happening. The timer configuration I've used is the next:\r\n\r\n<pre><code>\r\n\r\n    // Start 16 MHz crystal oscillator.\r\n    NRF_CLOCK->EVENTS_HFCLKSTARTED  = 0;\r\n    NRF_CLOCK->TASKS_HFCLKSTART     = 1;\r\n\r\n    // Wait for the external oscillator to start.\r\n    while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0) \r\n    {\r\n        // Do nothing.\r\n    }\r\n\r\n    // Clear TIMER2\r\n    NRF_TIMER2->TASKS_CLEAR = 1;\r\n\r\n    // Configure TIMER2 for compare[0] event every 200 ms.\r\n    NRF_TIMER2->PRESCALER = 4;                // Prescaler 4 results in 1 tick equals 1 microsecond.\r\n    NRF_TIMER2->CC[0]     = 1*1000UL;       // 1 tick equals 1\u00b5 , multiply by 1000 for ms value.\r\n    NRF_TIMER2->MODE      = TIMER_MODE_MODE_Timer;\r\n    NRF_TIMER2->BITMODE   = TIMER_BITMODE_BITMODE_24Bit;\r\n    NRF_TIMER2->SHORTS    = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\r\n    NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);\r\n\r\n\r\nAnd the timer interrupt configuration I've used is the next:\r\n\r\n\r\n\t\tuint32_t err_code;\r\n\t\tnrf_gpio_cfg_output(GPIO_OUTPUT_PIN_NUMBER);\r\n    timer2_init();                  // Use TIMER2 to generate events every 200 ms.\r\n\r\n\t\t// Enable TIMER2 interrupt\r\n    err_code = sd_nvic_ClearPendingIRQ(TIMER2_IRQn);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\n    err_code = sd_nvic_SetPriority(TIMER2_IRQn, NRF_APP_PRIORITY_HIGH);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\n    err_code = sd_nvic_EnableIRQ(TIMER2_IRQn);\r\n    APP_ERROR_CHECK(err_code);\t\r\n\t\r\n    NRF_TIMER2->TASKS_START = 1;    // Start event generation.\r\n\r\nIs the configuration of the  timer interrupts correct???\r\n\r\nThe libraries I'm using are the next:\r\n\r\n    include stdint.h\r\n    include string.h\r\n    include \"nordic_common.h\"\r\n    include \"nrf.h\"\r\n    include \"app_error.h\"\r\n    include \"nrf_gpio.h\"\r\n    include \"nrf51_bitfields.h\"\r\n    include \"boards.h\"\r\n    include \"app_timer.h\"\r\n    include \"app_gpiote.h\"\r\n    include \"app_button.h\"\r\n    include \"spi_master.h\"\r\n    include \"spi_master_config.h\"\r\n    include \"nrf_delay.h\"\r\n    include \"boards.h\"\r\n    include \"nrf_gpiote.h\"",
    "tag": "timer"
  },
  {
    "text": "Wheatstone Bridge Interface I'm looking at interfacing a typical Wheatstone bridge sensor to the nRF51822 ADC. This particular sensor only requires a mA or two for excitation and the output fits within the 1.2V precision reference.\r\n\r\nMy question is regarding an economical, low power interface design between a sensor like this and the nRF51822; Are there any tricks or tips that might make this an easier task?\r\n\r\nMy current idea is to use a pair of transistors in a current mirror configuration to excite the bridge, and then a small rail-to-rail op-amp to effectively unload and amplify the signal from the sensor and present it to the relatively low impedance ADC input of the nRF51822. I could power the current mirror and the op-amp from a FET controlled by the nRF51822 which would remove power from the sensor and amplifier when not in use.\r\n",
    "tag": "adc"
  },
  {
    "text": "button isr Hi,\r\n\r\nIs there any sample code for button interrupt and timer interrupt  with out using ble stack and services in nRF51822 ? I mean bare code for nRF51822, in which an interrupt is triggered when a button is pressed and an interrupt is triggered when a particular time is reached.\r\n\r\nthanks and regards,                          \r\nShiju ",
    "tag": "timer"
  },
  {
    "text": "ADC for battery measurment and ports 26,27 and 28 Hi,\r\n\r\nI am using ADC without external reference and no analog input in order to measure the battery level with a timer (code at the end).\r\n\r\nI am also reading several ports state using the buttons library.\r\n\r\nEverything works fine, except ports 26, 27 and 28 when I am actually turning the ADC on, even tough I am configuring the NRF->CONFIG to not use any analog input. (And the case about port 28 is even more rare, since it is just a regular IO)\r\n\r\nWhat am I doing wrong?\r\n\r\nThanks!\r\n\r\ninit code:\r\nstatic void bams_adc_init(void)\r\n{\t\r\n\t/* Enable interrupt on ADC sample ready event*/\t\t\r\n\tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n\tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n\tsd_nvic_EnableIRQ(ADC_IRQn);\r\n\t\r\n\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_Disabled << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< No analog input as analog input. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< VDD specified by PSEL with 1/3 prescaling used as input for the conversion. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n\t\r\n\t/* Enable ADC*/\r\n\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n}",
    "tag": "adc"
  },
  {
    "text": "More than 1 UART ? Hi all,\r\n\r\nI am new to Nordic semiconductor but I could be interessed by nRF9E5. To check if it could fit my requierement, I would like to know if it possible to configure virtual UART such as Arduino board ?\r\n\r\nDoes anyone managed to create one or two additionnal UART to this device ? \r\n\r\nMy app is to send data to two different devices using one single microcontroller. \r\n\r\nThanks in advance for your answers. \r\n\r\nPascal",
    "tag": "uart"
  },
  {
    "text": "Why does the NRF51422 S210 device reset itself if I send more than 9 bytes to the UART from a PC? If I have the PC insert 1msec byte spacing between data bytes sent to the NRF51422, it receives the message and doesn't reset.  I can send messages less than 10 bytes to the NRF51422 all day long without any issues without the need of any byte spacing.  I have verified that my UART receive buffer is not overflowing (circular buffer).  I have the baud rate set to 115200.  I have tried other baud rate values with the same luck.  I am using flow control on the NRF51422 (RTS/CTS) and PC.  I really don't want to place inter-byte spacing on the data being sent from the PC.  I'm not big on \"band-aids\".  ;)  \r\n\r\nFYI:  I'm sending serial data from the PC via an FTDI usb to serial cable (3.3V version).",
    "tag": "uart"
  },
  {
    "text": "Does the NRF51822 have a more sophisticated PWM capability than toggling GPIOs? The NRF51822 PWM examples I have located work by toggling GPIOs. Does the device have a more sophisticated mechanism than this for generating PWM signals? More pecifically, PWM signals are in some cases generated with a comparator and a reference signal. Does the device have any such capability on-board?",
    "tag": "pwm"
  },
  {
    "text": "micro second timer handler Hi,   \r\nI am using nRF51822. I need to create a timer interrupt handler, which can trigger at 1us (microsecond). I am using Keil. Now i am using the 1 ms (microsecond) timer interrupt handler. In this case i am using APP_TIMER_TICKS to get the number of ticks. I think the 32Khz crystal is used by the timer. In this case the minimum timer tick period will be approximately 30us. How can i implement a timer handler for 1 microsecond time out. I need both 1ms and i us timer handler in the same project.\r\n\r\nThanks in advance,  \r\nShiju C G",
    "tag": "timer"
  },
  {
    "text": "micro second timer handler Hi,   \r\nI am using nRF51822. I need to create a timer interrupt handler, which can trigger at 1us (microsecond). I am using Keil. Now i am using the 1 ms (microsecond) timer interrupt handler. In this case i am using APP_TIMER_TICKS to get the number of ticks. I think the 32Khz crystal is used by the timer. In this case the minimum timer tick period will be approximately 30us. How can i implement a timer handler for 1 microsecond time out. I need both 1ms and i us timer handler in the same project.\r\n\r\nThanks in advance,  \r\nShiju C G",
    "tag": "timer"
  },
  {
    "text": "SPI NRF_ERROR_NOT_SUPPORTED I want to use the pca10001 to communicate as a master to an accelerometer, but when i use the function spi_master_open i get a NRF_ERROR_NOT_SUPPORTED error. I get no clock on sclk when I measure with an oscilloscope.\r\n\r\nI have setup the spi as follows:\r\n\r\n\r\n    \tspi_master_config_t * spi_acc_config;\r\n\t\r\n\tspi_acc_config->SPI_Pin_MISO = \tSPI_PSELMISO0;\r\n\tspi_acc_config->SPI_Pin_MOSI = \tSPI_PSELMOSI0;\r\n\tspi_acc_config->SPI_Pin_SCK = \tSPI_PSELSCK0;\r\n\tspi_acc_config->SPI_Pin_SS = \t\tSPI_PSELSS0;\r\n\tspi_acc_config->SPI_Freq = \t\t\t20000UL;  /**< Slave clock frequency. */\r\n\tspi_acc_config->SPI_CONFIG_CPHA = 0;\r\n\tspi_acc_config->SPI_CONFIG_CPOL = 0;\r\n\tspi_acc_config->SPI_CONFIG_ORDER = 0; //MSB first\r\n\t\r\n\tuint32_t result = spi_master_open(spi_acc_, spi_acc_config);\r\n\t\r\n\tif (result == NRF_SUCCESS)\r\n\t{\r\n\t\tsimple_uart_putstring((const uint8_t *)\"\\n\\rSuccess\\n\\r\");\r\n\t}\r\n\telse if (result == NRF_ERROR_NOT_SUPPORTED)\r\n\t{\r\n\t\tsimple_uart_putstring((const uint8_t *)\"\\n\\rError not supported\\n\\r\");\r\n\t}\r\n\r\n\r\n[accelerometer.h](/attachment/3f2ca63a0f78bcfe0c68d358965affdd)\r\n[accelerometer.c](/attachment/c3309f106f3910c725e7e9c2d3b3e809)",
    "tag": "spi"
  },
  {
    "text": "Potential problem for long term test with UART enabled I'm testing a data collecting program which samples data every 2s and reports it through UART  (`printf(\"data=%d\\r\\n\", data)`) on a `PCA10001` board. I found this program may run into the error handler (FAILED) in some cases after running about 2 hours.\r\n\r\nUART setting: 38400 Baudrate, hardware flow control\r\n\r\nThe pass/fail conditions are\r\n\r\n1. PASSED: UART is enabled, USB is plugged into a computer, Terminal Emulator is running and receiving data from the COM port\r\n\r\n2. PASSED: UART is disabled, USB is plugged into a battery pack\r\n\r\n3. FAILED: UART is enabled, USB is plugged into a computer, no Terminal Emulator is running\r\n\r\n4. FAILED: UART is enabled, USB is plugged into a battery pack\r\n\r\nParticularly in the last case, even if I reset the chip, the program will run into the error handler directly after startup. The only solution is to plug it into a computer and reset again.\r\n\r\nI guess there's a Tx/Rx queue in the Segger programmer chip. And when it's overflow, the Segger chip will block any further UART operation from nrf51822. Running a Terminal Emulator or reconnecting the USB cable can clear this queue.\r\n\r\nI don't know whether this guess is correct. I write here to remind you, who are working on the evaluation kit, using UART for debug assertion and running long term program, to consider this potential issue. \r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "S310 ble_ant_app_hrm with UART breaks program I want to implement UART support in the S310 ble_ant_app_hrm example to pipe out the heart rate through UART as well as Bluetooth.\r\n\r\nI attempted to set up UART with both simple_uart and app_uart.  There is no error returned durring init however if I attempt a printf or a simple_uart_putstring the program hangs and advertising never starts.\r\n\r\nOnce I comment out the printf or the simple_uart_putstring the program functions as expected.\r\n\r\nAny ideas?",
    "tag": "uart"
  },
  {
    "text": "I2C with s110 with nRF51822 Hello, \r\n\r\ni\u00b4m using nRF51822 with S110 SoftDevice to transfer data from Sensors that will be read out via I2C by the Nrf51822. \r\n\r\nI have read some topics about how it is not possible (like the example of nrf6310 wich is not compatible with s110). i also downloaded the file \"twi_hw_master_sd.c\" but its actually not power aware. \r\n\r\nCan you please tell me which is the volitional way of using I2c together with s110? Is there anything in the api i didn't see?\r\n\r\nRight now i started implementing the I2C in the way of 'NRF_TWI1->Address = 0xXY'\r\n\r\nThanks for your help\r\nMatthias\r\n",
    "tag": "twi"
  },
  {
    "text": "I2C with s110 with nRF51822 Hello, \r\n\r\ni\u00b4m using nRF51822 with S110 SoftDevice to transfer data from Sensors that will be read out via I2C by the Nrf51822. \r\n\r\nI have read some topics about how it is not possible (like the example of nrf6310 wich is not compatible with s110). i also downloaded the file \"twi_hw_master_sd.c\" but its actually not power aware. \r\n\r\nCan you please tell me which is the volitional way of using I2c together with s110? Is there anything in the api i didn't see?\r\n\r\nRight now i started implementing the I2C in the way of 'NRF_TWI1->Address = 0xXY'\r\n\r\nThanks for your help\r\nMatthias\r\n",
    "tag": "i2c"
  },
  {
    "text": "I2C with s110 on nRF51822 Hello, \r\n\r\ni\u00b4m using nRF51822 with S110 SoftDevice to transfer data from Sensors that will be read out via I2C by the Nrf51822. \r\n\r\nI have read some topics about how it is not possible (like the example of nrf6310 wich is not compatible with s110). i also downloaded the file \"twi_hw_master_sd.c\" but its actually not power aware. \r\n\r\nCan you please tell me which is the volitional way of using I2c together with s110? Is there anything in the api i didn't see?\r\n\r\nRight now i started implementing the I2C in the way of 'NRF_TWI1->Address = 0xXY'\r\n\r\nThanks for your help\r\nMatthias\r\n",
    "tag": "i2c"
  },
  {
    "text": "I2C with s110 on nRF51822 Hello, \r\n\r\ni\u00b4m using nRF51822 with S110 SoftDevice to transfer data from Sensors that will be read out via I2C by the Nrf51822. \r\n\r\nI have read some topics about how it is not possible (like the example of nrf6310 wich is not compatible with s110). i also downloaded the file \"twi_hw_master_sd.c\" but its actually not power aware. \r\n\r\nCan you please tell me which is the volitional way of using I2c together with s110? Is there anything in the api i didn't see?\r\n\r\nRight now i started implementing the I2C in the way of 'NRF_TWI1->Address = 0xXY'\r\n\r\nThanks for your help\r\nMatthias\r\n",
    "tag": "twi"
  },
  {
    "text": "nrf51822 pin intterrupt Hi, \r\n\r\nI am using nrf51822 custom board.\r\n\r\nI'm trying to make intterrupt when a pin is 0 (or 1)  and do some calculations while it remains 0.\r\n\r\nHowever I could not manage to achive it. \r\n\r\nThank you. Have a good day.  ",
    "tag": "interrupt"
  },
  {
    "text": "Can't get TX_DS interrupt on PRX side (ACK payload) Hi,\r\n\r\nI have some problem. My code was working and everything was fine, but I decided to improve my program. I made some changes, and now TX_DS interrupt on PRX side doesn't fire. :(\r\n\r\nFrom the beginning:\r\n\r\nPTX side: this side is sending some packet to PRX side, all the time. But to check if packet was sent correctly, besides Shockburst auto-acknowledge, I need to get some payload from PRX side (something like time-synchro packet). It works, on this side. ;) But...\r\n\r\nPRX side: this side is always ready to get data and immediately send payload with ack packet. I mean, in TX FIFO is always one packet written with W_ACK_PAYLOAD. When PRX get some packet, ACK payload is sent immediately.\r\n\r\nBack to PTX side: TX_DR fire, RX_DR fire, packet sent correct and everything looks great. Now PTX side is sending second packet (A2), in order to PRX side can check if ack payload was sent correctly.\r\n\r\nBack to PRX side: PRX side gets second packet (A2), but.. TX_DS doesn't fire!\r\n\r\nWhat can be a reason of this behave?\r\n\r\nConfiguration is correct, i'm sure. Everything was working correctly earlier, and configuration section wasn't change. I changed only rutine. Routine on PRX side, for now looks like:\r\n\r\n1. Put first payload to TX buffer,\r\n2. Check if RX_DR fired in loop,\r\n3. If RX_DR fired, \r\n4. Set CE to low, \r\n5. Get payload length, \r\n6. Read payload, \r\n7. If payload is correct, flush TX and put new payload to TX buffer,\r\n8. Check if RX buffer is empty: if is, back to main loop, else, get new payload (never happened).\r\n\r\nPTX side is so easy, it doesn't make sense to describe this routine (send, check TX, check RX, send second packet, and so on.\r\n\r\nWell: what can be a reason, that TX_DS inerrupt doesn't fire, although PTX side receive ACK payload?\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Possible bug in TWI HW Hi\r\n\r\nI'm having a strange behaviour when using the TWI HW peripheral for reading from an I2C device. My application tries to read one byte from a register in a I2C device. As background:\r\n\r\n-I2C address: 0x55\r\n-Register address: 0x0A\r\n-Expected value: 0x10\r\n-I2C speed: 50KHz (very slow: at higher rates more errors)\r\n\r\nThe problem is that when reading, I've detected that the first SCL pulse I sent when starting to receive the register data has a variable width. Normally, there's no problem because its width is wider than normally, but sometimes (1/10) its witdh is smaller than 4us. When this happens, the I2C device doesn't recognize this pulse as a SCL pulse, so the received data is shifted one position. In other words: when expecting 0x10, i get 0x08.\r\n\r\nIn the first image, you can see a successul data transaction. [scope_0.bmp](/attachment/8437dd1a2a0eb451ec09be9b926a64fd)![image description](/attachment/ca12da202b313745d3c84c0e33ce8405)\r\n\r\nThe second image is a zoom over the first SCL pulse when receiving the data register. You can see this pulse is wider than the following ones. [scope_2.bmp](/attachment/41063224137fcd2968cd01ca07f0089e)![image description](/attachment/ffcaf1c4b3dd02fa4724d5cb68258ca8)\r\n\r\nIn the third image, its width is now 3.4us, causing the problems. [scope_4.bmp](/attachment/4cde3b9a29c008bf488f75f3878a7cf7)![image description](/attachment/c895b2cebf463bafacc1e62a3c8738fa)\r\n\r\nTo try to debug this problem, I've disabled the SD, and my SW is inside a while (1) and only reading this register. Only the TWI peripheral is enabled. \r\n\r\nI've no found errata references and no similar problems in this forum. Am I getting crazy? \r\n\r\nAny guess?\r\n\r\nThanks in advance\r\n\r\nCheers,\r\n\r\nElena\r\n\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "NRF_ERROR_INTERNAL err code 3003 Hi,\r\n\r\nI'm trying to connect to BLE and send data on UART. I'm using nrf51422 with softdevice s310 and SDK v5.2.0.\r\n\r\nThe following code gives me error 3003 which I figured out it is NRF_ERROR_INTERNAL.\r\nCan any one please let me know what does NRF_ERROR_INTERNAL error means?\r\n\r\n      err_code = ble_nus_send_string(&m_nus, data_a,\r\n                    (length - offset + length1 + 1 ));\r\n            APP_ERROR_CHECK(err_code);\r\n    \r\nThanks\r\n",
    "tag": "uart"
  },
  {
    "text": "Issues with nRF51822 EK ble_uart_example and iOS 8.0 Hi everyone,\r\n\r\nI dont know if I encounter these issues because of iOS 8.0 but I'm not able to receive data from the console, send via PCA100001, on my iPhone. Though, what does work is sending text from the iPhone to the PCA100001.\r\n\r\nI connected a USB-UART-Dongle and I can read my text messages sent from the iPhone. But when I try to send anything from the pc -> PCA100001 -> iPhone I dont see anything...\r\n\r\nFor experimentation I'm using the fixed ble_uart_example from this devzone, together with the 4.x SDK\r\n\r\nIs it my fault or is there something weird with the iOS App? I downloaded the latest with the iOS 7 fix.\r\n\r\n**UPDATE:\r\nI'm still pretty much wondering wether this is mine or iOS' fault. \r\n\r\n![image description](/attachment/58e97241598b58057be3396b24239a4c)\r\nFrom the screenshot you can see that the string (\"test\" input from console) is processed right and that the resulting errcode is 0. Still it does not show on the iOS-App?\r\n\r\nKind regards,\r\nStephan",
    "tag": "uart"
  },
  {
    "text": "Multiple nRF8001 connecting to multiple SPI Hi all,\r\n\r\nI am using the BLE nRF8001 and EFM32 (ARM Cortex M3). I used the following SDK for connecting the modules using ACI (SPI).\r\nhttps://github.com/NordicSemiconductor/ble-sdk-efm32\r\n\r\nNow I want to use all of the 3 SPIs of my EFM32 in order to connect it to 3 nRF8001. The SDK is able to connect only one SPI to one BLE. What should I change to have three?\r\n\r\nRegards\r\nFarid",
    "tag": "spi"
  },
  {
    "text": "how to use CLOCK_LFCLKSRC_SRC_RC?  I check the function spec that we can use use 32kHz RC as LFCLK, so I have no external 32k crystal connected with XL1/XL2 on my board.\r\n  I have set      \r\n   NRF_CLOCK->LFCLKSRC            = (CLOCK_LFCLKSRC_SRC_RC << CLOCK_LFCLKSRC_SRC_Pos);\r\n  And \r\n      SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_RC_250_PPM_TEMP_8000MS_CALIBRATION, false);\r\n\r\n   I found that if I start a repeated timer that the interval is APP_TIMER_TICKS(x, APP_TIMER_PRESCALER) (Here x is less than 50), my system will power off soon.\r\nCan you let me know what is wrong I did?\r\nThanks\r\nFrank",
    "tag": "timer"
  },
  {
    "text": "I'd like to use multiple i2c module. I'd like to use PCA10005 & nRF6310 & nRF6350(LCD) & TMP102(i2c).\r\nSo, To use multiple i2c module nRF6310, TMP102, I tested like below.\r\nBut nRF6350 didn't work.\r\nhow should I do?\r\n\r\n![image description](/attachment/4f14cba907b5eabc05276d570c8a8ef1)\r\n\r\nEdited :\r\nTest Code\r\n\r\n    #include \"twi_master.h\"\r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    #include \"nrf.h\"\r\n    #include \"nrf_delay.h\"\r\n    #include \"nrf_gpio.h\"\r\n    #include \"nrf6350.h\"\r\n    \r\n    #define TMP102_ADDRESS 0x90\r\n\r\n    const char text[6] = \"hi nao\";\r\n    /**\r\n     * @brief Function for application main entry.\r\n     */\r\n    int main(void)\r\n    {\r\n        nrf_gpio_port_dir_set(NRF_GPIO_PORT_SELECT_PORT1, NRF_GPIO_PORT_DIR_OUTPUT);\r\n    \tnrf6350_lcd_init();\r\n        nrf6350_lcd_write_string(text,6,1,1);\r\n        while(true)\r\n        {             \r\n\t\tint8_t temperature;\r\n\t\t\t\t\r\n            uint8_t data_buffer[2];\r\n\t\t\tif (twi_master_transfer(TMP102_ADDRESS | TWI_READ_BIT, data_buffer, 2, TWI_ISSUE_STOP)) \r\n\t\t\t{\r\n\t\t\t\t\ttemperature = (int8_t)data_buffer[0];\r\n\t\t\t\t\t//temperature_fraction   = (int8_t)data_buffer[1];\r\n\t\t\t\t\tnrf_gpio_port_clear(NRF_GPIO_PORT_SELECT_PORT1, 0x7F);\r\n\t\t\t\t\tnrf_gpio_port_set(NRF_GPIO_PORT_SELECT_PORT1, (uint8_t)temperature);\r\n\t\t\t}\r\n\t\t\tnrf_delay_ms(100);\r\n        }\r\n    }\r\n    /** @} */",
    "tag": "i2c"
  },
  {
    "text": "Is it necessary to SUSPEND TWI for each byte read? The nrf51 reference manual shows timing diagrams for the TWI interface when reading from slaves to have a shortcut between BB and SUSPEND. My assumption would be that's there to delay the ACK at the end of the read pending software reading the byte and deciding whether a STOP or repeated START should be sent.\r\n\r\nHowever the text also says that once a byte is received the TWI master stretches the clock anyway before sending an ACK until the byte is read from RXD. If that's the case, I don't see why you need the SUSPEND as well, you just need to decide whether to trigger a STOP or repeated START, or nothing, before you read the byte. \r\n\r\nWhich is correct? Does the TWI master indeed delay ACK/NACK automatically until RXD is read, or is it necessary to suspend the TWI master each byte read in order to delay the ACK? \r\n\r\n** Updating the original question after some investigation **\r\n\r\nAfter some work with an analyser indeed the text in the manual is wrong in several places, adding some notes for the next person looking for this information. The statement \r\n\r\n> After receiving a byte, the TWI master will delay sending the ACK/NACK bit by stretching the clock until the CPU has extracted the received byte, that is, by reading the RXD register.\r\n\r\nis not true. If you haven't already triggered a STOP or START by the time the last bit is clocked in, the TWI master sends an ACK and continues going, there's no waiting until RXD is read. \r\n\r\nThis is similarly misleading\r\n\r\n> The TWI master read sequence is stopped by triggering the STOP task. This task must be triggered before the last byte is extracted from RXD to ensure that the TWI master sends a NACK back to the slave before generating the stop condition.\r\n\r\nTriggering a STOP before reading the byte from RXD is not enough, the ACK has already been sent by then, you have to trigger the STOP during the read of the final byte, before the RXRDY event. \r\n\r\nSUSPEND, which isn't really documented at all, does suspend the TWI transaction after an ACK and just holds the clock line low until it's resumed. That's too late a place in the transaction to send a STOP or repeated START event however, the ACK has already occurred and the slave is expecting to send another byte. \r\n\r\nSo indeed for read transactions you pretty much must use SUSPEND for every non-final byte, to ensure you have time to read the byte before the next one clocks in. You should use a shortcut to do this and not just call TASK_SUSPEND in code, unless you are very sure your code won't be interrupted before it calls it (you have only a few hundred CPU cycles before the next byte has arrived at 100kHz, less at faster speeds so an interrupt at the wrong time would be problematic). \r\n\r\nHaving to use SUSPEND also puts your code slightly at risk of hitting PAN 56 lockup although I haven't yet. \r\n\r\nSimilarly for STOP and repeated START they need to be called while the final byte is clocking in and similarly you should use a short for that for the same reason, to ensure hardware triggers it when software could get delayed. If you are doing repeated STARTS, as there isn't a TWI short for BB->START, that would mean using PPI in that case and I haven't tested it. \r\n\r\nThe timing diagrams are correct, although they don't show repeated START after read, the text is wrong in a few areas. Would be good if the errors were corrected and the SUSPEND mode properly documented. \r\n\r\n\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Should the nRF51822 be used if there are heavy ADC requirements? We need to sample all 8 ADC channels for random 1ms pulses to record amplitude data from in real time.  How much will that impact the bluetooth performance if it needs to freeze the cpu in order to transmit?  Will that shut down the bluetooth function for the interim unless we freeze the data streams incoming from the adc?  Am I confused about this tradeoff?",
    "tag": "adc"
  },
  {
    "text": "USB dongle with nrf 51822 and uart \r\nHi, \r\nFirst I want to thank all nordic staff for their great work on sdk & this incredible tiny chip that do a lot :-). I play a little with the devkit sample and my nrf development kit and all work really fine.\r\n\r\nNext step, I have a project of building a box for controlling lights dimmer ( with PWM) . This box use a nrf51822 + an I2C chip for more PWM channels.\r\n\r\nThis box take it's settings from a windows application (in C#) that must send all parameters over the air. First problem I need a way to communicate to the box from old system like windows Xp and 7. From what i see BLE is not supported before windows 8.1.\r\n\r\nSo i start thinking for building some custom/diy dongle with another nrf51822 linked to a usb-uart chip like ftdi FT232R. I couldn't use the dongle provided with the development kit as I must keep it for later development.\r\n\r\nI know that two nrf firmwares will be needed: \r\n\r\n - for the dongle that connect to the nrf in the box and must \r\n   transmit data \r\n - for the box that do the\r\n   light control.\r\n\r\nSomes questions : \r\n\r\n - Is it possible to have two nrf51822 that communicate in this way ?\r\n - Do you know a simple way in order to communicate betwen the two nrf chip ? is there any protocole like gazel or other that could help ? \r\n - Is there specific point to look after in order to connect the ftdi FT232 chip ? \r\n\r\nThanks a lot.\r\n",
    "tag": "uart"
  },
  {
    "text": "understanding current consumption with twi and s310 softdevice [50ms_measure_30ms_other.jpg](/attachment/1a5d194bb2d2f9d080ea18af5dc81111)\r\n\r\nAttached is current measured using the s310 softdevice\r\n\r\nEvery 50ms timer takes a twi measurement, which is a twi 6 byte read followed immediately by a twi 1 byte write \r\n\r\nWhy does this measurement appear as 2 current peaks rather than one? What do these current peaks represent. \r\n\r\nIn addition there is a current peak every 30ms. The software does not contain a 30ms timer. \r\nWhat would be this using current every 30ms?\r\n\r\nThx\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "PPI interrupt was influenced by BLE connecting event Hi,\r\n\r\nI used PPI module and Timer2 to generate a 4Mhz pwm. But I founld when using softdevice(s110 v7.0), the pwm will be broke a while by BLE advertising or connecting event. So I suppose the ble event will influence the PPI module ?\r\n\r\nAnd is there any other method to generate a 4Mhz or 8Mhz clock to driver external device? ",
    "tag": "pwm"
  },
  {
    "text": "ADC example with UART Hi,\r\n\r\nI bought nordic evaluation board 2 days ago. I have been searching through the forums to enable and test the voltage level of a battery and monitor it via UART. After several hours of trail and error. I manage to combine two examples of nordic in to one but I am not being able to see the voltage level on my UART. Can you guys provide me with an example of ADC using UART as output. I will do the rest.\r\n\r\nthanks\r\n\r\nUpdate: \r\n\r\nThanks Stefan for the code",
    "tag": "uart"
  },
  {
    "text": "ADC example with UART Hi,\r\n\r\nI bought nordic evaluation board 2 days ago. I have been searching through the forums to enable and test the voltage level of a battery and monitor it via UART. After several hours of trail and error. I manage to combine two examples of nordic in to one but I am not being able to see the voltage level on my UART. Can you guys provide me with an example of ADC using UART as output. I will do the rest.\r\n\r\nthanks\r\n\r\nUpdate: \r\n\r\nThanks Stefan for the code",
    "tag": "adc"
  },
  {
    "text": "SPI Master not working with Flash I am working with the nrf51822 eval kit and custom boards based on the Laird BL600 module. I am using SDK v5.2.\r\n\r\nI am trying to connect to external Flash (Microchip SST25VF016B) through SPI 1. No matter what I do, the Flash returns 0xFF.\r\n\r\nI have tried the nrf51822 SPI loopback example, it works fine. Indeed, I can loop back MISO<->MOSI and read the correct data. So the nrf51822 chip seems to be working, at least with itself.\r\n\r\nI also took the Flash chip and hooked it to an Arduino Pro Mini. With that setup, I can talk to the Flash just fine. So I am pretty confident that the Flash works and that I am hooking it up correctly as I have the two rigs next to eachother for reference.\r\n\r\nI have made sure the mode settings and frequency are the same between the Arduino and the nrf51822. Also, just to try it, I used many different mode/frequency combinations. Nothing works. No matter what I do, I always get back 0xFF on the MISO line with the nrf51822.\r\n\r\nI don't have a scope, unfortunately, so I can't debug at that level. \r\n\r\nAnyone have any idea what could be causing this? Any idea at all? I am wide open as I am pretty much stuck and have been trying everything.\r\n\r\nI posted the code I am using for reference. Here is the Arduino test (which works and properly prints the Flash ID): https://gist.github.com/eely22/6fd9709f76584b8af792\r\n\r\nHere is the nrf51822 test (which doesn't work, and just returns 0xFF every time): https://gist.github.com/eely22/2bedc0ce3f7e2251174d\r\n\r\nFor the nrf51822, I am using the provided spi_master class. I have thoroughly gone through this and not changed anything in there except the frequency.",
    "tag": "spi"
  },
  {
    "text": "[NRF51] UART lock up at 921600 bps Hi,\r\n\r\nWe have an issue with app_uart_fifo which occasionally locks up during data transfer from NRF51 to an other uC.\r\n\r\nSystem description:\r\n\r\nWe're using first revision chip (QFAAC0) and the UART don't use hardware flow control (PCB is ready without CTS & RTS connected).\r\n\r\nWe have transmission from other uC to NRF51 (around 60 B/s), which causes missing bytes problem. That's why we've decided to increase baud rate to the highest possible rate in order to lower down missing bytes within each packet. We still have corrupted packets but number of these much less than for 115200 bps which we've used before.   \r\n\r\nProblem description:\r\nUnfortunately, as soon as we've increased baud rate to 921600, very rare lock ups have started to occur. It seems that the lock up occurs more often when more data is transfered from NRF51, e.g. when we transfer around 4500 B/s issue occurs around every 40 minutes and for around 600 B/s lock up occurs roughly every 5 hours period.\r\n\r\nI've been testing the same source code with 460800 bps and everyting seems to be working fine (14 hours test).\r\n\r\nThe source locks up in the fputc function:\r\n\r\n    int fputc(int ch, FILE * p_file) \r\n    {\r\n        while(app_uart_put((uint8_t)ch) != NRF_SUCCESS)\r\n            ;\r\n        return ch;\r\n    }\r\n\r\nThe tx fifo is full so the function locks up as it's not possible to add any byte to the fifo and int the same time the transmission interrupt doesn't occur. The debugger doesn't break in the following source code:\r\n\r\n        // Handle transmission.\r\n    if (NRF_UART0->EVENTS_TXDRDY != 0)\r\n    {\r\n        // Clear UART TX event flag.\r\n        NRF_UART0->EVENTS_TXDRDY = 0;\r\n        on_uart_event(ON_TX_READY);\r\n    }\r\n\r\nDo you have any hint what could cause such issue, please? Let me know if I could provide some more information from the debugger which can help with investigation.\r\n\r\nKind Regards,\r\nKrzysztof Rosinski\r\n\r\n\r\n\r\n\r\n  ",
    "tag": "uart"
  },
  {
    "text": "PWM code for a piezo buzzer Hi,\r\n\r\nI have a piezo buzzer connected to pin 14 on a Nordic nRF51822. Here's some code I use to drive it, based on the Nordic PWM library here: https://github.com/NordicSemiconductor/nrf51-pwm-library.\r\n\r\nThis code used to work! It doesn't any longer and I've been staring at it for hours trying to figure out why. A scope attached to pin 14 on the Nordic shows no changes in voltage at all. Since this was last working, I've bumped SDK versions twice, but I can't see that that would have much effect on it. Am currently on SDK 6.1.0 and SD 7.0.0.\r\n\r\nbuzzer.h:\r\n\r\n    #define PWM_TIMER               NRF_TIMER2\r\n    #define PWM_IRQn                TIMER2_IRQn\r\n    #define PWM_IRQHandler          TIMER2_IRQHandler\r\n    #define PWM_IRQ_PRIORITY        (3)\r\n    \r\n    #define PWM_PPI_CHANNEL_0       (0)\r\n    #define PWM_PPI_CHANNEL_1       (1)\r\n    #define PWM_GPIOTE_CHANNEL_0    (2)\r\n    \r\n    void buzzer_init(void);\r\n    void buzzer_ble_connect(void);\r\n    void buzzer_ble_disconnect(void);\r\n\r\nbuzzer.c:\r\n\r\n    #include <stdbool.h>\r\n    \r\n    #include \"nordic_common.h\"\r\n    #include \"nrf.h\"\r\n    #include \"nrf_gpio.h\"\r\n    #include \"nrf_gpiote.h\"\r\n    #include \"nrf_delay.h\"\r\n    #include \"nrf_sdm.h\"\r\n    #include \"app_timer.h\"\r\n    \r\n    #include \"buzzer.h\"\r\n    #include \"bike_tracker_201402.h\"\r\n    \r\n    static uint32_t                        m_pwm_next_value;\r\n    static uint32_t                        m_pwm_io_ch;\r\n    static uint32_t                        m_pwm_running;\r\n    static uint32_t                        m_pwm_max_value;\r\n    static app_timer_id_t                  m_buzzer_timeout_timer_id;\r\n    static bool                            m_buzzer_timed_out = false;\r\n    \r\n    // Sine wave\r\n    const uint8_t sin_table[] = {0,0,1,2,4,6,9,12,16,20,24,29,35,40,46,53,59,66,74,81,88,96,104,112,120,128,136,144,152,160,168,175,182,190,197,203,210,216,221,227,\r\n    \t\t232,236,240,244,247,250,252,254,255,255,255,255,255,254,252,250,247,244,240,236,232,227,221,216,210,203,197,190,182,175,168,160,152,144,136,128,120,112,104,\r\n    \t\t96,88,81,74,66,59,53,46,40,35,29,24,20,16,12,9,6,4,2,1,0};\r\n    \r\n    static void buzzer_timeout_handler(void * p_context)\r\n    {\r\n        UNUSED_PARAMETER(p_context);\r\n        m_buzzer_timed_out = true;\r\n    }\r\n    \r\n    static void nrf_pwm_set_value(uint32_t pwm_value)\r\n    {\r\n        m_pwm_next_value = pwm_value;\r\n        PWM_TIMER->EVENTS_COMPARE[3] = 0;\r\n        PWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE3_CLEAR_Msk | TIMER_SHORTS_COMPARE3_STOP_Msk;\r\n    \r\n        if ((PWM_TIMER->INTENSET & TIMER_INTENSET_COMPARE3_Msk) == 0)\r\n        {\r\n            PWM_TIMER->TASKS_STOP = 1;\r\n            PWM_TIMER->INTENSET = TIMER_INTENSET_COMPARE3_Msk;\r\n        }\r\n    \r\n        PWM_TIMER->TASKS_START = 1;\r\n    }\r\n    \r\n    void PWM_IRQHandler(void)\r\n    {\r\n        PWM_TIMER->EVENTS_COMPARE[3] = 0;\r\n        PWM_TIMER->INTENCLR = 0xFFFFFFFF;\r\n    \r\n    \tif (m_pwm_next_value == 0)\r\n    \t{\r\n    \t\tnrf_gpiote_unconfig(PWM_GPIOTE_CHANNEL_0);\r\n    \t\tnrf_gpio_pin_write(m_pwm_io_ch, 0);\r\n    \t\tm_pwm_running = 0;\r\n    \t}\r\n    \telse if (m_pwm_next_value >= m_pwm_max_value)\r\n    \t{\r\n    \t\tnrf_gpiote_unconfig(PWM_GPIOTE_CHANNEL_0);\r\n    \t\tnrf_gpio_pin_write(m_pwm_io_ch, 1);\r\n    \t\tm_pwm_running = 0;\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tPWM_TIMER->CC[0] = m_pwm_next_value * 2;\r\n    \r\n    \t\tif (!m_pwm_running)\r\n    \t\t{\r\n    \t\t\tnrf_gpiote_task_config(PWM_GPIOTE_CHANNEL_0, m_pwm_io_ch, NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n    \t\t\tm_pwm_running = 1;\r\n    \t\t}\r\n    \t}\r\n    \r\n        PWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE3_CLEAR_Msk;\r\n        PWM_TIMER->TASKS_START = 1;\r\n    }\r\n    \r\n    void buzzer_init(void)\r\n    {\r\n    \tuint32_t err_code;\r\n    \r\n    \tnrf_gpio_cfg_output(PIN_BUZZER_ON);\r\n    \r\n    \tm_pwm_io_ch = (uint32_t)PIN_BUZZER_ON;\r\n    \tm_pwm_running = 0;\r\n    \r\n    \t// Create timer once, start and stop the same timer multiple times.\r\n    \terr_code = app_timer_create(&m_buzzer_timeout_timer_id, APP_TIMER_MODE_SINGLE_SHOT, buzzer_timeout_handler);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \r\n    \tPWM_TIMER->PRESCALER = 0;\r\n    \tPWM_TIMER->TASKS_CLEAR = 1;\r\n    \tPWM_TIMER->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n    \tPWM_TIMER->MODE = TIMER_MODE_MODE_Timer;\r\n    \tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE3_CLEAR_Msk;\r\n    \tPWM_TIMER->EVENTS_COMPARE[0] = PWM_TIMER->EVENTS_COMPARE[1] = PWM_TIMER->EVENTS_COMPARE[2] = PWM_TIMER->EVENTS_COMPARE[3] = 0;\r\n    \r\n    \tsd_ppi_channel_assign(PWM_PPI_CHANNEL_0, &PWM_TIMER->EVENTS_COMPARE[0], &NRF_GPIOTE->TASKS_OUT[PWM_GPIOTE_CHANNEL_0]);\r\n    \tsd_ppi_channel_enable_set(1 << PWM_PPI_CHANNEL_0);\r\n    \r\n    \t// Strangely, omitting these two lines makes for a different, lower tone. No idea why.\r\n    \tsd_ppi_channel_assign(PWM_PPI_CHANNEL_1, &PWM_TIMER->EVENTS_COMPARE[3], &NRF_GPIOTE->TASKS_OUT[PWM_GPIOTE_CHANNEL_0]);\r\n    \tsd_ppi_channel_enable_set(1 << PWM_PPI_CHANNEL_1);\r\n    \r\n    \tsd_nvic_SetPriority(PWM_IRQn, PWM_IRQ_PRIORITY | 0x01);\r\n    \tsd_nvic_EnableIRQ(PWM_IRQn);\r\n    }\r\n    \r\n    static void buzzer_on(uint32_t frequency, uint32_t duration)\r\n    {\r\n    \tuint32_t err_code;\r\n    \tuint32_t counter = 0;\r\n    \r\n    \t// Only valid if the prescaler is 0:\r\n    \tm_pwm_max_value = (16 * 1000 * 1000 / (2 * frequency));\r\n    \tPWM_TIMER->CC[3] = m_pwm_max_value * 2;\r\n    \r\n    \tPWM_TIMER->TASKS_START = 1;\r\n    \r\n        // Start timeout timer again.\r\n        m_buzzer_timed_out = false;\r\n    \r\n        err_code = app_timer_start(m_buzzer_timeout_timer_id, APP_TIMER_TICKS(duration, 0), NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        while (!m_buzzer_timed_out)\r\n        {\r\n            nrf_pwm_set_value(sin_table[counter]);\r\n            counter = (counter + 1) % 100;\r\n    \r\n            // Add a delay to control the speed of the sine wave. Messing with this alters the sound a\r\n            // bit but not in an interesting way.\r\n            nrf_delay_us(8000);\r\n        }\r\n    \r\n        PWM_TIMER->TASKS_STOP = 1;\r\n    \r\n        err_code = app_timer_stop(m_buzzer_timeout_timer_id);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    void buzzer_ble_connect(void)\r\n    {\r\n        buzzer_on(440, 60);\r\n        buzzer_on(880, 180);\r\n        nrf_delay_ms(1000);\r\n    }\r\n    \r\n    void buzzer_ble_disconnect(void)\r\n    {\r\n        buzzer_on(880, 60);\r\n        buzzer_on(440, 180);\r\n        nrf_delay_ms(1000);\r\n    }\r\n\r\nmain.c:\r\n\r\n    int main(void)\r\n    {\r\n        // Test buzzer.\r\n    \tAPP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n    \r\n        buzzer_init();\r\n    \r\n        for (;;) {\r\n            buzzer_ble_connect();\r\n            buzzer_ble_disconnect();\r\n        }\r\n    }\r\n\r\nAny help would be greatly appreciated as always. Thanks in advance.\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "ADC interfacing Problem Hi \r\n am using a thermistor of 10 k with a known resistor of 10 k ,and am giving the voltage divided input to ANI2 (p0.02).The suppply voltage for thermistor is external of 1.5 volts battery.So normally the voltage input to adc seems to be 0.720volts .Since am using 10 bit adc configuration ,the expected output should be from 430 to 511 right ? (1023/2~=511 ) but am always getting low values of range 200-250 .. Here is my adc configuration \r\n\r\nuint16_t adc_init()\r\n{\r\n\tuint16_t adc_result;\r\n\t// interrupt ADC\r\n\tNRF_ADC->INTENSET = (ADC_INTENSET_END_Disabled << ADC_INTENSET_END_Pos);\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t// config ADC\r\n\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos)  \r\n\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput2 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t\r\n\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t\r\n\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)                             \r\n\t\t\t\t\t| (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t\r\n\t\r\n\t// enable ADC\t\t\r\n\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\t\t\t\t\t  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\r\n\t// start ADC conversion\r\n\tNRF_ADC->TASKS_START = 1;\r\n\t\r\n\t// wait for conversion to end\r\n\twhile (!NRF_ADC->EVENTS_END)\r\n\t{}\r\n\tNRF_ADC->EVENTS_END\t= 0;\r\n\t\r\n\t//Save your ADC result\r\n\tadc_result = NRF_ADC->RESULT;\t\r\n\t\t\r\n\t\t\treturn adc_result;\r\n\r\n}\r\n\r\n\r\nCould you please where i had made the mistake !! \r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "How to know the \"sd_ble_gatts_hvx\" is sent successful Hi,\r\n\r\nHow to known the \"sd_ble_gatts_hvx\" send to client (App) with successful ?\r\n\r\nAny flow control need ?\r\n\r\nCheers,\r\nJASON",
    "tag": "uart"
  },
  {
    "text": "\"synchronize\" two devices I have two nrf51822 devices, one running s110, the other s120. The s110 device reads ADC values every 20ms, and if they changed from the last reading it sends a notification with the values to the s120 device. My connection interval is 7.5ms, so this works fine. (packet is only 9 bytes).\r\nHowever, I also wish to know roughly how \"old\" the ADC readings are when received on the s120 device. I used the ble_app_multilink example in the SDK as a basis for the project, and tried the following:\r\n\r\nI modified it so that when the s120 enables notifications on the s110 it also starts RTC1 with a 64 prescaler. When the s110 receives this it also starts its RTC1 with the same prescaler. The idea is that the real-time clocks on the two devices are now roughly in sync, disregarding the time it takes to send and process the packet. This difference will in any case only add a constant offset. \r\nEvery time the s110 sends a message to the s120 it will timestamp the message, and the s120 will check how late it is. Since the packets are timestamped, then queued, i expected the difference to be maximum one connection interval, but the values seem to be completely random, anywhere from 2 ticks, to about 35 ticks. (~4ms to ~70ms).\r\nThe s120 device makes use of the ble_radio_notification to know when exactly to start the RTC, so i'm guessing it should be fairly accurate. \r\n\r\nSo, I have two questions:\r\n\r\n1) Why do i see such large variation in the received packets?\r\n\r\n2) Is there a better way to know how \"old\" the received packet is?",
    "tag": "adc"
  },
  {
    "text": "Windows 8.1 BLE and UART/Serial Port Terminal Program Hi,\r\nI have a project where I need to communicate using UART BLE between nRF51822 and a PC (MS Surface Pro 3) with Windows 8.1 and embedded BLE hardware.\r\n\r\nI have programmed the nRF51822/nRF6310 Motherboard using the PCA10001 ble_app_uart program including modifications to be detected by the BLE in the Surface Pro PC.\r\n\r\nIs there a way to communicate (Send and receive data) via a Terminal Program and not via the nRF UART program?\r\n\r\nHow can I use the BLE in my PC to communicate via a Terminal Program?\r\n(I need to communicate via the BLE in the PC and not via the dongle)!\r\n\r\nAny suggestions, help, tips and hints are most appreciated.\r\n\r\n---\r\n\r\n\r\nInformation to forum users:\r\n\r\nTo compile the ble_app_uart program and use it on the nRF6310 motherboard with PCA10004 or PCA10005 you need to change some options in Keil From the menu go to):\r\n\r\nProject -> Options for target 'nrf51822...' -> C/C++\r\n\r\nChange the defined preprocessor symbols to:\r\n\r\nBOARD_NRF6310 NRF51,DEBUG_NRF_USER, BLE_STACK_SUPPORT_REQD\r\n\r\n\r\nTo communicate directly to a bluetooth dongle (not PCA10000) on your computer you need to include a code snippet in the ble_app_uart software:\r\n\r\n\r\nThe code is put in the main.c file after the \"Function for starting advertising\" comment:\r\n\r\n\r\n/**@brief Function for starting advertising.\r\n */\r\nstatic void advertising_start(void)\r\n{\r\n\t\t\tble_gap_addr_t m_ble_addr;   \t\r\n\t\t\tuint32_t             err_code;\r\n\t\t\tble_gap_adv_params_t adv_params; \r\n\t\t\terr_code = sd_ble_gap_address_get(&m_ble_addr);\r\n\t\t\tAPP_ERROR_CHECK(err_code);\r\n\t\t\terr_code = sd_ble_gap_address_set(BLE_GAP_ADDR_CYCLE_MODE_NONE, &m_ble_addr);\r\n\t\t\tAPP_ERROR_CHECK(err_code);  \r\n\t\r\n- Start advertising\r\n\r\n---\r\n\r\nFrom here I need help too...\r\n\r\nThe bluetooth dongle find the Nordic Hardware and I can do a pairing.\r\n\r\nHow can I communicate with a Terminal Program using a Bluetooth Dongle.\r\n\r\nWindows 8.1 has direct support for Bluetooth BLE when you have a BLE-dongle, but how can I communicate via COM Port/UART using this option.\r\n\r\nI have tried to connect COM-ports to the Terminal-program but nothing works.\r\n\r\nUsing the PC with the PCA10001 dongle and the Nordic nRFUart software works ok, but I need to communicate via an external bluetooth dongle.\r\n\r\nIs there a quick and easy way to solve this problem, or do I need a separate COM Port/Uart-driver installed on the PC?",
    "tag": "uart"
  },
  {
    "text": "PCA 1000(1) JLINK/UART visible on Linux? Hi,\r\nI happily use the JLINK UART interface which show up as COMxx on windows for both the PCA10000 and PCA10001.\r\nWe are trying to 'see' the same on Linux. Have inatlled the latest J-Link drivers, but can't see a useful /dev/tty... I've tried 'vcom enbable' in jlinkexe... is there something else to do?\r\n\r\nthanks.\r\n",
    "tag": "uart"
  },
  {
    "text": "Detecting interrupts in a block of code I'm working with the nRF51822, using the S110 soft device.\r\n\r\nMy application includes some measurement functions that are timing critical. Ideally, the code would be atomic, but I think this is impractical while using the soft device.\r\n\r\nInstead, I would like to be able to detect if a measurement is interrupted and, if so, discard the measurement and repeat it. Is there any way to do this?\r\n\r\nThe measurement cycles vary in time, but will generally be < 100 us.\r\n\r\nThanks,\r\nPhilip",
    "tag": "interrupt"
  },
  {
    "text": "BLE Connect Events Cause Delays in App_Timer and PPI I was using TIMER1 PPI and GPIOTE to setup a PWM signal on a GPIO line.  This PWM will start and stop after 1 seconds.  I used led.c to based my code.    I was starting the Timer1 when the BLE_CONNECT_EVT came in but noticed that the PWM signal was locked up for about 4-5seconds before turning off.   It worked fine if I trigger the PWM start on a button push, or system start-up.  But if I used it at BLE_CONNECT_EVT, everything locks up.  I re-tested with only using app_timers to blink and LED on the same CONNECT event, and same the thing happens.  Since I use an app_timer to control both led and buzzer, the root cause may be app-timers.  Has anyone encountered this?\r\n\r\nThanks guys\r\n\r\np.s. I'm not using the scheduler for any of my timers.",
    "tag": "timer"
  },
  {
    "text": "SPI Master Error I've run into a problem using the provided spi master code. \r\n\r\nI get the following error message from Keil \r\n\r\nspi_master.c(381): error: #1059-D: an entity with an internal linkage cannot be referenced within an inline function with an external linkage\r\n\r\nHas anyone faced a similar problem? Or are there any recomendations about fixing this?\r\n\r\nThanks in advance",
    "tag": "spi"
  },
  {
    "text": "MCP and nRf51 Hi \r\n\r\nI am new to the nRF kit and C, but I have a project where I shall use the nrf51822 as master and MCP3201 ADC as slave. The nRF is only going to read values that i give it true the MCP.\r\n\r\nI cant find any easy exampels to understand and use, so I am wondering of any in this forum could help me! \r\n\r\nFrom Morten",
    "tag": "adc"
  },
  {
    "text": "Getting started with nrf51822 EK and TWI sensor Hello,\r\n\r\nFirstly, I just begun with BLE and I am trying to program nrf51822 to read the sensor data through TWI (I2C) connection and send this reading to the central device (which will be the PC with MCP in my case)\r\n\r\nI want to know what are the steps, the resources that can help me and the basic knowledge that I should have for completing this task.\r\n\r\nThanks",
    "tag": "twi"
  },
  {
    "text": "mbed Ticker implementation Hi,\r\n\r\nI am using nRF51822 and trying to use Ticker from mBed library.\r\nI have issues when using Ticker and PwmOut.\r\nHow is implemented the Ticker functionnality into nRF51822 ? Does it use Timer2 ? Is it possible to choose between Timer0/1/2 ?\r\n\r\nThanks.\r\nClement",
    "tag": "timer"
  },
  {
    "text": "Timer nrf24le1 Hello,\r\n\r\ni am currently trying to integrate a timer properly to my project.\r\n\r\nI want to set a pin to high for a duration of 1msec. \r\nI configured the timer like shown below:\r\n\r\n\r\n    //********TIMER STUFF**********\r\n    TMOD = (TMOD & 0xF0) | 0x20;  /* Set Mode (8-bit timer with reload) */\r\n    \t\r\n    TH1 = 256 - 123;              /* Reload TL1 to count 133 clocks; overflow each ~0.0001 sec! */\r\n    TL1 = TH1;\r\n    \t\r\n    ET1 = 1;                      /* Enable Timer 1 Interrupts */\r\n    TR1 = 1;                      /* Start Timer 1 Running */\r\n\r\nThe problem is, that if i choose a duration smaller than 2msec, the pin is always high.\r\nIf i choose a duration greater than 2msec. Everything works fine.\r\n\r\nIs there a maximum time value for swapping a pin from high to low?\r\n\r\nThanks for your help.\r\n",
    "tag": "timer"
  },
  {
    "text": "tx buffer to pin Hi\r\nI have an ADC that just recive, but i will need to make an buffer that makes tx values and just send them to a output pin. \r\n\r\nSo I wonder how i should code this and if it possible? \r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "nrf51822 UART FIFO and stop bits Hi,\r\nI wonder if there is any way to disable the Rx FIFO so that I don't have to fill it to generate an event, since I need exact timing for every incoming byte. \r\n\r\nAlso, is there anyway to set two stop bits? I can probably workaround it since the second stop bit is  high like the IDLE state but it would be nice to do things properly.\r\n\r\nBest regards,\r\nAndreas",
    "tag": "uart"
  },
  {
    "text": "nRF51822 - Small error in nrf6310 pin_change_int_example in gpio_init():\r\n\r\n    NRF_GPIOTE->CONFIG[0] =  (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos)\r\n                           | (0 << GPIOTE_CONFIG_PSEL_Pos)  \r\n                           | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\r\n\r\nthe `0` should be changed to `BUTTON_0` like this:\r\n\r\n    NRF_GPIOTE->CONFIG[0] =  (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos)\r\n                           | (BUTTON_0 << GPIOTE_CONFIG_PSEL_Pos)  \r\n                           | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\r\n\r\n\r\n Well for the nRF6310 it doesn't matter, but it's a bit confusing if someone try to port this tiny example to a different board.\r\n\r\n(Found in Sdk 5.2.0)",
    "tag": "interrupt"
  },
  {
    "text": "NRF8001 / MSP430 / UART hi guys,\r\n\r\ni would like to start my battery application  and i want to send und receive some Data between my MSP430 and the RFN8001.\r\n\r\nso to first i don\u00b4t anderstand wath ist about the Firmware from the Chip.. !\r\n\r\nneed i to prpgrame the Firmware (from the NRF8001) on the Chip !?\r\n\r\nor need i just to integrate this in the Software from my MSP430 ?\r\n\r\n\r\ncan you help me my be to find here some Exmaple like with rnf8001 and MSP430 and with UART \r\nCommunication !? \r\n\r\n\r\nmany Thanks.\r\n\r\n\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "spi_slave circular FIFO on NRF51822 S110 7.0 Are there any common solutions to the issue of spi_slave.c using an array as its buffer? I would like to setup a circular FIFO, but I am not sure if there is any way to do this without rewriting some of spi_slave.c.\r\n\r\nI will need to place an arbitrary amount of data in the MISO buffer and need to wrap around to the front, should the end be reached.\r\n\r\nThanks for any advice!\r\n\r\nEdit: I may be asking an elementary C question, so I will close this if I come to a solution on my own. Thanks.",
    "tag": "spi"
  },
  {
    "text": "How could I make a PWM on nRF51 Hi,\r\n\r\nI want to make a pulse for buzzer and led.\r\nI find a sample source(led.c) and the Nordic SDK.\r\nIt is good enough in case posivie and negative duty is same.\r\nI need to set a differnt value for positive and negative duty.\r\nIt is possible? If yes, please let me know.\r\n\r\nThe belows is my sample source.\r\n\r\n    #define BEEP_HW_OFF()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\r\n    \t\tNRF_GPIOTE->CONFIG[GPIOTE_CHANNEL_NUMBER] = (GPIOTE_CONFIG_MODE_Disabled << GPIOTE_CONFIG_MODE_Pos);\t\\\r\n    \t\tNRF_TIMER1->TASKS_STOP = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\r\n    \t\tnrf_gpio_pin_clear(BEEP_GPIO)\r\n    \r\n    #define BEEP_HW_ON()\t\t\t\t\t\t\t\t\t\\\r\n    \t\tnrf_gpio_cfg_output(BEEP_GPIO);\t\t\t\t\t\\\r\n    \t\tbeep_hw_init();\t\t\t\t\t\t\t\t\t\\\r\n    \t\tNRF_TIMER1->TASKS_START = 1\r\n    \r\n    static void beep_hw_init(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n        // Configure PPI channel 0 to toggle ADVERTISING_LED_PIN_NO on every TIMER1 COMPARE[0] match\r\n        err_code = sd_ppi_channel_assign(PPI_CHAN0_TO_TOGGLE_BEEP,\r\n                                         &(NRF_TIMER1->EVENTS_COMPARE[0]),\r\n                                         &(NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NUMBER]));\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // Enable PPI channel 0\r\n        err_code = sd_ppi_channel_enable_set(PPI_CHEN_CH0_Msk);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n    \r\n        // Configure timer\r\n        NRF_TIMER1->MODE      = TIMER_MODE_MODE_Timer;\r\n        NRF_TIMER1->BITMODE   = TIMER_BITMODE_BITMODE_16Bit;\r\n        NRF_TIMER1->PRESCALER = TIMER_PRESCALER;\r\n    \r\n        // Clear the timer\r\n        NRF_TIMER1->TASKS_CLEAR = 1;\r\n    \r\n        // Load the value to TIMER1 CC0 register. The following value is calculated to generate\r\n        // a 2 Hz waveform that will serve as input to the LED\r\n        NRF_TIMER1->CC[0] = BEEP_INTENSITY_HIGH;\r\n    \r\n        // Make the Capture Compare 0 event to clear the timer. This will restart the timer.\r\n        NRF_TIMER1->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\r\n    \r\n        // There is no need to setup NRF_TIMER1->INTENSET register because the application do not need\r\n        // to wake up the CPU on Timer interrupts.\r\n    \r\n    \r\n        // Configure the GPIOTE Task to toggle the LED state.\r\n        nrf_gpiote_task_config(GPIOTE_CHANNEL_NUMBER,\r\n                               BEEP_GPIO,\r\n                               NRF_GPIOTE_POLARITY_TOGGLE,\r\n                               NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n    }\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "nRF51822 twi hard fault Hi,\r\n\r\nI've an HardFault, the program crash to the HardFault service routine at this row of the twi_hw_master.c:\r\n\r\n--> NRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n\r\nThis appens after the call twi_master_init();\r\n\r\nThe same code runs well in the DK board PCA10004 and the problem happens in my custom  board, the softdevice firmware is the same.\r\n\r\nIf I disable just the twi all the rest works fine.\r\nI'm looking for additional informations because I have not test pads for test the SDA and SCL signals, so is not simple to find out what happen.\r\n\r\nI was reading the nRF51 pdf but seems that there are not usefull information.\r\n\r\nThanks for your attention.\r\n",
    "tag": "twi"
  },
  {
    "text": "Clarify the nRF51822 Debug options Please help: Debug is mentioned in many places and is of several types (uart, ble, assert...). I need clarification to distinguish which debug type is in effect, and how to use them. Is there a document or Blog clarifying any of this? Some may be great for diagnostics as well, but I do see some warning in the examples that some types are not recommended for use in final code.\r\n\r\nSome of what I did find:\r\n \r\n- sdk: Debug Logger: https://devzone.nordicsemi.com/documentation/nrf51/6.1.0/s110/html/a00683.html#details\r\n\r\n- sdk: UART Setup: https://devzone.nordicsemi.com/documentation/nrf51/6.1.0/s110/html/a00009.html\r\n\r\n- devzone 1588: https://devzone.nordicsemi.com/question/1588/can-nordic-please-document-how-to-debug-code-on-their-processors/\r\n\r\n- devzone 1489: https://devzone.nordicsemi.com/question/1489/can-i-debug-ble-program/\r\n\r\n- devzone 12397: https://devzone.nordicsemi.com/question/12397/how-to-get-line-no-and-file-name-using-ble_debug_assert_handler-while-debugging-application/\r\n\r\n===== details of many debug paths mentioned in docs and examples =====\r\n\r\n* ***This has several parts, any answers or links appreciated but please indicate the item number you are referring to so as to help all readers.***\r\n\r\n1) There seem to be several debug and diagnostic ports in the nRF51822-EK and nRF51822-DK:\r\n\r\n1a) Dongle PCA10000 includes both SWDIO and UART between nRF51822 and Segger IC, providing support for onboard debugging through SWDIO (Breakpoints, etc.) and UART (serial data as with a Terminal), as well as BLE communications to EK and DK.\r\n\r\n1b) nRF51822-EK PCA10001 also includes both SWDIO and UART between nRF51822 and Segger IC.\r\n\r\n1c) nRF51822-DK (set: PCA10004 + nRF6310 + Jlink_Light + dongle) also includes both SWDIO and UART between nRF51822 and [either Segger IC or nRF6310].\r\n\r\n1d) Possibly more Debug options by software and tools using virtual ports? \r\n\r\n\r\n2) PCA10001 nRF51822 EK\r\n\r\n2a) I can step code in Keil, and both nRFgo Studio can program OK, although I'm uncertain which ports are used for which features I believe the SWDIO is used for programming and stepping code.\r\n\r\n2b) I haven't had reliable connection using the Segger UART to a Terminal Program. I get binary gibberish with PuTTY set to EK's Segger Com \r\n\r\nPort (Com5 for me), 38400, CTS/RTS. Once I did get the \"Start:\" but it followed with gibberish. I got nothing with RealTerm or TeraTerm. I'm using Win8 64bit.\r\n\r\n2c) MCP may be connecting through the Dongle-UART-SeggerVirtualCom to show info of device that is \"ble-connected\" to the dongle?\r\n\r\n2d) Dongle ble_uart (segger vitual comm) may also be used somehow?\r\n\r\n2e) Smartphone App nRF UART 2.0 may be supported by some examples (I see some output to smartphone, but input from smartphone not doing much yet).\r\n\r\n2f) Which path used for over air upgrade of firmware (sd, application, ...), and is there an app that supports this?\r\n\r\n\r\n3) Not sure if nRF51822-DK (PCA10004 DK + nRF6310 + Jlink_Light) has same or more paths than nRF51822-EK?\r\n\r\n\r\n===== So... =====\r\n \r\n4) Which communication paths are used for what kind of debugging (EK-SWDIO, EK-UART-P0.8~P0.11-SeggerVirtualCom, ble-Donglev220-SWDIO, ble-DongleV220-UART-P0.8~P0.11, nRF6310_???, other?). \r\n\r\n4a) Which paths are available for users to code in C to a simple terminal or nRF UART 2.0, versus which match to a Tool? \r\n\r\n4a1) I expect these to be user friendly and bidirectional: [uart_SeggerVirtualCom to Terminal] and [ble_uart to the UART2.0 App].\r\n\r\n4a2) Some are reserved for Keil/nRFgoStudio/MCP/nRFTools/Apps\r\n\r\n4a3) Maybe some can be enabled for display in Keil/nRFgoStudio/MCP/nRFTools/Apps?\r\n\r\n4b) Some I found in various examples:\r\n\r\n4b1) ble_app_hrs: main.c: app_error_handler()\r\n\r\n4b2) ble_app_hrs: app_trace.h: ENABLE_DEBUG_LOG_SUPPORT\r\n\r\n4b3) I see mention of \"nrf assert\", \"debug assert\", and \"softdevice assert\" but am unclear how to use or what tool they each work with (Keil/nRFgoStudio/other/..), or maybe you have to code to light a LED or set a GPIO, and code to put data in a memory block for examination, or dump by simple uart?\r\n\r\n5) Which examples should have working debug (uart or other)? It seems only partly implented in some examples.\r\n\r\n5a) OK: \\nrf51_sdk_v6_1_0_b2ec2e6\\nrf51822\\Board\\pca10001\\uart_example (sdk610, erase s110) \r\n\r\nIn the Default build I see on PuTTY or TeraTerm the \"Start:\" and get good echo of typing from simple_uart_get() and simple_uart_get().\r\n\r\n5b) Incomplete: \\nrf51_sdk_v6_1_0_b2ec2e6\\nrf51822\\Board\\pca10001\\s110\\ble_app_hrs (load s110)\r\n\r\n5b1) This example seems to have partly coded debug on uart(SeggerVirtualCom)? When I enable ENABLE_DEBUG_LOG_SUPPORT I don't see any output \r\n\r\nfrom uart. When I comment out (//#define DM_DISABLE_LOGS) I get a compile error.\r\n\r\n5b2) Only enabling ENABLE_DEBUG_LOG_SUPPORT, putting app_trace_init() at beginning of main(), and putting an app_trace_log(\"+\") in the main loop I can see two cycles for each HRM BLE update when App connected [nRF Toolbox - HRM]. \r\n\r\n5c) Unclear: \\nrf51_sdk_v6_0_0_43681\\nrf51822\\Board\\pca10001\\s110\\experimental\\ble_app_uart (sdk600, load s110v71)\r\n\r\nThis appears to give output on ble_uart to the App [nRF UART 2.0] and App [nRF Toolbox - UART], but I'm not sure its processing any typing input from App.\r\n\r\n\r\n6) I tried these Terminal Packages: (I tested with: Win8-64bit, s110v7.1.0, and SDK6.1.0)\r\n\r\n- Using [nRF51822 UART P0.8~P0.11 == SeggerVirtualCom]\r\n\r\n6a) PuTTY 0.63 works (see 5a and 5b2), connection-serial [Com*,38400bps, 8, 1, none, CTS-RTS], See: http://www.putty.org/ and \r\n\r\nhttp://www.ehow.com/how_8733462_use-putty-serial-connection.html\r\n\r\n6c) TeraTerm 4.8.4 works (5b2), Setup-Serial [38400, 8, none, 1, Hardware, 0, 0], http://en.sourceforge.jp/projects/ttssh2/releases/\r\n\r\n6b) RealTerm 2.0.0.70 displays garbage (Fails 5b2), http://www.softpedia.com/get/System/System-Miscellaneous/RealTerm.shtml\r\n\r\n7) Are there any compatibility issues with the different types of debug and BLE or certain tools or Apps?\r\n\r\n7a) i.e. If fast BLE then slow uart may delay BLE, or uart comms may be truncated by BLE actions?\r\n\r\n7b) Which will work even with SoftDevice(s110v7.1.0)? \r\n\r\n8) Note: Describing debug types and usage might all be more appropriate in a Blog, with clear naming for each data path type to avoid confusion, such as: hw_segger_uart (terminal), hw_segger_swdio (keil?, nRFgoStudio?), hw_ble (MCP?, App?),  dongle_ble_uart (??), dongle_ble_swdio (??), app_ble, app_uart, ...\r\n\r\n9) A list of which debug types shouldn't be used in final production code (i.e. only suitable for development and temporary testing), some of this is in example comments but that can be easily missed as code grows and passed to different developers (wishing for good code review practices).\r\n\r\n10) (Personally I like the DAC trace method I saw in a magazine article: If you have a true DAC (not PWM) then at any point in code program a level and you can watch on a scope the code running and see normal patterns and unusual events in real time, no comms slowdown).\r\n\r\n===========",
    "tag": "uart"
  },
  {
    "text": "spi_master vs spi_master_5w? Folks,\r\n\r\nIn the latest SDK (6.1) for the nRF51822 I see two versions of SPI master code in the Source folder and examples: with and without \"5W\" appended to the filename.\r\n\r\nLooks like the 5W version has more features (and complexity) and is designed for \"serialization\", I.e., the ability to put to sleep and awaken a running device state.  Is that the correct interpretation?  Is the 5W version ready for use (or just an intermediate development version)?\r\n\r\nIn either case, the SDK 6.1 online docs seem confused as to version.  I would appreciate some advice on which version to use and documentation on same.\r\n\r\nAlso, looks like the (non-5W version of the) SPI Master driver assumes chip select is active low.  I have a device that's active high and I can modify your driver code, but would prefer not to do that.  How about adding chip select high vs. low to the configuration params for the SPI open call?\r\n\r\nThanks,\r\n\r\nMike\r\n",
    "tag": "spi"
  },
  {
    "text": "I2C interrupt while softdevice enabled Hello, \r\n\r\ni'm sorry for asking again, but i read nearly all threads about I2C and didn't get any answer yet. \r\n\r\nI want to use the interrupt to control the I2C sequences and safe energy (instead of using while loops) \r\n\r\nI replaced the NRF_TWI1->INTENSET.... with sd_app function below...\r\nIf i start a transmition it never goes into the handler or generates an event. can anybody tell me why?\r\n\r\nIs the NVIC_ENABLEIRQ right to use? in the end i have the usual handler.\r\n\r\n\r\n    \tvoid init_TWI1()\r\n\t{\r\n\t\t//I2C Init start\r\n\tuint32_t err_code;\r\n\tNVIC_EnableIRQ(SPI1_TWI1_IRQn);\r\n \tNRF_GPIO->PIN_CNF[1] = 0x60C;\r\n\tNRF_TWI1->PSELSCL = 0;\t//P0 als SCL\r\n\tNRF_TWI1->PSELSDA = 1;\t//P1 als SDA      \r\n\tNRF_TWI1->FREQUENCY = 0x06680000;\t//Frequenz = 400kHz\r\n\t\r\n\terr_code = sd_ppi_channel_assign(0,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&(NRF_TWI1->EVENTS_BB),\r\n                                     &(NRF_TWI1->EVENTS_TXDSENT));\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t//I2C init end\r\n\t}\r\n\r\n\r\n\r\n    \tvoid SPI1_TWI1_IRQHandler(void) \r\n\t{\r\n\t\tif(NRF_TWI1->EVENTS_RXDREADY != 0)\r\n\t\t{\r\n\t\t\tNRF_TWI1->EVENTS_RXDREADY = 0;\r\n\t\t}\r\n\t\t\tif(NRF_TWI1->EVENTS_TXDSENT != 0)\r\n\t\t{\r\n\t\t\tNRF_TWI1->EVENTS_TXDSENT = 0;\r\n\t\t}\r\n\t\t\tif(NRF_TWI1->EVENTS_BB != 0)\r\n\t\t{\r\n\t\t\tsd_app_evt_wait();\r\n\t\t\tNRF_TWI1->EVENTS_BB = 0;\r\n\t\t}\r\n\t\r\n\t}\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "TWI ignore ACK/NACK bit Hi, I am trying to control an Omnivision Camera module using the nRF51822 EK. The module uses their proprietary SCCB protocol, which is very similar to I2C. However, there is a key difference that the SCCB protocol does not require the slave to send ACK/NACK after transmission. If i were to use Nordic's TWI HW for this, is there a way to ignore the ACK/NACK condition and have the TWI HW keep transmitting even without those? \r\n\r\nThe full SCCB spec is here: http://www.ovt.com/download_document.php?type=document&DID=63",
    "tag": "twi"
  },
  {
    "text": "(nrf51822-EK) How to read twi Multiple Byte ? Hi.\r\n\r\nMy board : nrf51822 -Evaluation Kit ------ mma8452q\r\nproblem : read_registers(MMA8452_ADDRESS << 1,OUT_X_MSB, 6, rawData);\r\nsource code : [link text](https://github.com/wansik/nrf51822_mma8452q)\r\n\r\n\r\nmain.c\r\n-> readAccelData-> read_registers\r\n-> twi_master_transfer(device_address | TWI_READ_BIT, value, size, TWI_ISSUE_STOP);\r\n\r\nI can read Single Byte.\r\nI can write Single Byte.\r\n\r\nBut I can't read Multiple Byte.\r\n\r\nHow to read Multiple Byte?\r\n\r\nCould you give me some tips?\r\nHow to solve this problem..?\r\n",
    "tag": "twi"
  },
  {
    "text": "(nrf51822-EK) How to read twi Multiple Byte ? Hi.\r\n\r\nMy board : nrf51822 -Evaluation Kit ------ mma8452q\r\nproblem : read_registers(MMA8452_ADDRESS << 1,OUT_X_MSB, 6, rawData);\r\nsource code : [link text](https://github.com/wansik/nrf51822_mma8452q)\r\n\r\n\r\nmain.c\r\n-> readAccelData-> read_registers\r\n-> twi_master_transfer(device_address | TWI_READ_BIT, value, size, TWI_ISSUE_STOP);\r\n\r\nI can read Single Byte.\r\nI can write Single Byte.\r\n\r\nBut I can't read Multiple Byte.\r\n\r\nHow to read Multiple Byte?\r\n\r\nCould you give me some tips?\r\nHow to solve this problem..?\r\n",
    "tag": "i2c"
  },
  {
    "text": "TWI Clock Line Causing Bad Writes I'm using the nrf51822 TWI library. I've tried both twi hardware and software master library files and see the same behavior when using both (as a side note an explanation of the difference would be helpful.) I have 3 I2C chips wired to the NRF51822 all with distinct addresses that are wired according to their datasheets. I am reading the SCL/SDA lines with a logic analyzer and I am occasionally seeing an issue that causes bad writes. I've included a screenshot of the analyzer output. \r\n\r\nThis shows 2 one-byte writes, the first one to address 30 is correct. The device has write address 0x30, I am writing to register 0x33, and the value being written is 0x32. However, the next write should be a write to device address 0x30, register 0x30 with value 0x95, however that is not what is happening. It looks to me like the clock line is very briefly going low at the same time as the data line goes low (where I circled in red). As far as I can see with the resolution of the analyzer, the high-to-low edge on SCL and SDA occur at the same time. \r\n\r\n(if you right click on the image and download it, you can see the details more clearly)\r\n\r\n![image description](/attachment/1162b2357dd09708a22a2ee1965d5687)\r\n\r\nThis issue does not always occur at one place. Sometimes I don't see it, and when I do it's not always on the same write. I've tried putting in long delays between each write to make sure that the slave has finished the write, but that didn't make any difference. I also have seen it on more than one of the three slave devices. Finally, I will also mention that the SCL and SDA lines both have 10K pullup resistors to the NRF51822's VCC rail.\r\n\r\nI'm not very experienced using I2C so I've hit a wall debugging this. It doesn't seem like a code issue on the NRF51822, which leads me to think that it might be a wiring issue, but there isn't much I could change other than maybe the pull-up resistor values. \r\n\r\nAny help or suggestions will be greatly appreciated!  ",
    "tag": "i2c"
  },
  {
    "text": "TWI Clock Line Causing Bad Writes I'm using the nrf51822 TWI library. I've tried both twi hardware and software master library files and see the same behavior when using both (as a side note an explanation of the difference would be helpful.) I have 3 I2C chips wired to the NRF51822 all with distinct addresses that are wired according to their datasheets. I am reading the SCL/SDA lines with a logic analyzer and I am occasionally seeing an issue that causes bad writes. I've included a screenshot of the analyzer output. \r\n\r\nThis shows 2 one-byte writes, the first one to address 30 is correct. The device has write address 0x30, I am writing to register 0x33, and the value being written is 0x32. However, the next write should be a write to device address 0x30, register 0x30 with value 0x95, however that is not what is happening. It looks to me like the clock line is very briefly going low at the same time as the data line goes low (where I circled in red). As far as I can see with the resolution of the analyzer, the high-to-low edge on SCL and SDA occur at the same time. \r\n\r\n(if you right click on the image and download it, you can see the details more clearly)\r\n\r\n![image description](/attachment/1162b2357dd09708a22a2ee1965d5687)\r\n\r\nThis issue does not always occur at one place. Sometimes I don't see it, and when I do it's not always on the same write. I've tried putting in long delays between each write to make sure that the slave has finished the write, but that didn't make any difference. I also have seen it on more than one of the three slave devices. Finally, I will also mention that the SCL and SDA lines both have 10K pullup resistors to the NRF51822's VCC rail.\r\n\r\nI'm not very experienced using I2C so I've hit a wall debugging this. It doesn't seem like a code issue on the NRF51822, which leads me to think that it might be a wiring issue, but there isn't much I could change other than maybe the pull-up resistor values. \r\n\r\nAny help or suggestions will be greatly appreciated!  ",
    "tag": "twi"
  },
  {
    "text": "ble_nus service on beacon pca20006 with SD s110 I compiled a new HEX for the pca20006 Beacon based on the ble_app_uart project for the pca10001 (remapped the LEDs and buttons), but when I load the beacon using OTA DFU, it will not advertise. It will only very faintly flicker the red LED about 2-3 times per second. What could it be doing?\r\n\r\nI want my beacon app to merely Tx a fixed string whenever it Rx a certain sting over the BLE UART, but right now it is just trying to init the service and start advertising to no avail...\r\n\r\nEventually I want the beacon (or perhaps a custom made nRF51822 board about the same size) to perform some GPIO and SPI interconnect to another small custom board, then receive and transmit to the pca10001 attached to a PC visible to an off-the-shelf windows app as a generic COM port...\r\n\r\nI am kind of stuck right now, any suggestions?\r\n",
    "tag": "uart"
  },
  {
    "text": "ble_nus service UART on PCA20006 Beacon with s110 SD I compiled a new HEX for the pca20006 Beacon based on the ble_app_uart project for the pca10001 (remapped the LEDs and buttons), but when I load the beacon using OTA DFU, it will not advertise. It will only very faintly flicker the red LED about 2-3 times per second. What could it be doing?\r\n\r\nI want my beacon app to merely Tx a fixed string whenever it Rx a certain sting over the BLE UART, but right now it is just trying to init the service and start advertising to no avail...\r\n\r\nEventually I want the beacon (or perhaps a custom made nRF51822 board about the same size) to perform some GPIO and SPI interconnect to another small custom board, then receive and transmit to the pca10001 attached to a PC visible to an off-the-shelf windows app as a generic COM port...\r\n\r\nI am kind of stuck right now, any suggestions?\r\n",
    "tag": "uart"
  },
  {
    "text": "adc: is there a way to get the VBG out of the nrf? Hi,\r\n\r\nis there a way to get the VBG reference voltage out of the nrf51822?\r\nwe want to drive a very low current with it.\r\n\r\nThank you.\r\nRichard",
    "tag": "adc"
  },
  {
    "text": "3-wire SPI interface I am trying to connect an accelerometer to my board.  Unfortunately I only have enough GPIO's available to configure for a 3-wire SPI interface.  However I can't find any information on how to configure the nRF51822 for a 3-wire SPI interface,  or how it should be wired.  Can anyone help?\r\n\r\nThanks guys",
    "tag": "spi"
  },
  {
    "text": "Twi problem. How to read data(not include ACK)? Hi.\r\n\r\nMy board : nrf51822 -Evaluation Kit ------ mma8452q \r\n\r\nproblem : read_registers(MMA8452_ADDRESS << 1,OUT_X_MSB, 6, rawData);\r\n\r\nsource code : [link text](https://github.com/wansik/nrf51822_mma8452q)\r\n\r\n\r\nmain.c -> readAccelData -> read_registers \r\n\r\n-> twi_master_transfer(device_address | TWI_READ_BIT, value, size, TWI_ISSUE_STOP);\r\n\r\n\r\nI can read Single Byte.\r\nI can write Single Byte.\r\n\r\nBut I can't read Multiple Byte.\r\n\r\nMMA8452Q DataSheet\r\n[MMA8452Q.pdf](/attachment/91d52d5be28fa35367c2e382bb8619a0)\r\n\r\nMultiple Byte Read\r\n\r\nMaster:--------ACK------ACK------ACK...\r\n\r\nSlave:ACK:Data---Data----Data---...\r\n\r\n\r\n    // MSB first\r\n    for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    {\r\n        if (!twi_master_wait_while_scl_low())\r\n        {\r\n            transfer_succeeded = false;\r\n            break;\r\n        }\r\n\r\n        if (TWI_SDA_READ())//ACK Receive\r\n        {\r\n            byte_read |= i;\r\n        }\r\n        else\r\n        {\r\n            // No need to do anything\r\n        }\r\n\r\n        TWI_SCL_LOW();\r\n        TWI_DELAY();\r\n    }\r\n\r\nI guess...\r\n\r\nThis code read (ACK:Data).\r\n\r\nBut can't read (Data).\r\n\r\n\r\nHow to read Data(not include ACK)?\r\n\r\nCould you give me some tips? How to solve this problem..?",
    "tag": "twi"
  },
  {
    "text": "Twi problem. How to read data(not include ACK)? Hi.\r\n\r\nMy board : nrf51822 -Evaluation Kit ------ mma8452q \r\n\r\nproblem : read_registers(MMA8452_ADDRESS << 1,OUT_X_MSB, 6, rawData);\r\n\r\nsource code : [link text](https://github.com/wansik/nrf51822_mma8452q)\r\n\r\n\r\nmain.c -> readAccelData -> read_registers \r\n\r\n-> twi_master_transfer(device_address | TWI_READ_BIT, value, size, TWI_ISSUE_STOP);\r\n\r\n\r\nI can read Single Byte.\r\nI can write Single Byte.\r\n\r\nBut I can't read Multiple Byte.\r\n\r\nMMA8452Q DataSheet\r\n[MMA8452Q.pdf](/attachment/91d52d5be28fa35367c2e382bb8619a0)\r\n\r\nMultiple Byte Read\r\n\r\nMaster:--------ACK------ACK------ACK...\r\n\r\nSlave:ACK:Data---Data----Data---...\r\n\r\n\r\n    // MSB first\r\n    for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    {\r\n        if (!twi_master_wait_while_scl_low())\r\n        {\r\n            transfer_succeeded = false;\r\n            break;\r\n        }\r\n\r\n        if (TWI_SDA_READ())//ACK Receive\r\n        {\r\n            byte_read |= i;\r\n        }\r\n        else\r\n        {\r\n            // No need to do anything\r\n        }\r\n\r\n        TWI_SCL_LOW();\r\n        TWI_DELAY();\r\n    }\r\n\r\nI guess...\r\n\r\nThis code read (ACK:Data).\r\n\r\nBut can't read (Data).\r\n\r\n\r\nHow to read Data(not include ACK)?\r\n\r\nCould you give me some tips? How to solve this problem..?",
    "tag": "i2c"
  },
  {
    "text": "Time from power on to connect with master / slave Hello,\r\nI am new to nRF51822, and trying to make a simple application for master - slave data transfer.\r\nI want to know how Much time passes from the start of the device until the connection to the master \\ slave.\r\n\r\nWhat are possible solutions to this issue?\r\nMaybe measure the time until a breakpoint is reached in debug mode or use some  api timer function? \r\n\r\n\r\nP.S. sry for any mistakes, english isn't my native language ",
    "tag": "timer"
  },
  {
    "text": "sd_mutex and \"App High\" interrupt priority example I am looking for some guidance and an example on how to use the sd_mutex related functions.\r\nSo far, I keep getting into the HardFault_Handler whenever I call sd_mutex_acquire.\r\n\r\nI'm pretty sure this has something to do with the main/interrupt/event thread context that I am calling from (main), but I can't seem to find a good description of the rules for calling these apis. I do see a short section in the reference manual appendix (quoted below) but it doesn't really make sense to me since it seems to suggest that I should be able to call the api from any interrupt level (including main) that is lower than the SOFTDEVICE's UpperStack interrupt priority (2). Thus, I would think that I should be able to call from MAIN or Application Low (3) priorities.\r\n\r\nIs there any documentation that describes these rules better than the following brief description in the reference manual appendix?:\r\n\r\n\"SVC calls are conceptually software triggered interrupts with a procedure call standard for parameter passing and return values. Each API call generates an interrupt allowing single-thread API context and SoftDevice function locations to be independent from the application perspective at compile-time. SoftDevice API functions can only be called from lower interrupt priority when compared to the SVC priority. See the Exception (interrupt) management with a SoftDevice section on page 190.\"\r\n\r\nAlso, on a somewhat related topic, I would be very interested in seeing an example that uses Application High (P1) interrupt priority since I am having a lot of issues dealing with interrupt latency when the SOFTDEVICE is enabled.\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Use a GPIO in input and output to generate signals internally to peripherals Hello ,\r\n\r\nAs mentioned in another question, I would like to use the nrf51822 SPI slave peripheral to benefit from the DMA capability although I want to behave as an SPI master.\r\n\r\nTo do this, I would like to control the SPI_SS manually and the SPI_SCLK using timers and PPI and then route these GPIOs back into the SPI slave HW.  \r\n\r\nUnfortunately, I do not have these loopback wired externally and I would like to route them directly inside the pads so I do not need to change the current board layout.  \r\n\r\nHow can I do this?\r\n\r\nThanks  ",
    "tag": "spi"
  },
  {
    "text": "nrf51822 timers as counter max speed Hi,\r\n\r\nDoes anyone known what the maximum frequency is that the timers can operate on ?\r\nI want to count a signal that is 24Mhz while the clock frequency  is only 16Mhz.\r\nSo if the PPI interface is clocked it will probably not work.\r\n\r\nThanks in advance for you help.\r\n\r\nBest Regards,\r\nMarc",
    "tag": "timer"
  },
  {
    "text": "SPI SLave MISO High until buffers set I am working with the nRF51822 S110 and having trouble implementing SPI. In other devices' SPI protocols, MISO can be held high until the device is ready to transmit data. I want to bring MISO high and then set it low once the SPI_SLAVE_BUFFERS_SET_DONE event occurs. Is this possible?\r\n\r\nThe reason I want this behavior is simple. I will send a one byte \"command\" from the Master indicating I want to read my buffer. The nRF51822 SPI Slave will respond with the number of bytes that can be read, and then the Master will force clock those bytes into its buffer. I believe I am having problems with synchronicity in the system.\r\n\r\nI have no way of knowing when the nRF is ready to transmit its data and thus have to resort to arbitrary delays in my SPI Master firmware. I have no GPIOs tied between the two MCUs that could be used for indicating ready data.\r\n\r\nI noticed the below SPI Slave code and was hopeful that one of the configurations would solve my issue, but none are what I need. Is my only solution to try and disable the SPI Slave module to manually set the MISO line high and then reenable SPI once the buffers are set? Am I overcomplicating this and is there a simpler approach. I am definitely open to other, better ways of doing this and any feedback is appreciated.\r\n\r\nThanks.\r\n\r\n    /* Bits 10..8 : Drive configuration. */\r\n    #define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */\r\n    #define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */\r\n    #define GPIO_PIN_CNF_DRIVE_S0S1 (0x00UL) /*!< Standard '0', Standard '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_H0S1 (0x01UL) /*!< High '0', Standard '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_S0H1 (0x02UL) /*!< Standard '0', High '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_H0H1 (0x03UL) /*!< High '0', High '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_D0S1 (0x04UL) /*!< Disconnected '0', Standard '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_D0H1 (0x05UL) /*!< Disconnected '0', High '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_S0D1 (0x06UL) /*!< Standard '0', Disconnected '1'. */\r\n    #define GPIO_PIN_CNF_DRIVE_H0D1 (0x07UL) /*!< High '0', Disconnected '1'. */\r\n\r\n    void spi_slave_set_drive_config(uint32_t alternate_config)\r\n    {\r\n        m_drive_config = alternate_config;\r\n        return;\r\n    }\r\n\r\n\r\n    uint32_t spi_slave_init(const spi_slave_config_t * p_spi_slave_config){\r\n        uint32_t err_code;\r\n        uint32_t spi_mode_mask;\r\n        \r\n        if (p_spi_slave_config == NULL)\r\n        {\r\n            return NRF_ERROR_NULL;\r\n        }\r\n    \r\n        // Configure the SPI pins for input.\r\n        NRF_GPIO->PIN_CNF[p_spi_slave_config->pin_miso] = \r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos) |\r\n            (m_drive_config << GPIO_PIN_CNF_DRIVE_Pos)              |\r\n            (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)   |\r\n            (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)  |\r\n            (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);",
    "tag": "spi"
  },
  {
    "text": "programing and interrupts on custom PCB using nrf51822 Hey,\r\n\r\nI am designing a custom PCB with the nrf51822. I would like to use the reference layout that Nordic provides, specifically nrf51x22_qfaa. My project involves reading an accelerometer and gyroscope via TWI and transmitting certain measurements via BLE. I am designing this PCB in Altium Designer and I am using the reference files Nordic provides and footprints from their libraries. \r\n\r\nI'd really appreciate it if any of you could help me clear up a few things:\r\n\r\n1.) To program the chip on my custom PCB I am planning on including in my design the same 10 pin SWD header Nordic uses for the development boards with J-Link. Currently I am connecting SWDIO and SWCLK directly to the chip with a 12k pulldown resistor on SWCLK. Is this ideal? I'm confused about nrf_RST.\r\n\r\n2.) When I connect my accelerometer and gyroscope to the nrf51822 via TWI can I use any GPIO pins I want? I am planning on connecting SCLK and SDA to GPIO pins 8 and 9 and then connecting interrupts to GPIO pins 10-13. I also need to be able to wakeup on interrupts. (I think I remember seeing something in the user guide about restrictions on these pins when Softdevice is enabled but cant find it). Also I am planning on not including any external resistors and just using the internal pull ups. Is this advisable?\r\n\r\nAre there any other suggestions you have given the nature of my project? I'm a student and this is the first PCB I've designed. \r\n\r\nThanks for the help!\r\n",
    "tag": "twi"
  },
  {
    "text": "GPIOTE Task Handler - Sense Output Hi,\r\n\r\nI am using TIMER2, GPIOTE and PPI to implement a 6250Hz square wave at a GPIO pin. I can successfully create the square wave on the GPIO pin. However, I would like to be able to sense when this GPIO pin goes high after the GPIOTE peripheral has set it high. Is there any way of doing this? I know it is possible to sense an input pin and use the GPIOTE_IRQHandler. I am wondering if I can use the GPIOTE_IRQHandler when the output GPIO is set high by the GPIOTE peripheral?\r\n\r\nMany Thanks\r\n\r\nJack",
    "tag": "timer"
  },
  {
    "text": "realtime interrupt with 50us processing possible with s110? I have a situation where I need a software PWM for several channels, which are multiplexed via a shift register.\r\n\r\nThe output loop needs to run at several kHz for this to work, but the processing only takes about 50us, which at about 8kHz puts it at a little below 50% processor use.\r\n\r\nCan the softdevice be interrupted in this manner without breaking it, if I switch interrupt priorities? If I don't have the timer at highest priority, the softdevice interrupts for sometimes several ms, which means I lose at least 10s of cycles in the PWM, which is quite undesirable for the application.",
    "tag": "interrupt"
  },
  {
    "text": "How to use WFE reliably? After reading the fine-print regarding WFE, I came to the conclusion that WFE can send the CPU to sleep even if interrupts are still pending. Such interrupts would *not* be able then to wake the CPU. In order to wake the CPU the interrupt has to occur *while* the CPU is sleeping. Is this correct?\r\nIn my case I want to wake the CPU with a key press (via the GPIOTE PORT event), so I wonder if sleeping like this\r\n\r\n    if (!NVIC_GetPendingIRQ(GPIOTE_IRQn))\r\n      __wfe();\r\n\r\nwould allow the CPU to reliably wake up via the GPIOTE_IRQn interrupt (if GPIOTE_IRQn was not pending and thus the CPU was actually sent to sleep)? In other words, could a GPIOTE_IRQn interrupt occur right after having checked the interrupt pending flag but before or while executing WPE so that the CPU would still fall asleep and not wake up from this interrupt? I know that this would be a very rare case as the time span between NVIC_GetPendingIRQ() and __wpe() is so short, but if it happened it would render my device unresponsive.\r\n",
    "tag": "interrupt"
  },
  {
    "text": "How to calibrate the nRF51 ADC to correct offset and gain error According to the nRF51822 PS v3.1, table 51, offset error for the internal ADC is up to 2% and the gain error can be up to 2%. Is it possible to correct this error to obtain better accuracy for the ADC?\r\n",
    "tag": "adc"
  },
  {
    "text": "Softdevice error in ll_lm.s0.c:404 I've seeing random crashes at that originate from ll_lm.s0.c:404. It seems to be happening when I have uart logging turned off. I don't think i've seen assert callback called when logging is on. I'm using nrf51422 with s310. Any insights would help.",
    "tag": "uart"
  },
  {
    "text": "twi generating events while tx-send Hello, \r\n\r\nto reduce ernergy consumption i use the sd_app_evt_wait() function while the twi is sending or receiving data. \r\n\r\ni set nrf_twi->address and nrf_twi->txd and set tasks starttx to 1. the controller then sends automatically the address and the first txd, after each time the interrupt occurs, i chage txd to the next value. \r\n\r\nIs the controller generating two events in the beginning (one ofr the address and one for the first byte?) \r\ni cant really see it in debug mode, im sorry for that. \r\n\r\nMatthias\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "twi generating events while tx-send Hello, \r\n\r\nto reduce ernergy consumption i use the sd_app_evt_wait() function while the twi is sending or receiving data. \r\n\r\ni set nrf_twi->address and nrf_twi->txd and set tasks starttx to 1. the controller then sends automatically the address and the first txd, after each time the interrupt occurs, i chage txd to the next value. \r\n\r\nIs the controller generating two events in the beginning (one ofr the address and one for the first byte?) \r\ni cant really see it in debug mode, im sorry for that. \r\n\r\nMatthias\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "nRF UART Android App [Feature Request & a Question] Hi Nordic,\r\n\r\nI am a hardware/firmware guy without App development skills and I also lack the time to acquire these skills. I enjoyed your UART App during my development, thanks a lot for providing many useful example apps. \r\nHowever, I require currently an extra feature regarding the nRF UART App. Can you please add the possibility to send and receive raw hex data? Using ASCII encoding brings limitations and overhead for some applications, as you may guess. \r\nQuestion:\r\nIf I define a simple communication protocol over BLE UART with a very simple packet structure, should I implement a kind of simple CRC/CheckSum mechanism or can I securely assume that the BLE protocol (Nordic UART Service) will provide me only the valid uncorrupted data?\r\n\r\nKind regards...\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "UART debug logging Hello,\r\n\r\nI know that this question has been asked a few times, but I am a little desperate after trying to get debug logging over the Virtual COM Port to work. Here are the steps that I did:\r\n- I got myself a nRF51 USB Dongle (pca10031 board with nRF51422_xxAC chipset)\r\n- I configured a new Project in Keil with all the necessarey libraries and a 120 Soft Device\r\n- I wrote a main.c that toggles the onboard LED in an infinite loop and calls printf after each loop.\r\n- I called app_trace_init() at the beginning to set up the debug UART connection\r\n\r\nFrom looking at the app_trace_init function I gathered, that the Baud rate is 115200, as opposed to the Baud rate stated in the documentation (38400). I think that flow control is hardware? (UART_FLOW_CONTROL_ENABLED).\r\n\r\nI configured Putty to use 8 data bits, 1 stop bit, and varied all other parameters but to no avail. I can only get garbage characters, but at least the length seems to be similar to the string that I am trying to trace.\r\n\r\nCould you please point me in the right direction?\r\n\r\nThanks,\r\nMarius Heil",
    "tag": "uart"
  },
  {
    "text": "SPI Sensor Application Using nRF51-DK Hi all,\r\n\r\nFirst of all, I'd like to express how pleased I am using this development kit. The easiest ever to start with, well documented and most importantly I can use the 32kB version of uVision and not to worry about licensing. Thank you guys.\r\n\r\nHere I am seeking an advise that could help me to start with my design. I have a sensor, inclinometer, with SPI interface. My aim is to use DK and transmit X,Y registers to the mobile device. I tried almost all of the examples provided in SDK peripheral and ble_peripheral. So in order to succeed I guess I will need to implement some of the examples into a single design. \r\nI think about using an internal timer and read SPI data for example every 0.1s and modify a heart beat application just to receive raw data. However I am not sure whether it is the best approach, perhaps the UART example might be also good idea to receive serial data that could be seen on both PC and mobile device. All I need is X,Y coordinates on the phone so later on I can focus on building an application.\r\n\r\nCan you suggest how would you do that, what example to use? I built similar application using ZigBee previously but this is the first time I am using BLE. \r\n\r\nThanks for any ideas.\r\n\r\nMilan",
    "tag": "spi"
  },
  {
    "text": "Can I really not use LPCOMP and ADC at the same time? In the \"NRF51 Series Reference Manual\" (v3.0) it states:\r\n\r\n    The LPCOMP shares registers and other resources with peripherals that have the same ID as the LPCOMP.\r\n    You must disable all peripherals that have the same ID as the LPCOMP before the LPCOMP\r\n    can be configured and used. Disabling a peripheral that has the same ID as the LPCOMP will\r\n    not reset any of the registers that are shared with the LPCOMP. Therefore, it is important to\r\n    configure all relevant LPCOMP registers explicitly to secure that it operates correctly.\r\n\r\n    See the Instantiation table in Instantiation on page 17 for details on peripherals and their IDs.\r\n\r\n        Note: The LPCOMP is using the same analog pins as the ADC. The ADC must be disabled\r\n        before the LPCOMP can be enabled.\r\n\r\nAnd a bit before it states:\r\n\r\n    The selected analog pins will be acquired by the LPCOMP when it is enabled through the\r\n    ENABLE register.\r\n\r\nSo, from the documentation I see:\r\n\r\n- ADC and LPCOMP do not share the same ID. So that is not a reason to disable ADC...\r\n- Only selected analog pins will be acquired by LPCOMP, so we can use other pins for the ADC...\r\n- ADC must be disabled completely...\r\n\r\nWhat exactly is shared between LPCOMP and ADC? Is the mux for PSEL shared for example? Or can I only not use AIN0 when I use it already for ADC (which would be logical)? Or is it that I cannot do any LPCOMP stuff when I am doing ADC on a totally different pin?",
    "tag": "adc"
  },
  {
    "text": "Error after transmit complete event in SPI + SoftDevice enabled Hello,\r\n\r\nI am really new to using the Nordic nRF51822 and I'm having problems making SPI work with the S110 SoftDevice.  I was able to combine the sample codes spi_master_example and ble_app_hrs.  I created some custom service and wish to read some data from a sensor over SPI when a certain data is sent to the Nordic chip over the custom service.  All the BLE communication are working correctly, but once I send data over SPI to the sensor, the code gets stuck in the error handler.  Before the code jumps to the error handler, I can receive the SPI_MASTER_EVT_TRANSFER_COMPLETED event indicating that the SPI transfer was a success.  I can also see the data sent over SPI using an oscilloscope.  But after the transfer complete event, the BLE no longer works and the system just hangs within the error handler.\r\n\r\nI have tried reading everything about SPI in this forum, but I didn't find anything that can solve my problem.  Has anybody encountered this problem previously?  Any clues to solving it?\r\n\r\nIs there a good sample code for using the SPI master peripheral together with the S110 SoftDevice?  Most sample I found are for the I2C or UART.  A good working SPI + S110 SoftDevice sample code will help greatly.  \r\n\r\nI followed the following information from the link [https://devzone.nordicsemi.com/documentation/nrf51/6.0.0/s110/html/a00006.html](https://devzone.nordicsemi.com/documentation/nrf51/6.0.0/s110/html/a00006.html) to add the SPI support to the ble_app_hrs project.\r\n\r\n\r\nRegards,\r\n\r\nLeo",
    "tag": "spi"
  },
  {
    "text": "Debug UART with SDK 7.1 I just switched over from SDK v6 to SDK v7.1 (installed via those Keil Packs). The UART has suddenly stopped working (via Segger USB COM port) and I can no longer see any debug console output. It's just giving me garbage characters.\r\n\r\nI'm using the NRF51822 on the PCA10001 reference design.\r\n\r\nIs this a known issue? If I wanted to 'start over' in providing a console output, how would I go about enabling UART debug console output over the Segger COM port? I've already searched the forum and have been unable to resolve this.\r\n\r\nI also tried following the SDK instructions for Debug, but that didn't work either. http://developer.nordicsemi.com/nRF51_SDK/doc/7.0.1/s110/html/a00074.html\r\n\r\n38400 bps, 8N1, no parity, no flow control. Changed the bps to 115200, same settings, no change. No matter what settings I change I still get garbage characters.\r\n\r\nThanks.",
    "tag": "uart"
  },
  {
    "text": "troubles in 4 channels PWM signal generation Hello,\r\n\r\n  I try to generate 4 PWM signals on an nRF51 DK board, but I have two troubles :\r\n\r\n* in the \"Simple PWM\", during nrf_pwm_set_value() function the TIMER is stopped and  restarted, which will cause a glitch on the other channel too\r\n\r\n* I experience, that sometimes an event can be lost, which causes, that the pwm signal will change its polarity\r\nIf I see well, the 73. anomaly in nRF51822-PAN v3.0.pdf is in contact with this affect.\r\n\r\nI would be very thankful if somebody could help me.\r\n\r\nBest Regards\r\nGyorgy",
    "tag": "pwm"
  },
  {
    "text": "UART not working with sample experimental_ble_app_uart_s110_pca10028 Hi, \r\n\r\nAccess to the UART hangs the execution of the experimental_ble_app_uart_s110_pca10028 example.\r\nThe phenomen occures In the file simple_uart.c when checking for the state of EVENTS_RXDRDY:\r\n\r\n    uint8_t simple_uart_get(void)\r\n    {\r\n        // NEVER ENDING LOOP !\r\n        while (NRF_UART0->EVENTS_RXDRDY != 1)\r\n        {\r\n            // Wait for RXD data to be received\r\n        }\r\n        NRF_UART0->EVENTS_RXDRDY = 0;\r\n        return (uint8_t)NRF_UART0->RXD;\r\n    }",
    "tag": "uart"
  },
  {
    "text": "Interrupt service routine in \"spi_master_example\" Hi!\r\nI am using nRF51 SDK v6.10. I try to analysis the \"spi_master_example\". Source codes is \r\n\r\nworking well. But I couldn't understand how the \"spi_master_send_recv_irq()\" was calling \r\n\r\nwhen interrupt generated. I didn't see interrupt vector redirection \"SPI0_TWI0_IRQHandler\" \r\n\r\nto \"spi_master_send_recv_irq()\" in source codes.",
    "tag": "spi"
  },
  {
    "text": "Interrupt service routine in \"spi_master_example\" Hi!\r\nI am using nRF51 SDK v6.10. I try to analysis the \"spi_master_example\". Source codes is \r\n\r\nworking well. But I couldn't understand how the \"spi_master_send_recv_irq()\" was calling \r\n\r\nwhen interrupt generated. I didn't see interrupt vector redirection \"SPI0_TWI0_IRQHandler\" \r\n\r\nto \"spi_master_send_recv_irq()\" in source codes.",
    "tag": "interrupt"
  },
  {
    "text": "nRF51822 SPI isr not working Hello,\r\n\r\nI'm working on a custom board based on nRF51822, with keil 5.12 and a segger jlink. I'm trying to setup an SPI connection with the an accelerometer, starting from the spi_master_example of the 6.1 SDK. I simply adapted the SPI pinmap with my pin configuration and configured the spi_config with the correct values for the accelerometer.\r\n\r\nBy now, after the first send/receive call, the peripheral is always in busy state and SPI0_TWI0_IRQHandler is never called. Looking with the oscilloscope to the signals I found that, after the init of the peripheral, SCK and MISO are always high, while MOSI is always low.\r\n\r\nAnyone has an idea why it is not working properly or what I should check to have more details about what is wrong?\r\n\r\nThanks in advance for any help!\r\n\r\nUPDATE: in the board i tried to change the pin on which I drive the CLK and MOSI and all works fine. The question is CLK was on pin P0.02, while MOSI was on pin P0.01: can those pins be used to drive the SPI? In the Nordic reference manual the only requirements is that the pin have to be configured as GPIO and in the product specification those pins present also GPIO capabilities.\r\nAny idea on what could be (leaving out the accelerometer)?",
    "tag": "spi"
  },
  {
    "text": "nRF51822 SPI isr not working Hello,\r\n\r\nI'm working on a custom board based on nRF51822, with keil 5.12 and a segger jlink. I'm trying to setup an SPI connection with the an accelerometer, starting from the spi_master_example of the 6.1 SDK. I simply adapted the SPI pinmap with my pin configuration and configured the spi_config with the correct values for the accelerometer.\r\n\r\nBy now, after the first send/receive call, the peripheral is always in busy state and SPI0_TWI0_IRQHandler is never called. Looking with the oscilloscope to the signals I found that, after the init of the peripheral, SCK and MISO are always high, while MOSI is always low.\r\n\r\nAnyone has an idea why it is not working properly or what I should check to have more details about what is wrong?\r\n\r\nThanks in advance for any help!\r\n\r\nUPDATE: in the board i tried to change the pin on which I drive the CLK and MOSI and all works fine. The question is CLK was on pin P0.02, while MOSI was on pin P0.01: can those pins be used to drive the SPI? In the Nordic reference manual the only requirements is that the pin have to be configured as GPIO and in the product specification those pins present also GPIO capabilities.\r\nAny idea on what could be (leaving out the accelerometer)?",
    "tag": "interrupt"
  },
  {
    "text": "PWM glitch/duty inversion when rapidly changing duty cycle I need to create a backlight fade-in/out effect. For this I'm using the latest nrf_pwm lib form [here](https://github.com/NordicSemiconductor/nrf51-pwm-library) together with the S110 Softdevice. Using the scheduler and an application timer I'm updating every ~31.25ms the duty cycle using nrf_pwm_set_value() in order to create the fade effect. This basically works, however once in a while during a fade I'm seeing glitches and often the duty cycle seems to get inverted and screws up the fading.\r\n\r\nSearching this forum I came along these questions that seem to address the same issue, but I still don't know how to solve this problem:\r\n[Question](https://devzone.nordicsemi.com/question/16053/inverted-pwm-output-problem-when-changing-cc-nrf-timer-register/),[Qeustion](https://devzone.nordicsemi.com/question/15638/nrf_pwm-signal-glitches-flickering-on-nrf_pwm_set_value/),[Question](https://devzone.nordicsemi.com/question/6977/pwm-duty-cycle-update-best-practices/)\r\n\r\nI then tried using the functions provided in nrf_pwm_noglitch.h (also from [here](https://github.com/NordicSemiconductor/nrf51-pwm-library)). Here the problem with that appears that it doesn't update the duty cycly with every call to nrf_pwm_set_value() and the resulting fade isn't looking smooth anymore.\r\n\r\nI need some hints how to solve this problem or what I'm doing wrong ...\r\n\r\nThis how I'm initializing the pwm lib:\r\n\r\n       nrf_pwm_config_t pwm_config = PWM_DEFAULT_CONFIG;\r\n       pwm_config.mode             = PWM_MODE_LED_1000;\r\n       pwm_config.num_channels     = 1;\r\n       pwm_config.gpio_num[0]      = LIGHT_DIM;\r\n    \r\n       // Initialize the PWM library\r\n       nrf_pwm_init(&pwm_config);\r\n       nrf_pwm_set_value(0,0);\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "experimental_ble_app_uart on nRF51-dk Hello there,\r\n\r\nI am using the experimental_ble_app_uart with S110 on nRF51-dk and receiving sensor data via 1MHz SPI every time the timer ticks = 100ms. \r\nData transfer displayed on nRF Toolbox works fine but when I disconnect the application and trying to connect back again to the dev kit I receive an error shown on image below. It can be seen that the system returns an error after 20 second which I could not reference to and I suppose it is either a soft device timer or application.\r\n\r\nCould you please explain what is going on and why the connection cannot be instantiated again after disconnection? After the error message appears I am able to connect to the dev kit again on the first time however it just seems like that after disconnecting the dev kit doesn't advertise again only until the error where the state is updated and advertising allowed again. \r\n\r\n![image description](/attachment/9d3afd20d333dfc8c24c5ffe389c1871)\r\n\r\nI also include the time stamp image of data transfer where I am wondering that what is causing the discrepancy of 100ms timer? (APP_TIMER_TICKS(100, APP_TIMER_PRESCALER) In some cases it is too far from 100ms.\r\n\r\nMany thanks\r\n\r\nMilan\r\n\r\n![image description](/attachment/27804bed44f12099a500dc8964d5c9c8)",
    "tag": "uart"
  },
  {
    "text": "experimental_ble_app_uart on nRF51-dk Hello there,\r\n\r\nI am using the experimental_ble_app_uart with S110 on nRF51-dk and receiving sensor data via 1MHz SPI every time the timer ticks = 100ms. \r\nData transfer displayed on nRF Toolbox works fine but when I disconnect the application and trying to connect back again to the dev kit I receive an error shown on image below. It can be seen that the system returns an error after 20 second which I could not reference to and I suppose it is either a soft device timer or application.\r\n\r\nCould you please explain what is going on and why the connection cannot be instantiated again after disconnection? After the error message appears I am able to connect to the dev kit again on the first time however it just seems like that after disconnecting the dev kit doesn't advertise again only until the error where the state is updated and advertising allowed again. \r\n\r\n![image description](/attachment/9d3afd20d333dfc8c24c5ffe389c1871)\r\n\r\nI also include the time stamp image of data transfer where I am wondering that what is causing the discrepancy of 100ms timer? (APP_TIMER_TICKS(100, APP_TIMER_PRESCALER) In some cases it is too far from 100ms.\r\n\r\nMany thanks\r\n\r\nMilan\r\n\r\n![image description](/attachment/27804bed44f12099a500dc8964d5c9c8)",
    "tag": "spi"
  },
  {
    "text": "nRF8001 chip select pin Hi\r\n\r\nI have a MCU with an external sensor connected via SPI sampling data at 1000Hz.\r\nUsing the nRF8001 with REQN and RDYN lines is making trouble. The REQN line is pulled LOW after sending data to the nRF8001 for too long. It is pulled low by the lib from the time the data is send to the time the nRF8001 is ready to get the data. This is more then 1ms and way to long for a 1000Hz sampling from the sensor connected via SPI.\r\n\r\nMy quedtion is, is it possible to separate the REQN line from the chip select line? With a separation the SPI bus is blocked only when transmitting data via SPI.\r\n\r\nIn the lib a port named optional_chip_select is available but it seems like it is not used in the sdk.\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "TWI on Custom PCB nrf51822 Hey, \r\n\r\nI created a custom PCB with the nrf51822 that reads two sensors via TWI and transmits certain data over BLE. I can program the chip, print strings to the terminal w/ UART, connect over BLE etc... but I can't get TWI to work! \r\n\r\nTWI works perfectly on the development board with a breakout board of the sensor. Using the same exact code that works on the PCA_1005 I've even wired two GPIO's from my custom PCB to the breakout sensor and it still failed on the twi_master_transfer(....) call in sd_twi_hw_master.c.(in case my sensor on the board was soldered improperly or there was some problem with the schematic).\r\n\r\nI'm setting the SDA and SCL pins in twi_master_config.h, i've successfully used these same GPIO pins for UART, internal pull-ups are set. I'm using ble-app-hrs as a template for my code and calling twi after advertising_start()\r\n\r\nthe only guesses I have at this point are: problem with TWI on the chip (i just ordered it last week so it may be a new revision?), or something stupid I'm forgetting in software that I need to do when transferring from dev board to custom PCB.\r\n\r\nany thoughts? Thanks!",
    "tag": "twi"
  },
  {
    "text": "TWI on Custom PCB nrf51822 Hey, \r\n\r\nI created a custom PCB with the nrf51822 that reads two sensors via TWI and transmits certain data over BLE. I can program the chip, print strings to the terminal w/ UART, connect over BLE etc... but I can't get TWI to work! \r\n\r\nTWI works perfectly on the development board with a breakout board of the sensor. Using the same exact code that works on the PCA_1005 I've even wired two GPIO's from my custom PCB to the breakout sensor and it still failed on the twi_master_transfer(....) call in sd_twi_hw_master.c.(in case my sensor on the board was soldered improperly or there was some problem with the schematic).\r\n\r\nI'm setting the SDA and SCL pins in twi_master_config.h, i've successfully used these same GPIO pins for UART, internal pull-ups are set. I'm using ble-app-hrs as a template for my code and calling twi after advertising_start()\r\n\r\nthe only guesses I have at this point are: problem with TWI on the chip (i just ordered it last week so it may be a new revision?), or something stupid I'm forgetting in software that I need to do when transferring from dev board to custom PCB.\r\n\r\nany thoughts? Thanks!",
    "tag": "i2c"
  },
  {
    "text": "What is the max frequency the PWM peripheral can produce on the nRF51822? I want to drive motors at 40kHz and am wondering if I will be able to do this with the nRF51822.  If not 40kHz, I might be able to go as low as 15kHz.  What is the resolution and maximum frequency I can generate while also using the S110 soft device (e.g. maintaining ble communications).\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Controlling port pins I am trying to debug a SPI application using Keil and the Eval board, but am having problems with control of the port pins. I am using pin 23 as the CS pin. it configures correctly as an output, but the functions  **NRF_GPIO->OUTSET = 23; and NRF_GPIO->OUTCLR = 23;** have no effect on GPIO pin 23.\r\nhowever these instructions cause GPIO pins 0, 1, 2 and 4 to be set/reset. These two functions are declared in nrf_gpio.h :- \r\n\r\nstatic __INLINE void nrf_gpio_pin_set(uint32_t pin_number)\r\n\r\n{\r\n\r\n NRF_GPIO->OUTSET = (1UL << pin_number);\r\n\r\n}\r\n\r\nHowever, if I call the function **nrf_gpio_pin_set(23);** followed by **nrf_gpio_pin_clear(23);** in a loop the pin toggles as it should.\r\n\r\nThere also appears to be no activity on the other SPI pins - but one problem at a time !\r\n",
    "tag": "spi"
  },
  {
    "text": "how to implement accurate milisecond function I am new to nrf51822. \r\nI am trying to convert my Arduino code into NRF51822 \r\n\r\nI need something like this\r\n\r\n currentMillis = micros(); //microseconds since the Arduino board began running \r\n  if(currentMillis-past_time>=1000)\r\n{\r\ndo something\r\n}\r\n\r\nWhat is the best way to do this in NRF51822?\r\nShould I use RTC or go with simple timer? \r\nCan anyone share their function if they have already implemented?\r\n\r\nThanks",
    "tag": "timer"
  },
  {
    "text": "Is there a way to configure an IO port as high-impedance? Hi,\r\n\r\nI've tried  to search the documents and the forum for an answer to my question, but didn't have much luck.\r\n\r\nWe have a custom board that uses a STM32 micro and nRF51822 at the same time.  When the board was being designed, we didn't know if we were going to use SPI or I2C for communication between the two micros.  So, the SPI and I2C lines were added between the two micros.  During coding, we eventually went with using the SPI.  However, with the I2C lines still present on the hardware, it is affecting the I2C communication between the STM32 micro and the other sensors.  \r\n\r\nIs there a way to configure the GPIO ports on the nRF51822 as high-impedance?  That way it wouldn't affect the other devices using the I2C lines.\r\n\r\nAny help is much appreciated.\r\n\r\nThanks,\r\n\r\nLeo",
    "tag": "i2c"
  },
  {
    "text": "PWM analyzer example I have a PWM signal with a Period time of 13.2 ms(75Hz).\r\n\r\nPWM signal min. lvl= ~10%(1.2ms)\r\n\r\nPWM signal max. lvl= ~90%(12ms)\r\n\r\nNow I would like measure the pwm signal with the pwm analyzer example from nordic. Im working with the nRF51 DK(Rev.3, PCA10028). I see I have to do a few changes in the nrf6310.h file because the LEDs,Buttons,MISO,MOSI,SCK,CSN,RX and TX are defined on the false pins.\r\n\r\nDid I forget something which have to be changed?\r\n\r\nHow do I need to set up the 75Hz period time in the pwm analyzer example?\r\nOr is it not necessary to set up period time?",
    "tag": "pwm"
  },
  {
    "text": "S210 (v4) with SPI Master (SDK 7.1) on nRF51422 xxAA Hello\r\n\r\nI'm trying to get a SPI master onto my S210 programmed nRF51422.  I'm using uVision 5 and have all the nordic packs installed and built off of the ant broadcast tx example code.  I've got the SPI master example working and the S210 broadcast tx examples working but when I try to combine the two, I cannot initialize the SPI master when I have hooks in place for the S210.  I'm not sure what the difference in the configuration between with and without the S210 is (I'm still new to uvision and am not very fluent with it yet) but basically I included the packs and requisite dependencies to the S210 project that allow me to use the SPI Master in the nRF_Drivers pack and I can't initialize the SPI master.  What happens is that in the spi_master.c file's \"spi_master_open(\" routine, the app error hooks in when the device tries to clear out the \"EVENTS_READY\" value which I can see through the peripheral viewer is already at 0x00000000.  The lines before it that configure the pins work fine and I can see that reflected in the peripheral's registers but I'm just stuck as to what to do about getting the SPI to work.\r\n\r\nI was reading through the nRF51422's product spec and found the note about the organization of the RAM and noticed that it said that the CODE section shouldn't be combine with the Radio, Crypto or SPI, is this my issue?  And if it is, how do I insure that they get placed into separate blocks? I'm assuming that the soft device (AKA Radio?) exist in block 0 f the RAM so I should put the SPI into block 1?  Is this a define I do in uvision?\r\n\r\nThank you",
    "tag": "spi"
  },
  {
    "text": "nrf51822 pca10001 UART RX and TX pin voltage Hi,\r\n\r\nI modified the uart_example project for the pca10001 board of the nRF51822 evaluation kit to make it work with a UART TTL JPEG camera. So far, the camera can receive commands and send back responses just fine. However, I cannot capture any incoming data on the board. With nothing connected to the board and after the code executes and the UART pins are idle, I measure 3.0V on the TX pin and 3.3V on the RX pin. My Vcc is 3.0V and my board is connected to the USB port on the PC (which I measured at 5.08V).\r\n\r\nI would like to know why the \"high\" voltage is different on both pins, and how the RX pin can have a voltage higher than Vcc, as well as what state each pin is supposed to be in while idle. While using a logic analyzer, I can see the TX and RX work just fine *as long as* the board's RX pin is not connected to the camera's TX pin. When it is connected, the logic analyzer just shows that line being held high the whole time. The camera itself (jut connected to power and not the board) will hold its TX pin high at 3.3V and the RX pin will remain low (after it's done initializing). I figured the board would keep its TX pin high and its RX pin low as well.\r\n\r\nMy code even used the \"simple_uart_get()\" function with a huge array to store the incoming bytes, but no luck.\r\n\r\nThanks!",
    "tag": "uart"
  },
  {
    "text": "nrf51822's original interrupt priority Hi,\r\n    I want to know the original interrupt priority of nrf51822, without using soft device or using NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority). I also want to know whether I can find this priority information through the nrf51822's datasheet or not.",
    "tag": "interrupt"
  },
  {
    "text": "nrf51822's original interrupt priority Hi everyone,\r\n    I want to know the original interrupt priority of nrf51822, without using soft device or using NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority). I also want to know whether can I find this priority information through the nrf51822's datasheet or not. Thank you.",
    "tag": "interrupt"
  },
  {
    "text": "I cant read  or write data in nRF Uart (Blend Micro) Hello\r\n\r\nI have Blend Micro. I can using all functions with Blend Micro Software(BLE Controller) . But I cant using nRF Uart. I uploaded ble_uart sketch or hello world sketch. I set reqn reyn pin. I can connect but I cant send anything. How can I fix?",
    "tag": "uart"
  },
  {
    "text": "Unity3D Bluetooth Connection? Hello. I want to using nrf8001 in Unity3D.(any example) How can I do this? If you have any unity3d project, Could you send me? Thanks...",
    "tag": "uart"
  },
  {
    "text": "Battery Level Detection, PTR5528 Device: PTR5528\r\n\r\nBoard: custom.\r\n\r\nI have just given coin battery directly to VDD. At P0.00, P0.02 i have two leds. On p0.03 and 05 i am having one interrupt and other is SCK pin of SPI.\r\n\r\nSo, with this setup, i would like to measure battery voltage? Is that possible?\r\nOr, i am afraid that i have missed something on board to connect? Like connect one more line from coin cell to one of the adc line?\r\n\r\nAs ,later we have planned to measure battery voltage after out board out for proto.\r\n\r\nHelp? if i can still measure then how, please help!",
    "tag": "adc"
  },
  {
    "text": "nRF24l01+ SPI multiple registers read problem Hi,\r\nI'm writing my own library for the nRF24L01+. I'm using a Cortex-M0 LPC11U35 mcu.\r\nI'm able to write and read a single registers, write to multiple registers, correctly.\r\nBut when I try to read sequentially more than one register, the result is always the first byte. I'm making some tests with an oscilloscope, and all the SPI signals seems  to be correct, so I don't think I have problems with my SPI routines. My signals: [nRF24L01_problem.pdf](/attachment/527d3bebd0784d126e7b5979c9a4fcdf)\r\n\r\n![image description](/attachment/6db842a42808010ac13dcab180fa7689)\r\n\r\nDo you have some suggestions?\r\n\r\nMany thanks and best regards,\r\nDaniel",
    "tag": "spi"
  },
  {
    "text": "mbed nRF51822 timer bug Am I the only one to experience  what seems to be a bug? (same code is running fine on a Nucelo board)\r\n\r\nhttp://developer.mbed.org/users/roscop/code/nRF51822/\r\n\r\nThis code is to put in evidence a BUG in the TIMER implementation on Nordic TIMER of nRF51822. \r\nThis Example was created for plateform nRF51-DK. Led 2 will stop blinking (crashed main) when user button is pressed several time. User button start an interrpt, the interrupt set a tickker timer 200ms later. Meanwhile in the main loop LED 2 is changing state. You will see that after a while LED2 will stop blinking meaning that the program has crashed.\r\n\r\n\r\nI also posted this here:\r\nhttp://developer.mbed.org/forum/repo-56921-nRF51822-community/topic/5393/?page=1#comment-26678",
    "tag": "timer"
  },
  {
    "text": "How do I use Custom UUID , nrf51822 I want to use app(nrf uart 2.0) \r\n\r\nso, I try to change UUID,\r\n\r\nbut I don't know how make custom uuid and use it\r\n\r\nand I don't find function(ble_cs_init())\r\n\r\nhlep me, please",
    "tag": "uart"
  },
  {
    "text": "Updating firmware of external MCU via nrf51422. Hi!\r\n\r\nI looked through the forum and didn't find the answer.\r\n\r\nOur team is developing product with STM32F411 MCU and nrf51422 module. We need to provide firmware OTA update of STM processor from iOS/Android application.\r\n\r\nNow we see update process like this: user initiates fw update from the phone which sends command to the Nordic module. After that ble-module activates UART bootloader on the external MCU using special pins. Then nrf51422 starts data transfer via UART interface to the STM32 which writes received data into its ROM.\r\n\r\nIs method described above the best/optimal or there is another way to do this?",
    "tag": "uart"
  },
  {
    "text": "nRF8002 UART TX/RX to Vss after OTP burned: how? I'm looking for a simple and inexpensive solution for tying the TX and RX pins to GND after burning the OTP in production. What have other people done? I'd like to avoid having to use shunts or jumpers because of the cost and board-space. Similarly, having to solder down some wires would add a costly production step. So what's the simplest way to a) have the TX/RX pins available during production for in-circuit programming and subsequently, b) tie the TX/RX pins to GND?",
    "tag": "uart"
  },
  {
    "text": "Is it possible to vary the pulse width of a PWM in hardware? I need to use a high speed PWM (> 500 kHz) in which I can vary the pulse width.  In examples, it's handled in software which is too slow.\r\n\r\nIs there any way to set a pin on a compare event and clear it on another?  From the documentation I don't see how this would work.  If it can't be done, do you plan on implementing this in a future version of the chip?  Seems like a significant oversight.\r\n\r\nIs there something I'm missing here?\r\n\r\nThanks\r\n\r\nColin\r\n",
    "tag": "pwm"
  },
  {
    "text": "S120 interrupt latency We have an NRF51822 running S120 at 32MHz.\r\n\r\nOur system has two removable batteries. If a battery is removed we need to switch to the other battery as fast as possible. We would like to do this in an interrupt service routine. ie detect battery fail signal and run a very brief ISR which just flips a GPIO to select the other battery. With the current power supply design that would need to happen in 70 usec. Without the soft device, or other interrupt disabling, I am confident we could do this within 20 usec.\r\n\r\nFrom reading the S120 specification it seems there are times when interrupts are disabled, or otherwise locked out, for up to 1400usec. \r\n\r\nIs there any way to \"cheat\" the system? We don't even worry if the BTLE stack falls over and has to be restarted.\r\n\r\nFor example, one thing I was thinking of was changing the radio priority etc to one level lower and run a pin change interrupt at the highest level. I fully realise this could cause instability, but we could restart the BTLE stack if one of these events occurs.",
    "tag": "interrupt"
  },
  {
    "text": "nRFgo Studio does not recognise nRF51 The Segger programing interface works. The virtual com port appears on my PC (COM5). The problem is that there is no board listed in the Motherboards section of the Device Manager.\r\nI have loaded and verified the application nRFgoFirmware_7000.hex and the soft device  s210_nrf51422_4.0.1_softdevice.hex.\r\nAnybody any suggestions why the Motherboard is not detected?",
    "tag": "uart"
  },
  {
    "text": "ADC in the nrf51822 or nrf51422 What would be the best way to go about sampling and transmitting a signal at 60 Hz? I am considering setting up notifications and a characteristic, but I don't think that will actually transmit fast enough. Would it be better to do it another method? I'm looking for general advice or a nudge in the right direction as I'm relatively new to the softdevice and the BLE stack. \r\n\r\nIn terms of hardware I have the beacon reference design as well as the nrf51-dk and nrf51-dongle, but I will be designing a custom PCB at some point. ",
    "tag": "adc"
  },
  {
    "text": "BUG?:UART_INTENSET_RXTO dosen't work Hi All,\r\nI tried to use the nRF51422 device UART RXTO events using nrf51 SDK v6.1.\r\nI set the NRF_UART0->INTENSET in app_uart_init() as following:\r\n\r\n    // Enable UART interrupt\r\n    NRF_UART0->INTENCLR = 0xffffffffUL;\r\n    NRF_UART0->INTENSET = (UART_INTENSET_RXDRDY_Set << UART_INTENSET_RXDRDY_Pos) |\r\n                          (UART_INTENSET_TXDRDY_Set << UART_INTENSET_TXDRDY_Pos) |\r\n                          (UART_INTENSET_ERROR_Set << UART_INTENSET_ERROR_Pos) |\r\n    \t\t\t          (UART_INTENSET_RXTO_Set << UART_INTENSET_RXTO_Pos) ;\r\n\r\nI expected the NRF_UART0->INTENSET should be set as 0x20284, because I found the following defines in nrf51_bitfields.h\r\n\r\n    #define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */\r\n    #define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */\r\n    #define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */\r\n    #define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */\r\n\r\nhowever, I found the NRF_UART0->INTENSET was set as 0x0284.\r\n\r\nThen II tested to set the NRF_UART0->INTENSET = 0xFFFFFFFFUL, the NRF_UART0->INTENSET just became 0x1FFFF; Is this a bug for NRF_UART0->INTENSET ?\r\nHow can I make the UART RXTO events run?\r\n\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "spi slave status I am using the SPI Slave port in the nRF51822 and am always transferring 20 bytes.  No matter what I do, it seems that the status register in the IRQ says that I got a TX buffer over-read and a RX buffer overflow errors (0x3).  During every IRQ I write 3 to the status register, which clears the register, but the next IRQ has the same error in the register.  I'm using another nRF51822 as a SPI master to send the data and I'm pretty certain I'm only sending and receiving 20 bytes per packet.  Searching the questions database doesn't indicate there is a problem with the hardware.  Anyone have any ideas where to go to resolve this problem.  I am getting strange SPI data occasionally (millions of successful operations), which is crashing my program (by choice as a checksum fails).  I haven't determined where the error occurs, but I'm trying to resolve as many issues in this transmission path as possible and the STATUS register is haunting me.\r\n",
    "tag": "spi"
  },
  {
    "text": "Is the nRF24L01 IRQ line open-collector? I need to know whether the nRF24L01(+) has an open-collector IRQ output, or a full push-pull driver. The datasheet doesn't mention this fact.\r\n\r\nThe reason is, that I'm working on a circuit involving two peripherals (an nRF24L01 and another chip) attached to an MCU with only a single INT pin. If both the devices have open-collector IRQ lines, I can easily just wire them all together with an overall pullup resistor, and all will work fine. If however, the nRF24L01 has a full push/pull driver on the IRQ line, then this is impossible, and instead I'll have to buffer it somehow (perhaps with a 7407 or similar). When the interrupt fires, I can query each device over SPI to enquire which device fired the interrupt.",
    "tag": "interrupt"
  },
  {
    "text": "OLED 2864 I2C communication help.. I try to trun on the Display\r\n\r\nuint8_t Setting [20]  = {0xA8, 0x3F, 0xD3, 0x00, 0x40, 0xA0, 0xA1, 0xC0, 0xC8, 0xDA, 0x02, 0x81, 0x7F, 0xA4, 0xA6, 0xD5, 0x80, 0x8D, 0x14, 0xAF};\r\n\r\nint main(void)\r\n{\r\n    nrf_delay_ms(400);\r\n\r\n    if(twi_master_init()) // twi_master_init\r\n\t\t{\r\n\t\t\t  for(int i = 0; i<20; i++)\r\n\t\t\t {\r\n\t\t\t       twi_master_transfer(0x3C, &Setting[i],1,true);\r\n\t\t\t\t     nrf_delay_us(1000); \r\n\t\t\t }\r\n\t\t }\r\n}\r\n![image description](/attachment/6811cfe9fee588f3c321c8ed93cb4358)\r\n![image description](/attachment/98f29bddbcb970ba3e0340ea369c4a9a)\r\n![image description](/attachment/354fcfc39fc3d96ab61c84c4fec97aa1)\r\n\r\nBut still off.\r\n\r\nI connected  SCL - SCL, SDA-SDA, D/C -GND, CS - Non, Res - Non, VCC - 3.3v(out 3.2xx), GND -GND\r\n[DS_SSD1306.pdf](/attachment/91a788618c8c16a5de10eaa0ced60ea4)\r\n[DS_IM130625003_128x64_OLED_Module.pdf](/attachment/aef137a43f6aec02cac24fe69247d716)\r\n\r\n\r\nI don't know how can I do ",
    "tag": "i2c"
  },
  {
    "text": "OLED 2864 I2C communication help.. I try to trun on the Display\r\n\r\nuint8_t Setting [20]  = {0xA8, 0x3F, 0xD3, 0x00, 0x40, 0xA0, 0xA1, 0xC0, 0xC8, 0xDA, 0x02, 0x81, 0x7F, 0xA4, 0xA6, 0xD5, 0x80, 0x8D, 0x14, 0xAF};\r\n\r\nint main(void)\r\n{\r\n    nrf_delay_ms(400);\r\n\r\n    if(twi_master_init()) // twi_master_init\r\n\t\t{\r\n\t\t\t  for(int i = 0; i<20; i++)\r\n\t\t\t {\r\n\t\t\t       twi_master_transfer(0x3C, &Setting[i],1,true);\r\n\t\t\t\t     nrf_delay_us(1000); \r\n\t\t\t }\r\n\t\t }\r\n}\r\n![image description](/attachment/6811cfe9fee588f3c321c8ed93cb4358)\r\n![image description](/attachment/98f29bddbcb970ba3e0340ea369c4a9a)\r\n![image description](/attachment/354fcfc39fc3d96ab61c84c4fec97aa1)\r\n\r\nBut still off.\r\n\r\nI connected  SCL - SCL, SDA-SDA, D/C -GND, CS - Non, Res - Non, VCC - 3.3v(out 3.2xx), GND -GND\r\n[DS_SSD1306.pdf](/attachment/91a788618c8c16a5de10eaa0ced60ea4)\r\n[DS_IM130625003_128x64_OLED_Module.pdf](/attachment/aef137a43f6aec02cac24fe69247d716)\r\n\r\n\r\nI don't know how can I do ",
    "tag": "twi"
  },
  {
    "text": "NRF_PWM(For LED) and Button Interrupt Clash Hello,\r\n\r\ni am working with nrf_pwm library which is there in git. Also, on my device, with PTR51822, S110 7v is running. I am having tri color led on the device, by using pwm lib i am able to generate RGB colors. But after having done that the Button pin change interrupt is not reflecting.\r\n\r\nWhat arrangement i am having:\r\n- When  button is pressed, send a random character over nus_ble.(this i am carrying out from main context by setting flag)\r\n- Tri color led to light up color when some pattern of character i receive over nus_ble.()\r\n\r\n- What happening is:\r\n- If i light up some color first then button interrupt not works.\r\n- If i first press button, then button interrupt works, then i glow LED then it glows, after that if i again press button, the button interrupt does not works!\r\n\r\n- Desire:\r\n- Want tri color LED which occupies three gpio of nrf51822/ptr51822, and one button to work together!\r\n\r\nSome of my codes goes here:\r\nButton related:\r\n\r\n    static void button_int_Init( void ){\r\n    \t\r\n    \tnrf_gpio_cfg_input( TACT, NRF_GPIO_PIN_PULLDOWN );\r\n    \t\r\n    \tNRF_GPIOTE->INTENSET  = GPIOTE_INTENSET_IN0_Set << GPIOTE_INTENSET_IN0_Pos;\r\n    \t\r\n    \t\r\n    \tnrf_gpiote_unconfig( 0 );\r\n    \tnrf_gpiote_event_config( 0, TACT, NRF_GPIOTE_POLARITY_LOTOHI);\r\n    \tsd_nvic_SetPriority( GPIOTE_IRQn, 1 );\r\n    \tsd_nvic_EnableIRQ( GPIOTE_IRQn );\r\n    \t\r\n    }\r\n    \r\n    void GPIOTE_IRQHandler(void)\r\n    {\r\n        // Event causing the interrupt must be cleared.\r\n        if ((NRF_GPIOTE->EVENTS_IN[0] == 1) && \r\n            (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN0_Msk))\r\n        {\r\n            NRF_GPIOTE->EVENTS_IN[0] = 0;\r\n        }\r\n    \t\r\n    \tbuttonPressEventHappended = true;\r\n    \t\t\r\n    }\r\n\r\n\r\nMy Main context:\r\n\r\n     // Initialize\r\n    \t// Some var init code goes here...\r\n    \tnDataOffset = 0;\r\n    \tn_rgb_b_weight = n_rgb_g_weight = n_rgb_r_weight = 0;\r\n    \t\r\n    \t//\r\n    \t\r\n        leds_init();\r\n    \tperipheral_init();\r\n        timers_init();\r\n        buttons_init();\r\n            \r\n        ble_stack_init();\r\n        scheduler_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n        sec_params_init();\r\n        \r\n        button_int_Init();\r\n    \tinitAdxl() ;\r\n    \r\n    \tpwm_led_set_config( PWM_MODE_LED_255 );// With SoftDevice Enabled 1\r\n        advertising_start();\r\n\t\r\n\t\r\n- you can check out the body of nrf_pwm_init() , pwm_led_set_config() and nrf_pwm_set_value() from the github [here.](https://github.com/NordicSemiconductor/nrf51-pwm-library)\r\n\r\n- my button is on 26, which is named as TACT in the code.\r\n\r\n\r\nWhat could be the solution so i could make led and button work together? Or any way out so make button and some legs of LED work together with less PWM ?",
    "tag": "pwm"
  },
  {
    "text": "NRF_PWM(For LED) and Button Interrupt Clash Hello,\r\n\r\ni am working with nrf_pwm library which is there in git. Also, on my device, with PTR51822, S110 7v is running. I am having tri color led on the device, by using pwm lib i am able to generate RGB colors. But after having done that the Button pin change interrupt is not reflecting.\r\n\r\nWhat arrangement i am having:\r\n- When  button is pressed, send a random character over nus_ble.(this i am carrying out from main context by setting flag)\r\n- Tri color led to light up color when some pattern of character i receive over nus_ble.()\r\n\r\n- What happening is:\r\n- If i light up some color first then button interrupt not works.\r\n- If i first press button, then button interrupt works, then i glow LED then it glows, after that if i again press button, the button interrupt does not works!\r\n\r\n- Desire:\r\n- Want tri color LED which occupies three gpio of nrf51822/ptr51822, and one button to work together!\r\n\r\nSome of my codes goes here:\r\nButton related:\r\n\r\n    static void button_int_Init( void ){\r\n    \t\r\n    \tnrf_gpio_cfg_input( TACT, NRF_GPIO_PIN_PULLDOWN );\r\n    \t\r\n    \tNRF_GPIOTE->INTENSET  = GPIOTE_INTENSET_IN0_Set << GPIOTE_INTENSET_IN0_Pos;\r\n    \t\r\n    \t\r\n    \tnrf_gpiote_unconfig( 0 );\r\n    \tnrf_gpiote_event_config( 0, TACT, NRF_GPIOTE_POLARITY_LOTOHI);\r\n    \tsd_nvic_SetPriority( GPIOTE_IRQn, 1 );\r\n    \tsd_nvic_EnableIRQ( GPIOTE_IRQn );\r\n    \t\r\n    }\r\n    \r\n    void GPIOTE_IRQHandler(void)\r\n    {\r\n        // Event causing the interrupt must be cleared.\r\n        if ((NRF_GPIOTE->EVENTS_IN[0] == 1) && \r\n            (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN0_Msk))\r\n        {\r\n            NRF_GPIOTE->EVENTS_IN[0] = 0;\r\n        }\r\n    \t\r\n    \tbuttonPressEventHappended = true;\r\n    \t\t\r\n    }\r\n\r\n\r\nMy Main context:\r\n\r\n     // Initialize\r\n    \t// Some var init code goes here...\r\n    \tnDataOffset = 0;\r\n    \tn_rgb_b_weight = n_rgb_g_weight = n_rgb_r_weight = 0;\r\n    \t\r\n    \t//\r\n    \t\r\n        leds_init();\r\n    \tperipheral_init();\r\n        timers_init();\r\n        buttons_init();\r\n            \r\n        ble_stack_init();\r\n        scheduler_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n        sec_params_init();\r\n        \r\n        button_int_Init();\r\n    \tinitAdxl() ;\r\n    \r\n    \tpwm_led_set_config( PWM_MODE_LED_255 );// With SoftDevice Enabled 1\r\n        advertising_start();\r\n\t\r\n\t\r\n- you can check out the body of nrf_pwm_init() , pwm_led_set_config() and nrf_pwm_set_value() from the github [here.](https://github.com/NordicSemiconductor/nrf51-pwm-library)\r\n\r\n- my button is on 26, which is named as TACT in the code.\r\n\r\n\r\nWhat could be the solution so i could make led and button work together? Or any way out so make button and some legs of LED work together with less PWM ?",
    "tag": "pwm"
  },
  {
    "text": "Does the UART disable RTS when it sees CTS disabled? We have two nRF51822 chips (\"A\" and \"B\") connected via GPIO pins on our board, communicating via UART using the app_uart SDK module (in `APP_UART_FLOW_CONTROL_ENABLED` mode). One of the chips (\"B\") does not need to be active all the time, so it shuts down when it has nothing to do via the following process:\r\n\r\n 1. Disable receive via STOPRX task (if data was received when the RXTO event is received, it aborts).\r\n 1. Queue a message over the UART to \"A\".\r\n 1. Wait for the message to be completely sent.\r\n 1. Suspend the UART via SUSPEND task (effectively just STOPTX since STOPRX already ran).\r\n 1. Power down via `sd_power_system_off`.\r\n\r\nRecently I made some changes to app_uart to register for and pass on the CTS and NCTS events, and I've observed that when \"B\" set RTS high/disabled via the STOPRX task, \"A\" appears to do the same. I.e., it seems that when \"A\" sees CTS go high it takes its RTS high too. It's as if the \"SHORT\" in nrf51_bitfields called `UART_SHORTS_NCTS_STOPRX` is automatically enabled, even when `NRF_UART0->SHORTS` is set to 0.\r\n\r\nWhen I kept RTS low/enabled manually on \"A\" (using GPIO and not connecting it to the UART), I didn't see it set high when \"B\" set CTS high, so it seems this is being done by the UART. Can you confirm if this is expected, and if it's documented somewhere and I missed it?",
    "tag": "uart"
  },
  {
    "text": "What is the UART default parity configuration Hello,\r\n\r\nI'm currently reading nRF51_Series_Reference_Manual_v2.1.pdf. On page 28.9.9 there is the UART CONFIG register documented. Two bits of configuration for the Parity (ID B), where the value 0x0 denotes no parity and 0x7 even parity (as far as I read it together with 28.8: \"When parity is enabled, the parity will be generated automatically from the even parity of TXD and RXD for transmission and reception respectively.\"). 0x7 is a 3 bit value.\r\n\r\nAccording to 28.9.9 the reset Value of the configuration is 0x2.\r\n\r\nSounds wierd, isn't it? Is 0x7 just a typo and must be read as 0x2? 2 bits to encode 2 different configurations?\r\n\r\nkind regards,\r\nTorsten\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "BUG: APP_UART_FLOW_CONTROL_LOW_POWER sets all pins low Recently I was attempting to use the nrf51822 SDK's app_uart module's `APP_UART_FLOW_CONTROL_LOW_POWER` mode (currently using `APP_UART_FLOW_CONTROL_ENABLED`). I noticed that when I called `app_uart_init` all my LEDs came on. On investigation I noticed that in this block of code:\r\n\r\n        // Configure hardware flow control.\r\n        nrf_gpio_cfg_output(p_comm_params->rts_pin_no);\r\n        NRF_GPIO->OUT = 1 << p_comm_params->rts_pin_no;\r\n\r\nthe `OUT` should be `OUTSET`, otherwise it sets all pins to 0 *except* RTS (and sets RTS high or disabled as intended). Perhaps this wasn't caught if the UART was initialized early and subsequent code configured other pins correctly before them being cleared was a problem? I am using SDK 6.0.0 but the issue is present in 6.1.0.",
    "tag": "uart"
  },
  {
    "text": "n-AN36 change the Button to PWM I would like to modificate the LED Button application example. The LED characteristic should stay as it is, only the Button characteristic should be changed. I want to use the button characteristic to send the value of a pwm signal. When the device is in connection, it should always send the value of the pwm signal.\r\n\r\nGoal of the changes :\r\n\r\n1.)\r\n\r\nThe button_state value should be send all the time and not only when the button is pressed. \r\nI`m not sure, but I think that the button will be detected in the button_event_handler. If my presumption is true, how can I change that the value of the button_state will always be send?\r\n\r\n2.)\r\n\r\nThe value of the button_state should have a range from 0-100 and not only 1 or 0. Where in the code the value of the button_state will be set ? \r\n\r\nAnd do I have to change configuration of the value?\r\n\r\n\r\n**EDIT**\r\n\r\n[main.c](/attachment/60a8a819a9be28698aa210efc2b9c034)\r\n",
    "tag": "pwm"
  },
  {
    "text": "keil differences with or without soft device Hi\r\n\r\nin the SDK 7.1 examples, there are examples about how to use the hardware peripherals, and examples on how to use the BTLE stack, but nothing combined.\r\nHow do I combine this? What exactly is needed to change in e.g. the Keil target options?\r\n\r\nI thought that, for example to use the UART example in combination with the presence of the soft device, just had to add the compiler defines BLE_STACK_SUPPORT_REQD,  S110 and  SOFTDEVICE_PRESENT, and then adapt the memory areas for Read/Only memory and read/write memory. Or do  I also need to change some vector settings or so? Or use other linker files or templates?\r\n\r\nOr is there some combined example that I could start from?\r\nI just need the bluetooth stack, with a proprietary GATT profile, need to control 1 SPI interface, and need a service routine on 1 single external interrupt pin (like a button interrupt).\r\n",
    "tag": "spi"
  },
  {
    "text": "keil differences with or without soft device Hi\r\n\r\nin the SDK 7.1 examples, there are examples about how to use the hardware peripherals, and examples on how to use the BTLE stack, but nothing combined.\r\nHow do I combine this? What exactly is needed to change in e.g. the Keil target options?\r\n\r\nI thought that, for example to use the UART example in combination with the presence of the soft device, just had to add the compiler defines BLE_STACK_SUPPORT_REQD,  S110 and  SOFTDEVICE_PRESENT, and then adapt the memory areas for Read/Only memory and read/write memory. Or do  I also need to change some vector settings or so? Or use other linker files or templates?\r\n\r\nOr is there some combined example that I could start from?\r\nI just need the bluetooth stack, with a proprietary GATT profile, need to control 1 SPI interface, and need a service routine on 1 single external interrupt pin (like a button interrupt).\r\n",
    "tag": "interrupt"
  },
  {
    "text": "notification not receivied with timer     uint8_t ntime=0;\r\n    while(ntime<10)\r\n    {\r\n    \tnrf_timer_delay_ms(TIMER2, (110UL));\r\n    \tpin_read = nrf_gpio_pin_read(25);\r\n    \tif(pin_read==0) send_debug_message(\"PIN=0\");\r\n    \tif(pin_read==1) send_debug_message(\"PIN=1\");\r\n    \tntime++;\r\n    }\r\n\r\n\r\nBut I only receive notifications 6 times... why I miss the reset of 4 ?\r\nConnection remains connected and I can still talk to the BLE via nrf tool\r\n\r\nBTW, send_debug_message, sends a characteristic notification to android device or nrf master control panel.",
    "tag": "timer"
  },
  {
    "text": "ADC and S110 Good morning,\r\n\r\n    I'm working with S110 stack and I want to perform some ADC measurements. I configure the ADC as detailled in the example [here](https://github.com/NordicSemiconductor/nrf51-ADC-examples). Each time I want to make a measurement, I call the following function:\r\n\r\n\r\nvoid inicialitza_adc_vlatch(void)\r\n{\t\t\r\n\t\tuint32_t err_code;\r\n\t\tuint32_t p_is_running = 0;\r\n\r\n\t  ADC_tipus_conversio=ADC_MODE_VLATCH;\r\n\t\tADC_conversio_OK=NO;\r\n\t\t\r\n    // Configure ADC\r\n\t\t// Refer\u00e8ncia interna de 1.2V, no-pre-scaling, AIN4 (Vx que generem amb el regulador)\r\n\t\t\t\r\n\t  NRF_ADC->INTENSET   = ADC_INTENSET_END_Msk;\r\n    NRF_ADC->CONFIG     = (ADC_CONFIG_RES_10bit                       << ADC_CONFIG_RES_Pos)     |\r\n                          (ADC_CONFIG_INPSEL_AnalogInputNoPrescaling  << ADC_CONFIG_INPSEL_Pos)  |\r\n                          (ADC_CONFIG_REFSEL_VBG                      << ADC_CONFIG_REFSEL_Pos)  |\r\n                          (ADC_CONFIG_PSEL_AnalogInput4               << ADC_CONFIG_PSEL_Pos)    |\r\n                          (ADC_CONFIG_EXTREFSEL_None                  << ADC_CONFIG_EXTREFSEL_Pos);\r\n    NRF_ADC->EVENTS_END = 0;\r\n    NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Enabled;\r\n\r\n    \r\n\r\n    NRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.\r\n\t\r\n\t\r\n\t\r\n\t\t// Enable ADC interrupt\r\n\t\terr_code = sd_nvic_ClearPendingIRQ(ADC_IRQn);\r\n\t\tAPP_ERROR_CHECK(err_code);\r\n\r\n\t\terr_code = sd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);\r\n\t\tAPP_ERROR_CHECK(err_code);\r\n\r\n\t\terr_code = sd_nvic_EnableIRQ(ADC_IRQn);\r\n\t\tAPP_ERROR_CHECK(err_code);\r\n    \r\n\t\tsd_clock_hfclk_request();\r\n\t\twhile(! p_is_running) {  \t\t\t\t\t\t\t//wait for the hfclk to be available\r\n\t\t\tsd_clock_hfclk_is_running((&p_is_running));\r\n\t\t}   \r\n\t\t\r\n\t\t//Inicia la conversi\u00f3 => Caldr\u00e0 esperar que entri la interrupci\u00f3 quan la conversi\u00f3 acaba\r\n\t\tNRF_ADC->TASKS_START = 1;\r\n}\r\n\r\nFirst time is working fine but, second time, program is stuck in either 'sd_nvic_ClearPendingIRQ' function.\r\nWhat am I doing wrong?\r\n\r\nPlease, find also enclosed here below ADC IRQ handler:\r\n\r\n\r\nvoid ADC_IRQHandler(void)\r\n{\r\n    if (NRF_ADC->EVENTS_END != 0)\r\n    {\r\n        uint16_t    adc_result;\r\n\t\t\t\t\r\n        \r\n        NRF_ADC->EVENTS_END     = 0;\r\n        adc_result              = NRF_ADC->RESULT;\r\n        NRF_ADC->TASKS_STOP     = 1;\r\n\t\t\t\r\n\t\t\t\t//Release the external crystal\r\n\t\t\t\tsd_clock_hfclk_release();        \t\t  \r\n\t\t\t\t\r\n\t\t\t  if(ADC_tipus_conversio==ADC_MODE_VBAT)\r\n\t\t\t\t{\r\n\t\t\t\t\t\tADC_batt_lvl_in_milli_volts = ADC_RESULT_VBAT_MILLIVOLTS(adc_result);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t\tADC_vlatch_lvl_in_milli_volts = ADC_RESULT_VLATCH_MILLIVOLTS(adc_result);\r\n\t\t\t\t}\r\n     \r\n\t\t\t\tADC_conversio_OK=SI;\r\n\t\t\t\t\r\n    }\r\n}\r\n\r\n\r\nRegards.",
    "tag": "adc"
  },
  {
    "text": "twi_hw_master and SoftDevice Hi,\r\n\r\nI rely on twi_hw_master (from sdk 7.1.0) to communicate with a sensor. It works without any issues without the SoftDevice. With the SoftDevice enabled, using TWI causes program execution to stop (loop most likely).\r\n\r\nI have read similar posts and tried a few suggested solutions. The most promising one being using shortcuts instead of PPI:\r\nhttps://devzone.nordicsemi.com/question/5813/ready-to-development-twi-application-while-using-softdevice/\r\n\r\nWhile this also works without the SoftDevice, having the SoftDevice enabled causes TWI communication to fail. Note however that program execution continues in this case. Being unable to debug with the SoftDevice enabled, I can't see exactly where it fails. But printing TWI_ERRORSRC from the calling function shows no errors (0x00000000). Note that having the SoftDevice programmed in flash (without enabling it) gives the same result. \r\n\r\nSo is there any twi_hw* version that works with the newest SoftDevice/SDK? \r\nI am also curious as to why the SDK version does not work, as I can't see why using PPI CH0 should be a problem? And the version I linked to using SHORTS?\r\n\r\nI know that twi_sw_master works, but it is not an ideal solution.\r\n\r\nAny suggestions are appreciated. My only goal is to use the TWI module with the SoftDevice enabled.",
    "tag": "twi"
  },
  {
    "text": "fail to generate a TXDRDY Interrupt Hi,\r\n\r\nI'm unable to configure the UART so, that it will generate the TXDRDY event. I have an UART that should send periodicaly 4 Byte sequences without hardware handshake. I'm able to send the very first byte, but I'm unable to generate the interrupts that I need to send the next consecutive bytes.\r\n\r\nThe end of the configuration looks like this:\r\n\r\n        reg( STARTTX )  = 1;\r\n        sd_nvic_EnableIRQ( UART0_IRQn );\r\n        reg( TXDRDY )   = 0;\r\n        reg( INTENSET ) = 0x80;\r\n\r\nI send the first byte by calling a function send_byte() (and the first byte is received correctly):\r\n\r\n    void send_byte()\r\n    {\r\n        reg( TXDRDY )   = 0;\r\n        reg( INTENSET ) = 0x80;\r\n        std::uint8_t next_byte = *write_ptr_;\r\n        ++write_ptr_;\r\n        reg( TXD ) = next_byte;\r\n    }\r\n\r\nI expect this to cause an interrupt, when the byte was send. But my interrupt service function is never been called (veryfied by setting a brakepoint). Any idea, what I'm doing wrong here?\r\n\r\nEdit: Now I found a working solution (by accident / experimenting):\r\n\r\n    void interrupt_serivce()\r\n    {\r\n        reg( INTENCLR ) = 0x80;\r\n\r\n        if ( write_ptr_ != write_buffer_.end() )\r\n        {\r\n            send_byte();\r\n        }\r\n    }\r\n\r\n    template < class SystemVector >\r\n    void update( const SystemVector& v )\r\n    {\r\n        reg( INTENCLR ) = 0x80;\r\n\r\n        if ( write_ptr_ == write_buffer_.end() )\r\n        {\r\n            fag::pack_data< typename Configuration::consumed_signal_list_type >::pack( &write_buffer_[ 2 ], v );\r\n\r\n            write_ptr_ = write_buffer_.begin();\r\n            send_byte();\r\n        }\r\n    }\r\n\r\n    void send_byte()\r\n    {\r\n        reg( TXDRDY )   = 0;\r\n        reg( TXD )      = *write_ptr_;\r\n        ++write_ptr_;\r\n        reg( INTENSET ) = 0x80;\r\n    }\r\n\r\nupdate() is the function that will be called periodically, fills a buffer and directly sends the first byte of the buffer. interrupt_serivce() is the interrupt service handler and is called, when a byte was transmitted.\r\n\r\nWhat puzzles me is, why do I have to disable interups inbetween? If I do not reset the TXDRDY event, interrupts will not be generated. Why is this?\r\n\r\nThanks in advance ",
    "tag": "uart"
  },
  {
    "text": "fail to generate a TXDRDY Interrupt Hi,\r\n\r\nI'm unable to configure the UART so, that it will generate the TXDRDY event. I have an UART that should send periodicaly 4 Byte sequences without hardware handshake. I'm able to send the very first byte, but I'm unable to generate the interrupts that I need to send the next consecutive bytes.\r\n\r\nThe end of the configuration looks like this:\r\n\r\n        reg( STARTTX )  = 1;\r\n        sd_nvic_EnableIRQ( UART0_IRQn );\r\n        reg( TXDRDY )   = 0;\r\n        reg( INTENSET ) = 0x80;\r\n\r\nI send the first byte by calling a function send_byte() (and the first byte is received correctly):\r\n\r\n    void send_byte()\r\n    {\r\n        reg( TXDRDY )   = 0;\r\n        reg( INTENSET ) = 0x80;\r\n        std::uint8_t next_byte = *write_ptr_;\r\n        ++write_ptr_;\r\n        reg( TXD ) = next_byte;\r\n    }\r\n\r\nI expect this to cause an interrupt, when the byte was send. But my interrupt service function is never been called (veryfied by setting a brakepoint). Any idea, what I'm doing wrong here?\r\n\r\nEdit: Now I found a working solution (by accident / experimenting):\r\n\r\n    void interrupt_serivce()\r\n    {\r\n        reg( INTENCLR ) = 0x80;\r\n\r\n        if ( write_ptr_ != write_buffer_.end() )\r\n        {\r\n            send_byte();\r\n        }\r\n    }\r\n\r\n    template < class SystemVector >\r\n    void update( const SystemVector& v )\r\n    {\r\n        reg( INTENCLR ) = 0x80;\r\n\r\n        if ( write_ptr_ == write_buffer_.end() )\r\n        {\r\n            fag::pack_data< typename Configuration::consumed_signal_list_type >::pack( &write_buffer_[ 2 ], v );\r\n\r\n            write_ptr_ = write_buffer_.begin();\r\n            send_byte();\r\n        }\r\n    }\r\n\r\n    void send_byte()\r\n    {\r\n        reg( TXDRDY )   = 0;\r\n        reg( TXD )      = *write_ptr_;\r\n        ++write_ptr_;\r\n        reg( INTENSET ) = 0x80;\r\n    }\r\n\r\nupdate() is the function that will be called periodically, fills a buffer and directly sends the first byte of the buffer. interrupt_serivce() is the interrupt service handler and is called, when a byte was transmitted.\r\n\r\nWhat puzzles me is, why do I have to disable interups inbetween? If I do not reset the TXDRDY event, interrupts will not be generated. Why is this?\r\n\r\nThanks in advance ",
    "tag": "interrupt"
  },
  {
    "text": "SoftDevice safe TWI implementation not returning false on NACK I\u2019m running into a problem with the SoftDevice safe twi that\u2019s been posted in the forums a few times. I got the file here:\r\n\r\nhttps://devzone.nordicsemi.com/question/12230/twi-with-s110-on-nrf51822/\r\n\r\nOne of my peripherals is the [24LC128](http://ww1.microchip.com/downloads/en/DeviceDoc/21191s.pdf)  (linked to datasheet). To optimize bus throughput for writes, the 24LC128 uses acknowledgement polling. The quick description of this is that it takes a while to process a write command, so if you want to do multiple writes in a row, you repeatedly send the command byte to the 24LC128 until it acknowledges and then complete the write operation. It seems that for some reason the SD safe TWI implementation does not return false when it receives a NACK for a write, it only times out. I think the difference is in the twi_master_write(uint8_t * data, uint8_t data_length, bool issue_stop_condition) method. In the normal hw_twi file it checks NRF_TWI1->EVENTS_ERROR and returns false if this is not zero. I think this is where a false is returned if the peripheral does not ACK. This is missing from the SoftDevice safe code.\r\n\r\nI don\u2019t want to mess around in the sd_twi_hw_master.c file because I\u2019m not familiar with the intricacies of the SoftDevice and how it plays with PPI and TWI, but it seems like it might be as simple as adding in the check from the normal twi file into the SoftDevice safe version. Can someone advise me on how to proceed here? I\u2019ve attached the sd_twi_hd_master.c file that I am currently using for reference.\r\n\r\n[sd_twi_hw_master.c](/attachment/e70730704caf85ea9beb923fe14f96de)\r\n\r\nThanks!\r\nSeth",
    "tag": "twi"
  },
  {
    "text": "SoftDevice safe TWI implementation not returning false on NACK I\u2019m running into a problem with the SoftDevice safe twi that\u2019s been posted in the forums a few times. I got the file here:\r\n\r\nhttps://devzone.nordicsemi.com/question/12230/twi-with-s110-on-nrf51822/\r\n\r\nOne of my peripherals is the [24LC128](http://ww1.microchip.com/downloads/en/DeviceDoc/21191s.pdf)  (linked to datasheet). To optimize bus throughput for writes, the 24LC128 uses acknowledgement polling. The quick description of this is that it takes a while to process a write command, so if you want to do multiple writes in a row, you repeatedly send the command byte to the 24LC128 until it acknowledges and then complete the write operation. It seems that for some reason the SD safe TWI implementation does not return false when it receives a NACK for a write, it only times out. I think the difference is in the twi_master_write(uint8_t * data, uint8_t data_length, bool issue_stop_condition) method. In the normal hw_twi file it checks NRF_TWI1->EVENTS_ERROR and returns false if this is not zero. I think this is where a false is returned if the peripheral does not ACK. This is missing from the SoftDevice safe code.\r\n\r\nI don\u2019t want to mess around in the sd_twi_hw_master.c file because I\u2019m not familiar with the intricacies of the SoftDevice and how it plays with PPI and TWI, but it seems like it might be as simple as adding in the check from the normal twi file into the SoftDevice safe version. Can someone advise me on how to proceed here? I\u2019ve attached the sd_twi_hd_master.c file that I am currently using for reference.\r\n\r\n[sd_twi_hw_master.c](/attachment/e70730704caf85ea9beb923fe14f96de)\r\n\r\nThanks!\r\nSeth",
    "tag": "i2c"
  },
  {
    "text": "Using SPI master mode (NOT WORKING) Hi,\r\nI'm using a nRF51422+nRF6310 and I need to use SPI in order to connect with some devices. I am trying to run the example \"spi_master_example_with_spi_slave\" but I found is not working. \r\nApparently is not crashing (is not going to the error handler), the problem is that I cannot see the clock signal ( neither the MISO, MOSI...) in any of the pins. Not only I tried with the appropiate pin but also I tried with all the other pins and I'm not seeing the signal on my oscilloscope. \r\nWhat can be working bad? How can I solve that problem and use my SPI in master mode? \r\nI hope you can help me whit the issue,\r\nThanks in advance",
    "tag": "spi"
  },
  {
    "text": "TWI SW setting the frequency rate ( cant find ) Hello!\r\n\r\nLooking around and reading a bunch of posts, I found little information on how to initialize the TWI sw frequency, which currently is 100 kHz( calculated it with a test). Is there are way to init the Frequency rate for the TWI software ? Setting the frequency rate manually, on the HW version is easy.But what about the SW version , is the TWI always on 100kHz?\r\nRegards, Volkan",
    "tag": "twi"
  },
  {
    "text": "UART RX executed when connected via BT Hi,\r\n\r\nI have the following code with SD110 7.1.0:\r\n\r\n    static void uart_init(void) // device inter-communication\r\n    {\r\n\r\n    // Configure RX and TX pins.\r\n    nrf_gpio_pin_set(0);\r\n    nrf_gpio_cfg_output(0);\r\n    nrf_gpio_cfg_input(0, NRF_GPIO_PIN_PULLUP);\r\n\r\n\r\n    NRF_UART0->PSELTXD = 0;\r\n    NRF_UART0->PSELRXD = 1;\r\n\r\n    // Configure baud rate and parity.\r\n    NRF_UART0->BAUDRATE = (115200 << UART_BAUDRATE_BAUDRATE_Pos);\r\n\r\n\tNRF_UART0->CONFIG = (UART_CONFIG_PARITY_Excluded << UART_CONFIG_PARITY_Pos);\r\n\r\n    NRF_UART0->ENABLE        = (UART_ENABLE_ENABLE_Enabled << UART_ENABLE_ENABLE_Pos);\r\n    NRF_UART0->EVENTS_RXDRDY = 0;\r\n    NRF_UART0->EVENTS_TXDRDY = 0;\r\n\r\n    NRF_UART0->CONFIG       &= ~(UART_CONFIG_HWFC_Enabled << UART_CONFIG_HWFC_Pos);\r\n\r\n    #define  UART_PIN_DISCONNECTED 0xFFFFFFFF /**< Value indicating that no pin is connected to this UART register. */\r\n\r\n\tNRF_UART0->PSELRTS       = UART_PIN_DISCONNECTED;\r\n    NRF_UART0->PSELCTS       = UART_PIN_DISCONNECTED;\r\n\r\n    NRF_UART0->TASKS_STARTTX = 1;\r\n    NRF_UART0->TASKS_STARTRX = 1;\r\n\r\n    // Enable UART interrupt\r\n    NRF_UART0->INTENCLR = 0xffffffffUL;\r\n    NRF_UART0->INTENSET = (UART_INTENSET_RXDRDY_Set << UART_INTENSET_RXDRDY_Pos) |\r\n                          (UART_INTENSET_TXDRDY_Set << UART_INTENSET_TXDRDY_Pos) |\r\n                          (UART_INTENSET_ERROR_Set << UART_INTENSET_ERROR_Pos);\r\n\r\n    NVIC_ClearPendingIRQ(UART0_IRQn);\r\n    NVIC_SetPriority(UART0_IRQn, APP_IRQ_PRIORITY_LOW);\r\n    NVIC_EnableIRQ(UART0_IRQn);\r\n    }\r\n\r\n    /**@brief Function for handling the UART Interrupt.\r\n     *\r\n     * @details UART interrupt handler to process TX Ready when TXD is available, RX Ready when a byte\r\n     *          is received, or in case of error when receiving a byte.\r\n     */\r\n    void UART0_IRQHandler(void)\r\n    {\r\n    // Handle reception\r\n    if ((NRF_UART0->EVENTS_RXDRDY != 0) && (NRF_UART0->INTENSET & UART_INTENSET_RXDRDY_Msk))\r\n    {\r\n        // This event executed when connected via BT (from phone)\r\n        // Clear UART RX event flag\r\n        NRF_UART0->EVENTS_RXDRDY  = 0;\r\n        uart_rx_buff[in_wr_ptr++] = (uint8_t)NRF_UART0->RXD;\r\n\t\tif(in_wr_ptr >= sizeof(uart_rx_buff))\r\n\t\t{\r\n\t\t\tin_wr_ptr = 0;\r\n\t\t}\r\n    }\r\n\r\n    // Handle transmission.\r\n    if ((NRF_UART0->EVENTS_TXDRDY != 0) && (NRF_UART0->INTENSET & UART_INTENSET_TXDRDY_Msk))\r\n    {\r\n        // Clear UART TX event flag.\r\n        NRF_UART0->EVENTS_TXDRDY = 0;\r\n        //on_uart_event(ON_TX_READY);\r\n    }\r\n\r\n    // Handle errors.\r\n    if ((NRF_UART0->EVENTS_ERROR != 0) && (NRF_UART0->INTENSET & UART_INTENSET_ERROR_Msk))\r\n    {\r\n        uint32_t       error_source;\r\n\r\n        // Clear UART ERROR event flag.\r\n        NRF_UART0->EVENTS_ERROR = 0;\r\n\r\n        // Clear error source.\r\n        error_source        = NRF_UART0->ERRORSRC;\r\n        NRF_UART0->ERRORSRC = error_source;\r\n    }\r\n    }\r\n\r\nCould anybody explain me why receive RX event when I connect via BT? I don't use UART through BT just I want to use UART module of this chip via pin1-2 (RX-TX only)\r\n\r\nThanks!",
    "tag": "uart"
  },
  {
    "text": "I can not find the DAC function in nrf51822. I want to operate\r\n\r\nTries to operate a small speaker.\r\n\r\nhttp://www.wvshare.com/product/Analog-Test-Board.htm \r\n\r\nbut I can not find the DAC function in nrf51822.\r\n\r\nHow do I create the Analog signal?",
    "tag": "adc"
  },
  {
    "text": "Slave example SPI doesn't work Hi,\r\n\r\nI am trying to use the spi_slave_example on my nordic nrf51822. But i have an issue :\r\n\r\nI can build all target and download code to flash memory but nothing happen :\r\n\r\nat the begin of the main.c, i placed : nrf_gpio_pin_set(LED_0); to see if the programm is running, but no LED switch on.\r\n\r\nOn the file nrf6310.h, i have configured the LED pin :\r\n\r\n![image description](/attachment/b92aaab68a492c8efdfead45a47341cb)\r\n\r\nWith the debugger :\r\n\r\n![image description](/attachment/19262a75b224ce69c75706e0b8f1edce)\r\n\r\nDid i miss a step ?\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "How do I use an external interrupt? Have tried to use an external interrupt coding.\r\n\r\n    /*------------------------------------------------------------------------------------------------------------*/\r\n    #define Record 28\r\n    #define Play 26\r\n    \r\n    static void gpio_init(void)\r\n    {\r\n    nrf_gpio_cfg_input(Record, NRF_GPIO_PIN_PULLUP);\r\n    nrf_gpio_cfg_input(Play, NRF_GPIO_PIN_PULLUP);\r\n\t\r\n\t NVIC_DisableIRQ(GPIOTE_IRQn);\r\n    NVIC_ClearPendingIRQ(GPIOTE_IRQn);\r\n\t\r\n    // Enable interrupt:\r\n\t  NVIC_SetPriority(GPIOTE_IRQn, 3); //optional: set priority of interrupt\r\n    NVIC_EnableIRQ(GPIOTE_IRQn);\r\n    NRF_GPIOTE->CONFIG[0] =  (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos)\r\n                           | (0x1C << GPIOTE_CONFIG_PSEL_Pos)   //  \ud540\ubc88\ud638 \uc124\uc815\r\n                           | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\r\n    NRF_GPIOTE->INTENSET  = GPIOTE_INTENSET_IN0_Set << GPIOTE_INTENSET_IN0_Pos;\r\n\t  \r\n\t\r\n\t\r\n    NRF_GPIO->PIN_CNF[Record] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)\r\n\t                                                      | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos) \r\n\t                                                            | (GPIO_PIN_CNF_PULL_Pullup << GPIO_PIN_CNF_PULL_Pos)   \r\n\t                                                 | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) \r\n\t                                                           | (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);\r\n\r\n    NRF_GPIO->PIN_CNF[Play] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos) \r\n\t                                                      | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos) \r\n\t                                                            | (GPIO_PIN_CNF_PULL_Pullup << GPIO_PIN_CNF_PULL_Pos) \r\n\t                                                 | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) \r\n\t                                                          | (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);\r\n\t\t\t    // Configure GPIOTE channel 0 to generate event on input pin low-to-high transition.\r\n    nrf_gpiote_event_config(0, Record, GPIOTE_CONFIG_POLARITY_Toggle);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\t\r\n    }\r\n\r\n\r\n    /** @brief Function for handling the GPIOTE interrupt which is triggered on pin 0 change.\r\n     */\r\n    void GPIOTE_IRQHandler(void)\r\n    {\r\n    \t\r\n\t/*\r\n    // Event causing the interrupt must be cleared.\r\n    if ((NRF_GPIOTE->EVENTS_IN[0] == 1) && \r\n        (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN0_Msk))\r\n    {\r\n\t\t\t  \r\n        NRF_GPIOTE->EVENTS_IN[0] = 0;\r\n    }\r\n    */\r\n\t\t if(NRF_GPIOTE->EVENTS_IN[0] == 1)\r\n\t\t{\r\n         \r\n\t\t\t\tNRF_GPIOTE->EVENTS_IN[0] = 0;  //this is where you should set breakpoint to make sure CC[0] and cc[1] don't change while you are in breakpoint\r\n\t\t}\r\n\r\n\t\tif(NRF_GPIOTE->EVENTS_IN[1] == 1) //will run only if you intenset event 1\r\n\t\t{\r\n\r\n\t\t\t\tNRF_GPIOTE->EVENTS_IN[1] = 0;  //this is where you should set breakpoint to make sure CC[0] and cc[1] don't change while you are in breakpoint\r\n\t\t}\r\n\t\t\r\n\t\t if (nrf_gpio_pin_read(Record) == 0) {Record_Start = (!Record_Start);} //do something }\r\n\r\n     if (nrf_gpio_pin_read(Play) == 0) { Record_Play = (!Record_Play);}//do something }\r\n\t\t\r\n    \r\n\t\t\r\n    }\r\n\r\nPress the Record button is changed to 1 if the variable is 0 Record_Start\r\n\r\nif 1, to be changed to zero.\r\n\r\nHowever, pressing the button once 0-> 1-> 0 just changed in this way.\r\n\r\nWhat is the source of the problem?",
    "tag": "interrupt"
  },
  {
    "text": "Timer change interval Hello! How can I dynamically change timer interval by the button, without using PPI?",
    "tag": "timer"
  },
  {
    "text": "How do I use button Push Interrupt I want to change Variable state( 0->1 or 1->0) when I push the button.\r\n\r\nI was searching for example relating to the GPIO.\r\n\r\nbut I did not find that i want.\r\n\r\n\r\nEverything is a  timer example\r\n\r\nI would like to implement a function that operates when just press a button(using a interrupt).\r\n\r\nYou can do the advice would be appreciated.\r\n\r\nI'd like to get help on how to implement.\r\n\r\nWhat should I do?\r\n\r\n\r\nI use nrf51822-DK and small button.\r\n\r\n\r\n\r\n\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "pin_change_int_example don't work when I download program(pin_change_int_example) in nrf51822, Immediate Interrupt is occured\r\n\r\nAnd when I push the button, Interrupt is stop...\r\n\r\nWhat is problem?\r\n\r\nI want to use Interrupt. but I don't use it.\r\n\r\npin 0 -- button -- gnd\r\n\r\npin 8 -- LED -- gnd\r\n",
    "tag": "interrupt"
  },
  {
    "text": "NUS (nRF UART app) error 6 or 9 Hi, I'm using my custom board with NordicSemi nRF51822-QFAA and J-Link.\r\n\r\n(Softdevice S110 7.1, SDK 7.2, and using IAR for ARM 7.1)\r\n\r\nI was testing the NUS example using the nRF UART app. The test device was iPhone 5S (iOS 8.1.3).\r\n\r\n\r\nThe NUS example worked fine. So I added HID service and test it again.\r\n\r\nHowever sometimes, I received an error message like this :\r\n\r\n\r\n    Log : Did connect to Nordic_Keyboard\r\n    \r\n\r\n    Log : Did disconnect from Nordic_Keyboard, error code 6\r\n\r\nIn which case this error code 6 appears?\r\n\r\nAlso sometimes error code 9 appears as well. Can I view the lists of error codes?\r\n\r\n-Regards, Mango922\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "Dual Bootloader -- DFU (BLE) + UART? Wondering if there are any example/reference implementations of a bootloader for the nRF51822 that support Device Firmware Update over both UART and BLE?  We've got the BLE stuff working well, but would like to make sure that we've got UART for those that might not have a compatible BLE SmartPhone.\r\n\r\nThanks!",
    "tag": "uart"
  },
  {
    "text": "SPI Master transfer not completing Hi,\r\n\r\nI am using the SPI Master 1 to control an EEPROM. I used the spi_example project to help get the code working. It all works fine if the code that initiates the SPI transfer is in main() or simply in a function called by main(). But if I attempt an SPI transfer in an \"application timer\" timeout handler function, it doesn't seem to work properly. It just seems like the transfer never completes. As shown in the oscilloscope trace below, the Chip Select (top yellow waveform) goes low fine, the SPI clock (green waveform) is generated fine, the data to the slave (blue waveform) is fine (the value is 00000110). Ignore the pink waveform. But for some reason the Chip Select doesn't go high, when it does if the SPI initiation is in main(). \r\n\r\n![image description](/attachment/3a43f14beef9ee72b0bfc69991160195)\r\n\r\n\r\nSo when I next try to start a transfer I am stuck at:\r\n\r\nwhile (!m_transfer_completed)\r\n{\r\n  //wait for current transfer to complete\r\n}\r\n\r\nIs there any reason why it would work in main but not in an application timer timeout handler?\r\n\r\n\r\nKind regards\r\n\r\nJack\r\n\r\nedit: \r\n\r\nI am setting the Chip Select high at the end of the transaction, where m_transfer_completed is also set as true. Then when I try to initiate another spi transfer, the code gets to the while loop. So essentially, the Chip Select pin should go high before the while loop occurs.\r\n\r\nHere is some extracts from my code:\r\n\r\nIn the function timers_init() that is called in main, I have:\r\n\r\n\terr_code = app_timer_create(&m_del_timer_id,\r\n\t                            APP_TIMER_MODE_REPEATED,\r\n\t                            del_timer_handler);\r\n\r\nHere is the implementation of del_timer_handler\r\n\r\nvoid del_timer_handler(void * p_context)\r\n{\r\neeprom_write(m_tx_eeprom,m_rx_eeprom,m_eeprom_last_write_addr,m_eeprom_last_write_addr + EEPROM_PAGE_SIZE);\r\n\r\n}\r\n\r\neeprom_write is defined as:\r\n\r\n//To write to EEPROM, first send a write enable\r\n\r\nstatic void eeprom_write(uint8_t * const tx_buffer, uint8_t * const rx_buffer,\r\n\t\t\t\t\t\tuint32_t from_addr, uint32_t to_addr)\r\n{\r\n\r\n   execute_eeprom_command(EEPROM_WREN,tx_buffer,rx_buffer,NULL,NULL);\t\t\r\n   execute_eeprom_command(EEPROM_WRITE,tx_buffer,rx_buffer,from_addr,to_addr);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n}\r\n\r\nexecute_eeprom_command is defined below:\r\n\r\n  void execute_eeprom_command(eeprom_command_t command, uint8_t * const tx_buffer, uint8_t * const rx_buffer, uint32_t from_addr, uint32_t to_addr) \r\n\r\n{\r\n\r\n\tuint16_t  rx_len = 0;\r\n\tuint16_t  tx_len = 0;\t\r\n\t\r\n\twhile (!m_eeprom_transfer_completed)\r\n\t{\r\n\t\t//wait for current transfer to complete\r\n\t}\r\n\t\tm_eeprom_transfer_completed = false;\r\n\t\t\t\t\r\n\t\t//Initalize buffers.\r\n\t\teeprom_buf_init(command,tx_buffer, &tx_len, rx_buffer, &rx_len, from_addr, to_addr);\t\t\t\r\n\t\t\t\t\r\n\t\t //initialise SPI Master\t\t\t\t\r\n\t\tspi1_master_init();\r\n\t\t\t\t\t\t\t\t\r\n\t\t//Start transfer.\r\n\t\t\t\t\r\n\t\tuint32_t err_code = spi_master_send_recv(SPI_MASTER_1, tx_buffer, tx_len, rx_buffer, rx_len);\r\n\t\tAPP_ERROR_CHECK(err_code);\r\n}\r\n\r\n\r\nNote, I am using the SS pin of the spi_master for the Chip Select. So the spi_master should automatically toggle the pin as required. I have also tried implementing the Chip Select independently of the spi_master and I still have the same problem. When doing this, I set the Chip Select to high in the spi master event handler:\r\n\r\n\r\n\r\nvoid spi_master_1_event_handler(spi_master_evt_t spi_master_evt)\r\n{\r\n\r\n\r\n\r\n\r\nswitch (spi_master_evt.evt_type)\r\n    \r\n    {\r\n        case SPI_MASTER_EVT_TRANSFER_COMPLETED:\r\n            //Check if received data is correct.\r\n        \r\n            //Close SPI master.\r\n            spi_master_close(SPI_MASTER_1);\r\n\t\t\t\t        \r\n            m_eeprom_transfer_completed = true;\r\n\t // nrf_gpio_pin_set(EEPROM_CS_PIN);\t\t\t\t\r\n\r\n            break;\r\n        \r\n        default:\r\n            //No implementation needed.\r\n            break;\r\n    }\r\n}\r\n",
    "tag": "interrupt"
  },
  {
    "text": "How to use sd_nvic_SetPriority with GPIOTE handler on nRF51822 Hmm... this should be a simple question.   But I haven't found a direct answer yet in the online SDK docs, the ARM NVIC docs, nor in this forum (and have only been confused by trying to work with the combination of them :-)\r\n\r\nIm using the S110 SD, with SDK 6.2.1 and the GPIOTE peripheral, which I've initialized and registered a single user.  It appears to be running at NRF_APP_PRIORITY_LOW by default, so that when the GPIOTE handler dispatches to my sub-handler, that code is subject to interrupt by other peripherals running at the same level (but with lower device address?)\r\n\r\nWhere and how do I call \r\n\r\n    uint32_t sd_nvic_SetPriority(IRQn_Type  IRQn, nrf_app_irq_priority_t  priority) \r\n\r\nBefore or after initializing the GPIOTE module?  Can the priority level be changed dynamically or is it set for the life of the app?  And what's the appropriate value of the IRQn argument for the GPIOTE device? (the symbol GPIOTE_IRQn doesn't seem to be defined.)\r\n\r\nIs there some sample code that demonstrates this?\r\n\r\nTIA,\r\n\r\nMike",
    "tag": "interrupt"
  },
  {
    "text": "Can BLE and SoC events cause SD_EVT_IRQn simultaneously? Hello everybody,\r\n\r\nIn the SD_EVT_IRQn ISR I check for BLE and SoC events and set flags for each so my application can fetch and dispatch the events in the main context.\r\n\r\nBecause SD_EVT_IRQn can be caused by both SoC and BLE events, I use the code in the ISR to determine which flag to set. Here's a sanitized version:\r\n\r\n    void SD_EVT_IRQHandler( void )\r\n    {                                                                                                                               \r\n        uint16_t dummy;                                                                                                            \r\n        // Null pointer lets us take a peek and get the return code                                                                 \r\n        uint32_t rc = sd_ble_evt_get(NULL, &dummy);                                                                                \r\n\r\n        // If it's not a BLE event, it must be a SoC event                                                                     \r\n        if (NRF_ERROR_NOT_FOUND == rc)                                                                                              \r\n        {                                                                                                                           \r\n            signal_raise(SIGNAL_NRF_SOC_EVENT);                                                                            \r\n        }                                                                                                                           \r\n        else                                                                                                                        \r\n        {                                                                                                                           \r\n            signal_raise(SIGNAL_NRF_BLE_EVENT);                                                                           \r\n        }                                                                                                                           \r\n    }\r\n\r\nI'm uneasy about this code since it's only capable of catching either a SoC or a BLE event, but not both if they happen to occur \"simultaneously\". I can't find documentation if it's possible to enter the ISR only once, but have both a SoC and a BLE event pending. I would hope that the ISR runs twice, once for each event type, otherwise I risk missing events.\r\n\r\nJust a comment for Nordic developers: It's a bit of a pain sharing the same IRQ for both SoC and BLE events. I understand that the IVT is limited in size, so that may not be possible. However, my world would be much nicer if functions like sd_is_ble_event_pending() and sd_is_nrf_event_pending() existed.\r\n\r\nCan anybody with knowledge of the S110's inner-workings put my mind at ease?\r\n\r\nThank you! ",
    "tag": "interrupt"
  },
  {
    "text": "CCCD is null in Android Hi everyone, \r\n\r\nI successfully compiled and loaded the experimental_ble_app_uart onto my pca10028 board.\r\nI downloaded and installed the nRF toolbox on my nexus 7 tablet. Connecting and sending uart data from the tablet to the board works fine.\r\nHowever, the other direction poses me problems. In Android, I get a null pointer from\r\n\r\n    mRXCharacteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID);\r\n\r\nAlso, with mRXCharacteristic.getDescriptors() I get an empty answer. It works for the TX-Characteristic, though! What could be wrong?\r\nThanks for any help.",
    "tag": "uart"
  },
  {
    "text": "spi_interrupt not ocuurs I am using spi_master.c for spi communication with nRF51822EK.\r\n\r\nAnd i had sent and recieved  data packet successfully for 1st time with spi_master_send_recv(). When i sending 2nd packet of data it writes the initial bytes(1st 2 bytes),enables spi interrupt also, but m not getting spi interrupt.\r\n\r\n\r\nI am using sdk6 and sd7.\r\nSPI interrupt priority---3\r\n",
    "tag": "spi"
  },
  {
    "text": "spi_interrupt not ocuurs I am using spi_master.c for spi communication with nRF51822EK.\r\n\r\nAnd i had sent and recieved  data packet successfully for 1st time with spi_master_send_recv(). When i sending 2nd packet of data it writes the initial bytes(1st 2 bytes),enables spi interrupt also, but m not getting spi interrupt.\r\n\r\n\r\nI am using sdk6 and sd7.\r\nSPI interrupt priority---3\r\n",
    "tag": "interrupt"
  },
  {
    "text": "SPI with multiple chip selects As I understand the SPI HW driver documentation, it appears to be at least biased for using a single chip select (slave select in the API). I have an application where I have 5 devices on the SPI bus.\r\n\r\nShould I create an SPI master configuration structure for each of the 5 devices? Only the SPI_Pin_SS would be different in each of them, and I think I would need to close and open SPI to switch between the devices.\r\n\r\nOr can I use a single structure with spi configuration function to configure the SPI pins (CLK, MOSI, MISO) and manually configure the chip selects?  And then when I want to change device I want, just change the SPI_Pin_SS?\r\n\r\n**Another way?**\r\nAfter reading RK's answer, began to wonder if could use GPIOTE to handle the multiple chip selects. Would it work to assign SPI_Pin_SS to an \"unused\" pin, and cofigure GPIOTE task to toggle desired CS when SPI toggles _SS ? I haven't explored GPIOTE at all yet so this may be a naive idea.",
    "tag": "spi"
  },
  {
    "text": "nrf51822 SPI Slave example doesn't work Hi,\r\n\r\nI'm trying to get the SPI Slave example working on my nRF51822 PCA100001 development kit. \r\n\r\n1) SPI1_TWI1_IRQHandler never gets called even though the ACQUIRED and END enabled bits are set in the SPIS1 INTENSET register.\r\n\r\nI try to trigger the interrupt manually by setting the NRF_SPIS1->TASKS_ACQUIRE to 1 and the ACQUIRED Event never gets set.\r\n\r\n2) I have verified that the SPI data I'm sending to the nRF51822 has the 7.1 usec delay between CSN going low and the start of my data being clocked out.\r\n\r\n3) When I enable the SPI Slave on the nRF51822 the incoming SCK signal is getting divided down even though I have verified that I have not enabled a Pull up or down on this pin in the nRF51822.\r\n\r\nThanks for the help!",
    "tag": "spi"
  },
  {
    "text": "Debugging gets stuck at INLINE app_timer_evt_get() I am trying to debug my code today and am finding that Eclipse is constantly breaking execution at the INLINE function app_timer_evt_get().  I do not have any break point set here, Eclipse is automatically stopping here.  I reverted to an older version of the project and this does not occur, however going through all the code changes I cannot see any reason why this would now be occurring, other than perhaps slightly large code size.  Has anyone seen this problem?\r\n\r\nThanks for the help guys.\r\n\r\n-K\r\n\r\np.s. If I do not try and debug the code runs fine, but trying to run from the Debug window of Eclipse (even with zero breakpoints set), execution stops at app_timer_evt_get() on every single app_timer event.",
    "tag": "timer"
  },
  {
    "text": "nRF51822 ADC without UART I am using the adc to sample a sensor and send this over the air.\r\nFor testing I used the simple_uart library and it works.\r\nBut now I don't need the uart connection and I removed it from the project, but now the adc always returns 0.\r\n\r\nI don't need have to send something over the uart, but I need to run \"simple_uart_config()\", to make the adc work. without it it won't work.",
    "tag": "adc"
  },
  {
    "text": "nRF51822 ADC without UART I am using the adc to sample a sensor and send this over the air.\r\nFor testing I used the simple_uart library and it works.\r\nBut now I don't need the uart connection and I removed it from the project, but now the adc always returns 0.\r\n\r\nI don't need have to send something over the uart, but I need to run \"simple_uart_config()\", to make the adc work. without it it won't work.",
    "tag": "uart"
  },
  {
    "text": "ADC from Various Pins Hi, \r\nI want to simultaneously read the value from 3 analog pins. For this, do I create just one adc_init function and handler functions or do I need to create multiple initializing and handling functions; one per pin?\r\nThanks.",
    "tag": "adc"
  },
  {
    "text": "Reference Design of nRF51822 for 1 meter range minimum I need a reference design of nRF51822 for minimum  1 meter range . The circuit will run from [CR2032](https://www.sparkfun.com/products/338) battery for at least 24 hours and will take some readings from ADC input and sends these data to another similar circuit . The receiver circuit always waits for incoming data and when ADC values will cross threshold limit  then it will send data to receiver and receiver will execute corresponding commands . The sensors will run through external power supply , nRF51822 circuit  will just read the data and will transmit or receive and communicate among them . \r\n\r\nThe casing of the receiver will be made of [ 3mm thick Acrylic Sheet ](http://www.amazon.co.uk/Clear-Acrylic-Sheet-Size-thick/dp/B002U5I7NA)  and will be fully airtight , the pcb will be put inside the casing , the casing will be hollow type . \r\n\r\nPlease help me by providing a reference design which will meet these requirements , any idea , concept correction will be highly appreciated . Thanks in advance . ",
    "tag": "adc"
  },
  {
    "text": "BLE UART+ADC Hello,\r\n\r\nI successfully flashed the experimental_ble_app_uart, I just modified it to do an echo (when I send something with my phone uart app, it give me back the same value)\r\n\r\nnow, I'd like to use ADCs (I help me with adc_example_with_softdevice_and_UART) but when I try to use the timers:\r\n\r\n        // ADC timer handler to start ADC sampling\r\n        static void adc_sampling_timeout_handler(void * p_context)\r\n    \r\n    {\r\n    \tuint32_t p_is_running = 0;\r\n    \t\t\r\n    \tsd_clock_hfclk_request();\r\n    \twhile(! p_is_running) {  \t\t\t\t\t\t\t//wait for the hfclk to be available\r\n    \t\tsd_clock_hfclk_is_running((&p_is_running));\r\n    \t}               \r\n    \t//nrf_gpio_pin_toggle(LED_2);\t\t//Toggle LED2 to indicate start of sampling\r\n    \tNRF_ADC->TASKS_START = 1;\t\t\t\t\t\t\t//Start ADC sampling\r\n    }\r\n        static void timers_init(void)\r\n        {\r\n        \t  uint32_t err_code;\r\n        \t\r\n            // Initialize timer module\r\n        \t\tAPP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        \t\r\n        \t\terr_code = app_timer_create(&m_adc_sampling_timer_id, APP_TIMER_MODE_REPEATED,adc_sampling_timeout_handler);\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n\r\nMy application compile but doesn't run (ble not detected)\r\n\r\n(I'm using :\r\n\r\n - nRF_Examples.7.2.0\r\n - keil 5\r\n - s110_nrf51822_7.1.0_softdevice)\r\n\r\nAny ideas ?\r\nThank you\r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "BLE UART+ADC Hello,\r\n\r\nI successfully flashed the experimental_ble_app_uart, I just modified it to do an echo (when I send something with my phone uart app, it give me back the same value)\r\n\r\nnow, I'd like to use ADCs (I help me with adc_example_with_softdevice_and_UART) but when I try to use the timers:\r\n\r\n        // ADC timer handler to start ADC sampling\r\n        static void adc_sampling_timeout_handler(void * p_context)\r\n    \r\n    {\r\n    \tuint32_t p_is_running = 0;\r\n    \t\t\r\n    \tsd_clock_hfclk_request();\r\n    \twhile(! p_is_running) {  \t\t\t\t\t\t\t//wait for the hfclk to be available\r\n    \t\tsd_clock_hfclk_is_running((&p_is_running));\r\n    \t}               \r\n    \t//nrf_gpio_pin_toggle(LED_2);\t\t//Toggle LED2 to indicate start of sampling\r\n    \tNRF_ADC->TASKS_START = 1;\t\t\t\t\t\t\t//Start ADC sampling\r\n    }\r\n        static void timers_init(void)\r\n        {\r\n        \t  uint32_t err_code;\r\n        \t\r\n            // Initialize timer module\r\n        \t\tAPP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        \t\r\n        \t\terr_code = app_timer_create(&m_adc_sampling_timer_id, APP_TIMER_MODE_REPEATED,adc_sampling_timeout_handler);\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n\r\nMy application compile but doesn't run (ble not detected)\r\n\r\n(I'm using :\r\n\r\n - nRF_Examples.7.2.0\r\n - keil 5\r\n - s110_nrf51822_7.1.0_softdevice)\r\n\r\nAny ideas ?\r\nThank you\r\n\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "nRF51 DK UART to USB not working (Virtual COM port) Hi all,\r\n\r\nI'm having problems into making the virtual COM port of the nRF51 DK work.\r\n\r\nThe only line in the User guide regarding it's configuration is the following:\r\n\r\n\"Note: The terminal used must send a DTR signal in order to configure the UART Interface MCU pins.\"\r\n\r\nSo what does it mean? Which signals after the DTR signal should I send to configure the baud rate exactly?\r\n\r\nAnd what are the default parameters if I don't send anything and I just want it to work out of the box? I need to know them to configure the nrf UART in code.\r\n\r\nI'm using Mac OS X, and when I plug the board the Virtual COM port is detected as /dev/(cu|tty).usbmodem14111. Do I need some driver?\r\n\r\nThanks for your help.",
    "tag": "uart"
  },
  {
    "text": "BLE UART bidirectional connection  nRF51822DK help Greetings,\r\nMy name is Maria, I\u2019m working in an application with the nRF51822DK to communicate via Bluetooth to the USB dongle (PCA10000) and send data between them. In the module I have to do an ADC and send the result to the dongle to display it in the computer screen via UART, then I have to write a value in the computer and sent it back to the module.  I\u2019m actually getting start with this system and I have basic skills in programing, what steps do you suggest I should take?\r\nPlease help!\r\nThank you\r\n",
    "tag": "uart"
  },
  {
    "text": "BLE UART bidirectional connection  nRF51822DK help Greetings,\r\nMy name is Maria, I\u2019m working in an application with the nRF51822DK to communicate via Bluetooth to the USB dongle (PCA10000) and send data between them. In the module I have to do an ADC and send the result to the dongle to display it in the computer screen via UART, then I have to write a value in the computer and sent it back to the module.  I\u2019m actually getting start with this system and I have basic skills in programing, what steps do you suggest I should take?\r\nPlease help!\r\nThank you\r\n",
    "tag": "adc"
  },
  {
    "text": "Decimal Conversion Hi, I have just managed to successfully read ADC values and send as a service but they are in uint8 format. Is there an easy way to convert this to decimal within my adc handler?\r\nThank you for any response.",
    "tag": "adc"
  },
  {
    "text": "Event based app_uart is not working Hi,\r\nI am trying to run event based UART. here is my code snippet:\r\n\r\n    void uart_callback(app_uart_evt_t *p_app_uart_event)\r\n    {\r\n    uint8_t rxbyte;\r\n    switch(p_app_uart_event->evt_type)\r\n    {\r\n    case APP_UART_DATA_READY:\r\n\r\n            while((app_uart_get(&rxbyte) == NRF_SUCCESS))\r\n            {\r\n                rx_buffer[rx_buf_len++] = rxbyte;\r\n                if(rxbyte == '\\n')\r\n                {\r\n                    uart_putstring(rx_buffer);\r\n                    rx_buf_len = 0;\r\n                    break;\r\n                }\r\n                if(rx_buf_len == RX_BUFF_SIZE)\r\n                    break;\r\n            }\r\n\r\n            /********************************************/\r\n            /* if(app_uart_get(&rxbyte) == NRF_SUCCESS) */\r\n            /*     app_uart_put(rxbyte);                */\r\n            /********************************************/\r\n            break;\r\n        case APP_UART_TX_EMPTY:\r\n            break;\r\n        case APP_UART_COMMUNICATION_ERROR:\r\n            break;\r\n        case APP_UART_FIFO_ERROR:\r\n            break;\r\n        default:\r\n            break;\r\n\r\n    }\r\n    }\r\n    /**@brief Function for initializing the UART module.**/\r\n    static void uart_init(void)\r\n    {\r\n    static const app_uart_comm_params_t comm_params =\r\n    {\r\n        .rx_pin_no = RX_PIN_NUMBER,\r\n        .tx_pin_no = TX_PIN_NUMBER,\r\n        .rts_pin_no = RTS_PIN_NUMBER,\r\n        .cts_pin_no = CTS_PIN_NUMBER,\r\n        .flow_control = APP_UART_FLOW_CONTROL_DISABLED,\r\n        .use_parity = false,\r\n        .baud_rate = UART_BAUDRATE_BAUDRATE_Baud4800\r\n    };\r\n    uint32_t errcode = 0;\r\n\r\n    rx_buf_len = 0;\r\n    APP_UART_FIFO_INIT(&comm_params, RX_BUFF_SIZE, TX_BUFF_SIZE, uart_callback, APP_IRQ_PRIORITY_LOW, errcode);\r\n    //APP_UART_INIT(&comm_params, uart_callback, APP_IRQ_PRIORITY_LOW, errcode);\r\n    APP_ERROR_CHECK(errcode);\r\n    }\r\n\r\nin main() among others I am calling uart_init() which initialises uart and enables interrupts as you can see above in code. when uart interrupt occurs my uart_callback should be called, but when I connect 6310 motherboard's rs232 to PC nothing happens. Could you please help me? what I am doing wrong?\r\nI am using:\r\n   \r\n\r\ngcc Compiler\r\n   \r\n\r\n6310 Motherboard + pca1004\r\n   \r\n\r\nSDK Version 6.1.0.0\r\n\r\nKind Regards \r\nShuhrat",
    "tag": "uart"
  },
  {
    "text": "pulse sensor amped with RFduino doesn't work hello, my name is alessio and  i'm italian. I have got a problem with \"RFduino\" and the \"pulse sensor amped\"  ( heart rate) .\r\nI downloaded the library of the sensor in the official site but when I compile the code, the ide of the arduino detects errors of  incompatibility with the sensor and the Arduino example sketch.\r\n\r\ninterrupt : \r\n\r\n  \r\n\r\n      volatile int rate[10];                    // array to hold last ten IBI values\r\n    volatile unsigned long sampleCounter = 0;          // used to determine pulse timing\r\n    volatile unsigned long lastBeatTime = 0;           // used to find IBI\r\n    volatile int P =512;                      // used to find peak in pulse wave, seeded\r\n    volatile int T = 512;                     // used to find trough in pulse wave, seeded\r\n    volatile int thresh = 512;                // used to find instant moment of heart beat, seeded\r\n    volatile int amp = 100;                   // used to hold amplitude of pulse waveform, seeded\r\n    volatile boolean firstBeat = true;        // used to seed rate array so we startup with reasonable BPM\r\n    volatile boolean secondBeat = false;      // used to seed rate array so we startup with reasonable BPM\r\n    \r\n    \r\n    void interruptSetup(){     \r\n      TCCR1A = 0x00;\r\n    TCCR1B = 0x0C; // prescaler = 256\r\n    OCR1A = 0x7C; // count to 124\r\n    TIMSK1 = 0x02;\r\n    sei(); \r\n    } \r\n    \r\n    \r\n    // THIS IS THE TIMER 2 INTERRUPT SERVICE ROUTINE. \r\n    // Timer 2 makes sure that we take a reading every 2 miliseconds\r\n    ISR(TIMER2_COMPA_vect){                         // triggered when Timer2 counts to 124\r\n      cli();                                      // disable interrupts while we do this\r\n      Signal = analogRead(pin_viola_sensore);              // read the Pulse Sensor \r\n      sampleCounter += 2;                         // keep track of the time in mS with this variable\r\n      int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise\r\n    \r\n        //  find the peak and trough of the pulse wave\r\n      if(Signal < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI\r\n        if (Signal < T){                        // T is the trough\r\n          T = Signal;                         // keep track of lowest point in pulse wave \r\n        }\r\n      }\r\n    \r\n      if(Signal > thresh && Signal > P){          // thresh condition helps avoid noise\r\n        P = Signal;                             // P is the peak\r\n      }                                        // keep track of highest point in pulse wave\r\n    \r\n      //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT\r\n      // signal surges up in value every time there is a pulse\r\n      if (N > 250){                                   // avoid high frequency noise\r\n        if ( (Signal > thresh) && (Pulse == false) && (N > (IBI/5)*3) ){        \r\n          Pulse = true;                               // set the Pulse flag when we think there is a pulse\r\n          digitalWrite(blinkPin,HIGH);                // turn on pin 13 LED\r\n          IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS\r\n          lastBeatTime = sampleCounter;               // keep track of time for next pulse\r\n    \r\n          if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE\r\n            secondBeat = false;                  // clear secondBeat flag\r\n            for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup\r\n              rate[i] = IBI;                      \r\n            }\r\n          }\r\n    \r\n          if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE\r\n            firstBeat = false;                   // clear firstBeat flag\r\n            secondBeat = true;                   // set the second beat flag\r\n            sei();                               // enable interrupts again\r\n            return;                              // IBI value is unreliable so discard it\r\n          }   \r\n    \r\n    \r\n          // keep a running total of the last 10 IBI values\r\n          word runningTotal = 0;                  // clear the runningTotal variable    \r\n    \r\n          for(int i=0; i<=8; i++){                // shift data in the rate array\r\n            rate[i] = rate[i+1];                  // and drop the oldest IBI value \r\n            runningTotal += rate[i];              // add up the 9 oldest IBI values\r\n          }\r\n    \r\n          rate[9] = IBI;                          // add the latest IBI to the rate array\r\n          runningTotal += rate[9];                // add the latest IBI to runningTotal\r\n          runningTotal /= 10;                     // average the last 10 IBI values \r\n          BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!\r\n          QS = true;                              // set Quantified Self flag \r\n          // QS FLAG IS NOT CLEARED INSIDE THIS ISR\r\n        }                       \r\n      }\r\n    \r\n      if (Signal < thresh && Pulse == true){   // when the values are going down, the beat is over\r\n        digitalWrite(blinkPin,LOW);            // turn off pin 13 LED\r\n        Pulse = false;                         // reset the Pulse flag so we can do it again\r\n        amp = P - T;                           // get amplitude of the pulse wave\r\n        thresh = amp/2 + T;                    // set thresh at 50% of the amplitude\r\n        P = thresh;                            // reset these for next time\r\n        T = thresh;\r\n      }\r\n    \r\n      if (N > 2500){                           // if 2.5 seconds go by without a beat\r\n        thresh = 512;                          // set thresh default\r\n        P = 512;                               // set P default\r\n        T = 512;                               // set T default\r\n        lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date        \r\n        firstBeat = true;                      // set these to avoid noise\r\n        secondBeat = false;                    // when we get the heartbeat back\r\n      }\r\n    \r\n      sei();                                   // enable interrupts when youre done!\r\n    }// end isr\r\n\r\n the error is caused surely the interrupt routine but I can not solve the problem since I do not know the code to replace all ' internal program.\r\nthe error the error  printed is :\r\n_____________________________\r\n\r\nInterrupt.ino: In function 'void interruptSetup()':\r\n\r\nInterrupt.ino:16:3: error: 'TCCR1A' was not declared in this scope\r\n\r\nInterrupt.ino:17:1: error: 'TCCR1B' was not declared in this scope\r\n\r\nInterrupt.ino:18:1: error: 'OCR1A' was not declared in this scope\r\n\r\nInterrupt.ino:19:1: error: 'TIMSK1' was not declared in this scope\r\n\r\nInterrupt.ino:20:5: error: 'sei' was not declared in this scope\r\n\r\nInterrupt.ino: At global scope:\r\n\r\nInterrupt.ino:26:4: error: expected constructor, destructor, or type conversion before '(' token\r\n______________________\r\n\r\nI think that the code is not compatible with RFduino but only with arduino but I would make it compatible with it . I do not know what to change to code of internal setup interrupt.\r\nI thank everyone in advance for the help  ;D\r\n",
    "tag": "timer"
  },
  {
    "text": "Is the TWI Implementation Multi-Master? Looking to put the device on an I2C bus shared with other micro controllers to control a common sensor. Is this possible?",
    "tag": "twi"
  },
  {
    "text": "Is the TWI Implementation Multi-Master? Looking to put the device on an I2C bus shared with other micro controllers to control a common sensor. Is this possible?",
    "tag": "i2c"
  },
  {
    "text": "NRF9E5 I2C Hi,\r\n\r\n1- Many MCUs, including NRF9E5, have specialized communication ports like UART or SPI. Why not I2C? I assume that every pin can be programmed for any communication protocol if hardware allows.\r\n2- I would like to use NRF9E5 in my project where I have a few I2C sensors and ICs. Is that just an I2C (or TWI, Two Wire Interface) library enough?\r\n3- Is I2C would be your recommendation with NRF9E5? What do you prefer?",
    "tag": "i2c"
  },
  {
    "text": "NRF9E5 I2C Hi,\r\n\r\n1- Many MCUs, including NRF9E5, have specialized communication ports like UART or SPI. Why not I2C? I assume that every pin can be programmed for any communication protocol if hardware allows.\r\n2- I would like to use NRF9E5 in my project where I have a few I2C sensors and ICs. Is that just an I2C (or TWI, Two Wire Interface) library enough?\r\n3- Is I2C would be your recommendation with NRF9E5? What do you prefer?",
    "tag": "spi"
  },
  {
    "text": "NRF9E5 ADC PIN AS DIGITAL INPUT Hi,\r\n\r\nAs far as I know the ADC pins can be used as digital inputs. Is it the same with NRF9E5? I could not find anything like pros/cons. Datasheet doesnot say anything about that. If it is the case, is there anything alse you would like to contribute?\r\n\r\nNote: I plan to use it for button reading. \r\n\r\nAnything is appreciated. Thanks.",
    "tag": "adc"
  },
  {
    "text": "UART between nRF51422 and other MCU I am using a nRF51422 (SDK 6.1.0 with S310) and i have a question about th UART.\r\n\r\nI can send and receive data from/to an other MCU but i have to set different parameters to configure UART on 2 MCUs.\r\n\r\n  - **nRF51 UART configuration:**\r\n\r\n       params.baud_rate =   UART_BAUDRATE_BAUDRATE_Baud38400;\r\n       \r\n       params.tx_pin_no = TX_PIN_NUMBER;\r\n   \r\n       params.rx_pin_no = RX_PIN_NUMBER;\r\n   \r\n       params.rts_pin_no = RTS_PIN_NUMBER;\r\n   \r\n       params.cts_pin_no = CTS_PIN_NUMBER;\r\n   \r\n       params.use_parity = true;\r\n   \r\n       params.flow_control = APP_UART_FLOW_CONTROL_ENABLED;\r\n\r\n - **other MCU UART configuration:**\r\n\r\n  BaudRate = 38400;\r\n\r\n  WordLength = UART_WORDLENGTH_9B;  **9 bits????!!!**\r\n\r\n  StopBits = UART_STOPBITS_1;\r\n\r\n  huart2.Init.Parity = UART_PARITY_EVEN;\r\n  \r\n  huart2.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;\r\n\r\nIf i set 8 bits, i can't exchange data. \r\nFor information, i am using app_uart_fifo.c\r\n\r\nThanks.\r\n\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "Softdevice S310 and interrupt Hi support team,\r\n\r\nI would like to know if the following behavior is a normal behavior:\r\nMy config: NRF51422 AAE0 + S310 V2.0\r\n\r\nWhen I enable some inetrrupt like UART for example, soon I enable the softdevice by calling sd_softdevice_enable() function, the interrupt previously activated are disabled.\r\nI've looked the Interrupt Enable control register @0xE000E100 before and after the sd_softdevice_enable() function.\r\n\r\nIs it the normal behavior?\r\n\r\nThanks,\r\nBruno",
    "tag": "interrupt"
  },
  {
    "text": "TWI with S110 softdevice Enabled Hello Everyone\r\n\r\nI want to implement TWI interface in my project.Presently I am using Keil UV5 IDE, PCA10028 Development board and s110 7.1.0 softdevice, along with that PWM , UART and ADC peripherals are being used. I search for some of the question related to TWI in this forum and i have got confused.\r\n\r\n1. Can i use twi with softdevice S110  enabled without any problem?\r\n\r\n2 .Is there any example code for TWI with softdevice enabled? i have found three driver files on three different links  ***twi_hw_master.c*** in Nordic Examples\r\nOn some post it was ***sd_twi_hw_master.c*** and one ***hal_twi.c*** https://devzone.nordicsemi.com/question/15510/s120-with-twi/\r\non this link\r\n\r\nso which one should i use.\r\n\r\n\r\nThanks & Regards\r\nAsma\r\n\r\n\r\n\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Getting data from external H/W and sending over BLE Hello, I'm new to bluetooth system.\r\n\r\nI want to make some H/W device which using with sensor, MCU and Bluetooth.\r\n\r\nVery simple, MCU control the sensor and get the data, transmit data to bluetooth chip. Bluetooth chip sending to smartphone.\r\n\r\nFirst, I make this system by using bluetooth module, which use SPP Service. MCU is Arduino.\r\n\r\nJust connect the Arduino's RX, TX pin to bluetooth module's TX, RX pin.\r\n\r\nHowever, When I tried it by using nRF51DK, I find it's some difficult. \r\n\r\nI have nothing to do with any serial communication between mcu and nrf51DK(UART, I2C, SPI anything is OK)\r\n\r\nMy data is less than 20bytes(it's range is 0 to 60000, positive integer)\r\n\r\nIs there any good example for my situation? I tried to using experimental_ble_app_uart\\pca10028, But it require must using console terminal in PC.\r\n\r\nThanks for reading my question. ",
    "tag": "uart"
  },
  {
    "text": "Controlling a microservo from nRF51822 when BLE is activated I am trying to control a servo motor from nRF51822 when BLE is activated. I am using mbed development framework and libraries. \r\nMy servo example works flowlessly if BLE/SoftDevice S110 is not used. However, when I use BLE for advertising or to establish a connection to a central device, my servo starts glitching/bumping. \r\nI have seen this example that shows how to use PWM together with SoftDevice  \r\n\r\nhttps://github.com/NordicSemiconductor/nrf51-pwm-library \r\n\r\nHowever I have not been able to make it work with my servo. Is there any simple servo example?\r\n\r\nThanks!\r\n ",
    "tag": "pwm"
  },
  {
    "text": "How to get SPI Slave to work on NRF51-DK? I have been trying to get the SPI Slave to work on an NRF51-DK for about a day now and I haven't been making any progress.\r\n\r\nI first tried it with the softdevice enabled (which is needed for the final application) however I then thought that maybe that could be a problem. I therefore erased everything and relinked for a blank device.\r\n\r\nThis however did not solve the problem. \r\n\r\nI tried getting the SPI Slave example to work with an Arduino Board as Master the results are more than strange.\r\n\r\nThe registers for the SPI device seem to set correctly. The pins are selected correctly and I have tried different ones.\r\n\r\nThe problem is that while SPI_SLAVE_XFER_DONE triggers event.rx_amount and event.tx_amount is always 0 even though using a logic analyzer I can clearly see that both MOSI and MISO clock stuff.\r\n\r\nThe strange part is that MISO always clocks 0x20 as the first byte (which is nowhere in the TX Buffer) and then follows this up by clocking 55 AA AA 55 55 AA AA 55 55 etc.\r\n\r\nI already made sure that both master and slave use the same mode and bit ordering and frankly I'm at a complete loss now as to what I'm doing wrong.\r\n\r\nI checked that the NRF51-DK is actually a slave by unplugging the clock pin which resultet in MISO flatlining. Also keeping theSlave Select pin HIGH will disable the NRF51-DK as expected. \r\n\r\nI'm attaching the waveform that I got from my logic analyzer. Note that I implemented a 1ms delay between setting slaveselect to LOW and starting the clock.\r\n[SPI Waveform.csv](/attachment/a4630f1b7813dd70e8a73522f47d436d)\r\n[SPI Waveform.png](/attachment/8754eee0f82bb452eb32729337d1f3a6)\r\n",
    "tag": "spi"
  },
  {
    "text": "twi_sw_master.c compilation error Hello,\r\n\r\nI am working with the nRF DK trying to read a sensor over I2C. I wrote some code in Keil uVision and I finally could read the sensor. The problem now is, for some weird reason I can't figure out, the twi_sw_master.c file gives some compilation errors.\r\n\r\n        compiling twi_sw_master.c...\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(136): error:  #254: type name is not allowed\r\n              for (uint_fast8_t i=18; i--;)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(136): error:  #65: expected a \";\"\r\n              for (uint_fast8_t i=18; i--;)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(136): error:  #20: identifier \"i\" is undefined\r\n              for (uint_fast8_t i=18; i--;)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(311): error:  #254: type name is not allowed\r\n          for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(311): error:  #65: expected a \";\"\r\n          for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(311): error:  #20: identifier \"i\" is undefined\r\n          for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(384): error:  #254: type name is not allowed\r\n          for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(384): error:  #65: expected a \";\"\r\n          for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(384): error:  #20: identifier \"i\" is undefined\r\n          for (uint_fast8_t i = 0x80; i != 0; i>>=1)\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c(474): warning:  #1-D: last line of file ends without a newline\r\n      /*lint --flb \"Leave library region\" */\r\n    RTE\\nRF_Drivers\\nRF51422_xxAB\\twi_sw_master.c: 1 warning, 9 errors\r\n    \".\\Objects\\mag3110.axf\" - 9 Error(s), 1 Warning(s).\r\n    Target not created.\r\n    Build Time Elapsed:  00:00:01\r\n\r\nI can't understand what the problem is. I researched about #254 error but the explanation doesn't help that much. \r\n\r\nThis is the file:\r\n\r\nhttps://github.com/finnurtorfa/nrf51/blob/master/lib/nrf51sdk/Nordic/nrf51822/Source/twi_master/twi_sw_master.c \r\n\r\nI used that file because I was getting compiling errors with the original one. I am getting the same errors with the new. \r\n\r\nDoes anyone know what the problem is?\r\n\r\nThank you.",
    "tag": "twi"
  },
  {
    "text": "UART and SPI Hi guys, \r\n\r\nI encoutered a problem when using UART and SPI. I use the experimental_ble_app_uart as base and added the code for the SPI from the spi master example. Each one individually works fine but when used together it doesn't work anymore. More precisely: the SPI will not send more than the first two bytes once I have used the UART to the device (RX). When I only use the UART TX it still works ok.\r\nI think it has something to do with interrupts and priority? But I can't quite understand it yet. \r\nAny suggestions?\r\n\r\nSetup:\r\nSDK 7.2\r\nPCA10028, NRF51422\r\nEclipse/GCC\r\nSoftdevice S110\r\n\r\n\r\nthanks for any help",
    "tag": "spi"
  },
  {
    "text": "UART and SPI Hi guys, \r\n\r\nI encoutered a problem when using UART and SPI. I use the experimental_ble_app_uart as base and added the code for the SPI from the spi master example. Each one individually works fine but when used together it doesn't work anymore. More precisely: the SPI will not send more than the first two bytes once I have used the UART to the device (RX). When I only use the UART TX it still works ok.\r\nI think it has something to do with interrupts and priority? But I can't quite understand it yet. \r\nAny suggestions?\r\n\r\nSetup:\r\nSDK 7.2\r\nPCA10028, NRF51422\r\nEclipse/GCC\r\nSoftdevice S110\r\n\r\n\r\nthanks for any help",
    "tag": "uart"
  },
  {
    "text": "UART and SPI Hi guys, \r\n\r\nI encoutered a problem when using UART and SPI. I use the experimental_ble_app_uart as base and added the code for the SPI from the spi master example. Each one individually works fine but when used together it doesn't work anymore. More precisely: the SPI will not send more than the first two bytes once I have used the UART to the device (RX). When I only use the UART TX it still works ok.\r\nI think it has something to do with interrupts and priority? But I can't quite understand it yet. \r\nAny suggestions?\r\n\r\nSetup:\r\nSDK 7.2\r\nPCA10028, NRF51422\r\nEclipse/GCC\r\nSoftdevice S110\r\n\r\n\r\nthanks for any help",
    "tag": "interrupt"
  },
  {
    "text": "ADC with UART nRF51422 Hi, I've been trying for a couple of days to get the example code from GitHub (https://github.com/NordicSemiconductor/nrf51-ADC-examples) to work on my nRF51422 (Using the PCA10028 board).\r\n\r\nI used the \"ADC example with UART and BLE connectivity\" example, but since I don't need the BLE part yet, I removed it. When I try to compile the project I get the following errors:\r\n\r\nBuild target 'nrf51422_xxac'  \r\ncompiling main.c...  \r\nlinking...  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_error_handler (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_timer_create (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_timer_init (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_timer_start (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_uart_put (referred from main.o).    \r\nNot enough information to list image symbols.  \r\nFinished: 1 information, 0 warning and 5 error messages.  \r\n\".\\_build\\nrf51422_xxac.axf\" - 5 Error(s), 0 Warning(s).   \r\n\r\nI feel like I need to include another file, but I don't know what I'm missing. I've included the following:\r\n\r\n\\#include <stdbool.h>  \r\n\\#include <stdint.h>  \r\n\\#include \"simple_uart.h\"  \r\n\\#include \"nordic_common.h\"  \r\n\\#include \"nrf.h\"  \r\n\\#include \"nrf_soc.h\"  \r\n\\#include \"bsp.h\"  \r\n\\#include \"board_config.h\"  \r\n\\#include \"app_timer.h\"  \r\n\\#include \"app_util_platform.h\"  \r\n\\#include \"app_uart.h\"  \r\n\\#include \"pca10028.h\"  \r\n\r\nWhat am I missing?",
    "tag": "uart"
  },
  {
    "text": "ADC with UART nRF51422 Hi, I've been trying for a couple of days to get the example code from GitHub (https://github.com/NordicSemiconductor/nrf51-ADC-examples) to work on my nRF51422 (Using the PCA10028 board).\r\n\r\nI used the \"ADC example with UART and BLE connectivity\" example, but since I don't need the BLE part yet, I removed it. When I try to compile the project I get the following errors:\r\n\r\nBuild target 'nrf51422_xxac'  \r\ncompiling main.c...  \r\nlinking...  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_error_handler (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_timer_create (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_timer_init (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_timer_start (referred from main.o).  \r\n.\\_build\\nrf51422_xxac.axf: Error: L6218E: Undefined symbol app_uart_put (referred from main.o).    \r\nNot enough information to list image symbols.  \r\nFinished: 1 information, 0 warning and 5 error messages.  \r\n\".\\_build\\nrf51422_xxac.axf\" - 5 Error(s), 0 Warning(s).   \r\n\r\nI feel like I need to include another file, but I don't know what I'm missing. I've included the following:\r\n\r\n\\#include <stdbool.h>  \r\n\\#include <stdint.h>  \r\n\\#include \"simple_uart.h\"  \r\n\\#include \"nordic_common.h\"  \r\n\\#include \"nrf.h\"  \r\n\\#include \"nrf_soc.h\"  \r\n\\#include \"bsp.h\"  \r\n\\#include \"board_config.h\"  \r\n\\#include \"app_timer.h\"  \r\n\\#include \"app_util_platform.h\"  \r\n\\#include \"app_uart.h\"  \r\n\\#include \"pca10028.h\"  \r\n\r\nWhat am I missing?",
    "tag": "adc"
  },
  {
    "text": "Why is UUID in wrong order? Hi,\r\n\r\nThis time I am trying to work out the UART example.\r\n\r\nI got it to the point where it is advertising, but the advertisement is wrong.\r\n\r\nWhen I check with an Android phone, the advertisement data is all the way around.\r\nThis should be the advertised one: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E\r\nAnd the received one: 9eca0001-0ee5-a9e0-93f3-a3b50100406e\r\n\r\nI followed [this thread](https://devzone.nordicsemi.com/question/639/how-can-i-use-a-vendor-specific-uuid/) but it did not help.\r\n\r\nI tried modifying the advertisement data in the ble_nus_init:\r\n\r\n> ble_uuid128_t   nus_base_uuid = {0, 0,\r\n> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n> 0};\r\n> \r\n> ble_uuid128_t   nus_base_uuid = {0x9E,\r\n> 0xCA, 0xDC, 0x24, 0x0E, 0xE5, 0xA9,\r\n> 0xE0, 0x93, 0xF3, 0xA3, 0xB5, 0x00,\r\n> 0x00, 0x40, 0x6E};\r\n> \r\n> ble_uuid128_t   nus_base_uuid = {0x6E,\r\n> 0x40, 0x00, 0x00, 0xB5, 0xA3, 0xF3,\r\n> 0x93, 0xE0, 0xA9, 0xE5, 0x0E, 0x24,\r\n> 0xDC, 0xCA, 0x9E};\r\n\r\nBut the received advertisement data always stayed the same.\r\nThe ble_nus functions are coming from this [site](https://github.com/NordicSemiconductor/nrf51-UART-examples). The main function is a modified of that (removed all the parts, only kept the service_init and the advertisement_init).\r\n\r\nThanks for the help!",
    "tag": "uart"
  },
  {
    "text": "why are there 8 bits to select the analog input I'm just reading the documentation regarding the analog digital converter and wonder why there is one bit in the configuration register for every analog input. What will happen when I set more than one bit in CONFIG.D?\r\n\r\ncheers Torsten",
    "tag": "adc"
  },
  {
    "text": "Can't get a ADC result that makes sense Hi,\r\n\r\nI'm working on a simple ADC application where I sample using analog channel 1 and then read the value through the debugger. However my results are nonsense. I have connected a potmeter with VDD on the right pin, ground on the left and the analog input as the center pin. No matter which analog pin I connect the center potmeter pin to, i get a value around 0x50. I feel I have forgotten to set-up the analog input pin. It's like there's missing a connection between the input-pin and the ADC.\r\n\r\n\r\n    \\#include <stdbool.h> \r\n    \\#include \"nrf.h\" \r\n    \\#include \"nrf_delay.h\" \r\n    \\#include \"nrf_gpio.h\" \r\n\r\n\r\n    uint32_t result = 0;\r\n\r\n    /** Configures port 1 as output */\r\n    static void gpio_config(void)\r\n    {\r\n      nrf_gpio_range_cfg_output(8, 15);\r\n      nrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT1, 0);\r\n\t\r\n\t    nrf_gpio_cfg_input(20, NRF_GPIO_PIN_PULLUP);\t\t//BUTTON 4\r\n\t    nrf_gpio_cfg_output(23);\t\t\t\t\t\t//LED 3\r\n\t    nrf_gpio_cfg_output(24);\t\t\t\t\t\t//LED 4\r\n\t\r\n\t    //Interupt on button 4\r\n\t    NVIC_EnableIRQ(GPIOTE_IRQn);\r\n            NRF_GPIOTE->CONFIG[0] = (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos)\r\n                            | (20 << GPIOTE_CONFIG_PSEL_Pos)\t\t\t\t//BUTTON 4\r\n                            | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\r\n    NRF_GPIOTE->INTENSET = GPIOTE_INTENSET_IN0_Set << GPIOTE_INTENSET_IN0_Pos;\r\n\r\n    }\r\n\r\n    void GPIOTE_IRQHandler(void)\r\n    {\r\n        // Event causing the interrupt must be cleared.\r\n        if ((NRF_GPIOTE->EVENTS_IN[0] == 1) &&\r\n            (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN0_Msk))\r\n        {\r\n            NRF_GPIOTE->EVENTS_IN[0] = 0;\r\n    \t\t\t\tnrf_gpio_pin_toggle(23);\r\n    \t\t\t\tNRF_ADC->TASKS_START = 1;\r\n        }\r\n    }\r\n\r\n    /** Configures and enables the ADC */\r\n    void ADC_init(void)\r\n    {\t\r\n\t/* Enable interrupt on ADC sample ready event*/\t\t\r\n\t    NRF_ADC->INTENSET = ADC_INTENSET_END_Msk;\r\n\t    NVIC_EnableIRQ(ADC_IRQn);\t\r\n\t\r\n\t\r\n\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) \t\t\t\t\t\t\t\t\t\t/* Bits 17..16 : No external reference. */\r\n\t\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput1 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t\t\t\t\t\t\t/*!< Use analog input 1 as analog input. */\r\n\t\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling << ADC_CONFIG_REFSEL_Pos)\t\t\t/*!< Use VDD/3 */\r\n\t\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) \t\t\t/*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */\r\n\t\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/*!< 8 bit */\r\n\t\r\n\t/* Enable ADC*/\r\n\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\t\r\n    }\r\n\r\n    /* Interrupt handler for ADC data ready event */\r\n    void ADC_IRQHandler(void)\r\n    {\r\n\t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n\r\n      /* Write ADC result to port 1 */\r\n     \t//nrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT1, NRF_ADC->RESULT); \r\n\t    nrf_gpio_pin_toggle(24);\r\n\t\r\n\t    //Use the STOP task to save current. Workaround for PAN_028 rev1.2 anomaly 1.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n\t\r\n\t    //Write result\r\n\t    result = NRF_ADC->RESULT;  \r\n    }\r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "GPIO ADC and S210 Hi,\r\nI am developing an application to capture data on a PC over ANT+ using the ANTUSB-m as slave and the nRF51 DK as master.\r\n\r\nIn order to test my program I want to be able to measure a GPIO input on the DK and send the value over ANT+ to the USB device.\r\n\r\nMy problem is that I'm not really a coder and I am really just looking for a quick and dirty solution for the testing. Is it possible to combine the speed and cadence example from the Keil library with the 'adc sampling' example in Github and then send the result of the adc instead of the speed and cadence that the Keil demo creates? (does that make sense?)\r\n\r\nI have noticed that the examples in GitHub are all for the nRF51822 so won't support the S210 softdevice for ANT.\r\n\r\nMy problem is similar to [this](https://devzone.nordicsemi.com/question/24192/adc-in-the-nrf51822-or-nrf51422/) post but for S210.\r\n\r\nThanks in advance,\r\n\r\nDarren.",
    "tag": "adc"
  },
  {
    "text": "Trouble with communication between two nRF24L01+ chips I have worked with the nRF24L01+ for a couple of days now without getting it to work.\r\nThe setup of the chip is done as described below, without any luck of getting a communication going from one chip to another. The routines are tested on a board with a TM4C123G micro controller with two nRF24L01+ breakout boards mounted to two separate SPI channels. The SPI communication seems to work fine (checked with a scope).\r\n\r\nNo matter what data is sent, the received data is all zeros. The status register does not change on either of the nRF24L01+ chips and seems to be the same before and after a send/receive.\r\n\r\nHopefully some of you can verify that the routines below is correct or point out the mistakes. Any help is appreciated.\r\n\r\nThanks in advance :-)\r\n\r\n**Read/Write routine**\r\n\r\n1. Wait 10 \u00b5s\r\n2. Set CS low (chip select)\r\n3. SPI put (W_REGISTER + register address)\r\n4. SPI get STATUS byte\r\n5. For all data bytes\r\n      1. If read mode: SPI put NOP and save returned value from SPI get\r\n      2. If write mode: SPI put data byte and discard returned value from SPI get\r\n      3. Wait 10 \u00b5s (for each byte)\r\n6. Set CS high (chip deselect)\r\n\r\n\r\n**Initialization**\r\n\r\nWith the Read/Write routine shown above, the following operations are done in order to initialize the device (after voltage is applied to the MCU and nRF24L01+):\r\n![image description](/attachment/17aa173e08d1d077303f68d05e17394e)\r\n\r\n\r\n**Reset**\r\n\r\n1. Set CS low (select chip)\r\n2. Wait 10 \u00b5s\r\n3. SPI Put 0x27 (W_REGISTER + STATUS)\r\n4. Read 1 byte with SPI (discarded STATUS byte)\r\n5. Wait 10 \u00b5s\r\n6. SPI Put 0x70 (Clear IRQ bits in STATUS)\r\n7. Read 1 byte with SPI (discarded STATUS byte)\r\n8. Wait 10 \u00b5s\r\n9. Set CS high (deselect chip)\r\n\r\n\r\n**Transmit**\r\n\r\n1. Send FLUSH_TX command\r\n2. Send W_TX_PAYLOAD with 5 byte data\r\n3. Wait 10 \u00b5s\r\n4. Set CE high (chip enable)\r\n5. Wait 20 \u00b5s\r\n6. Set CE low (chip disable)\r\n7. Wait 10 \u00b5s\r\n\r\n\r\n**Receive**\r\n\r\n1. Set CE high (chip enable)\r\n2. Wait 130 \u00b5s\r\n3. Send command R_RX_PAYLOAD and save 5 bytes of data\r\n4. Reset registers (with routine above)\r\n5. Wait 130 \u00b5s\r\n6. Set CE low (chip disable)",
    "tag": "spi"
  },
  {
    "text": "nRF24LU1 TWI (I2C) Support? Curious if there are any available bit-bang TWI routines available for the nRF24LU1?\r\n\r\nThanks!\r\n-Tim",
    "tag": "twi"
  },
  {
    "text": "nRF24LU1 TWI (I2C) Support? Curious if there are any available bit-bang TWI routines available for the nRF24LU1?\r\n\r\nThanks!\r\n-Tim",
    "tag": "i2c"
  },
  {
    "text": "Correctly scaling and biasing a microphone preamp input to nRF51822 I'm using the MAX9814 electret pre-amp's output as an input to an analog pin of the nRF51822. The MAX9814 has a 1.2V swing at 1.2V DC (so it goes from 0 to 2.4V). VDD for the nRF51822 and the MAX9814 is 3V.\r\n\r\nI believe that a direct connection (MAX9814 MICOUT -> nRF51822 An) should work with a 1/1 scaling and VDD as reference, although I will lose 0.4V of the range (2.6--3V). Any potential issues with this setup?\r\n\r\nIf I wanted to use a DC block capacitor (MAX9814 MICOUT -> CAP_DC -> nRF51822 An), what is the best biasing scheme to use in order to get a full resolution? I looked through the datasheet, but the scaling doesn't quite work in my case unless I add another reference voltage, which isn't ideal. Any advice? Any reference resources? (I prefer to avoid using a voltage divided for AREF, as the board space is very tight).\r\n\r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Unexpected system reset(may caused with spi and twi conflict) Hi, Guys,\r\n\r\nI have occured a wired thing. I use NRF51822 with softdevice S130 to do a BLE project. I use both spi and twi to get information from sensor(I use spi0 and twi1, I know that the spi0 and twi0 share the same base address). However, after power on, the chip continuously reset itself. The reset reason is 0x08 cpu lock-up. The wired thing is, this won't happen during the debug session. only happen on regular power-on session. So I can not even debug where goes wrong. Does anyone who may know this? Thank you so much. \r\n\r\nI use twi_hw_master and spi_master from the SDK V7.1.0, but I use SHORTS in twi_hd_master instead of PPI.\r\n\r\nUPDATE: after tried several times, I think I know what's going on, the thing is SPI and TWI can not coexist. If I disable one of these two, the system works fine. But I still don't know why, because I use SPI0 and TWI1, there two peripheral didn't share the resource. Does any one know why?",
    "tag": "spi"
  },
  {
    "text": "Unexpected system reset(may caused with spi and twi conflict) Hi, Guys,\r\n\r\nI have occured a wired thing. I use NRF51822 with softdevice S130 to do a BLE project. I use both spi and twi to get information from sensor(I use spi0 and twi1, I know that the spi0 and twi0 share the same base address). However, after power on, the chip continuously reset itself. The reset reason is 0x08 cpu lock-up. The wired thing is, this won't happen during the debug session. only happen on regular power-on session. So I can not even debug where goes wrong. Does anyone who may know this? Thank you so much. \r\n\r\nI use twi_hw_master and spi_master from the SDK V7.1.0, but I use SHORTS in twi_hd_master instead of PPI.\r\n\r\nUPDATE: after tried several times, I think I know what's going on, the thing is SPI and TWI can not coexist. If I disable one of these two, the system works fine. But I still don't know why, because I use SPI0 and TWI1, there two peripheral didn't share the resource. Does any one know why?",
    "tag": "twi"
  },
  {
    "text": "Change GPIO definition I have a nRF51 DK with 8 additional LEDs on P3 and a temperature Sensor from Sensirion(SHT2x). I know that the nRF51422 has an internal temperature sensor but I prefer to use an external. First, I will test the Sensor without the SoftDevice.\r\n\r\n*Goal:\r\nRead the value of the Temperature trough I2C and represent the value on the additional LEDs on P3.* \r\n\r\nSensor connection to nRF51 DK:\r\n\r\n-VDD(3.3V) on VDD\r\n\r\n-VSS on GND\r\n\r\n-SCL on P0.07\r\n\r\n-SDA on P0.30\r\n\r\nIn the sdk there is a twi_sw_master_example which I want to modify for my application(SDK 6.1). Is there a newer example? I've been looking for it in SDK 8.0 but didnt find anything. Or is there an example which reads the value of an external temperatur sensor trough I2C?\r\n\r\nThe problem is:\r\n\r\nThe twi_sw_master_example is for an older Hardware. So I will need to change the GPIO definitions. I think that the nrf_gpio.h file should define all GPIO, but I cant realy find out where are all Ports and Pins defined. \r\n\r\nFrom the nrf_gpio.h file I have this:\r\n\r\nHere, the GPIO ports are defined as follows:\r\n\r\n - Port 0 -> pin 0-7\r\n\r\n - Port 1 -> pin 8-15\r\n\r\n - Port 2 -> pin 16-23\r\n\r\n - Port 3 -> pin 24-31\r\n\r\n\r\nBut this is only a comment. Where will it be defined?\r\n\r\nOn the nRF51DK is Port 3 -> P0.12-P0.19.\r\n\r\nWhere I have to change the Port definitions?\r\n\r\nAnd in the twi_master_config.h file I see the definition for SCL and SDA:\r\n\r\n  #define TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER (24U)\r\n  \r\n  #define TWI_MASTER_CONFIG_DATA_PIN_NUMBER (25U)\r\n\r\nWhats is this U after the number standing for?\r\n",
    "tag": "twi"
  },
  {
    "text": "nrf UART 2.0 project Hi,\r\n\r\nI am working on a project regarding a portable device for healthcare monitoring. This device will have a nrf8001 module integrated that will communicate with a iOS smartphone through the nrf UART app 2.0. Now this is a standalone app and my idea was to use include that app in a bigger one that controls all the tasks that has to be performed by the portable device. Do you know if there is any similar project? where they took the nrf UART 2.0 app source code and they integrated it in a bigger app (also modifying it, if necessary). I have low experience with objective-C programming so it would be useful to have some references. I understood the source code for the nrf APP but it's hard to include it in a bigger app (storyboard with multiple windows and so on).\r\n\r\nThanks.\r\nClaudio'",
    "tag": "uart"
  },
  {
    "text": "SoftDevice Safe TWI Implementation Broke with SDK 8.0.0 So I've been using a user submitted SD safe TWI implementation that I found here. This has worked well so far, but upon updating to SDK 8.0.0 parts have broken. Now when I perform reads it continues to read past the correct number of bytes for long period of time. I'm diving into the details of the TWI implementation now, but I'm not well versed in PPI at all so I was hoping someone here might have some thoughts on the issue. \r\n\r\nFinally, will Nordic PLEASE officially support SoftDevice safe TWI? It's clearly possible and a problem faced by many developers. It seems like each user submitted solution has it's own nuances, and this is the second time I'm having major problems with it.\r\n\r\nThe implementation I'm using is this: [twi_hw_master_sd.c](/attachment/f265cf1042badd35f680064144fba66b) ",
    "tag": "twi"
  },
  {
    "text": "SoftDevice Safe TWI Implementation Broke with SDK 8.0.0 So I've been using a user submitted SD safe TWI implementation that I found here. This has worked well so far, but upon updating to SDK 8.0.0 parts have broken. Now when I perform reads it continues to read past the correct number of bytes for long period of time. I'm diving into the details of the TWI implementation now, but I'm not well versed in PPI at all so I was hoping someone here might have some thoughts on the issue. \r\n\r\nFinally, will Nordic PLEASE officially support SoftDevice safe TWI? It's clearly possible and a problem faced by many developers. It seems like each user submitted solution has it's own nuances, and this is the second time I'm having major problems with it.\r\n\r\nThe implementation I'm using is this: [twi_hw_master_sd.c](/attachment/f265cf1042badd35f680064144fba66b) ",
    "tag": "i2c"
  },
  {
    "text": "Interrupt from external Pin doesn't trigger with short pulse? Hi,  \r\nI need to implement a simple external interrupt triggered by another IC on a nrf51822.\r\nAfter searching the devzone I found the example in the GIT repo (https://github.com/Rallare/nrf51_app_gpiote_example) which I used.\r\n\r\nEverything works fine when I use a button, but when I change the pin to the one I actually want, it doesn't work.\r\nThe signal is a 500ns long pulse (high) with 250Hz. I don't get the interrupt (neither rising nor falling edge). Is the pulse too short to detect? Shouldn't it be the edge that is detected?\r\n\r\nThanks in advance.\r\n\r\nNo\u00e9",
    "tag": "interrupt"
  },
  {
    "text": "interrupts and critical section Is it possible for gpiote_event_handler interrupt to get executed while the program is executing code inside timer_event_handler?\r\n\r\nThese events modify same variables so to be safe I put CRITICAL_REGION_ENTER/EXIT in both of them but is that necessary?",
    "tag": "interrupt"
  },
  {
    "text": "Why doesn't the TWI transmit an address? Using the nRF51422 with the TWI hardware version. Just playing around to verify signals with the following code which just configures the TWI1 and then repeats continuously with a master transmit of one data byte=0x57. \r\n\r\nI get a 7 clock transitions on SCL along with the 0x57 on the SDA, but it never transmits the addresss. It seems once data is placed in the TXD, it automatically sends it out. I have tried reversing the start and TXD register steps as in the canned code and add a stop task but it is always the same, no address. What am I doing wrong?\r\n\r\nthanks\r\n\r\n    /******************************************************************************************************************/\r\n    twi_master_config();\r\n    nrf_delay_ms(100);\r\n    \r\n    NRF_TWI1->ADDRESS=0x78;\r\n    \r\n    \twhile(1)  //endless single byte transmission\r\n    \t{\r\n    \t\tNRF_TWI1->TASKS_STARTTX=1;\r\n    \t\tNRF_TWI1->TXD=0X57;\r\n    \t\tnrf_delay_ms(10);\r\n    \t}\r\n    \t\r\n    \t\r\n    void twi_master_config(void)\r\n    {\r\n       NRF_TWI1->ENABLE=0;\t//disable TWI\r\n    \t\r\n       NRF_GPIO->PIN_CNF[2] = \r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)\r\n          | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)\r\n          | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)\r\n          | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos);    \r\n    \r\n        NRF_GPIO->PIN_CNF[0] = \r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)\r\n          | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)\r\n          | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)\r\n          | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos); \t\r\n    \t\t\t\r\n      NRF_TWI1->EVENTS_RXDREADY = 0;\r\n      NRF_TWI1->EVENTS_TXDSENT = 0;\r\n      NRF_TWI1->PSELSCL = 0x00000002;  //SCL\r\n      NRF_TWI1->PSELSDA = 0x00000000;  //SDA\r\n      NRF_TWI1->FREQUENCY = 0x01980000; //100k\r\n      NRF_PPI->CH[0].EEP = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n      NRF_PPI->CH[0].TEP = (uint32_t)&NRF_TWI1->TASKS_SUSPEND;\r\n      NRF_PPI->CHENCLR = PPI_CHENCLR_CH0_Msk;\r\n      NRF_TWI1->ENABLE = 1;\r\n    }\r\n    \r\n    /******************************************************************************************************************/\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Why doesn't the TWI transmit an address? Using the nRF51422 with the TWI hardware version. Just playing around to verify signals with the following code which just configures the TWI1 and then repeats continuously with a master transmit of one data byte=0x57. \r\n\r\nI get a 7 clock transitions on SCL along with the 0x57 on the SDA, but it never transmits the addresss. It seems once data is placed in the TXD, it automatically sends it out. I have tried reversing the start and TXD register steps as in the canned code and add a stop task but it is always the same, no address. What am I doing wrong?\r\n\r\nthanks\r\n\r\n    /******************************************************************************************************************/\r\n    twi_master_config();\r\n    nrf_delay_ms(100);\r\n    \r\n    NRF_TWI1->ADDRESS=0x78;\r\n    \r\n    \twhile(1)  //endless single byte transmission\r\n    \t{\r\n    \t\tNRF_TWI1->TASKS_STARTTX=1;\r\n    \t\tNRF_TWI1->TXD=0X57;\r\n    \t\tnrf_delay_ms(10);\r\n    \t}\r\n    \t\r\n    \t\r\n    void twi_master_config(void)\r\n    {\r\n       NRF_TWI1->ENABLE=0;\t//disable TWI\r\n    \t\r\n       NRF_GPIO->PIN_CNF[2] = \r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)\r\n          | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)\r\n          | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)\r\n          | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos);    \r\n    \r\n        NRF_GPIO->PIN_CNF[0] = \r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)\r\n          | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)\r\n          | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)\r\n          | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos); \t\r\n    \t\t\t\r\n      NRF_TWI1->EVENTS_RXDREADY = 0;\r\n      NRF_TWI1->EVENTS_TXDSENT = 0;\r\n      NRF_TWI1->PSELSCL = 0x00000002;  //SCL\r\n      NRF_TWI1->PSELSDA = 0x00000000;  //SDA\r\n      NRF_TWI1->FREQUENCY = 0x01980000; //100k\r\n      NRF_PPI->CH[0].EEP = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n      NRF_PPI->CH[0].TEP = (uint32_t)&NRF_TWI1->TASKS_SUSPEND;\r\n      NRF_PPI->CHENCLR = PPI_CHENCLR_CH0_Msk;\r\n      NRF_TWI1->ENABLE = 1;\r\n    }\r\n    \r\n    /******************************************************************************************************************/\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Using I2C, NUS, and Two Timer Interrupts - Reading Sensor from both Timer Interrupts - Custom Board with MCU NordicSemi nRF51822-QFAA\r\n\r\n- Softdevice S110 7.1\r\n\r\n- IAR for ARM 7.1\r\n\r\n- SDK 7.2 using NUS example\r\n\r\n- Testing with iPhone 5S, 6 and iPad air (iOS 8.1.3)\r\n\r\n / Nexus 5 and Galaxy Note 3 (Android 4.4.2).\r\n\r\n/************************************************************************/\r\n\r\nHi, I'm using a relative humidity + temperature sensor (SI7020-A10).\r\n\r\n[Datasheet SI7020-A10.pdf](/attachment/ba8d02903b3daa7b5505d0a47cb69732)\r\n\r\n\r\nAfter I connect with a test device (iOS device or Android device),\r\n\r\ntwo timers starts. (Lets say I use timer timer1 and timer2.\r\n\r\nTimer1's interval is 3 second and timer2's interval is 10 seconds.)\r\n\r\n\r\n\r\nBoth timer interrupts reads my sensor's data. Then timer1 sends the data\r\n\r\nusing NUS to the app.\r\n\r\nOne concern is that after 30 seconds (which is the least common multiple of each intervals)\r\n\r\nboth interrupts will read the sensor.\r\n\r\nI'm worried that would it cause problems or not.\r\n\r\n/************************************************************************/\r\n\r\nSo my questions are,\r\n\r\n0.Does both timer interrupt has the same priority?\r\n\r\n1.What exactly happens at each 30 seconds?\r\n\r\nFor example, when I start timer1 and timer2, even though 30 seconds pasts,\r\n\r\ntimer1 interrupt will occur first than timer2. Does the Program Counter jumps immediately \r\n\r\nto the timer2 interrupt handler before finishing timer1 interrupt handler?\r\n\r\nOr does it jumps later after it finishes the first interrupt handler?\r\n\r\n2.Is this fine for each timer interrupts to read the sensor? I'm worried it is okay\r\n\r\nwhether it works properly or not.\r\n\r\n\r\n-Regards, Mango922\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "nrf8001 interrupt I am using an Arduino and NRF8001 break out board from Adafruit. I am using the UART profile (adafruit sample code) to send data between mobile phone and Arduino. However, I don't want my arduino to look for serial data at all times. \r\n\r\nI am thinking their should be a way that NRF8001 can send an interrupt signal to Arduino to wakeup, if data is available?\r\n\r\nIs that a possibility? I couldn't figure out. I have came across /RDY terminal, but it doesn't seem to be able to do the above. \r\n\r\nThanks\r\nHani",
    "tag": "interrupt"
  },
  {
    "text": "nrf51422/ nrf51822 compatibility with nrf8001 ACI Interface Hi All,\r\n\r\nHas anyone mimicked the nrf8001 ACI interface over SPI on the nrf51x22 devices using S110 soft device?\r\n\r\nI am interested in increasing throughput by using 6 packets per connection interval with an interval of 7.5 ms but would like to retain code compatibility with the nrf8001 on the host processor.\r\n\r\nI would like to know if this is possible or if there is another solution that achieves the same goal. \r\n\r\nThe nrf51x22 devices also have a more attractive package type than the nrf8001.\r\n\r\nThanks, Kirem",
    "tag": "spi"
  },
  {
    "text": "Attach an SPI sensor to the NRF51822 beacon? Hi,\r\nI intend to buy the NRF51822 beacon to use it to transmit data from an SPI-linked sensor. Is this feasible? (It seems so, but I just want to make sure). Also, will I be able to program the beacon to acquire and send data according to a schedule I choose or, for instance, to first fill in its RAM with sensor data and then to transmit all the data?\r\nThanks,\r\nAndrei",
    "tag": "spi"
  },
  {
    "text": "If I want to read the battery level, can I just use ADC? I would like to send the current status of the battery as a beacon.\r\n\r\nADC and a few resistors and what do I need?\r\n\r\nI am currently using nrf51822.\r\n\r\nI know nrf51822 to support the 10bit ADC.\r\n\r\nJust supply the + and - connections on the battery level nrf51822 Can I read?\r\n\r\nAnd do I need additional hardware is what?\r\n\r\nAnd do I need additional software (Source) is what?",
    "tag": "adc"
  },
  {
    "text": "Timer handler not called I know this was asked before, but none of the posts address my problem. There is a similar thread , but the issue on that one was that the softdevice was not being used. I'm using S210 softdevice and trying to make a current efficient delay using a timer, but my handler is never called: \r\n\r\n    // do nothing\r\n    \r\n    static void delay(void * p_context)\r\n    \r\n    {\r\n    \r\n    // do nothing\r\n    \r\n    }\r\n    \r\n    \r\n     app_timer_id_t module_init(void)\r\n    \r\n    {\r\n    \r\n    \t\r\n        // Initialize and start a single shot timer, which is used as a delay\r\n    \r\n        APP_TIMER_INIT(RTC_PRESCALER, 1u, 1u, false);\r\n        app_timer_id_t timer_id;\r\n        uint32_t err_code = app_timer_create(&timer_id, APP_TIMER_MODE_SINGLE_SHOT, delay);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n    \t\r\n    \treturn (timer_id);\r\n    }\r\n    \r\n    \t\r\n    \r\n    app_timer_id_t timer_id;\r\n    \t\r\n    {\r\n    .\r\n    .\r\n    .\r\n    \r\n       timer_id = module_init(); \r\n    \r\n       uint32_t err_code = app_timer_start(timer_id, 50u, NULL);  \r\n    \r\n       app_timer_stop(timer_id);\r\n    \t\r\n    .\r\n    .\r\n    .\r\n    .\r\n    }\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "Is the nRF8001 recommend for new design Reading the following post:\r\n\r\nhttps://devzone.nordicsemi.com/question/5945/nrf51822-vs-nrf8001-when-having-an-external-mcu/\r\n\r\nmade me think that I could use either the nRF51822 or nRF8001 in my design.  However, the following post:\r\n\r\nhttps://devzone.nordicsemi.com/question/22410/nrf8001-communication-msp430-and-uart/\r\n\r\nmakes me think that the nRF8001 probably isn't well supported like the nRF51822.  For example, having to use the windows nRFgo to setup the header file (For the nRF51822 I use the SDK on my Mac).  Also using Arduino code that you convert as the basis for the design makes me wonder if this board is becoming an afterthought.\r\n\r\nAll I need in my design is UART passthrough, which is why I was thinking about using the nRF8001, but I can use the nRF51822 - just has more features than I need.\r\n\r\nIs it true that nRF8001 is BLE 4.0 and not BLE 4.1.  Specifically that you can't change the advertising interval?\r\n\r\nSo is the nRF8001 recommended for a new designs?\r\n\r\nIf so is there another way to setup the nRF8001 without using the Windows nRFgo?\r\n",
    "tag": "uart"
  },
  {
    "text": "CrossWorks example Hi guys,\r\n\r\nI have followed https://devzone.nordicsemi.com/question/31440/nrf51_sdk_800-ble_stack_init-hangs/ to set up CrossWorks. Even though I got pass the ble_stack_init();, I still can't discover the device for some reasons. Can anyone give me some pointers here? (btw, I can run blinky example with no problem.)\r\n\r\nThanks.",
    "tag": "uart"
  },
  {
    "text": "No TWI example in SDK8 Why is there no TWI example in SDK7.2 or SDK8?",
    "tag": "twi"
  },
  {
    "text": "No TWI example in SDK8 Why is there no TWI example in SDK7.2 or SDK8?",
    "tag": "i2c"
  },
  {
    "text": "IoT cloud provider can you recommend me cloud provider which support Nordic, nrf51822->BLE->AndroidPhone->IoTcloud? e.g  http://developer.garmin.com   http://www.cumulocity.com   or ...\r\n\r\nId like to visualize data (e.g. pedometer) statistically .. means that few (hundreds) sensors/customers can see anonymously if they are better/worse comparing average value of all sensors\r\n",
    "tag": "adc"
  },
  {
    "text": "What BLE profile would suit a ECG signal best and is there any example code for ADC in to that profile? Have searched for a while and cant find any.",
    "tag": "adc"
  },
  {
    "text": "Fail to get BLE_UARTConsole on my nrf51dk with my Nexus 5 (5.0) running the nRF UART 2.0 app to work. Just took the http://developer.mbed.org/teams/Bluetooth-Low-Energy/code/BLE_UARTConsole/ code and run it on the board.\r\n\r\nBut when I try to connect with my phone I get: \"Device doesn't support UART. Disconnecting\".\r\n\r\nWhat am I missing? Do I have to change any code?",
    "tag": "adc"
  },
  {
    "text": "Timer 1 has no Different resolution We're currently running into a lot of bugs using timer1(and 2) especially with the softdevice enabled. Every so often it glitches, and after further inspection of the code, we notice that regardless of NRF_TIMER1->BITMODE = x; the bitmode doesn't change.\r\n\r\nwe use the following code.\r\n\r\n    void TIMER1_IRQHandler(){\r\n\t\tNRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n\t\tNRF_TIMER1->CC[0] += 125; ///add an additional 125, so that it interrupts on the next 125 ticks\t\r\n\t\tNRF_TIMER1->CC[0] = 75125;\r\n\r\n\t\tif (NRF_TIMER1->CC[0] > 0xffff)\r\n\t\t{\r\n\t\t\twhile(1);\r\n\t\t}\r\n\t\t///it should also roll over after reaching the 4billion mark in 9 hours\r\n\t\tmain_interrupt();\r\n\t}\r\n\r\nIt will NEVER reach the infinite whileloop.\r\nand we initialize it like so\r\n\r\n    \t\t\r\n\t\tNRF_TIMER1->POWER = 1;\r\n\t\t/// we want this function to be called every 1 ms\r\n\t\tNRF_TIMER1->MODE = TIMER_MODE_MODE_Timer << TIMER_MODE_MODE_Pos;\r\n\t\t///8 bit timer\r\n\t\tNRF_TIMER1->BITMODE = TIMER_BITMODE_BITMODE_08Bit << TIMER_BITMODE_BITMODE_Pos;\r\n\t\t///16Mhz / 2 ^ 7 = 125000,\r\n\t\tNRF_TIMER1->PRESCALER = 7;\r\n\t\t///so to generate a 1Khz interrupt, we set compare register to 125\r\n\t\tNRF_TIMER1->CC[0] = 125;\r\n\t\tNRF_TIMER1->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n\t\t///set as the highest priority\r\n\t\tNVIC_SetPriority(TIMER1_IRQn, 0);\r\n\t\tNVIC_EnableIRQ(TIMER1_IRQn);\r\n\t\tnrf_delay_us(100);\r\n\r\nIf you notice that we even tried setting the bitmode to 8bit, and it still will count up to 16bit value before rolling over. We NEED a 32bit timer. Our current hardware is the nrf51822 QFAC A1",
    "tag": "timer"
  },
  {
    "text": "Why Battery level is always 100? \r\nstatic void adc_init(void)\r\n\r\n{\t\r\n\r\n\t/* Enable interrupt on ADC sample ready event*/\t\t\r\n\r\n\tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n\r\n\tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n\r\n\tsd_nvic_EnableIRQ(ADC_IRQn);\r\n\t\r\n\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) \r\n\t\t\t| (ADC_CONFIG_PSEL_Disabled << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t\r\n\t\t\t| (ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t\r\n\t\t\t| (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) \r\n\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t\r\n\t\r\n\t/* Enable ADC*/\r\n\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n\t\r\n}\r\n\r\n\r\n\r\nvoid ADC_IRQHandler(void)\r\n\r\n{\r\n\r\n\tuint8_t adc_result;\r\n\t\t\r\n        NRF_ADC->EVENTS_END = 0;\t\r\n\t\r\n\tADC_Value = (NRF_ADC->RESULT)/255*100;\r\n\t\r\n        NRF_ADC->TASKS_STOP = 1;\r\n\t\r\n\tsd_clock_hfclk_release();\r\n}\t\r\n\r\n\r\nThe result of this source is always 100.\r\n\r\nThe amount of the battery is falling but 100.\r\n\r\nWhat is the problem?\r\n\r\nI have connected the battery to the VTG and GND.\r\n\r\nWhat part did wrong? \r\n\r\n~~~~",
    "tag": "adc"
  },
  {
    "text": "If I add Button Init, don't work my source I will use ADC / Button function over SoftDevice.\r\n\r\nbelow by source.\r\n\r\nthe thread is repeated not go beyond the conn_params_init.\r\n\r\n #define ADC_SAMPLING_INTERVAL           APP_TIMER_TICKS(1000, APP_TIMER_PRESCALER) \r\n\r\n #define BUTTON_DETECTION_DELAY          APP_TIMER_TICKS(50, APP_TIMER_PRESCALER)    \r\n{\r\n\r\n    timers_init();\r\n    gpiote_init();\r\n    buttons_init();\r\n    ble_stack_init();\r\n    gap_params_init();\r\n    services_init();\r\n    advertising_init();\r\n    conn_params_init();\r\n    sec_params_init();\r\n    \r\n    err_code = app_button_enable();\r\n    APP_ERROR_CHECK(err_code);\r\n\r\n    adc_init();        \r\n    \r\n    application_timers_start();\r\n    advertising_start();\r\n}\r\n\r\nstatic void application_timers_start(void)\r\n\r\n{\r\n\r\n    uint32_t err_code;\r\n\r\n\t//ADC timer start\r\n\terr_code = app_timer_start(m_adc_sampling_timer_id, ADC_SAMPLING_INTERVAL, NULL);\r\n    APP_ERROR_CHECK(err_code);\r\n}\r\n\r\nstatic void adc_sampling_timeout_handler(void * p_context)\r\n\r\n{\r\n\r\n\tuint32_t p_is_running = 0;\r\n\t\t\r\n\tsd_clock_hfclk_request();\r\n\twhile(! p_is_running) {  \t\t\t\t\t\t\t//wait for the hfclk to be available\r\n\t\tsd_clock_hfclk_is_running((&p_is_running));\r\n\t}               \r\n\t\r\n\tNRF_ADC->TASKS_START = 1;\t\t\t\t\t\t\t//Start ADC sampling\r\n}\r\n\r\nstatic void timers_init(void)\r\n\r\n{\r\n\r\n\t  uint32_t err_code;\r\n\t\r\n    // Initialize timer module\r\n    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n\t\r\n\t\terr_code = app_timer_create(&m_adc_sampling_timer_id,\r\n                                APP_TIMER_MODE_REPEATED,\r\n                                adc_sampling_timeout_handler);\r\n    APP_ERROR_CHECK(err_code);\r\n}\r\n\r\n\r\nstatic void adc_init(void)\r\n\r\n{\t\r\n\r\n\t/* Enable interrupt on ADC sample ready event*/\t\t\r\n\tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n\tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n\tsd_nvic_EnableIRQ(ADC_IRQn);\r\n\t\r\n\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_Disabled << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< Use analog input 2 as analog input. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n\t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n\t\r\n\t/* Enable ADC*/\r\n\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n\t\r\n\tAD_SDA_STANDARD0_NODRIVE1();\r\n\tAD_SCL_OUTPUT();\r\n\tAD_SDA_INPUT();\r\n}\r\n\r\n\r\nvoid ADC_IRQHandler(void)\r\n\r\n{\r\n\r\n\tuint8_t adc_result;\r\n\t\r\n\t/* Clear dataready event */\r\n    NRF_ADC->EVENTS_END = 0;\t\r\n\r\n\tADC_Value = (NRF_ADC->RESULT);\r\n\t\r\n    NRF_ADC->TASKS_STOP = 1;\r\n\t\r\n\t//Release the external crystal\r\n\tsd_clock_hfclk_release();\r\n}\t\r\n\r\nstatic void gpiote_init(void)\r\n\r\n{\r\n\r\n    APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS);\r\n}\r\n\r\n\r\nstatic void button_event_handler(uint8_t pin_no, uint8_t button_action)\r\n\r\n{\r\n\r\n    if (button_action == APP_BUTTON_PUSH)\r\n    {\r\n        switch (pin_no)\r\n        {\r\n            case BT_ONE:     Zero_Point();         break;\r\n\t\t\tcase BT_TWO:  \t\t\t               break;\r\n            default:   APP_ERROR_HANDLER(pin_no);  break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstatic void buttons_init(void)\r\n\r\n{\r\n\r\n      static app_button_cfg_t buttons[] =\r\n      {\r\n\r\n        {BT_ONE,   false, BUTTON_PULL, button_event_handler},\r\n\t    {BT_TWO,   false, BUTTON_PULL, button_event_handler},\t\t\t\t \r\n      };\r\n\r\n      APP_BUTTON_INIT(buttons, sizeof(buttons) / sizeof(buttons[0]), BUTTON_DETECTION_DELAY, false);\r\n}\r\n\r\n#EDIT  MY Question  \r\n\r\nI'm sure It will not work when I use the two functions at the same time.\r\n{\r\n\r\n    APP_BUTTON_INIT(buttons, sizeof(buttons) / sizeof(buttons[0]), BUTTON_DETECTION_DELAY, false);\r\n \r\n    app_timer_create(&m_adc_sampling_timer_id,\r\n                                APP_TIMER_MODE_REPEATED,\r\n                                adc_sampling_timeout_handler);\r\n}\r\n\r\nHow should I fix it?",
    "tag": "adc"
  },
  {
    "text": "How to use PCA10000 dongle and a Windows terminal app (e.g. Putty) I have a system fully operational using the nRF8001 communicating to both IOS and Android devices using nRFUart app from Nordic as well as a custom app using the uart tx and rx pipes.\r\n\r\nI thought it would be a trivial matter to plug in the PCA10000 dongle, flash it, and then use it as an interface between a Windows terminal emulator and my system.\r\n\r\nThe dongle is up and running properly after flashing.\r\n\r\nUsing the Master Control panel, I discover the device, enable services and can see data arriving at RX.\r\n\r\nIs it possible, then, to use a terminal emulator like TeraTerm or putty instead of the master control panel (or in concert with it?) or the nRFUart app that that came with the Master Emulator (as part of the dev kit) to simply capture data coming over BLE?\r\n\r\nAs an alternative to TeraTerm etc., I have tried the Master Emulator nRFUart.  When I run nRFUart, it correctly discovers my system, detects the RX and TX pipes and says \"ready to connect\"  However, that is far as I get.  \r\n\r\nThanks!",
    "tag": "uart"
  },
  {
    "text": "Using both TWI instances in nrf51822 Hello,\r\n\r\nWe're creating a new design with the nRF518122 as a TWI master to two separate I2C busses.  No SPI devices of any kind, so I don't think there is a resource sharing issue.  The reference manual indicates that the part has two separate TWI instances, but looking through the Nordic-provided twi_hw_master.c driver file, it's clear the driver code is hard-coded to use TWI1 as the only master, and there is no support in the driver for operating both masters simultaneously.  Some questions:\r\n\r\n - Is there any reason why the driver was written to use TWI1 specifically?  Why not TWI0?\r\n - Any reason any I couldn't just make a separate copy of twi_hw_master.c for the TWI0 instance?\r\n\r\nThanks!",
    "tag": "twi"
  },
  {
    "text": "[nRF51822] How to include dynamic data in advertizing payload  I am trying to include an ADC reading in BLE advertizing packets. I am learning from several BLE app examples in Nordic's github repository. I package data information in \"advertising_init()\" method, as many programs do. And inside \"advertising_init()\" method, it reads from ADC. However, it seems the program only reads ADC once, because the ADC data don't get updated from an initial value. Could anyone help have a look at my code below, and point out what I did wrong? \r\n\r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    #include \"ble_advdata.h\"\r\n    #include \"nordic_common.h\"\r\n    #include \"softdevice_handler.h\"\r\n    #include \"bsp.h\"\r\n    #include \"app_timer.h\"\r\n    #include \"ble_srv_common.h\"\r\n    #include \"custom_board.h\"\r\n    \r\n    #define IS_SRVC_CHANGED_CHARACT_PRESENT 1                                 /**< Include or not the service_changed characteristic. if not enabled, the server's database cannot be changed for the lifetime of the device*/\r\n    \r\n    #define APP_CFG_NON_CONN_ADV_TIMEOUT    0                                 /**< Time for which the device must be advertising in non-connectable mode (in seconds). 0 disables timeout. */\r\n    #define NON_CONNECTABLE_ADV_INTERVAL    MSEC_TO_UNITS(100, UNIT_0_625_MS) /**< The advertising interval for non-connectable advertisement (100 ms). This value can vary between 100ms to 10.24s). */\r\n    \r\n    #define DEAD_BEEF                       0xDEADBEEF                        /**< Value used as error code on stack dump, can be used to identify stack location on stack unwind. */\r\n    \r\n    #define APP_TIMER_PRESCALER             0                                 /**< Value of the RTC1 PRESCALER register. */\r\n    #define APP_TIMER_MAX_TIMERS            (2+BSP_APP_TIMERS_NUMBER)         /**< Maximum number of simultaneously created timers. */\r\n    #define APP_TIMER_OP_QUEUE_SIZE         4                                 /**< Size of timer operation queues. */\r\n    \r\n    #define ADV_INTERVAL_IN_MS              1200\r\n    #define ADV_INTERVAL                    MSEC_TO_UNITS(ADV_INTERVAL_IN_MS, UNIT_0_625_MS) /**< The advertising interval (in units of 0.625 ms. */\r\n    #define ADV_TIMEOUT_IN_SECONDS          0                                           /**< The advertising timeout (in units of seconds). */\r\n    #define ADVDATA_UPDATE_INTERVAL         APP_TIMER_TICKS(ADV_INTERVAL_IN_MS, APP_TIMER_PRESCALER)\r\n    \r\n    #define DEVICE_NAME                      \"MyBeacon\"\r\n    \r\n    static ble_gap_adv_params_t m_adv_params;                                 /**< Parameters to be passed to the stack when starting advertising. */\r\n    static app_timer_id_t m_advdata_update_timer;\r\n    \r\n    static uint8_t adc_data_get(void)  \r\n    {\r\n    \t  uint8_t adc_read; \r\n    \r\n    \t  NRF_ADC->INTENSET= 0;   // disable interrupt\r\n    \t\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n    \t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput5 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< Use analog input 5 as analog input. */\r\n    \t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n    \t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n    \t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n        NRF_ADC->EVENTS_END = 0;\r\n    \t\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;    // Enable ADC\r\n    \t  NRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.\r\n    \t\tNRF_ADC->TASKS_START = 1;\t\t\t//Start ADC sampling\r\n    \t\twhile (NRF_ADC->BUSY) {}    // wait till ADC sampling finishes\r\n    \t\tNRF_ADC->EVENTS_END = 0;\t  \r\n    \t\tadc_read = NRF_ADC->RESULT;   // read ADC result\r\n        NRF_ADC->TASKS_STOP = 1;   //Use the STOP task to save current. Workaround for PAN_028 rev1.5 anomaly 1.\r\n    \t  nrf_gpio_pin_toggle(LED_BLUE);  // see if this function is called\r\n    \t\treturn adc_read;\r\n    }\r\n    \r\n    /**@brief Callback function for asserts in the SoftDevice.\r\n     *\r\n     * @details This function will be called in case of an assert in the SoftDevice.\r\n     *\r\n     * @warning This handler is an example only and does not fit a final product. You need to analyze\r\n     *          how your product is supposed to react in case of Assert.\r\n     * @warning On assert from the SoftDevice, the system can only recover on reset.\r\n     *\r\n     * @param[in]   line_num   Line number of the failing ASSERT call.\r\n     * @param[in]   file_name  File name of the failing ASSERT call.\r\n     */\r\n    void assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name)\r\n    {\r\n        app_error_handler(DEAD_BEEF, line_num, p_file_name);\r\n    }\r\n    \r\n    /**@brief Function for initializing the Advertising functionality.\r\n     *\r\n     * @details Encodes the required advertising data and passes it to the stack.\r\n     *          Also builds a structure to be passed to the stack when starting advertising.\r\n     */\r\n    static void advertising_init(void) \r\n    {  \r\n        uint32_t      err_code;\r\n        ble_advdata_t advdata;\r\n        uint8_t       flags = BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;  \r\n        ble_advdata_service_data_t service_data[1];\r\n    \t\tuint8_t adc_data = adc_data_get();\r\n        \r\n        service_data[0].service_uuid = BLE_UUID_BATTERY_SERVICE;  // 0x180F, battery service\r\n    \t\tservice_data[0].data.size   = sizeof(adc_data);\r\n    \t\tservice_data[0].data.p_data  = (uint8_t *) &adc_data;  \r\n    \r\n        // Build and set advertising data.\r\n        memset(&advdata, 0, sizeof(advdata));\r\n    \t\tadvdata.name_type             = BLE_ADVDATA_SHORT_NAME;\r\n        advdata.flags                 = flags;\r\n    \t\tadvdata.service_data_count   = 1;\r\n        advdata.p_service_data_array = service_data;\r\n    \r\n    \t\t// Set device name\r\n        ble_gap_conn_sec_mode_t sec_mode;\r\n    \t\tBLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);\r\n    \t  sec_mode.sm = 1;     /**< Security Mode (1 or 2), 0 for no permissions at all. */\r\n    \t  sec_mode.lv = 1;     /**< Level (1, 2 or 3), 0 for no permissions at all. */\r\n    \t  err_code = sd_ble_gap_device_name_set(&sec_mode, (const uint8_t *)DEVICE_NAME, strlen(DEVICE_NAME));\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t\t\r\n        err_code = ble_advdata_set(&advdata, NULL);  // commit the advertizement data\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // Initialize advertising parameters (used when starting advertising).\r\n    \t\t// m_adv_params is a global variable\r\n        memset(&m_adv_params, 0, sizeof(m_adv_params));\r\n    \r\n        m_adv_params.type        = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;\r\n        m_adv_params.p_peer_addr = NULL;                             // Undirected advertisement.\r\n        m_adv_params.fp          = BLE_GAP_ADV_FP_ANY;              // Filter policy\r\n        m_adv_params.interval    = NON_CONNECTABLE_ADV_INTERVAL;\r\n        m_adv_params.timeout     = APP_CFG_NON_CONN_ADV_TIMEOUT;\r\n    \t\t\r\n    \t\t// nrf_gpio_pin_toggle(LED_GREEN);  // set if this function is called\r\n    }\r\n    \r\n    /**@brief Function for starting advertising.\r\n     */\r\n    static void advertising_start(void)\r\n    {\r\n        uint32_t err_code;\r\n        err_code = sd_ble_gap_adv_start(&m_adv_params);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    void advdata_update_timer_timeout_handler(void * p_context)\r\n    {\r\n        advertising_init();  // update ADC read on each timer timeout\r\n    }\r\n    \r\n    static void timers_init(void)\r\n    {\r\n        // Initialize timer module, making it use the scheduler\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        \r\n        uint32_t err_code = app_timer_create(&m_advdata_update_timer, APP_TIMER_MODE_REPEATED, advdata_update_timer_timeout_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**@brief Function for starting timers.\r\n    */\r\n    static void timers_start(void)\r\n    {\r\n        uint32_t err_code = app_timer_start(m_advdata_update_timer, ADVDATA_UPDATE_INTERVAL, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**@brief Function for initializing the BLE stack.\r\n     *\r\n     * @details Initializes the SoftDevice and the BLE event interrupt.\r\n     */\r\n    static void ble_stack_init(void)\r\n    {\r\n        // Initialize the SoftDevice handler module.\r\n        SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_RC_250_PPM_TEMP_4000MS_CALIBRATION, false);\r\n    \t\r\n        // Enable BLE stack \r\n        uint32_t err_code;\r\n        ble_enable_params_t ble_enable_params;\r\n        memset(&ble_enable_params, 0, sizeof(ble_enable_params));\r\n        ble_enable_params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT;\r\n        err_code = sd_ble_enable(&ble_enable_params);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**@brief Function for doing power management.\r\n     */\r\n    static void power_manage(void)\r\n    {\r\n        uint32_t err_code = sd_app_evt_wait();\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    static void led_init()\r\n    {\r\n    \t//nrf_gpio_cfg_output(LED_RED);\r\n    \t\tnrf_gpio_cfg_output(LED_BLUE);\r\n    \t  nrf_gpio_cfg_output(LED_GREEN);\r\n    }\r\n    \r\n    /**\r\n     * @brief Function for application main entry.\r\n     */\r\n    int main(void)\r\n    {\r\n        \r\n        // Initialize.\r\n        ble_stack_init();\r\n    \t  timers_init();\r\n        advertising_init();\r\n        led_init();\r\n    \t\r\n        // Start execution.\r\n    \t  timers_start();\r\n        advertising_start();\r\n    \r\n        // Enter main loop.\r\n        for (;; )\r\n        {\r\n            power_manage();\r\n        }\r\n    }",
    "tag": "adc"
  },
  {
    "text": "ppi with uart hi,\r\nI am using the nrf51422 for the first time. I need to connect a GSM-GPS module for reading nmea string. I have to use the uart to enable communication with the GPS and I would use the interface ppi to capture the data and put them in a buffer until the arrival of carriege return. The goal is not to involve the CPU in the process of reading data from the port and only after they have arrived in the buffer to draw the attention of the CPU to the next process. E 'possible to realize a code in this way. If it is possible you can give me some advice.\r\nBest regard",
    "tag": "uart"
  },
  {
    "text": "Using nrf51822 board with adxl335 accelerometer (ADC) Hi,\r\n\r\nI'm trying to use adxl335 accelerometer to detect motion. \r\n\r\nI'm having trouble understanding what the output of the accelerometer means. \r\nObviously, it should tell me something about the acceleration but it's in unit mV/g. \r\nHow do I interpret this output and convert it into data related to acceleration or motion? \r\n \r\nAlso, I've found a lot of codes on adxl335 with Arduino,\r\nbut there seems to be less resources on adxl335 with nrf51822 kit. \r\nI'm trying to use the GPIOs and program it to do the ADC conversion.\r\nCould anyone help me on this?\r\n\r\nThank you a lot. ",
    "tag": "adc"
  },
  {
    "text": "twi_hw_master.c assumes PPI channel 0 is available Throughout twi_hw_master.c, there are lots of places where the code directly accesses PPI channel #0 and thus assumes it's available, as in:\r\n\r\n    NRF_PPI->CH[0].TEP = (uint32_t)&NRF_TWI1->TASKS_STOP;\r\n\r\nLater on, if I invoke nrf_drv_ppi_channel_alloc() to use one of the PPI channels for something in my own application, that function will initially return channel #0, which in incorrect since that entry is already taken by the TWI master.\r\n\r\nThis seems like a bug.  It seems like nrf_drv_ppi_channel_alloc() should look at each of the EEP/TEP registers to find which channels are actually allocated, rather than rely the m_channels_allocated bitmask.  It also seems like TWI HW Master should use nrf_drv_ppi_channel_alloc() to prevent these collisions.  This is in SDK v8.0.0.  Thoughts?",
    "tag": "twi"
  },
  {
    "text": "How can I compile programs for the PCA10024 (MBED) using the IoT SDK? I've been trying to get a simple blinky program to compile for the better part of a day now. The makefiles are outdated and so are the keil projects. Is this SDK no longer supported?",
    "tag": "adc"
  },
  {
    "text": "How can I compile a simple blinky program for the PCA10024 with the IOT SDK? How can I compile a simple blinky program for the PCA10024 with the IOT SDK, and using the (iot modified) s110 softdevice?\r\n\r\nI've been trying to get a simple blinky program to compile for the better part of a day now. The makefiles are outdated and so are the keil projects. Is this SDK no longer supported?\r\n\r\nI'd prefer to be able to use a makefile and the GNU embedded tools",
    "tag": "adc"
  },
  {
    "text": "ADC registering too high values I am using LMT84 temperature sensor directly connected to P06 on my nRF24LE1, QFN24. Using the built-in BG reference of 1.2V, I measure temperatures from about -30C up to 85C.\r\n\r\nThe circuit is battery driven. I use 10bit adc, 12us T_ACQ, logging every 10seconds or rare. The voltage from the sensor is accurate, it is measured with oscilloscope and multimeter.\r\n\r\nHowever, the ADC is measuring some values too high. It is a little difference between the two circuits I am testing on; one shows 33mv too high (measuring 958mV), the other approx 20mV too high (measuring 945mV). The voltage shall be 925mV. As far as I read both datasheets, there are no need for a buffer between the sensor and the ADC.\r\n\r\nAny ideas for further fault finding?",
    "tag": "adc"
  },
  {
    "text": "Function for initializing ADC for battery measurement I am going though this code for nrf51822 and here i am not getting why we used ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling and all that stuffs. Can anybody explain me in deep about this ADC initialization as i am new to it and if possible share links where this is explained  so refer that for settings appropriate values. \r\n\r\nI used the below code for reference.\r\n\r\nNRF_ADC->CONFIG     = (ADC_CONFIG_RES_8bit                        << ADC_CONFIG_RES_Pos)     |\r\n                          (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)  |\r\n                          (ADC_CONFIG_REFSEL_VBG                      << ADC_CONFIG_REFSEL_Pos)  |\r\n                          (ADC_CONFIG_PSEL_Disabled                   << ADC_CONFIG_PSEL_Pos)    |\r\n                          (ADC_CONFIG_EXTREFSEL_None                  << ADC_CONFIG_EXTREFSEL_Pos);\r\n\t\t\t\t\t\t  ",
    "tag": "adc"
  },
  {
    "text": "_timeout_handler I have just started coding in Timers in nrf51822. Here i am not clear with the Timer part. Can anybody explain me how to use timer with use of Event Scheduler. Here in **app_timer_create()** function i am not clear with app_timer_timeout_handler_t **timeout_handle**. Want some explanation in timeout_handler how to use it and where to use it and why to use it.\r\n\r\n\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "TWI High Current S110 8.0.0 Hello,\r\n\r\nI migrated my project from softdevice S110 7.1.0 on a nRF51422 FAC to softdevice S110 8.0.0 and an nRF51822 FAA G3. My code used to have a current consumption around 10 to 15 uA. \r\n\r\nNow when I enable the TWI hardware version I get an above average current consumption. \r\n\r\nTWI Hardware +- 1,5 mA\r\n\r\nThe TWI communication does work and all works fine but the current consumption is very high. With the software version everything is ok but I cannot configure it to use the maximum frequency of 400 kHz I get only set it to a max of 250 kHz. \r\n\r\nI have DC/DC Enabled and integrated on my new board with the nRF51822 FAA G3. \r\n\r\nIs this a known issue or am I forgetting something? \r\n  ",
    "tag": "twi"
  },
  {
    "text": "nRF51 UART problem CMSIS-RTOS and Keil MDK-ARM Networking I'm trying to solve an intermittent problem when using the nRF51422 UART with CMSIS-RTOS (RTX) and MDK Networking library (V6.2) (TCP/IP stack).\r\n\r\nMy questions relate to event/timer handling, correct use of the rtos_suspend variable and the like. I hope this might be useful to others having difficulty with RTX.\r\n\r\n**Brief application details**\r\n\r\nUsing RTX configuration for nRF51 family - RTC1 provides the tick timer.\r\nNo Soft Device in use.\r\nnRF51 UART connected to modem (RS232).\r\nOwn hardware.\r\n\r\nI've written a CMSIS compatible USART driver adding GPRS Modem and null modem support.\r\n\r\nnRF51 establishes a PPP connection via the modem then uses http get/post requests etc to a cloud based server using BSD Sockets interface. Frequency is several requests every few minutes.\r\n\r\nTwo RTX threads for the comms - one runs net_main() and the other handles client activity.\r\n\r\nThe client thread brings up the PPP connection when needed (when new data arrive on the nRF51's SPI slave port), POSTs the new data, receives the HTTP OK response, then drops the connection (after a delay) if no longer required.\r\n\r\nAdditional timer thread is running which is required by RTX and the networking library.\r\n\r\n**Problem details**\r\n\r\nI think the CMSIS-USART driver is working fine but there may be some problems remaining.\r\n\r\nThe application works fine for several hours at a time but then the client thread hangs - apparently always in osSignalWait() (from either BSD sockets recv() or send()). With only one UART on the nRF51422 I can't use the debugging build of the MDK networking library.\r\n\r\nI'm assuming the net_main() loop is responsible for maintaining the PPP link and for exchanging all receive / transmit IP data between my UART driver and the client thread via sockets, or alternatively signalling the open socket that a timeout or other underlying network error has occurred.\r\n\r\nThe PPP link is at some point being terminated, but the client thread remains stuck waiting for a signal, never returning to my application so that I can deal with the error. My modem driver is also not being notified that 'NO CARRIER' has been received, although this and the preceding LCP termination and response frames are clearly in transmit and receive buffers as the last exchange of data before the hang occurs.\r\n\r\nAlthough this may turn out to be a networking library problem (I have also raised this with Keil tech support) it looks like something is going wrong with the signalling mechanism so I wondered if this might be associated with the nRF51 implementation of RTX and use of rtos_suspend variable?\r\n\r\nHaving seen the note about limitations of use of RTX in the S110 data, I've already set the global rtos_suspend variable to zero in my UART ISR (since this posts events to RTX) and also in the callback functions from the Nordic spi_slave.c driver file (which are called from ISR context). These don't seem to have prevented the problem occurring.\r\n\r\nI have also tried setting rtos_suspend to zero (instead of 1) in RTX_Conf_CM.c. This seemed to improve things considerably but has not eliminated the problem and may just be a coincidence.\r\n\r\nIt is not immediately obvious where else this might be causing problems so I would appreciate any suggestions of where to look next.\r\n\r\nIs there another CMSIS compatible USART driver available that I could try?\r\n\r\nIs this requirement (for setting rtos_suspend to 0) a limitation of using any code libraries (such as MDK middleware) using RTX which are not built specifically for Nordic parts? I note there are some recent comments on mbed.org about other difficulties using RTX.\r\n",
    "tag": "uart"
  },
  {
    "text": "Unusual TWI/I2C Problem Hello\r\n\r\nI've been experiencing an unusual problem using the TWI/I2C library for the nRF51-DK board. Basically, I found that I need to shift my device address to the left by 1-bit in order for the board and the device to communicate and I don't understand why?\r\n\r\nThe IC is an ADT7420 temperature sensor, its default address is 0x48 and its device id register is found at 0x0B. I was attempting to read this device ID to verify the operation of the chip, however the chip failed to respond unless I shifted the address to the left by 1 bit (i.e. 0x48<<1 which equals 0x90), however with a different IC (a TMP007 IR sensor) there was no problem. I decided to try shifitng the bits after looking at the SDA and SCL waveforms on an oscilloscope and they seemed out of alignment by one clock cycle. I also tested the ADT7420 with an Arduino and I had no problem with the normal address of 0x48.\r\n\r\nI'm using the latest version of the SDK, Keil v5 and the I2C is operating at 100 kHz.\r\n\r\nHere's a simplified section of code that I'm using:\r\n\r\n\r\n----------\r\n\r\n   \r\n\r\n     bool readI2cData(uint8_t address, uint8_t reg, uint8_t* data, uint8_t len)\r\n    {\t\t\r\n    \t// initialize data to zero so we don't return random values.\r\n    \tfor (int i = 0; i < len; i++) \r\n    \t{\r\n    \t\tdata[i] = 0;\r\n    \t}\r\n    \t\r\n      // Write: register address we want to start reading from\r\n      if (twi_master_transfer(address, &reg, 1, TWI_DONT_ISSUE_STOP))\r\n      {\r\n    \t\t// Read: the number of bytes requested.\r\n        if (twi_master_transfer(address | TWI_READ_BIT, data, len, TWI_ISSUE_STOP))\r\n        {\t\t\t\r\n          // Read succeeded.\r\n    \t\t\treturn true;\r\n        }\r\n    \t}\r\n    \t\r\n    \t// read or write failed.\r\n      return false;\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n    \r\n    \t\r\n    \r\n    \t twi_master_init(); // Initialise I2C bus\r\n    \r\n    \r\n    \t while (true)\r\n        {\r\n    \r\n    \t\tuint8_t temp_read[2];\r\n    \t\treadI2cData(0x48<<1, 0x0B, temp_read, 2);\r\n    \t\t\r\n            nrf_delay_ms(100);\r\n    \r\n        }\r\n    }\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Unusual TWI/I2C Problem Hello\r\n\r\nI've been experiencing an unusual problem using the TWI/I2C library for the nRF51-DK board. Basically, I found that I need to shift my device address to the left by 1-bit in order for the board and the device to communicate and I don't understand why?\r\n\r\nThe IC is an ADT7420 temperature sensor, its default address is 0x48 and its device id register is found at 0x0B. I was attempting to read this device ID to verify the operation of the chip, however the chip failed to respond unless I shifted the address to the left by 1 bit (i.e. 0x48<<1 which equals 0x90), however with a different IC (a TMP007 IR sensor) there was no problem. I decided to try shifitng the bits after looking at the SDA and SCL waveforms on an oscilloscope and they seemed out of alignment by one clock cycle. I also tested the ADT7420 with an Arduino and I had no problem with the normal address of 0x48.\r\n\r\nI'm using the latest version of the SDK, Keil v5 and the I2C is operating at 100 kHz.\r\n\r\nHere's a simplified section of code that I'm using:\r\n\r\n\r\n----------\r\n\r\n   \r\n\r\n     bool readI2cData(uint8_t address, uint8_t reg, uint8_t* data, uint8_t len)\r\n    {\t\t\r\n    \t// initialize data to zero so we don't return random values.\r\n    \tfor (int i = 0; i < len; i++) \r\n    \t{\r\n    \t\tdata[i] = 0;\r\n    \t}\r\n    \t\r\n      // Write: register address we want to start reading from\r\n      if (twi_master_transfer(address, &reg, 1, TWI_DONT_ISSUE_STOP))\r\n      {\r\n    \t\t// Read: the number of bytes requested.\r\n        if (twi_master_transfer(address | TWI_READ_BIT, data, len, TWI_ISSUE_STOP))\r\n        {\t\t\t\r\n          // Read succeeded.\r\n    \t\t\treturn true;\r\n        }\r\n    \t}\r\n    \t\r\n    \t// read or write failed.\r\n      return false;\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n    \r\n    \t\r\n    \r\n    \t twi_master_init(); // Initialise I2C bus\r\n    \r\n    \r\n    \t while (true)\r\n        {\r\n    \r\n    \t\tuint8_t temp_read[2];\r\n    \t\treadI2cData(0x48<<1, 0x0B, temp_read, 2);\r\n    \t\t\r\n            nrf_delay_ms(100);\r\n    \r\n        }\r\n    }\r\n\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "ASSERT: ..\\client_handling.c, 394, error 0x00000010 This is my question , about using timer . so everyone have found this question ,can connect with me , very appreciate !",
    "tag": "timer"
  },
  {
    "text": "nRF8001 MSP430 setup I am using the minimal port referenced in this question: https://devzone.nordicsemi.com/question/22410/nrf8001-communication-msp430-and-uart/\r\nto interface the nRF8001 using an MSP430 device. I am currently in the process of porting the aci_setup.c functions in order to setup the device to communicate using a UART over BLE profile. I am really struggling with the implementation.\r\n\r\nI noticed that when I run the setup code my queue fills up. It seems that the interrupts are no longer triggered at some point causing the queue to never be emptied. I inserted code to reenable the RDY interrupts in one of the loops called in the aci_setup function but now it seems the number of command response events isnt the same as the number of commands written and so the code will not proceed.\r\n\r\nThe github to my code is: https://github.com/dmh43/MCU/tree/9ee708698a28cc083b1171d077fb5da3dcaee7a4/BLE%20Demo\r\n\r\nand the most relevant file I think is aci_setup.c\r\n\r\nThank you!!\r\n\r\nDany",
    "tag": "uart"
  },
  {
    "text": "SPI_MASTER_0 not defined My code is attached but essentially it is saying that SPI_MASTER_0 is not defined when I compile. I have the line:\r\n\r\n`#define SPI_MASTER_0_ENABLE /**< Enable SPI_MASTER_0 */`\r\n\r\nincluded which I believe defines SPI_MASTER_0 according to the spec. The code included is essentially copy-and-pasted out of the \"spi master example\" included with the SDK 6.1.0 and softdevice S110. \r\n\r\nI am including spi_master.h. \r\n\r\n[partial_code.c](/attachment/254f171c7f2c4de42e83e537dc612ede)\r\n\r\n\r\nI am guessing I am doing something dumb that I am simply over looking but I can't seem to find it. Does anyone has any suggestions?\r\n\r\nI did notice that in the gcc examples you must include a flag like this:\r\n\r\nCFLAGS += -DSPI_MASTER_0_ENABLE -DSPI_MASTER_1_ENABLE\r\n\r\nIs this true for the Keil examples? How would you do that? I am guessing I am not including the .h file that defines SPI_MASTER_0. It seems like spi_master.h but the compiled doesn't seem to agree. ",
    "tag": "spi"
  },
  {
    "text": "I want to measurement Battery level.  (I use nrf51822)\r\n\r\nI use two 3V batteries in series.\r\n\r\nTherefore Input Voltage of My Circuit is 6V.\r\n\r\nMy own source was coded as a collection of information.\r\n\r\nOh, by the way, I used a battery is Cr2032 Coin Cell.\r\n\r\nLooking for information on a coin cell is found in the link below.\r\n\r\n[Coin Cell Link](http://biz.maxell.com/en/product_primary/?pci=9&pn=pb0002)\r\n\r\nIs there anything wrong with my source?\r\n\r\nUm, but uses a lot of battery, the battery is still in 100% condition.\r\n\r\nWhat mistakes did I do?\r\n\r\n  I need help. please!\r\n\r\n---------------------------------------------------------------------------------------------------------------------\r\n\r\n      /**< Reference voltage (in milli volts) used by ADC while doing conversion. */\r\n    \r\n      #define ADC_REF_VOLTAGE_IN_MILLIVOLTS        1200                    \r\n      \r\n      /**< The ADC is configured to use VDD with 1/3 prescaling as input. And hence the result of                       \r\n            conversion is to be multiplied by 3 to get the actual value of the battery voltage.*/\r\n                                    \r\n       #define ADC_PRE_SCALING_COMPENSATION         3                                          \r\n      \r\n      /**< Typical forward voltage drop of the diode (Part no: SD103ATW-7-F) that is connected in \r\n             series with the voltage supply. This is the voltage drop when the forward current is 1mA. \r\n             Source: Data sheet of 'SURFACE MOUNT SCHOTTKY BARRIER DIODE ARRAY' available at \r\n             www.diodes.com. */\r\n    \r\n      #define DIODE_FWD_VOLT_DROP_MILLIVOLTS       270                                        \r\n      #define ADC_RESULT_IN_MILLI_VOLTS(ADC_VALUE)\\\r\n            ((((ADC_VALUE) * ADC_REF_VOLTAGE_IN_MILLIVOLTS) / 255) * ADC_PRE_SCALING_COMPENSATION)\r\n    \r\n    \r\n    \r\n    static void adc_init(void)\r\n    {\t\r\n    \t\r\n    \t/* Enable interrupt on ADC sample ready event*/\t\t\r\n    \tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n    \tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n    \tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    \t\r\n    \tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_Disabled << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< Use analog input 2 as analog input. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n    \t\r\n    \t/* Enable ADC*/\r\n    \tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n    \t\r\n    }\r\n    \r\n    \r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \r\n        uint8_t     adc_result;\r\n        uint16_t    batt_lvl_in_milli_volts;\r\n        int percent;\r\n    \t\r\n    \t/* Clear dataready event */\r\n        NRF_ADC->EVENTS_END = 0;\t\r\n      \r\n    \tadc_result = (NRF_ADC->RESULT);\r\n        batt_lvl_in_milli_volts  = ADC_RESULT_IN_MILLI_VOLTS(adc_result);\r\n    \tpercent = battery_level_in_percent(batt_lvl_in_milli_volts);\r\n        NRF_ADC->TASKS_STOP = 1;\r\n    \t\r\n    \t//Release the external crystal\r\n    \tsd_clock_hfclk_release();\r\n    }\t\r\n\t\r\n\t\r\n\r\n--------------------------------------------------------------------------------------------------------------------\r\n\r\n#Edit : 2015-04-13\r\n\r\nCurrent connection status is shown in the figure below.\r\n\r\n![connection status](/attachment/c909d6aefd1a37766c4f033f16168904) \r\n\r\nThe battery is connected exactly as shown.\r\n\r\nWithout resistance, without capacitor\r\n\r\nWhat is wrong with this approach?",
    "tag": "adc"
  },
  {
    "text": "nrf51822: Interfacing external flash memory using SPI We have a **custom** board on which we have NRF51822 SOC. We also have a small external flash memory(From Spansion) on our board. I'm trying to figure out the ways to use this external non-volatile flash memory as SPI slave. NRF51822 would act as master and will store some information on this non-volatile flash memory. I've read the documentation on SPI from the **nRF51_Series_Reference_manual v3.0** (section 26) and also read the API documentation on [SPI master driver](https://devzone.nordicsemi.com/documentation/nrf51/6.1.0/s110/html/a00674.html).  So far so good, but It would be of tremendous help If someone can point me to simple slave implementation(Preferrable a flash memory block). \r\n\r\nAlso, Are there any slave related APIs as well(something similar to [spi_master_open](https://devzone.nordicsemi.com/documentation/nrf51/6.1.0/s110/html/a00674.html#ga3cf5563d474f5b41080b6ae53be0ee51)) and if yes then how to use such API in my scenario ?\r\n\r\nThanks a lot.",
    "tag": "spi"
  },
  {
    "text": "TWI on nRF51 DK (nRf51422) with s110 ![image description](/attachment/94923bc53e0dff724b7e349b9fb8942c)Hi all,\r\n\r\nI'm trying to get TWI working on the nRF51 DK but it's not working.\r\nI used the twi_hw_master_sd.c file so softdevice use should not be a problem.\r\nWhen I debug the code it gets stuck at the twi_master_transfer(0x58,dataW,2,true); line\r\n\r\nI'm using pin 18 and 19 as specified in the config file ( 24U and 25U). I checked the pins with an oscilloscope but it seems no clock or data signal is found. Both pins do stay 'high' all the time tho. Also the device stays advertising all the time so thats not the problem. Furthermore the TWI device which i'm trying to communicatie with does send ACK according to the datasheet(see picture)\r\n\r\nMaybe i'm doing something  wrong or should I add some code about using the softdevice?\r\nI really need to get this working asap as with an arduino it only took 1 hour..\r\n\r\nThanks!\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "How to change the major/minor via UART communication For a school project we have to develop a beacon system, to easy use different beacons we want to be able to change the major and minor from the beacons with UART communication.\r\nBut I can not find a way to change this, I only read about changing it when you connect via bluetooth or when you need to program the nrf51822 chip again.\r\n\r\nThanks in advance!",
    "tag": "uart"
  },
  {
    "text": "Want to use nRF51822 as wireless connectivity chip (UART) to an external MCU using a UART 4 wire electrical interface. \r\n\r\nAre there examples of routines that support communication with the external UART interface?\r\n",
    "tag": "uart"
  },
  {
    "text": "spi pin mapping mbed I am trying to write my firmware in mbed instead of microvision. I have my own custom PCB w/ the nRF51822 and use SPI with different GPIO pins than the standard ones. \r\n\r\nMy firmware runs fine on the dev kit when I use SPI(p25, p28, p29) which are the recommended pins but when I try using SPI(p0, p2, p3) as I have wired in my PCB it doesn't work. I checked out the source code and it looks like it should work w/ any pin mapping.. ->\r\n\r\nmbed/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/spi_api.c\r\n\r\nWhats up with this and how can i fix it?\r\n\r\nThanks,\r\nMike",
    "tag": "spi"
  },
  {
    "text": "Question about high resolution timer Hi,\r\n\r\nI'd like to get a timer with 1ms interval or higher resolution, and found some questions about this:\r\n\r\n1) If the app_timer is used, looks like we only can get minimum interval 5ms. With the less interval, it causes the system crashed and reboot. BTW, to use the 5ms interval, I updated the example macro MS_TO_TICK to below:\r\n\r\n    #define MS_TO_TICK(MS)                  ((TICKS_PER_100MS * MS) / 100)\r\n\r\nIs 5ms as the resolution for app_timer expected? If it's using 32K RTC as the clock source, I suppose the resolution should be much higher, right?\r\n\r\n2) I turned to solution with the timer in TIMER mode as the [example](https://github.com/NordicSemiconductor/nrf51-TIMER-examples) suggested, but observed some confusing issues:\r\n\r\nFor easier usage, I referred the code of app_timer to define below macros:\r\n\r\n    #define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))\r\n    #define TIMER_PRESCALER                 6\r\n    #define TIMER_FREQUENCY                 (256 * 1024)   /* 16M / exp(2, PRESCALER) */\r\n    #define TIMER_TICKS_PER_MS              ROUNDED_DIV(TIMER_FREQUENCY, 1000)\r\n    #define TIMER_MS_TO_TICK(MS)            (TIMER_TICKS_PER_MS * MS)\r\n\r\nand set CC as below:\r\n\r\n    NRF_TIMER2->CC[0] = TIMER_MS_TO_TICK(100);\r\n\r\nBut from the logs I added in timer handler, this setting gets 25ms interval instead of 100ms. What am I missing for this setting?\r\n\r\nAnother issue about timer is that whatever I set for BITMODE, 16 bit or 32 bit, the max CC value is always (64K - 1). If this is true, it will limit the max interval I'm trying to set. Could you please confirm this?\r\n\r\nThanks & Regards,\r\nStanley ",
    "tag": "timer"
  },
  {
    "text": "I creat a function to response BLE_GATTC_EVT_HVX:i \"uartput\" the packet that recived from BLE,but if the packet is longer than 70-80 bytes,the latter packets will not be recived,what can i do to solve this? I think the time of uartput is too long (beacuse of the packet recived is too long ,but i can not change it),and when the BLE_GATTC_EVT_HVX comeing ,the uartput is not over,so the BLE_GATTC_EVT_HVX is lost?  I'm not sure about this reason.   S130 stack",
    "tag": "uart"
  },
  {
    "text": "Reading ADC value from analog input Hello, I'm using nRF51822-mKIT for a research. \r\n\r\n![image description](/attachment/473b25a7fcb0a18406a6a4fdf0ce5579)\r\n\r\nTo verify ADC readings from analog input, I've connected P0_5 to GND and ran the following code:\r\n\r\n    uint16_t adc_result;    \r\n\r\n    NRF_ADC->INTENSET = (ADC_INTENSET_END_Disabled << ADC_INTENSET_END_Pos);\t /*!< Interrupt enabled. */\r\n\t\t\t\t\t\r\n\t// config ADC\r\n\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /*!< Analog external reference inputs disabled. */\r\n\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput6 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t\r\n\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t /*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */\r\n\t\t\t\t\t| (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos);\t /*!< 10bit ADC resolution. */ \r\n\t\r\n\t// enable ADC\t\t\r\n\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled; /* Bit 0 : ADC enable. */\t\t\r\n\t\r\n\t// start ADC conversion\r\n\tNRF_ADC->TASKS_START = 1;\r\n\t\r\n\t// wait for conversion to end\r\n\twhile (!NRF_ADC->EVENTS_END)\r\n\t{}\r\n\tNRF_ADC->EVENTS_END\t= 0;\r\n\t\r\n\t//Save your ADC result\r\n\tadc_result = NRF_ADC->RESULT;\t\r\n\t\t\r\n\t//Use the STOP task to save current. Workaround for PAN_028 rev1.1 anomaly 1.\r\n    NRF_ADC->TASKS_STOP = 1;\r\n    \t\t\r\n    return adc_result;\r\n\r\nI was expecting adc_result to be 0x00, but I got a value of 0xAA.\r\nFunnier thing is, when I connected P0_5 to VCC (which is around 3V), I still get adc_result of 0xAA.\r\nI spent a lot of time trying to find the root cause.\r\n1. I tried changing ADC config, but none of the configuration gave me the expected value\r\n2. I read about LPCOMP that needs to be disabled before ADC gets enabled, so I tried that, but still no luck\r\n3. I doubted my hardware, so I swapped the eval board to a new one, but it the issue still remains.\r\n\r\nCould someone give me an idea what might be a root cause?\r\n",
    "tag": "adc"
  },
  {
    "text": "Measuring VDD with ADC Hi,\r\n\r\nI am running the nRF51822 from a coin-cell. I need to measure the cell voltage. Until now, I have attached VDD to an ADC pin with a voltage divider and a capacitor (as described in the reference manual para 31.1.2).\r\nHowever, I later saw that according to the register settings, it is possible to select  a prescaled VDD with the INPSEL register, and then convert with VBG as a reference (REFSEL).\r\n\r\nI just want to make sure that I have not overlooked anything, before I remove the voltage divider and capacitor from my design.\r\n\r\nHelp appreciated.\r\n\r\nThanks,\r\nUri",
    "tag": "adc"
  },
  {
    "text": "NUS service on S310 SD 2.0.1 Today I tried to update the SoftDevice of my project. I was working with the experimental NUS example with the old S310 SD (1.0.0). Because I want to communicate thru ANT and BLE I need to stay with the S310 SD. \r\nHowever after updating to the S310 2.0.1.\r\n\r\nI'm not able to get my programm running. \r\n\r\nDoes somebody have an idea how I can solve my issue?\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "TWI & SD 110 error on STARTRX I'm trying to use the TWI interface with the S110.\r\nI download the \"twi_hw_master_SD.c\" from another post, because it support the BLE stack.\r\n\r\nI'm trying to start the peripheral to read 4 byte from my external ram.\r\nHere is the code:\r\n\r\n    err_code = twi_master_init();\t// Init the TWI interface\r\n    while(!twi_master_transfer(FVRAM_ADDRESS | TWI_READ_BIT, local, 4, TWI_ISSUE_STOP)){};\r\n\r\nThe read function exit with an error after setting the STARTRX (@line 136), because \"NRF_TWI1->EVENTS_ERROR\" is equal to 1.\r\n\r\nI'm using the TWI @ 100KHz, pin 14 = SCL & pin 15 = SDA.\r\n\r\n\r\nThanks!",
    "tag": "twi"
  },
  {
    "text": "How to use the GPIOTE_IRQHandler for two or more different events? Hello\r\n\r\nI'm trying to implement a number of different interrupts using the nRF51 DK but I'm having trouble understanding how to use the GPIOTE_IRQHandler function.\r\n\r\nBasically, I need one interrupt to sense a pin that will be used for sending the device in and out of sleep mode, and a second interrupt for toggling an LED from a different pin. I've tried looking at the other examples mentioned on Devzone but its not clear to me how to structure the GPIOTE_IRQHandler function and how to use the PORT functionality (since it uses less power apparently).\r\n\r\nFor example, how would I change the code here to add an additional interrupt to toggle an LED?\r\n\r\nhttps://github.com/NordicSemiconductor/nrf51-powerdown-examples/blob/master/system-on-wakeup-on-gpio/main.c \r\n\r\n\r\nThanks",
    "tag": "interrupt"
  },
  {
    "text": "MPU6000 SPI Hello, I'm working with the EK PCA10003, that has the NRF51422. I'm trying to read the information of the accelerometer MPU6000 with an ISP interface. At the moment I cannot receive any data from the accelerometer, I'm sure that the initialization of the ISP is ok, because I can read data from a Memory, but I'm not sure what is the problem with the accelerometer. If someone has an example or the steps for the initialization of the MPU6000 please give a hand (I'm working with the spi master example)",
    "tag": "spi"
  },
  {
    "text": "Stream data between two nRF51 devices over BLE to UART Hello\r\n\r\nIs there a way to stream data from one nRF51 device, to a second nRF51 and have the received data sent over UART to a host PC? Basically in my setup, I have a custom PCB with an nRF51822 chip, and I want to stream data from it to a PC connected to an nRF51-DK board for data-logging.\r\n\r\nI'm thinking something similar to what is discussed in the following tutorial but between two nRF51 boards:\r\n\r\nhttps://devzone.nordicsemi.com/tutorials/4/testing-and-using-a-simple-ble-application/\r\n\r\nThanks\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "I2C while using a Softdevice with nRF51822 Hello,\r\n\r\nI read a while in this forum and found out it might be a little tricky to get I2C working when using a Softdevice. Is that information still valid or outdated?\r\n\r\nhttp://developer.nordicsemi.com/nRF51_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00784.html\r\n\r\nCould I use this on a nRF51822 based module with S110 loaded to talk with my I2C enabled sensor?\r\n\r\nKind Regards\r\nmuhkuhns",
    "tag": "i2c"
  },
  {
    "text": "I2C while using a Softdevice with nRF51822 Hello,\r\n\r\nI read a while in this forum and found out it might be a little tricky to get I2C working when using a Softdevice. Is that information still valid or outdated?\r\n\r\nhttp://developer.nordicsemi.com/nRF51_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00784.html\r\n\r\nCould I use this on a nRF51822 based module with S110 loaded to talk with my I2C enabled sensor?\r\n\r\nKind Regards\r\nmuhkuhns",
    "tag": "twi"
  },
  {
    "text": "A simple BLE-less UART example not working on nRF51822 I am trying to do a simple UART test with nRF51822 without BLE functionality. The code is a simplified version of the UART example in nRF51 SDK, and can be found [here](http://pastebin.com/Kb63qVPK) . It is really not much there: it sends the data from RX back to TX; if it gets a 'q' or 'Q', it just quits. I use an external serial monitor (Bus Pirate) to interact with it. However, two strange things happen: \r\n\r\n1) If I compile it without SoftDevice (and ROM address starts with 0x00000), I can see nothing from my serial monitor, no matter what I type in.\r\n\r\n2) If I compile it with SoftDevice 8.0.0 (although it doesn't use any BLE functions, and ROM address starts with 0x18000), I can repetitively see \"Start:\" and \"Hit.\", even I type in nothing in my serial monitor, and there is no 1000ms delay in the between. It is strange because a) \"Start:\" is not part of the while loop and should only be printed out once in the beginning; b) If \"Hit.\" means the while loop is executed, there should be 1000 ms delay. \r\n\r\nCan anyone advise what I am missing in such a simple UART program? ",
    "tag": "uart"
  },
  {
    "text": "TWI no data from Sensor I have a temperature/humidity sensor from Sensirion. The Type is SHT21x. The sensor has I2C so it should be able to tranfer the data from the sensor to the Nordic chip over I2C. I`m working with the nRF51DK. The sensor works fine. I wrote my own I2C protocol with bit banging and both measurements did what they should. Now I want to use the soft device, because later I would like to send the data to a mobile device. So I tried to get it work with the twi_hw_master example.\r\n\r\nSoftDevice 8.0.0 is flashed on the chip. \r\n\r\nThe measurement for the humidity works fine! But when I try to read the temperature I wont get data from the sensor. But I do get the ACK when I send the read command for the temperature.\r\n\r\nI have a case open on nordic support but for days the problem wont get fixed. Maybe somebody worked with the sensor from Sensiron and had the same problem?\r\n\r\nBelow my code:\r\n\r\n\r\n    static void timer_timeout_handler()\r\n    {\r\n\t hum_temp = !hum_temp;\r\n\t if(hum_temp == true)\r\n\t {\r\n\t\tnrf_gpio_pin_toggle(24);\r\n\t\ttwi_master_transfer(0x80, &hm_hum, 1,0);\r\n\t\ttwi_master_transfer(0x81, hum_data,3,1);\r\n\t\tnrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT1, *hum_data);\r\n\t }\r\n\t else\r\n\t {\r\n\t\tnrf_gpio_pin_toggle(23);\r\n\t\ttwi_master_transfer(0x80, &hm_temp, 1,0);\r\n\t\ttwi_master_transfer(0x81, temp_data,3,1);\r\n\t\tnrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT1, *temp_data);\r\n\t }\r\n    }\r\n\r\nEvery 2 seconds I will jump in the timer_timeout_ handler() routine.\r\n\r\nHere the read function:\r\n\r\n    static bool twi_master_read(uint8_t *data, uint8_t data_length, bool issue_stop_condition)\r\n    {\r\n        uint32_t timeout = MAX_TIMEOUT_LOOPS;   /* max loops to wait for RXDREADY event*/\r\n\r\n    if (data_length == 0)\r\n    {\r\n        /* Return false for requesting data of size 0 */\r\n        NRF_TWI1->SHORTS = 0; //short are not enabled yet, may not be necessary\r\n        return false;\r\n    }\r\n    else if (data_length == 1)\r\n    {\r\n        NRF_TWI1->SHORTS = TWI_SHORTS_BB_STOP_Enabled << TWI_SHORTS_BB_STOP_Pos;\r\n    }\r\n    else\r\n    {\r\n        NRF_TWI1->SHORTS = TWI_SHORTS_BB_SUSPEND_Enabled << TWI_SHORTS_BB_SUSPEND_Pos;\r\n    }\r\n\r\n    NRF_TWI1->EVENTS_RXDREADY = 0;\r\n    NRF_TWI1->TASKS_STARTRX   = 1;\r\n\r\n    /** @snippet [TWI HW master read] */\r\n    while (true)\r\n    {\r\n        while(NRF_TWI1->EVENTS_RXDREADY == 0 && NRF_TWI1->EVENTS_ERROR == 0 && (--timeout))\r\n        {\r\n            // Do nothing.\r\n        }\r\n        NRF_TWI1->EVENTS_RXDREADY = 0;\r\n\r\n        if (timeout == 0 || NRF_TWI1->EVENTS_ERROR != 0)\r\n        {\r\n          // Recover the peripheral as indicated by PAN 56: \"TWI: TWI module lock-up.\" found at\r\n          // Product Anomaly Notification document found at\r\n          // https://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF51822/#Downloads\r\n          NRF_TWI1->EVENTS_ERROR = 0;\r\n          NRF_TWI1->ENABLE       = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos;\r\n          NRF_TWI1->POWER        = 0;\r\n          nrf_delay_us(5);\r\n          NRF_TWI1->POWER        = 1;\r\n          NRF_TWI1->ENABLE       = TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos;\r\n\r\n          (void)twi_master_init();\r\n\r\n          NRF_TWI1->SHORTS = 0;\r\n          return false;\r\n        }\r\n\r\n        *data++ = NRF_TWI1->RXD;\r\n\r\n        if (--data_length == 1)\r\n        {\r\n            NRF_TWI1->SHORTS = TWI_SHORTS_BB_STOP_Enabled << TWI_SHORTS_BB_STOP_Pos;\r\n        }\r\n\r\n        if (data_length == 0)\r\n        {\r\n            break;\r\n        }\r\n\r\n        // Recover the peripheral as indicated by PAN 56: \"TWI: TWI module lock-up.\" found at\r\n        // Product Anomaly Notification document found at\r\n        // https://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF51822/#Downloads\r\n        nrf_delay_us(20);\r\n        NRF_TWI1->TASKS_RESUME = 1;\r\n    }\r\n    /** @snippet [TWI HW master read] */\r\n\r\n    /* Wait until stop sequence is sent */\r\n    while(NRF_TWI1->EVENTS_STOPPED == 0)\r\n    {\r\n        // Do nothing.\r\n    }\r\n    NRF_TWI1->EVENTS_STOPPED = 0;\r\n\r\n    NRF_TWI1->SHORTS = 0;\r\n\t\t\r\n    return true;\r\n    }\r\n\r\n\r\nI need to know how to fix this problem.",
    "tag": "twi"
  },
  {
    "text": "Less power usage: SPI or I2C? 1 sensor per nRF51288. \r\n\r\nSensor supports either 400kHz I2C (10k pull up recommended) or SPI (2MHz typ, Max 20 MHz)\r\n\r\nFrom the nRF51288 Product Specification:\r\n\r\nRun current for SPI master at 4 Mbps. 200 \u03bcA\r\n\r\nRun current for TWI at 400 kbps. 400 \u03bcA\r\n\r\nSo the run current for I2C is more than double and it is also slower, thus longer on.. right?\r\n\r\nIs there anything else that could influence the power usage? (Power on/off etc.) Or can I safely say:\r\n\r\nSPI uses less power than I2C?\r\n\r\nWhat does HW/SW controlled mean?",
    "tag": "i2c"
  },
  {
    "text": "Less power usage: SPI or I2C? 1 sensor per nRF51288. \r\n\r\nSensor supports either 400kHz I2C (10k pull up recommended) or SPI (2MHz typ, Max 20 MHz)\r\n\r\nFrom the nRF51288 Product Specification:\r\n\r\nRun current for SPI master at 4 Mbps. 200 \u03bcA\r\n\r\nRun current for TWI at 400 kbps. 400 \u03bcA\r\n\r\nSo the run current for I2C is more than double and it is also slower, thus longer on.. right?\r\n\r\nIs there anything else that could influence the power usage? (Power on/off etc.) Or can I safely say:\r\n\r\nSPI uses less power than I2C?\r\n\r\nWhat does HW/SW controlled mean?",
    "tag": "twi"
  },
  {
    "text": "Less power usage: SPI or I2C? 1 sensor per nRF51288. \r\n\r\nSensor supports either 400kHz I2C (10k pull up recommended) or SPI (2MHz typ, Max 20 MHz)\r\n\r\nFrom the nRF51288 Product Specification:\r\n\r\nRun current for SPI master at 4 Mbps. 200 \u03bcA\r\n\r\nRun current for TWI at 400 kbps. 400 \u03bcA\r\n\r\nSo the run current for I2C is more than double and it is also slower, thus longer on.. right?\r\n\r\nIs there anything else that could influence the power usage? (Power on/off etc.) Or can I safely say:\r\n\r\nSPI uses less power than I2C?\r\n\r\nWhat does HW/SW controlled mean?",
    "tag": "spi"
  },
  {
    "text": "Can VDD be measured? (without routing it to an GPIO) No text. It's a really short question.\r\n\r\nSo this is a simple example:\r\n\r\n\t\tNRF_ADC->CONFIG     = (ADC_CONFIG_RES_8bit                        << ADC_CONFIG_RES_Pos)     |\r\n                          (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)  |\r\n                          (ADC_CONFIG_REFSEL_VBG                      << ADC_CONFIG_REFSEL_Pos)  |\r\n                          (ADC_CONFIG_PSEL_Disabled                   << ADC_CONFIG_PSEL_Pos)    |\r\n                          (ADC_CONFIG_EXTREFSEL_None                  << ADC_CONFIG_EXTREFSEL_Pos);\r\n\t\t\t\t\t\tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tNRF_ADC->TASKS_START = 1;\r\n\t\t\t\t\t\tnrf_delay_ms(1);\r\n\t\t\t\t\t\tuint8_t raw_voltage = NRF_ADC->RESULT;\r\n\t\t\t\t\t\tprintf(\"%3.2fV\\n\", raw_voltage*0.0140625);\r\n\r\n2,88V. nRF51-DK connected via USB. Works.",
    "tag": "adc"
  },
  {
    "text": "Printing floating point numbers to UART Hey everyone,\r\n\r\nI'm trying to print floating point numbers to the UART to debug my application. I know the nrf51 is doing the operations correctly because if I convert the variable to an int I can print it correctly and I get (~)accurate values.\r\nWhen I try to print floats nothing happens. I read that this may be because I'm linking against a library (for sprintf) that has no floating point support.\r\n\r\nAny workarounds?",
    "tag": "uart"
  },
  {
    "text": "nrf51822 fix UART error Rate / SPI? Hello,\r\n\r\ni am new to nRF Bluetooth.\r\nMy Setup ist:\r\n\r\nOne Atmel atmega640 and one nrf51822 communication via UART (at the moment).\r\n\r\nI am sending data from atmega640 to the nrf and i am experiencing an error-rate about 10% in incoming Data in the nrf when using a UARt Datarate of 38400 baud, which seems to be normal without using Hardware FlowControl. (https://devzone.nordicsemi.com/question/15665/uart-works-uncorrectly-while-ble-is-exchanging-data/)\r\n\r\nMy Problem is at the moment, that i need a communication with less Errors and higher DataRate, but there is already a Hardware, which i have to use with only two traces (RX/TX) between both chips. Additionally there is no HWFW available on Atmel's Atmega.\r\n\r\nI am thinking about switching to SPI, where i can use the two existing UART traces (can i assign any pin for SPI on the nRF51822, too?) and manually solder two additional cables f\u00fcr SPI's \"clk\" and \"ce\".\r\nThe nRF51822 would act as SPI Slave.\r\n\r\nIs this a good idea? Will this work better or do i have to expect similar or other Problems when using Softdevice S110 with SPI? Which maximum datarates can i expect with SPI and ATMega640 (with 16MHz external Clock) as SPI-Master?\r\n",
    "tag": "uart"
  },
  {
    "text": "nrf51822 fix UART error Rate / SPI? Hello,\r\n\r\ni am new to nRF Bluetooth.\r\nMy Setup ist:\r\n\r\nOne Atmel atmega640 and one nrf51822 communication via UART (at the moment).\r\n\r\nI am sending data from atmega640 to the nrf and i am experiencing an error-rate about 10% in incoming Data in the nrf when using a UARt Datarate of 38400 baud, which seems to be normal without using Hardware FlowControl. (https://devzone.nordicsemi.com/question/15665/uart-works-uncorrectly-while-ble-is-exchanging-data/)\r\n\r\nMy Problem is at the moment, that i need a communication with less Errors and higher DataRate, but there is already a Hardware, which i have to use with only two traces (RX/TX) between both chips. Additionally there is no HWFW available on Atmel's Atmega.\r\n\r\nI am thinking about switching to SPI, where i can use the two existing UART traces (can i assign any pin for SPI on the nRF51822, too?) and manually solder two additional cables f\u00fcr SPI's \"clk\" and \"ce\".\r\nThe nRF51822 would act as SPI Slave.\r\n\r\nIs this a good idea? Will this work better or do i have to expect similar or other Problems when using Softdevice S110 with SPI? Which maximum datarates can i expect with SPI and ATMega640 (with 16MHz external Clock) as SPI-Master?\r\n",
    "tag": "spi"
  },
  {
    "text": "Printf ( UART ) causing TWI not to work Hi all,\r\n\r\nI had a working TWI connection combined with BLE advertising. When\r\nI added uart code for printing to putty this TWI connection was no longer functional.\r\n\r\nSo I deleted the added UART code and discovered the TWI connection stopped working\r\nas soon as I open a serial connection in putty( 38400 baud, COM7). Even when nothing in my code even metioned uart connection using usb. When I unplug my\r\nusb connection to my nRF51 DK and reconnect ( and thus disabling putty ) TWI starts working again.\r\n\r\nMy guess is it has something to do with priorities?\r\n\r\nKind regards,\r\n\r\nNils",
    "tag": "twi"
  },
  {
    "text": "Printf ( UART ) causing TWI not to work Hi all,\r\n\r\nI had a working TWI connection combined with BLE advertising. When\r\nI added uart code for printing to putty this TWI connection was no longer functional.\r\n\r\nSo I deleted the added UART code and discovered the TWI connection stopped working\r\nas soon as I open a serial connection in putty( 38400 baud, COM7). Even when nothing in my code even metioned uart connection using usb. When I unplug my\r\nusb connection to my nRF51 DK and reconnect ( and thus disabling putty ) TWI starts working again.\r\n\r\nMy guess is it has something to do with priorities?\r\n\r\nKind regards,\r\n\r\nNils",
    "tag": "uart"
  },
  {
    "text": "Idling with low-speed timer Hi,\r\n\r\nI am trying to build a low power device using the nRF51422 SoC without a Soft Device. I need a timer to occasionally wake up the chip and as I read the product specification it should be possible to achieve a current consumption of 250uA when using only the 1MHz low-speed timer and a 16MHz crystal oscillator (PS 3.1, table 22, page 40). However, with an example from SDK 8.0 as starting point and the nRF51 development kit, I have not been able to get the power lower than approximately 550uA. I use the current measurement guideline from the DK user guide. What can be done to lower the current further?\r\n\r\nA sub question: When programming using IAR the current consumption is considerable higher until the development kit is restarted. Is it possible to avoid this?\r\n\r\nBest Regards,\r\ncth",
    "tag": "timer"
  },
  {
    "text": "Adjustable Volume for PWM Driven Piezo on 51422 I am driving a piezo at a fixed frequency but want to provide adjustable volume by adjusting the duty cycle. I would like to adjust it by setting the duty cycle to 5 levels. For simplicity, lets say 0, 12.5, 25, 37.5, and 50%. However, I am finding this is impacting stability of the Bluetooth communication. Is there any example code that could be used to provide such functionality.",
    "tag": "adc"
  },
  {
    "text": "Data streaming from multiple sensors (BLE + UART + TWI) Hi,\r\nI want to use BLE for following situation and I wonder if it is achievable.\r\nI have a 3 boards with nrf51822. Two of these boards have mpu6050 sensors connected to nrf51822 via TWI (I2C). These two boards work as BLE peripheral and server. Third board is BLE central and client device. What I want to do is:\r\n\r\n1. read data via I2C from sensors on each peripheral\r\n2. send data from both peripherals to central via BLE.\r\n3. send collected data from central via UART (to computer). Generally central works as USB BLE dongle.\r\n\r\nThe problem might be because i want to send packet of no more than 20 bytes (I know that max 20 bytes per notification is possible) with frequency min 30 Hz (50 Hz is recommended).\r\n\r\nHere are my questions:\r\n\r\n1. Is it possible to read 20 bytes from TWI and send it via BLE (peripheral) with mentioned frequency? I'm asking because I read that BLE generally \"blocks\" uC during his work. But in my situation I first read data and next I send it via BLE so i believe it is not problem.\r\n2. Is it possible by central to read data from 2 pheripherials via BLE and send it via UART with mentioned frequency ?\r\n3. How many such peripherals central can handle? \r\n",
    "tag": "uart"
  },
  {
    "text": "Data streaming from multiple sensors (BLE + UART + TWI) Hi,\r\nI want to use BLE for following situation and I wonder if it is achievable.\r\nI have a 3 boards with nrf51822. Two of these boards have mpu6050 sensors connected to nrf51822 via TWI (I2C). These two boards work as BLE peripheral and server. Third board is BLE central and client device. What I want to do is:\r\n\r\n1. read data via I2C from sensors on each peripheral\r\n2. send data from both peripherals to central via BLE.\r\n3. send collected data from central via UART (to computer). Generally central works as USB BLE dongle.\r\n\r\nThe problem might be because i want to send packet of no more than 20 bytes (I know that max 20 bytes per notification is possible) with frequency min 30 Hz (50 Hz is recommended).\r\n\r\nHere are my questions:\r\n\r\n1. Is it possible to read 20 bytes from TWI and send it via BLE (peripheral) with mentioned frequency? I'm asking because I read that BLE generally \"blocks\" uC during his work. But in my situation I first read data and next I send it via BLE so i believe it is not problem.\r\n2. Is it possible by central to read data from 2 pheripherials via BLE and send it via UART with mentioned frequency ?\r\n3. How many such peripherals central can handle? \r\n",
    "tag": "twi"
  },
  {
    "text": "printf / UART debug does not work properly on nRF51822 s110 ble_app_hts example. Hi,\r\n\r\nThanks for taking the time looking into issue.\r\nWe are using Keil uVision 5.14.\r\nOur target is a custom board (BMD200 eval Module based on nRF51822)\r\nWe were able to run uart example with expected outputs to Putty through the UART by following the example from:\r\nhttp://developer.nordicsemi.com/nRF51_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00054.html\r\nWhich is awesome.\r\n\r\nWe switched the project to ble_app_hts (http://developer.nordicsemi.com/nRF51_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00071.html), copied what worked in the uart example and add printf() to places like main(), device_manager_evt_handler(), on_ble_evt(), on_adv_evt, etc, etc. However only the printfs in main() works. We also tried adding the \"ENABLE_DEBUG_LOG_SUPPORT\" define to the project c/c++ tab, and use the app_trace_init(). The only thing that's printed was a '[' character. We then added \"printf(\"Hello!: \\n\\r\");\" right after  app_trace_init();, and \"Hel\" was then printed, nothing more.\r\n\r\nWhat's more interesting is in the uart example, instead of initializing uart in main(), we use the app_trace.c API, and it still works as expected.\r\n\r\nSo in summary,\r\nwithout \"ENABLE_DEBUG_LOG_SUPPORT\" defined, by using printf() and uart initialization in main() of the ble_app_hts example, every print statement within main() work, just not outside of main().\r\nwith \"ENABLE_DEBUG_LOG_SUPPORT\" defined, and using the app_trace.c API, only a few characters are printed.\r\nJust wondering if anyone has encountered this...\r\n\r\nAlso, this might be considered a separate question (if so, I can start a new thread.)\r\nI thought the printf() did not work in functions other than main() because they are callbacks running from different context invoked by the softdevice layer (I am really new at this, so just make assumptions here.), So I decided to use an enum to track which functions/callbacks the program has executed and print the enum in the main() loop. However, the enum value doesn't change at all after the \"advertise\" state.\r\n\r\nIt doesn't seem to make sense because we have the nRF master control app running, and connected to it, and requesting notifications (battery level) from it. We also changed the enum value in \"hts_sim_measurement(ble_hts_meas_t * p_meas)\" function, which is supposed to be executed very x seconds. But still, the enum value just doesn't change. Did I miss anything here?\r\n\r\nThank you!\r\n(Please find attached the main.c. It's quite messy with our modification. The purpose is to illustrate the issues I have mentioned, where we used printf()s and where we use the enum value to indicate the state of the program.)[main.c](/attachment/0c819ea8e8e264f5f6f321d73408dd36)\r\n",
    "tag": "uart"
  },
  {
    "text": "Converting ble_app_uart to SPI slave Hi\r\nI have tried to convert ble_app_uart to use spi slave rather than the uart with no success.\r\nPlease can I have some pointers as how to go about it. \r\n\r\nThank you",
    "tag": "spi"
  },
  {
    "text": "How to turn on the BSP UART \r\nHello,\r\n\r\nI am altering this project: nRF51_SDK_8.0.0_5fc2c3a\\examples\\ble_peripheral\\ble_app_hrs\\pca10028\r\n\r\nI am trying to turn on the BSP UART.  I main.c the project uses bsp_init() to enable the buttons and leds.\r\n\r\nI just want to use the UART so I modified the bsp_init() to this:\r\n\r\n    err_code = bsp_init(BSP_INIT_UART,\r\n                        APP_TIMER_TICKS(100, APP_TIMER_PRESCALER),\r\n                        NULL);\t\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nThen I have an output message using this function:\r\n\r\n\t  err_code = bsp_indication_text_set(BSP_INDICATE_SENT_OK, \"Test UART Output\\n\\r\");\r\n\t  APP_ERROR_CHECK(err_code);\r\n\r\nPutting a breakpoint inside the bsp_indication_text_set() function on the printf statment, I am not able to get it to stop on the printf statement.\r\n\r\n    uint32_t bsp_indication_text_set(bsp_indication_t indicate, char const * p_text)\r\n    {\r\n        uint32_t err_code = bsp_indication_set(indicate);\r\n\r\n    #ifdef BSP_UART_SUPPORT\r\n        printf(\"%s\", p_text);                            // Set breakpoint here\r\n    #endif // BSP_UART_SUPPORT\r\n\r\n        return err_code; \r\n    }\r\n\r\nI am guessing BSP_UART_SUPPORT is not set properly to execute the printf statement.\r\n\r\nAm I not turning on the BSP UART correctly?\r\n\r\n\r\nI added  #define BSP_UART_SUPPORT\t1\r\n\r\n    #ifdef BSP_UART_SUPPORT\r\n        printf(\"%s\", p_text);\r\n    #endif // BSP_UART_SUPPORT\r\n\r\n    return err_code;\r\n\r\nI put a breakpoint on the printf statement and the return statement.  The debugger stops at t the printf.  I take the next step in the code and it does not stop on the return statement.  I believe there is some issue with the uart and the printf statement is not executing properly.\r\n\r\nThanks,\r\nGlenn",
    "tag": "uart"
  },
  {
    "text": "Trying to initiate SPI calls SystemReset Hello,\r\n\r\nI am currently trying to write my frist few lines of code.. I started with the ble_uart example and then mixed in some code from the spi_master example.. I wanted to try to communicate with a Sensor over SPI and to make sure it works, use UART.\r\n\r\nBut my code won't work and I haven't yet found out why. I will keep on searching but probably one of you could easily point out the problem.\r\n\r\nIt seems that after\r\n\r\n    /* Clear waiting interrupts and events */\r\n        p_spi_instance->p_nrf_spi->EVENTS_READY = 0;\r\n\r\nthis is called: \r\n\r\n    NVIC_SystemReset\r\n\r\n\r\nBut I don't have a clue why.\r\n\r\nFeel free to have a look at the attached [main.c](/attachment/b258b743decfca3ab3db77a68571c1a0) \r\n(Of course the uart_init call should be before my printfs.. but thats not the cause of the problem)",
    "tag": "spi"
  },
  {
    "text": "Trying to initiate SPI calls SystemReset Hello,\r\n\r\nI am currently trying to write my frist few lines of code.. I started with the ble_uart example and then mixed in some code from the spi_master example.. I wanted to try to communicate with a Sensor over SPI and to make sure it works, use UART.\r\n\r\nBut my code won't work and I haven't yet found out why. I will keep on searching but probably one of you could easily point out the problem.\r\n\r\nIt seems that after\r\n\r\n    /* Clear waiting interrupts and events */\r\n        p_spi_instance->p_nrf_spi->EVENTS_READY = 0;\r\n\r\nthis is called: \r\n\r\n    NVIC_SystemReset\r\n\r\n\r\nBut I don't have a clue why.\r\n\r\nFeel free to have a look at the attached [main.c](/attachment/b258b743decfca3ab3db77a68571c1a0) \r\n(Of course the uart_init call should be before my printfs.. but thats not the cause of the problem)",
    "tag": "uart"
  },
  {
    "text": "ADC_RESULT in nrf51822 I was trying to calculate analog voltage in nrf51822 through ADC.\r\nI used analog 2 pin\r\nref voltage =1.2v\r\npre scaler = 1/3\r\nso while i connected 0.9v to analog pin. \r\nI see analog result as 0xDB.\r\nI was trying to calculate voltage through formula\r\ninput voltage = 1.2v * (1/pre-scalar)*(ADC_RES/256).\r\nMy voltage doesnt match to ADC_result.\r\nCan you please provide me solution for calculating input voltage?\r\n",
    "tag": "adc"
  },
  {
    "text": "SPI_MASTER_EVT_TRANSFER_COMPLETED never reached in ble_UART example [main.c](/attachment/cde247fea6b25bd80ce9dd2de64f5c07)\r\n\r\nI am trying to talk to this sensor: http://www.meas-spec.com/product/pressure/MS5803-05BA.aspx via SPI... it quite seems to work as I get expected responses to commands but as the title says \"SPI_MASTER_EVT_TRANSFER_COMPLETED\" is never called. And I can't figure out why. Also debugging just stops at an certain line without giving any error (at least I can't see any)",
    "tag": "spi"
  },
  {
    "text": "SPI_MASTER_EVT_TRANSFER_COMPLETED never reached in ble_UART example [main.c](/attachment/cde247fea6b25bd80ce9dd2de64f5c07)\r\n\r\nI am trying to talk to this sensor: http://www.meas-spec.com/product/pressure/MS5803-05BA.aspx via SPI... it quite seems to work as I get expected responses to commands but as the title says \"SPI_MASTER_EVT_TRANSFER_COMPLETED\" is never called. And I can't figure out why. Also debugging just stops at an certain line without giving any error (at least I can't see any)",
    "tag": "uart"
  },
  {
    "text": "SPI_Master : Expecting same result in SPI Mode 0 and 3 but it differs In the sensor datasheet it says one can use SPI_Mode 0 or 3 (doesn't say that there is anything to do to switch between them). \r\n\r\nI connected MISO from the DK with SDO from the Sensor and MOSI with SDI\r\n\r\n![image description](/attachment/9fedc8f7257f7bc88c17163d71833239)\r\n\r\nI tried all 4 CPHA/CPOL combinations and 2 should give me the same result.. but they all differ! (Of course I chose a coefficient that should be constant (and with no change in spi mode but just resetting to get the result again it is.). \r\n\r\nRX from left to right: reset-command, prom-read-command 0xA6, prom read results\r\n\r\n    ActiveLow + Trailing : FE FE 92 93 \r\n    ActiveLow + Leading : FF FF C9 49 \r\n    ActiveHigh + Leading : FE FE FE C8 \r\n    ActiveHigh + Trailing : FF FE FE 87\r\n\r\nWhat am I missing? I used the ble_uart example and added SPI.\r\nOf course I tried other speeds too.\r\n\r\nMaybe someone with a 100% working SPI Slave could flash, just edit the command and test if the code works?\r\n\r\n[main.c](/attachment/b39c981fe054731cf2a11838cc73c658)\r\n[ble_app_uart.zip](/attachment/8dc03947921a7e7ad8ae62febe8fb3e5)\r\n\r\n[Datasheet of Sensor](http://www.meas-spec.com/downloads/MS5803-05BA.pdf)",
    "tag": "spi"
  },
  {
    "text": "Debugger stops at APP_ERROR_CHECK(sd_nvic_ClearPendingIRQ(p_spi_instance->irq_type)); I am trying to add SPI to the ble_uart_example on my nRF51-DK but when I try to debug my code debugging just stops (All \"step one line\" etc. buttons grayed out) at this line\r\n\r\n        //Disable interrupt SPI.\r\n        APP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type));\r\n\r\nCode optimisation level0. The app still seems to work.. UART PC <-> Bluetooth Smartphone still works and also the SPI code seems to get executed..\r\n\r\n[main.c](/attachment/3ff1d3d8e9599a99178fb4c5d61f4b3c)",
    "tag": "spi"
  },
  {
    "text": "ble_uart_example LED2 is blinking when maximum connection interval > 1999ms Also it seems not to advertise. What may cause this problem?\r\n\r\n\r\nAll I could found in the ble_gap.h is:\r\n\r\n> If both conn_sup_timeout and\r\n> max_conn_interval are specified, then\r\n> the following constraint applies:  *  \r\n> conn_sup_timeout * 4 > (1 +\r\n> slave_latency) * max_conn_interval\r\n\r\nAccording to this (imagine max_conn_interval would be 4000):\r\n\r\n    #define MAX_CONN_INTERVAL               MSEC_TO_UNITS(75, UNIT_1_25_MS)             /**< Maximum acceptable connection interval (75 ms), Connection interval uses 1.25 ms units. */\r\n    #define SLAVE_LATENCY                   0                                           /**< Slave latency. */\r\n    #define CONN_SUP_TIMEOUT                MSEC_TO_UNITS(4000, UNIT_10_MS)             /**< Connection supervisory timeout (4 seconds), Supervision Timeout uses 10 ms units. */\r\n\r\nIt would be 4000*4 > (1+0) * 4000. Looks true to me.\r\n\r\nEdit: Seems like it works till 1999 and bugs if >2000. It should go all the way up to 4000. Shouldn't it? Also it says in the nRF Master Control Panel: 1998,75ms. (1998 -> 1997,50ms)\r\nI thought maybe the MSEC_TO_UNITS could cause the problem. But nope, just 3200 also doesn't work.",
    "tag": "uart"
  },
  {
    "text": "Read String from UART over BLE and execute function? Hello\r\n\r\nI'm using the nRF51 DK and I have a UART over BLE link set up between the board and a phone with the nRF UART app. I'm trying to get the board to execute a particular function when a certain string is received from the app. For example, the string {'R','e','a','d'} should get the board to start a function that sends data back to the app.\r\n\r\nI was wondering what the best way of doing this is?\r\n\r\nI currently have it working, but my solution seems unstable as the BLE frequently disconnects. Basically, I edited the \"nus_data_handler\" function found in the \"ble_app_uart_s110_pca10028\" example. I copy the data as it is received into an array, and execute functions based on what data is received. Is this an appropriate place to do these actions or is there an alternative?\r\n\r\nHere is a simplified version of the function I'm using:\r\n\r\n    static void nus_data_handler(ble_nus_t * p_nus, uint8_t * p_data, uint16_t length)\r\n    {\r\n    \tfor (uint32_t i = 0; i < length; i++)\r\n    \t{\r\n    \t\tUART_copy_array[i]=p_data[i];\r\n    \t\twhile(app_uart_put(p_data[i]) != NRF_SUCCESS)\r\n    \t\t{\r\n    \t\t\t\r\n    \t\t}\r\n    \t}\r\n    \twhile(app_uart_put('\\n') != NRF_SUCCESS);\r\n    \t\r\n    \r\n    \t\r\n    \t\t\tif((UART_copy_array[0]=='R')&&(UART_copy_array[1]=='e')&&(UART_copy_array[2]=='a')&&(UART_copy_array[3]=='d')){\r\n    \t\t\t\r\n    \t\t\t//Execute Function\r\n    \t\t}\r\n    }\r\n\r\nAny help would be much appreciated.\r\n\r\nThanks",
    "tag": "uart"
  },
  {
    "text": "spi_master_send_recv in an ISR I am calling the spi_master_send_recv in a ISR from a GPIO using app_gpiote.c  It causes a hardfault on APP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type)); Otherswise spi_master_send_recv works well when using the function from e.g. main().  Any hint...",
    "tag": "spi"
  },
  {
    "text": "Timers not working when using C++? So. After countless hours of messing around, reading SDK, examples and stuff I'm begginning to feel kind of frustrated. I want a microsecond timer. For that I tried a number of different approaches: app_timer, timer driver API and accessing the timers directly. So far app_timer seems to be the only one that worked, but it lacks in resolution I need.\r\n\r\nApproach 1:\r\n\r\n    nrf_drv_timer_t timerThing = NRF_DRV_TIMER_INSTANCE(1);\r\n    \r\n    void timerHandler(nrf_timer_events_t event)\r\n    {\r\n    \tif(event == NRF_TIMER_EVENTS_COMPARE0) log(\"time!\\r\\n\");\r\n    }\r\n    \r\n    void main()\r\n    {\r\n    \tlog(\"init\\r\\n\");\r\n    \tuint32_t ticks, ms = 2000;\r\n    \t\r\n    \tnrf_drv_timer_init(&timerThing, NULL, timerHandler);\r\n    \tticks = nrf_drv_timer_ms_to_ticks(&timerThing, ms);\r\n    \tnrf_drv_timer_extended_compare(&timerThing, NRF_TIMER_CC_CHANNEL0, ticks, NRF_TIMER_SHORTS_COMPARE0_CLEAR_MASK, true);\r\n    \tnrf_drv_timer_enable(&timerThing);\r\n    \t\r\n    \twhile(1);\r\n    \treturn 0;\r\n    }\r\n\r\nI looked into 'examples/peripheral/timer', basically copied the code just to get it running.\r\nWell.. The handler IS called just fine, the problem however is the fact that it's being called constantly. It doesn't matter what value I set for 'ms' variable. I checked the value returned by ms to ticks conversion function and it appears to be correct.\r\n\r\nSo I started to look around the devzone and I noticed that people were usually using these timers directly (if what I'm saying makes any sense).\r\n\r\n    volatile bool foobar = false;\r\n    \r\n    void TIMER1_IRQHandler()\r\n    {\r\n        if(NRF_TIMER1->EVENTS_COMPARE[0])\r\n        {\r\n            NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n            foobar = true;\r\n        }\r\n    }\r\n    \r\n    void uartEventHandler(app_uart_evt_t *event) {}\r\n    \r\n    int main()\r\n    {\r\n        uint32_t errorCode;\r\n        \r\n        app_uart_comm_params_t uartParams =\r\n        {\r\n            RX_PIN_NUMBER,\r\n            TX_PIN_NUMBER,\r\n            RTS_PIN_NUMBER,\r\n            CTS_PIN_NUMBER,\r\n            APP_UART_FLOW_CONTROL_DISABLED,\r\n            false,\r\n            UART_BAUDRATE_BAUDRATE_Baud115200 // 57600 // 115200\r\n        };\r\n    \r\n        APP_UART_FIFO_INIT(&uartParams, 32, 256, uartEventHandler, APP_IRQ_PRIORITY_LOW, errorCode);\r\n        \r\n        debugOut(\"Hello World!\\r\\n\");\r\n        \r\n        NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n        NRF_TIMER1->EVENTS_COMPARE[1] = 0;\r\n        NRF_TIMER1->EVENTS_COMPARE[2] = 0;\r\n        NRF_TIMER1->EVENTS_COMPARE[3] = 0;\r\n        \r\n        NRF_TIMER1->TASKS_STOP  = 1;\r\n        NRF_TIMER1->MODE        = TIMER_MODE_MODE_Timer << TIMER_MODE_MODE_Pos;\r\n        NRF_TIMER1->BITMODE     = TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n        NRF_TIMER1->PRESCALER   = 9;\r\n        NRF_TIMER1->TASKS_CLEAR = 1;\r\n        NRF_TIMER1->CC[0] = 31250;\r\n        NRF_TIMER1->INTENSET    = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n        NRF_TIMER1->SHORTS      = TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\r\n        NVIC_EnableIRQ(TIMER1_IRQn);\r\n        NRF_TIMER1->TASKS_START = 1;\r\n        \r\n        while(1)\r\n        {\r\n            if(foobar)\r\n            {\r\n                debugOut(\"foo\\r\\n\");\r\n                foobar = false;\r\n            }\r\n            else debugOut(\"no\\r\\n\");\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n\r\n\r\nThis at first wasn't working. It appeared as if it got stuck inside the interrupt or something. After compiling it with Keil it worked at first but then I did *something* that made it stop.\r\nNow I can't get it to work again:\r\n\r\n![image description](http://i.imgur.com/8GPwmpY.png)\r\n\r\nI'm obviously doing something very wrong, I'm just unable to find out what exactly it is.\r\nWhat am I missing here? Please forgive me if it's something rather silly, I'm still trying to learn the way everything works here.\r\n\r\nEDIT:\r\n\r\nI found something interesting. This is the code that orginally worked: http://pastebin.com/CGGxRLhs\r\n\r\nIt's C. After putting in in a .cpp file (compiling as C++) it doesn't work.\r\nPutting in in a .c file makes it work just fine...",
    "tag": "timer"
  },
  {
    "text": "softdevice affecting the IR pulse timing Hello devzone...\r\nMy setup: nRF51422 and S110 peripheral\r\nMy setup transmits IR data on reception of Bluetooth data from a central device. I have used PWM for generating IR pulses. It is configured as GPIOTE, the timer compare event toggles the pin. This works fine without the softdevice enabled.\r\nIf the softdevice is enabled, it blocks the CPU for sometime to serve the radio events which mess up the IR mark and space timings. I have to start and stop the timer tasks and events at proper intervals. Since softdevice blocks the CPU there is delay which increases the IR data timings.\r\nThe IR is an integral part of my application, so i would like to avoid ble events till the application sends IR data. \r\nAny suggestions and design improvements where in i can have a sync between IR and ble?\r\nCan i disable the events from sd for the time IR data is being sent?\r\n\r\nThanks..:-)",
    "tag": "pwm"
  },
  {
    "text": "Can I use UART with an external module linked up to nRF51DK via SWD? I am really struggling getting anything to work on my revision 1 module and as it has nothing connected at this moment all I can use is BLE or UART to observe any function.\r\n\r\nIf it is possible.. how to find out the correct values for\r\n\r\n      RX_PIN_NUMBER,\r\n      TX_PIN_NUMBER,\r\n      RTS_PIN_NUMBER,\r\n      CTS_PIN_NUMBER,\r\n\r\n?",
    "tag": "uart"
  },
  {
    "text": "Add delay argument to spi_master_send_recv : Where does the Chipselect get pulled high? Hello,\r\n\r\nfor my sensor I need to have a delay BEFORE pulling CS high. So I would like to add an argument to the\r\n\r\n    spi_master_send_recv()\r\nfunction that give me exactly this possibility.\r\n\r\nBut I am not 100% sure where exactly the chipselect pin is triggered..\r\nI tried my best with the debugger and found this line\r\n\r\n    nrf_gpio_pin_set(p_spi_instance->pin_slave_select);\r\n\r\ninside this function:\r\n\r\n    spi_master_send_recv_irq()\r\n\r\nBut I have really no clue how this function is called and how I could add my argument to this call.\r\n\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "nRF51822 interrupt Hi,\r\n\r\nI just replaced the BLE chip in my board from CC2540 to nRF51822. I simply want to know how to configure the interrupt on a pin as well as rising/falling edge interrupts. I looked nrf_gpio.h and nrf_gpiote.h but neither was helpful. I know this is quite simple but couldn't find it myself. Can anyone please help me?\r\n\r\nThanks,\r\nBrian",
    "tag": "interrupt"
  },
  {
    "text": "TWI Module lock-up still present in nrf51822 v3 [PAN #56] Hi,\r\n\r\nI am currently experiencing TWI module lock-up issues with the hardware TWI library, which is supposedly fixed according to PAN v3.0, issue #56. (The issue was previously identified in PAN v2.3)\r\n\r\nMy setup is as follows, custom board, SD110v8, NRF51822 QFAAH0 (16kB flash, v3 silicon). My code is modified from the dfu_ble_dual_bank example in the Keil packs. The TWI transaction is triggered every 2s by the app_timer. \r\n\r\nIf I change the TWI library to software TWI, then the problem disappears. \r\n\r\nAn interesting note is, before the dfu bootloader starts (prior to the function call of : bootloader_dfu_start ), the module lock up doesnt seem to happen.  Once the bootloader fully starts, (after calling bootloader_dfu_start function), the TWI transaction would randomly occur, fairly frequently. \r\n\r\nCould someone from Nordic provide some insight to this problem? As my observations seem to contradict the PAN v3.0\r\n\r\nWarm regards,\r\nMike\r\n",
    "tag": "twi"
  },
  {
    "text": "nrf9E5 ADC Calibration We would like to be able to calibrate the rRF9E5 ADC\r\n\r\nOur proposal is to permanently fit voltage dividers, each using two precision resistors, on two of the ADC Ports and use these to determine corrections to ADC when measuring on the other two ADC ports (and also measuring supply voltage).\r\n\r\nWe are assuming:\r\n- ADC performance is same for all ADC ports;\r\n- actual measurement varies linearly from true measurement;\r\n- performance may be temperature dependent, so we will probably need to calibrate each time.\r\n\r\nComments / suggestions welcome.\r\n\r\nThanks\r\n\r\nDamien",
    "tag": "adc"
  },
  {
    "text": "How to add an own timer to the multilink_peripheral_example ? Hello,\r\n\r\nI would like to move on from using nrf_delay_ms().\r\n\r\nI thought this would give me some first results, but It don't. Whats wrong?\r\n\r\n    //a\r\n        static void test_timer_handler(void * p_context)\r\n        {\r\n            UNUSED_PARAMETER(p_context);\r\n        \t\tprintf(\"Hallo\");\r\n        }\r\n        static app_timer_id_t   m_test_timer_id;\r\n        void test_timer_create_and_start(void) {\r\n        app_timer_create(&m_test_timer_id, APP_TIMER_MODE_REPEATED, test_timer_handler);\r\n        app_timer_start(m_test_timer_id, 100, NULL);\t\r\n        }\r\n    //b\r\n\r\n\r\n    int main(void)\r\n    {   uint32_t err_code;\r\n    \r\n        ble_stack_init();\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, NULL);\r\n        APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS);\r\n        err_code = bsp_init(BSP_INIT_LED | BSP_INIT_BUTTONS, APP_TIMER_TICKS(100, APP_TIMER_PRESCALER), button_event_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n    \t//a Timer\r\n    \t\ttest_timer_create_and_start();\t\r\n    \t//b \r\n\r\n\r\nMy bad. I was a little dizzy and forgot to increase the Max_timer define.. It was in fact that easy to get a timer running.",
    "tag": "timer"
  },
  {
    "text": "SPI doesn't work when started by Timer Short: Working Timer. Working SPI. SPI does not work when triggered by timer_handler.\r\n\r\nHello,\r\n\r\nI am currently trying to replace delays with timer in my code...\r\n\r\nI set up a working timer that goes off every 4 seconds. In the handler that is called I would like to call the function that initiates a measurement and then gets the values afterwards. It does not work in combination. Debugger stops at     `if (p_spi_instance->disable_all_irq)` in the SPI routine. (Flag is not set btw).\r\n\r\nIf I log via UART instead of any value it only outputs 0.\r\n\r\n[main.c](/attachment/fe5709b09252cce04e66b6e3f1195030)\r\n\r\n//Edit:\r\n\r\n    static void test_timer_handler(void * p_context)\r\n    {\r\n        UNUSED_PARAMETER(p_context);\r\n    \t\tprintf(\"Hallo\\n\");\r\n    \t\thole_temperatur();\r\n    }\r\n\r\nWhen I call this function from within the timer handler:\r\n\r\n            static int32_t hole_temperatur(void)\r\n        {\r\n        \t\t\t\t\r\n        \t\t\t\t\tif (m_transfer_completed) \r\n        \t\t\t\t{\t// ADC Temperatur 256 Aufloesung\r\n        \t\t\t\t\tm_transfer_completed = false;\t\r\n        \t\t\t\t\tm_tx_data_1B[0] = 0x50; \r\n        \t\t\t\t\tuint32_t err_code = spi_master_send_recv(SPI_MASTER_0, m_tx_data_1B, 1, m_rx_data_1B, 1);\r\n    APP_ERROR_CHECK(err_code);\t\r\n        \t\t\t\t\tprintf(\"%d %X %d \\n\",err_code, m_rx_data_1B[0], m_transfer_completed);\r\n        \t\t\t\t\tnrf_delay_ms(1);\r\n        \t\t\t\t}\r\n        \t\t\t\t\r\n        \t\t\t\t\tif (m_transfer_completed)\r\n                { //Hole und berechne Temperatur\r\n                  m_transfer_completed = false;\t\t\t\t\t\r\n        \t\t\t\t\tm_tx_data_4B[0] = 0x00;\r\n        \t\t\t\t\tm_tx_data_4B[1] = 0xFF;\r\n        \t\t\t\t\tm_tx_data_4B[2] = 0xFF;\r\n        \t\t\t\t\tm_tx_data_4B[3] = 0xFF;\r\n        \t\t\t\t\tuint32_t err_code = spi_master_send_recv(SPI_MASTER_0, m_tx_data_4B, 4, m_rx_data_4B, 4);\t\r\n        \t\t\t\t\tAPP_ERROR_CHECK(err_code);\t\r\n        \t\t\t\t\tprintf(\"%d \\n\",err_code);\r\n        \t\t\t\t\tnrf_delay_ms(1);\r\n        \t\t\t\t\tprintf(\"%X \\n\",m_rx_data_4B[1]);\r\n        \t\t\t\t\t//printf(\"%X \\n\",m_rx_data_4B[2]);\r\n        \t\t\t\t\t//printf(\"%X \\n\",m_rx_data_4B[3]);\r\n        \t\t\t\t\tD2 = m_rx_data_4B[1]<<16 | m_rx_data_4B[2]<<8 | m_rx_data_4B[3];\r\n        \t\t\t\t\t//printf(\"%d \\n\",D2);\r\n        \t\t\t\t\t//printf(\"%s \\n\", m_transfer_completed ? \"true\" : \"false\");\r\n        \t\t\t\t\tdT = (int32_t)D2 - ( (int32_t)Koeff[5] * 256 );\t\t\t\t\r\n        \t\t\t\t\tT = 2000 + ((int64_t)dT * Koeff[6]) / 8388608LL;\t\t\t\t\t\r\n        \t\t\t\t} return T = (int32_t)T;\r\n        }\r\n\r\nIt outputs \"0 FE 0\"  So no error. Expected Read Result **but transfer not completed**!\r\nI removed the static from the variable declaration but that didn't help. The flag is meant to be set inside the spi_master_event_handler.\r\n\r\nWhen I remove the if(transfer_completed) from the //Hole und berechne Part I only receive a capital H every 4 seconds. (The \"Hallo\" is also gone missing)\r\n\r\nWell it looks like it is the H from Hallo. With the hallo-printf statement excluded I aint got nothin'.\r\n\r\n\r\n\r\nHow else could I realize this? All I could think of is just setting a flag in the timer_handler and check for this in the main()-loop and then execute the code from here. But that wouldn't help me with current consumption, would it? This would also keep the chip awake or would this be better than using delay?\r\n\r\n    timer_handler {test_flag=true}\r\n    \r\n        for (;;)\r\n        {\r\n          power_manage();       \r\n                if(test_flag) { printf(\"%d \\n\",hole_temperatur()); test_flag=false;}\r\n    }",
    "tag": "timer"
  },
  {
    "text": "SPI doesn't work when started by Timer Short: Working Timer. Working SPI. SPI does not work when triggered by timer_handler.\r\n\r\nHello,\r\n\r\nI am currently trying to replace delays with timer in my code...\r\n\r\nI set up a working timer that goes off every 4 seconds. In the handler that is called I would like to call the function that initiates a measurement and then gets the values afterwards. It does not work in combination. Debugger stops at     `if (p_spi_instance->disable_all_irq)` in the SPI routine. (Flag is not set btw).\r\n\r\nIf I log via UART instead of any value it only outputs 0.\r\n\r\n[main.c](/attachment/fe5709b09252cce04e66b6e3f1195030)\r\n\r\n//Edit:\r\n\r\n    static void test_timer_handler(void * p_context)\r\n    {\r\n        UNUSED_PARAMETER(p_context);\r\n    \t\tprintf(\"Hallo\\n\");\r\n    \t\thole_temperatur();\r\n    }\r\n\r\nWhen I call this function from within the timer handler:\r\n\r\n            static int32_t hole_temperatur(void)\r\n        {\r\n        \t\t\t\t\r\n        \t\t\t\t\tif (m_transfer_completed) \r\n        \t\t\t\t{\t// ADC Temperatur 256 Aufloesung\r\n        \t\t\t\t\tm_transfer_completed = false;\t\r\n        \t\t\t\t\tm_tx_data_1B[0] = 0x50; \r\n        \t\t\t\t\tuint32_t err_code = spi_master_send_recv(SPI_MASTER_0, m_tx_data_1B, 1, m_rx_data_1B, 1);\r\n    APP_ERROR_CHECK(err_code);\t\r\n        \t\t\t\t\tprintf(\"%d %X %d \\n\",err_code, m_rx_data_1B[0], m_transfer_completed);\r\n        \t\t\t\t\tnrf_delay_ms(1);\r\n        \t\t\t\t}\r\n        \t\t\t\t\r\n        \t\t\t\t\tif (m_transfer_completed)\r\n                { //Hole und berechne Temperatur\r\n                  m_transfer_completed = false;\t\t\t\t\t\r\n        \t\t\t\t\tm_tx_data_4B[0] = 0x00;\r\n        \t\t\t\t\tm_tx_data_4B[1] = 0xFF;\r\n        \t\t\t\t\tm_tx_data_4B[2] = 0xFF;\r\n        \t\t\t\t\tm_tx_data_4B[3] = 0xFF;\r\n        \t\t\t\t\tuint32_t err_code = spi_master_send_recv(SPI_MASTER_0, m_tx_data_4B, 4, m_rx_data_4B, 4);\t\r\n        \t\t\t\t\tAPP_ERROR_CHECK(err_code);\t\r\n        \t\t\t\t\tprintf(\"%d \\n\",err_code);\r\n        \t\t\t\t\tnrf_delay_ms(1);\r\n        \t\t\t\t\tprintf(\"%X \\n\",m_rx_data_4B[1]);\r\n        \t\t\t\t\t//printf(\"%X \\n\",m_rx_data_4B[2]);\r\n        \t\t\t\t\t//printf(\"%X \\n\",m_rx_data_4B[3]);\r\n        \t\t\t\t\tD2 = m_rx_data_4B[1]<<16 | m_rx_data_4B[2]<<8 | m_rx_data_4B[3];\r\n        \t\t\t\t\t//printf(\"%d \\n\",D2);\r\n        \t\t\t\t\t//printf(\"%s \\n\", m_transfer_completed ? \"true\" : \"false\");\r\n        \t\t\t\t\tdT = (int32_t)D2 - ( (int32_t)Koeff[5] * 256 );\t\t\t\t\r\n        \t\t\t\t\tT = 2000 + ((int64_t)dT * Koeff[6]) / 8388608LL;\t\t\t\t\t\r\n        \t\t\t\t} return T = (int32_t)T;\r\n        }\r\n\r\nIt outputs \"0 FE 0\"  So no error. Expected Read Result **but transfer not completed**!\r\nI removed the static from the variable declaration but that didn't help. The flag is meant to be set inside the spi_master_event_handler.\r\n\r\nWhen I remove the if(transfer_completed) from the //Hole und berechne Part I only receive a capital H every 4 seconds. (The \"Hallo\" is also gone missing)\r\n\r\nWell it looks like it is the H from Hallo. With the hallo-printf statement excluded I aint got nothin'.\r\n\r\n\r\n\r\nHow else could I realize this? All I could think of is just setting a flag in the timer_handler and check for this in the main()-loop and then execute the code from here. But that wouldn't help me with current consumption, would it? This would also keep the chip awake or would this be better than using delay?\r\n\r\n    timer_handler {test_flag=true}\r\n    \r\n        for (;;)\r\n        {\r\n          power_manage();       \r\n                if(test_flag) { printf(\"%d \\n\",hole_temperatur()); test_flag=false;}\r\n    }",
    "tag": "spi"
  },
  {
    "text": "simple example of SPI + S110 (on SDK 8.x) ? Hello,\r\n\r\nI wrote a firmware for my project, based on the UART over BLE example, so using the softdevice, establishing connections, etc. It works.\r\n\r\nI'd now like to use a sensor connected via SPI. I have looked at the spi_master_with_spi_slave example, but it does not use the softdevice, and I suspect it won't \"just work\" if I do the same thing, as the softdevice might interfere with interrupts for example. Am I right ?\r\n\r\nDoes anyone have a simple example of reading and writing data using SPI with SoftDevice enabled (and a BLE connection running) ?\r\n\r\nThe main problem I'm affraid of is that in some test code I have done with this sensor and without SoftDevice, I have this function :\r\n\r\n    /**\r\n     * Reads a byte from the specified register in the MFRC522 chip.\r\n     * The interface is described in the datasheet section 8.1.2.\r\n     */\r\n    uint8_t PCD_ReadRegister1(\tuint8_t reg ) {\r\n    \tuint32_t err_code;\r\n    \r\n    \tm_tx_data[0] = 0x80 | (reg << 1);\r\n    \tm_tx_data[1] = 0x00;\r\n    \r\n    \tm_transfer_done = false;\r\n    \terr_code = spi_master_send_recv(SPI_MASTER_HW, m_tx_data, 2, m_rx_data, 2);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \r\n    \twhile (!m_transfer_done)\r\n    \t\t;\r\n    \r\n    \treturn m_rx_data[1];\r\n    } // End PCD_ReadRegister()\r\n\r\nbut it ends with a \"while (!m_transfer_done), and so it blocks the rest of the execution. How should I rewrite this, but be able to do stuff like :\r\n\r\n    val = PCD_ReadRegister1(VersionReg);\r\n    sprintf(str, \"version: 0x%02x\\r\\n\", val);\r\n    simple_uart_putstring(str);\r\n\r\n(that assumes that PCD_ReadRegister1 returns directly the value, but if I do that I will have a while loop that will block the SoftDevice and other stuff)\r\n\r\n?\r\n\r\nThanks for your help",
    "tag": "spi"
  },
  {
    "text": "Battery Level  discharge curve, How can I read? I found this website.\r\n\r\n[link text](http://biz.maxell.com/en/product_primary/?pci=9&pn=pb0002) \r\n\r\ncurve is shown below.\r\n\r\n![image description](/attachment/e57d34e70b4bc0cbbb469b4305882d60)\r\n\r\nThere are app_utils.h information below.\r\n\r\n * @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.\r\n *\r\n *  @details The calculation is based on a linearized version of the battery's discharge\r\n *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and\r\n *           is considered to be the lower boundary.\r\n *\r\n *           The discharge curve for CR2032 is non-linear. In this model it is split into\r\n *           4 linear sections:\r\n *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)\r\n *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)\r\n *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)\r\n *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)\r\n *\r\n *           These numbers are by no means accurate. Temperature and\r\n *           load in the actual application is not accounted for!\r\n *\r\n *  @param[in] mvolts The voltage in mV\r\n *\r\n *  @return    Battery level in percent.\r\n\r\nI don't understand the above graph look.\r\n\r\nHow can I split like a source in the app_utils.h?\r\n\r\nWhat are criteria divides?\r\n\r\nAnd can you analyze that graph?\r\n\r\nIf you analyze, what should I do?\r\n\r\nOr is there another way?\r\n\r\nOh.. I use CR2032. I would like to know how to use, even if the other batteries ago.\r\n",
    "tag": "adc"
  },
  {
    "text": "On the fly configuration change Hi Team,\r\n\r\nIn my application UART is used.\r\nI need to send parity bit based on particular responses that I need to send to the device\r\nconnected to UART.  \r\nCan I change configuration of UART on-the-fly for this?\r\nIn datasheet it is mentioned that parity checking is supported.  \r\nWhat to do if I need to send 0x00 data with parity bit 1?\r\n\r\n\r\nRegards,\r\nMilan Joshi",
    "tag": "uart"
  },
  {
    "text": "Current consumption of if condition in for(;;) loop Hello,\r\n\r\nas I couldn't manage to get my SPI Measurement working flawlessly when called from inside a timer handler I tried to work around it by just setting a flag inside the timer handler and then call the measurement from inside the `main()`-function in the `for(;;)`-loop after the `power_manage();`-function by putting the code inside `if(flag) { SPI-Stuff; flag=false; }`\r\n\r\n    int main(void)\r\n    { \r\n    \r\n        for (;;)\r\n        {\r\n          power_manage();\t\r\n    \t\t\t\t\r\n    \t\t\tif(test_flag) {\r\n    lots of code\r\n    \t\t\t\ttest_flag=false;\r\n    \t\t\t}\r\n    \r\n        }\r\n    }\r\n\r\nWhat is the current consumption of this? In what state is the chip when constantly checking the if flag?",
    "tag": "spi"
  },
  {
    "text": "nrf_pwm_noglitch stuck if output 100% I have a LED dimming project that uses nRF51822 and nrf_pwm_noglitch. If I turn to 100% duty cycle, then it will be stuck at 100% unless I turn it to 0%.\r\n\r\nSo in other words, I cannot go from 100% to 50% to 0%, I can only go from 100% to 0% to 50%, but in that case, the LED blinks and it defeats the purpose of using noglitch.\r\n\r\nWhat's wrong?",
    "tag": "pwm"
  },
  {
    "text": "How to clear RTC interrupt? Hi all, \r\n\r\nI have an TICK interrupt on RTC1 on nRF51822, but the program keeps cycling in the interrupt - as if the interrupt is never cleared? \r\n\r\nHere's my code: \r\n\r\n \r\n\r\n    void RTC1_IRQHandler(void) {\r\n\r\n    // Clear all events (also unexpected ones)\r\n        NRF_RTC1->EVENTS_COMPARE[0] = 0;\r\n        NRF_RTC1->EVENTS_COMPARE[1] = 0;\r\n        NRF_RTC1->EVENTS_COMPARE[2] = 0;\r\n        NRF_RTC1->EVENTS_COMPARE[3] = 0;\r\n        NRF_RTC1->EVENTS_TICK       = 0;\r\n        NRF_RTC1->EVENTS_OVRFLW     = 0;\r\n \r\n\t//Also try to clear this way: \r\n        NRF_RTC1->INTENCLR = 0xff;\r\n        NRF_RTC1->EVTENCLR = 0xff;\r\n\r\n      //Run timers:\r\n      SWTimers_timeouts_check();\r\n\r\n      //Run scheduler:\r\n      Scheduler_isr();\r\n\r\n    }",
    "tag": "interrupt"
  },
  {
    "text": "TWI is not working with SoftDevice This seems to be a common problem after searching in this forum. In my case, I need to read from an I2C slave and send the data out in BLE. I have made it work without SoftDevice using this library code http://pastebin.com/qLLAy418 . However, it failed to work with SoftDevice. I also tried with another version which has SoftDevice knobs http://pastebin.com/AV6cQK0x. It doesn't work either. I also tried other code https://github.com/NordicSemiconductor/nrf51-ble-app-lbs/blob/twi-display-5.1.0/twi_hw_master.c that someone claimed to work (https://devzone.nordicsemi.com/question/15743/nrf51822-s110-problem-with-i2c-to-mpu9150/), but it doesn't work for me. Can anyone provide any suggestion on this problem? ",
    "tag": "twi"
  },
  {
    "text": "SPI Master MISO Noise Issue I'm trying to connect to a ST LSM6DS3 via SPI on the Nordic chip. I have used SPI on Nordic with other peripherals but couldn't seem to get it to work with this ST chip. Eventually, after debugging it from a firmware stand-point I decided to scope it out and see if the SPI signals were corresponding to what I was getting in firmware. What I discovered is the two situations:\r\n\r\n1.  when I probe MISO  when it is disconnected to the Nordic chip the response from the ST chip is correct. Nice clean crisp signal\r\n\r\n2. When I probe it with MISO connected to the Nordic chip I get some sort of noise. \r\n\r\n\r\nI included the two captures below and was hoping to get an idea why the SPI interface is behaving like this. Does anyone know why it is doing this and how to make it stop? Do I have some internal pull-up/pull-down's configured incorrectly? I am a bit out of ideas... :/\r\n\r\n\r\n\r\n\r\n![Good Response with MISO Disconnected From Nordic Chip](/attachment/bcaced8340dd2565307054b14f0884c9)\r\n\r\n\r\n![MISO Connected to Nordic -- Noisey(?)](/attachment/ebfe02a55d3c3ac859ed50d4b1434566)\r\n\r\n \r\n![Zoom of Noise](/attachment/4ac89c7a26e99ba2c1f8ddd4e15c61f9)\r\n\r\n\r\nST Datasheet: http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/DM00133076.pdf",
    "tag": "spi"
  },
  {
    "text": "SPI Master MISO Noise Issue I'm trying to connect to a ST LSM6DS3 via SPI on the Nordic chip. I have used SPI on Nordic with other peripherals but couldn't seem to get it to work with this ST chip. Eventually, after debugging it from a firmware stand-point I decided to scope it out and see if the SPI signals were corresponding to what I was getting in firmware. What I discovered is the two situations:\r\n\r\n1.  when I probe MISO  when it is disconnected to the Nordic chip the response from the ST chip is correct. Nice clean crisp signal\r\n\r\n2. When I probe it with MISO connected to the Nordic chip I get some sort of noise. \r\n\r\n\r\nI included the two captures below and was hoping to get an idea why the SPI interface is behaving like this. Does anyone know why it is doing this and how to make it stop? Do I have some internal pull-up/pull-down's configured incorrectly? I am a bit out of ideas... :/\r\n\r\n\r\n\r\n\r\n![Good Response with MISO Disconnected From Nordic Chip](/attachment/bcaced8340dd2565307054b14f0884c9)\r\n\r\n\r\n![MISO Connected to Nordic -- Noisey(?)](/attachment/ebfe02a55d3c3ac859ed50d4b1434566)\r\n\r\n \r\n![Zoom of Noise](/attachment/4ac89c7a26e99ba2c1f8ddd4e15c61f9)\r\n\r\n\r\nST Datasheet: http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/DM00133076.pdf",
    "tag": "spi"
  },
  {
    "text": "nrf51822 PWM with softdevice and ppi I am using nRF51822 to generate 3K HZ PWM signal for a buzzer.\r\nI  read other people's question and try it.But as far i can't solve this issue.Please help.\r\n\r\nAt first i use the simplest way,use for loop and delay. \r\nSomeone said that when softdevice enable,in some interval time will be effected(i forget the word, sorry). It's look like the same circumstances.The PWM signal sometimes display wrong period,like something have affect the waveform.I guess ,it will be some  relation with BLE? \r\n\r\nSO i try another way.I copy the code  from the example project  pwm_example and do some change.It works's well.But when i use it with softdevice ,here comes the same trouble.\r\nIt uses PPI ,i think it can avoid BLE or other effect,but it's not.\r\n\r\nCould someone give me some suggestion?Thank you. Below it's my code.Please help.\r\nUse S110 .keil\r\n\r\nvoid TIMER2_IRQHandler(void)\r\n{\r\n    static bool cc0_turn = false; /**< Keeps track of which CC register to be used. */\r\n\r\n    if ((NRF_TIMER2->EVENTS_COMPARE[1] != 0) && \r\n       ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE1_Msk) != 0))\r\n    {\r\n        // Sets the next CC1 value\r\n        NRF_TIMER2->EVENTS_COMPARE[1] = 0;\r\n        //NRF_TIMER2->CC[1]             = (NRF_TIMER2->CC[1] + MAX_SAMPLE_LEVELS);\r\n\t\t\tNRF_TIMER2->CC[1]             = (NRF_TIMER2->CC[1] + 83);\r\n    \r\n        // Every other interrupt CC0 and CC2 will be set to their next values.\r\n           uint32_t next_sample = 40;\r\n        if (cc0_turn)\r\n        {\r\n            NRF_TIMER2->CC[0] = NRF_TIMER2->CC[1] + next_sample;\r\n        }\r\n        else\r\n        {\r\n            NRF_TIMER2->CC[2] = NRF_TIMER2->CC[1] + next_sample;\r\n        }\r\n        // Next turn the other CC will get its value.\r\n        cc0_turn = !cc0_turn;\r\n    }\r\n}\r\n\r\n\r\n/** @brief Function for initializing the Timer 2 peripheral.\r\n */\r\n void timer2_init(void)\r\n{\r\n    // Start 16 MHz crystal oscillator .\r\n   \r\n\r\n    NRF_TIMER2->MODE      = TIMER_MODE_MODE_Timer;\r\n    NRF_TIMER2->BITMODE   = TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n    NRF_TIMER2->PRESCALER = TIMER_PRESCALERS;\r\n\r\n    // Clears the timer, sets it to 0.\r\n    NRF_TIMER2->TASKS_CLEAR = 1;\r\n\r\n    // Load the initial values to TIMER2 CC registers.\r\n   \r\n\t\r\n   N RF_TIMER2->CC[0] = MAX_SAMPLE_LEVELS + next_sample_get();\r\n    NRF_TIMER2->CC[1] = MAX_SAMPLE_LEVELS;\r\n\r\n    // CC2 will be set on the first CC1 interrupt.\r\n    NRF_TIMER2->CC[2] = 0;\r\n\r\n    // Interrupt setup.\r\n    NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos);\r\n}\r\n\r\n\r\n/** @brief Function for initializing the GPIO Tasks/Events peripheral.\r\n */\r\n void gpiote_init(void)\r\n{\r\n    // Connect GPIO input buffers and configure PWM_OUTPUT_PIN_NUMBER as an output.\r\n    \r\n    nrf_gpio_cfg_output(22);\r\n\r\n    \r\n    // @note Only one GPIOTE task can be connected to an output pin.\r\n    nrf_gpiote_task_config(0, 22, \\\r\n                           NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n}\r\n\r\n\r\n/** @brief Function for initializing the Programmable Peripheral Interconnect peripheral.\r\n */\r\n void ppi_init(void)\r\n{\r\n    \r\n\t\r\n\tsd_ppi_channel_assign(0, &(NRF_TIMER2->EVENTS_COMPARE[0]), &(NRF_GPIOTE->TASKS_OUT[0]));\r\n\tsd_ppi_channel_assign(1, &(NRF_TIMER2->EVENTS_COMPARE[1]), &(NRF_GPIOTE->TASKS_OUT[0]));\r\n\tsd_ppi_channel_assign(3, &(NRF_TIMER2->EVENTS_COMPARE[2]), &(NRF_GPIOTE->TASKS_OUT[0]));\r\n\t\r\n\t\t\tsd_ppi_channel_enable_set(PPI_CHEN_CH0_Msk);\r\n\t\t\tsd_ppi_channel_enable_set(PPI_CHEN_CH1_Msk);\r\n\t\t\tsd_ppi_channel_enable_set(PPI_CHEN_CH2_Msk);\r\n}\r\n\r\n\r\n\r\ngpiote_init();\r\n\r\nppi_init();\r\n\r\ntimer2_init();\t\r\n\r\nsd_nvic_SetPriority(TIMER2_IRQn,3);\r\n\r\nsd_nvic_EnableIRQ(TIMER2_IRQn);\r\n\r\nleds_init();//BLE LED \r\n\r\n    timers_init();\r\n\r\nbuttons_init();\r\n\r\n    uart_init();\r\n\t\r\n\t\tble_stack_init(); \r\n   \r\n\t\tgap_params_init();\r\n\r\n\t\tservices_init();\r\n\r\n\t\tadvertising_init();\r\n\r\n             conn_params_init();\r\n\r\n             sec_params_init();\r\n\r\n\t\tadc_init();\r\n\r\n\t\tadvertising_start();",
    "tag": "pwm"
  },
  {
    "text": "Interrupt in Bootloader not working I'm using interrupt_handler.c for a bootloader without a softdevice from [this source](https://devzone.nordicsemi.com/question/33621/how-to-make-the-nrf51822-flash-jump-successful-without-softdevice/). Interrupt handling in the main app seems to work fine. But interrupts in the bootloader leading to a reset.\r\n\r\nFor example my uart interrupt.\r\n\r\n 1. on an uart interrupt section bootloop is called\r\n 2. jumps to uart0\r\n 3. jumps to execute\r\n 4. execute jumps to 0x0000 0000\r\n\r\nWhy?\r\n \r\n    [uart.c]\r\n    void UART0_IRQHandler_Bootloader(void)\r\n    {\r\n        // some code\r\n    }\r\n\r\n\r\n    [interrupt_handler.c]\r\n    bootload \r\n            CMP R0, #0x24;\r\n            BEQ swi0\r\n            CMP R0, #0x21;\r\n            BEQ rtc1\r\n            CMP R0, #0x16;\r\n            BEQ gpiote\r\n            CMP R0, #0x12;\r\n            BEQ uart0\r\n            //RETURN code needed\r\n    uart0\r\n            EXTERN  UART0_IRQHandler_Bootloader[WEAK]     \r\n            LDR    R0,=UART0_IRQHandler_Bootloader\r\n            B execute ;            \r\n    execute            \r\n            BX     R0  ;\r\n\r\n\r\nI did some investigations:\r\nR0 is loaded with 0x0000 0000 is above example.\r\nWhen removing [WEAK] everything works as expected.\r\nLeaving [WEAK] linker (Keil 5.14) is removing UART0_IRQHandler_Bootloader section.\r\n\r\n    Removing Unused input sections from the image.\r\n\r\n        Removing main.o(.rev16_text), (4 bytes).\r\n        Removing main.o(.revsh_text), (4 bytes).\r\n        Removing main.o(i.init), (60 bytes).\r\n        Removing uartreader.o(.rev16_text), (4 bytes).\r\n        Removing uartreader.o(.revsh_text), (4 bytes).\r\n        Removing uartreader.o(i.UART0_IRQHandler_Bootloader), (140 bytes).\r\n        Removing uartreader.o(.bss), (50 bytes).\r\n        Removing arm_startup_nrf51.o(HEAP), (1024 bytes).\r\n        Removing system_nrf51.o(.rev16_text), (4 bytes).\r\n        Removing system_nrf51.o(.revsh_text), (4 bytes).\r\n        Removing system_nrf51.o(i.SystemCoreClockUpdate), (16 bytes).\r\n\r\n    11 unused section(s) (total 1314 bytes) removed from the image.\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Conflict between SPI1 and TWI1 on nRF51 Hello\r\n\r\nI've been having some strange problems with my SPI and TWI bus. In my setup, I'm using SPI0 and TWI1. I noticed that, even though I'm not using it, that SPI1 was consuming a lot of power so I disabled it with NRF_SPI0->ENABLE = 0;.\r\n\r\nNow I seem to be having problems with my TWI1 bus, it stops working sometimes when SPI1 is disabled, why is this happening? Are they somehow related? Or how do I stop the SPI1 bus from consuming power when I'm not using it?\r\n\r\nThanks\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "Conflict between SPI1 and TWI1 on nRF51 Hello\r\n\r\nI've been having some strange problems with my SPI and TWI bus. In my setup, I'm using SPI0 and TWI1. I noticed that, even though I'm not using it, that SPI1 was consuming a lot of power so I disabled it with NRF_SPI0->ENABLE = 0;.\r\n\r\nNow I seem to be having problems with my TWI1 bus, it stops working sometimes when SPI1 is disabled, why is this happening? Are they somehow related? Or how do I stop the SPI1 bus from consuming power when I'm not using it?\r\n\r\nThanks\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Will using a UART/Serial Port Emulation over BLE cause power consumption to go up? Nordic has provided a good SPP implementation over BLE. \r\n\r\nhttps://devzone.nordicsemi.com/question/37607/what-is-the-difference-between-developing-ble-custom-gatt-profiles-and-bluetooth-classic-spp/\r\n\r\nHowever, will it raise power consumption and cause BLE to lose its low-power characteristics? If yes, is it because the connection is always on like in Bluetooth Classic SPP? ",
    "tag": "uart"
  },
  {
    "text": "help required in porting uart soft library Hi Team,\r\n\r\nCan anyone help me implementing this?\r\n\r\n[AN-G-001.zip](/attachment/044495d0b0880b4b0d58bca6f89b9b2f)\r\n\r\n",
    "tag": "uart"
  },
  {
    "text": "SPI communication between nRF51422 and Arduino I want to set up an SPI communication between nRF51422 SOC (integrated on nRF51 DK) and Arduino board. I know that it is possible since I've read it in various posts and nRF51 reference manual. But, I couldn't find a working example for it (SPI) in the nRF51 SDK, as is given for UART communication.\r\n\r\nI have read the SPI master loopback example and the SPI slave example, provided with the SDK, but I couldn't comprehend whether they could be used for TX or RX from nRF51's side. If they can be, then how?\r\n\r\nFor the SPI TX/RX from the Arduino's side, I've read the Arduino SPI Library and trying to implement it, in a similar manner as this (www.arduino.cc/en/Tutorial/SPITransaction). Does it look fine? If not, then what should be used instead?",
    "tag": "spi"
  },
  {
    "text": "BLE Blocking Interrupts Hi,\r\n\r\nI am using the nRF51822 with an external chip. The nRF51822 has interrupts which trigger when one of the signals from the external chip goes low. When using BLE and the CPU is blocked during transmission of the radio, the interrupts are not triggered. Is there any way to prevent BLE from stopping interrupts triggering?\r\n\r\nKind regards\r\n\r\nJack",
    "tag": "interrupt"
  },
  {
    "text": "Crossworks UART - app_error_handler Hi, \r\n\r\nCurrently when I run the HRM demo I end up in the app error handler, unfortunately the error codes don't print to my terminal window. I'm using crossworks, and I was hoping somebody would able to explain how to configure the uart in crossworks so that the printf functions will write to my terminal window. Apologies if this is a basic question, I'm a bit lost and any help would be appreciated! ",
    "tag": "uart"
  },
  {
    "text": "Strange behavior of UART within service \r\nI have a custom service that, when the user writes to one of the characteristics, triggers an action to transmit the information written to that characteristic through the UART to another system. When I test this, Bluetooth disconnects less than a second later, and I've seen that the disconnect reason is a timeout. Has anyone seen this behavior, or know why it's occurring? Thanks in advance for any suggestions.",
    "tag": "uart"
  },
  {
    "text": "SEVONPEND setting - how to? If my way of thinking is not wrong, I have to set SEVONPEND flag to wake up cpu from sd_app_evt_wait on pended event. How to set this flag? I cannot find any function/macro to do this - I don't want to mess up other flags that are stored in that register.\r\n\r\nI want my application to wake up (only wakeup, no execution of IRQ handler) when ADC finishes sampling.",
    "tag": "adc"
  },
  {
    "text": "Using GPIOTE Interrupts to stop RTC Interrupt Hello\r\n\r\nThis is probably a very simple problem to solve but I'm having trouble disabling an RTC0 interrupt by using a GPIOTE PORT interrupt on an nRF51 board.\r\n\r\nBasically, I have an RTC0 counter triggering an interrupt once per second to read data from some sensors. I'm trying to use a GPIOTE interrupt to stop the RTC0, but I don't seem to be able to execute my GPIOTE function when the RTC0 interrupt is active. What's the best way to do this?\r\n\r\nI've tried setting the priority of the two events as follows:\r\n\r\n    \tNVIC_SetPriority(RTC0_IRQn, 2);\r\n        NVIC_SetPriority(GPIOTE_IRQn, 1);\r\n\r\nBut the RTC0 interrupt does not respond, however each interrupt subroutine works fine individually. Any idea why this is the case?\r\n\r\nAny help would be greatly appreciated.\r\n\r\nThanks",
    "tag": "interrupt"
  },
  {
    "text": "Softdevice with SPI: Rx Byte replaced with 0x00 I have a program running with SD 7.2 and SPI on my nrF51822 talking to a SPI slave device. I use GPIOTE triggered on an edge to set a chip select line and read bytes from the slave. I do not use Timer 0 or PPI for my SPI implementation.\r\n\r\nThe method works perfectly without softdevice, but when I brought it into my BLE application the second byte I receive always seems to be 0 when I transfer a value from the SPI RX buffer to an inline declared byte array. I break before saving the second byte to a temp. variable and the RX buff shows it is non-zero. But after the assignment, I see 0x00 stored into the temp. variable. I return on receiving 0 and have observed this when letting my program run free as well.\r\n\r\nI checked against the SD resource specifications and it does not seem like anything I am doing should conflict with the softdevice. Am I missing anything critical?",
    "tag": "spi"
  },
  {
    "text": "Reading ADC values from multiple pins Hello, I'm using nRF51822-mKIT for a research.\r\n\r\nI recently posted a question related to \"reading ADC value from analog input\", having issues with reading proper ADC value from input pin. However, after narrowing down, I have found out that the root cause was that I tried to read ADC values *simultaneously* from multiple pins.\r\n\r\nThe following is the code that I have right now:\r\n\r\n    static void rr_interval_timeout_handler(void * p_context) {\r\n        UNUSED_PARAMETER(p_context);\r\n        if (m_rr_interval_enabled) {\r\n    \t\t/*!<AIn2 corrosponds to Vgas>*/\r\n    \t\t/*!<AIn4 corrosponds to Vref>*/\r\n    \t\tdata[2] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput6); /*!<AIn6 corrosponds to Vtemp>*/\r\n        }\r\n    }\r\n\r\n    unsigned short adc_read(unsigned int adc_in_mask)\r\n    {\r\n    \tuint16_t adc_result;\r\n\t    // interrupt ADC\r\n\t    NRF_ADC->INTENSET = (ADC_INTENSET_END_Disabled << ADC_INTENSET_END_Pos); /*!< Interrupt enabled. */\r\n\t    // config ADC\r\n\t    NRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n\t\t\t\t\t\t| (adc_in_mask << ADC_CONFIG_PSEL_Pos)\t /*!< Use analog input 0 as analog input. */\r\n\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos) /*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n\t\t\t\t\t\t| (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos);\t /*!< 10bit ADC resolution. */ \r\n\t    // enable ADC\t\t\r\n\t    NRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled; /* Bit 0 : ADC enable. */\r\n\t    // start ADC conversion\r\n\t    NRF_ADC->TASKS_START = 1;\r\n\t    // wait for conversion to end\r\n\t    while (!NRF_ADC->EVENTS_END)\r\n\t    {}\r\n\t    NRF_ADC->EVENTS_END\t= 0;\r\n\t    adc_result = ADC_RESULT_IN_MILLI_VOLTS(NRF_ADC->RESULT);\r\n\t    //Use the STOP task to save current. Workaround for PAN_028 rev1.1 anomaly 1.\r\n        NRF_ADC->TASKS_STOP = 1;\r\n\t    return adc_result;\r\n    }\r\n\r\nYou can see that I am currently collecting an ADC value from AnalogInput6 only. What I want to have is a code that collects ADC values from AnalogInput2 and AnalogInput4 as well in a very short interval (simultaneously if possible).\r\n\r\nThe bottom code is the one that I tried and failed to get correct ADC values:\r\n\r\n    static void rr_interval_timeout_handler(void * p_context) {\r\n        UNUSED_PARAMETER(p_context);\r\n        if (m_rr_interval_enabled) {\r\n            data[0] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput2); /*!<AIn2 corrosponds to Vgas>*/\r\n            data[1] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput4); /*!<AIn4 corrosponds to Vref>*/\r\n            data[2] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput6); /*!<AIn6 corrosponds to Vtemp>*/\r\n        }\r\n    }\r\n\r\nIs there any way that I could read ADC values from multiple pins?\r\nThank you in advance.\r\n\r\n=====SOLUTION=====\r\n\r\nThanks to Stefan, I got a working code! Hope this helps to people who were having similar problem.\r\nI have modified my code to collect ADC values from each pin sequentially, using a counter.\r\n\r\n    uint8_t count = 0;\r\n\r\n    static void rr_interval_timeout_handler(void * p_context)\r\n    {\r\n        UNUSED_PARAMETER(p_context);\r\n        if (m_rr_interval_enabled)\r\n        {\r\n\t\t\tif(count == 0) {\r\n\t\t\t\tdata[0] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput2); /*!<AIn2 corrosponds to Vgas>*/\r\n\t\t\t} else if(count == 1) {\r\n\t\t\t\tdata[1] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput4); /*!<AIn4 corrosponds to Vref>*/\r\n\t\t\t} else if(count == 2) {\r\n\t\t\t\tdata[2] = (uint16_t) adc_read(ADC_CONFIG_PSEL_AnalogInput6); /*!<AIn6 corrosponds to Vtemp>*/\r\n\t\t\t}\r\n        }\r\n    }\r\n\r\n    static void heart_rate_meas_timeout_handler(void * p_context)\r\n    {\r\n        uint32_t        err_code;\r\n        UNUSED_PARAMETER(p_context);\r\n    \r\n\t    ble_hrs_rr_interval_add(&m_hrs, data[count]);\r\n\t\terr_code = ble_hrs_heart_rate_measurement_send(&m_hrs, count);\r\n\t\tcount++;\r\n\t\tif(count > 2) {\r\n\t\t\tcount = 0;\r\n\t\t}\r\n        if ((err_code != NRF_SUCCESS) &&\r\n            (err_code != NRF_ERROR_INVALID_STATE) &&\r\n            (err_code != BLE_ERROR_NO_TX_BUFFERS) &&\r\n            (err_code != BLE_ERROR_GATTS_SYS_ATTR_MISSING)\r\n        )\r\n        {\r\n            APP_ERROR_HANDLER(err_code);\r\n        }\r\n    }",
    "tag": "adc"
  },
  {
    "text": "nrf24LE1 I2C pin resistor Hello,\r\n\r\nI have a problem with getting i2c to work. What I did is enabled the 2-wire block, and tried to send various data as a master(by setting the registers), but I cant measure any chnage on SDA or SCL lines with logic analyzers. I am using 10k pullups on my PCB. \r\n\r\nI also tried to program this example as a i2c master, https://devzone.nordicsemi.com/question/1975/2-wire-communication-between-two-nrf24le1-coding-problem/, but again nothing on SDA or SCL. But I am able to communicate with two sensors ,that I have on the same board as the nrf24le1, with the use of arduino. \r\n\r\nAny ideas please? Are there already any resistors on the W2SDA and W2SCL pins?",
    "tag": "i2c"
  },
  {
    "text": "Discrepancy between installations/packages - Keil nRF51 pwm example? Hello all\r\n\r\nI'm new to Nordic products and the Keil compiler and in order to fast-track my development I have two computers, home and work, running Keil MDK-ARM (lite) with Nordic packages installed.\r\n\r\nOn my home computer I had imported (from the pack installer) the no-softdevice template project and used a custom board definition. Into this I copy pasted the pwm example code from [1] and modified slightly to work with my setup - Essentially holding one two buttons set predefined duty which is output to an LED. This programs and works perfectly.\r\n\r\nNow on my work computer after copying this project over then compiling and flashing, I cannot seem to get any action out of it. The program seemingly compiles and programs without error. I even tried repeating the steps done on my home computer by starting a fresh new project but same result.\r\n\r\nThe only subtly I have noticed is that I can get away with using \"nrf_gpiote_task_config\" at home but on my work computer this had to be changed to \"nrf_gpiote_task_configure\", which seems to hint that there may be differences in the libraries being used??\r\n\r\nAny suggestions on where to start with this?\r\n\r\n\r\n\r\n[1] https://github.com/finnurtorfa/nrf51/blob/master/lib/nrf51sdk/Nordic/nrf51822/Board/nrf6310/pwm_example/main.c",
    "tag": "pwm"
  },
  {
    "text": "ADC input selection change time I am using internal ADC to sample 2 (sometimes 3) channels on about 333Hz frequency.\r\nWhat I do is:\r\n\r\n- set channel 1 as input (always two-thirds prescaling, VBG reference)\r\n\r\n- start 3ms repeated timer\r\n\r\n- when timer triggers, sampling at chan1 starts and app goes to sleep\r\n\r\n- wakeup when adc finishes - check one more time if it really is not busy - store result\r\n\r\n- change ADC input to channel 2 and start sampling - then go to sleep\r\n\r\n- wait for wakeup again, check if not busy, store result - change input to chan 1 - go to sleep\r\n\r\n- wait for another 3ms timer trigger...\r\n\r\n\r\nMy problem is that sometimes (very rarely, but regularly!) my readings seems to be connected, ex. Chan1 should read value about 0, Chan2 should read value about 1000. In most cases it is ok, but sometimes chan1 reads value about 1000 (just like CONFIG.INPSEL mux react too slowly). It is possible that my code is buggy, but I am wondering if it is possible that ADC reacts REALLY slowly for its input changes when sampling really fast.",
    "tag": "adc"
  },
  {
    "text": "nrf51822 PWM Library on mBed Hello, I am trying to use the ['nrf51-pwm-library](https://github.com/NordicSemiconductor/nrf51-pwm-library)' on mBed with a nrf51822 on RedBearLab Nano.\r\n\r\nI copied the nrf_pwm.h/c files and they compile, but I never get any sort of signal out of the PWM pin. (Pin 19 on the RBL Nano is an on board LED.)\r\n\r\nI assume there is something simple I am missing?\r\n\r\nHere is the main.c code:\r\n\r\n\r\n    #include \"mbed.h\"\r\n    #include \"BLEDevice.h\"\r\n    \r\n    #include \"nrf_gpio.h\"\r\n    #include \"nrf_delay.h\"\r\n    #include \"nrf_pwm.h\"\r\n    \r\n    \r\n    \r\n    \r\n    void pwm_init()\r\n    {\r\n        nrf_pwm_config_t pwm_config = PWM_DEFAULT_CONFIG;\r\n        \r\n        pwm_config.mode             = PWM_MODE_BUZZER_255;\r\n        pwm_config.num_channels     = 1;\r\n        pwm_config.gpio_num[0]      = 19;\r\n        \r\n        // Initialize the PWM library\r\n        nrf_pwm_init(&pwm_config);       \r\n    }\r\n    \r\n    \r\n    int main(void)\r\n    {    \r\n        \r\n        pwm_init();\r\n        \r\n        while (true)\r\n        {\r\n            nrf_pwm_set_value(0, 0);\r\n            \r\n            nrf_delay_us(500000);  \r\n            \r\n            nrf_pwm_set_value(0, 127);  \r\n            \r\n            nrf_delay_us(500000); \r\n            \r\n            nrf_pwm_set_value(0, 255);  \r\n            \r\n            nrf_delay_us(500000); \r\n        }\r\n    \r\n    }",
    "tag": "pwm"
  },
  {
    "text": "FLICKER IN BUZZER Hi \r\nI am using timer1 for generating 4khz input to buzzer.It works fine when no ble starts.When advertising starts buzzer shows some flickers according to advertising time interveltime intervel.when connected it buzzer sounds continuous flicker. Tested with Oscilloscope but didnt find any change in frequency or wave form.how to solve this problem?",
    "tag": "timer"
  },
  {
    "text": "sd_app_evt_wait() and hardware interrupts Hello, \r\n\r\nI'm developing on a nrf51822 with the S110 softdevice.\r\nTo save power, I use the sd_app_evt_wait() function to go into sleep mode.\r\nTo wake up, i want to use an gpiote interrupt, from an external accelerometer.\r\nBut it seems, that the chip doesn't continue execution from gpiote interrupts.\r\nThe button example uses a timer, to get a software interrupt, but I hope there is a more elegant way of doing it, than creating an ultra short timer.\r\n\r\nBest regards \r\n\r\nJonathan\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Question about high speed ADC usage Hi,\r\n\r\nI need to send an audio signal through BLE connection of nRF51822 module, this signal need to quantized and sampled at rate of minimum 8000 sample/second by ADC, i configured the minimum connection interval to 9 ms but the sampling still very low and far from required, i try to decrease the interval below 9 ms but the connection failed. is there any way to increase the sampling rate?\r\n\r\nThanks for your help in this issue\r\n\r\nRegards ",
    "tag": "adc"
  },
  {
    "text": "TWI / I2c  device unable to read / write the device ?  irrespective of following reference manual. Here are my functions which i  wrote for reading / writing the i2c slave device ( after reading reference manual (nrf51422) . Unfortunately they are not working. Plz help me with the code. \r\n\r\n    void twi_init_slz(void )\r\n    {\r\n    \t(*(unsigned volatile int *)0x040003500)= 0x00;               //Disable SPI AND TWI\r\n    \t//(*(unsigned volatile int *)0x040003200)= 0x00; \t\t\t\t\t\t\t//SHORTCUT REGISTER\r\n    \t(*(unsigned volatile int *)0x040003508)= 30U;\t\t\t\t\t\t\t\t //PSELSCL\t\r\n    \t(*(unsigned volatile int *)0x04000350C)= 7U;\t\t\t\t\t\t\t\t\t//PSELSDA\r\n    \t(*(unsigned volatile int *)0x050000518)= ~((1UL<<30)|(1UL<<7));\r\n    \t(*(unsigned volatile int *)0x050000778)= (6UL<<8)|(3UL<<2);\t\t//set pin\r\n    \t(*(unsigned volatile int *)0x05000071C)= (6UL<<8)|(3UL<<2);\t\t//set pin\r\n    \t//(*(unsigned volatile int *)0x040003300)= (1UL<<2)|(1UL<<7)|(1UL<<7)|(1UL<<9)|(1UL<<14);\t//INTEN\r\n    \t(*(unsigned volatile int *)0x040003304)= (1UL<<2)|(1UL<<7)|(1UL<<7)|(1UL<<9)|(1UL<<14);\t//INTENSET\r\n    \t(*(unsigned volatile int *)0x040003524)= 0x01980000;\t\t\t\t//FREQUENCY\t\t\r\n    \t(*(unsigned volatile int *)0x040003124)= 1UL;\t\t\t\t//ERROR\t\r\n    \r\n    \t(*(unsigned volatile int *)0x040003500)= 0x05;     //ENABLE TWI\r\n    }\r\n    \r\n    void set_address_twi_slz(int address)\r\n    {\r\n    \t(*(unsigned volatile int *)0x040003588)= address;\t\t\t\t//I2C ADDRESS\r\n    \r\n    }\r\n    \r\n    int read_twi_slz(void)\r\n    {\t\r\n    \tnrf_delay_ms(10); \r\n    \tprintf(\"In read\\n\");\r\n    \t//(*(unsigned volatile int *)0x40003588)|= 1UL;\t\r\n    \t(*(unsigned volatile int *)0x40003000)= 1;\t\t\t\t\t\t//STARTRX\r\n    \tnrf_delay_ms(10); while(!((*(unsigned volatile int *)0x40003108))); //wait for RXREADY EVENT   \r\n    \tnrf_delay_ms(10); \r\n    \tint read_i2c_value = (*(unsigned volatile int *)0x40003518); //copying RX Register\r\n    \tnrf_delay_ms(10); \r\n    \t(*(unsigned volatile int *)0x40003014)= 1;\t\t //Stop\r\n    \treturn read_i2c_value;\r\n    }\r\n    \r\n    bool write_twi_slz(int data)\r\n    {\r\n    \t(*(unsigned volatile int *)0x40003008)=1;\r\n    \t(*(unsigned volatile int *)0x4000351C)=data;\r\n    \tint check =(*(unsigned volatile int *)0x04000351C);\r\n    \tif(check)\r\n    \t{\r\n    \t\t\treturn 1; // successfully sent\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\t\treturn 0; //Sent error\r\n    \t}\r\n    }\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Could I stop and restart a timer in this timer timeout handler? In timeout handler, I need to reload a new  value, could this be fail since the timer stop is delayed by SWI0.",
    "tag": "timer"
  },
  {
    "text": "How to enable and disable all interrupts ? Hi Team,\r\n\r\nIs there any way to enable/disable all interrupts?\r\nWill BLE connection get disconnected because of this?  If yes the what are the possible ways to \r\nmaintain the connection?",
    "tag": "interrupt"
  },
  {
    "text": "Correct TWI library for use with SoftDevice? Hello\r\n\r\nI'm trying to communicate with an sensor over the TWI HW interface during a BLE connection with the S110 soft-device, and every time I try to use the TWI bus the nRF51 goes into reset. I've tried many different variations of edited TWI libraries that are here on Devzone but all have failed, what is the correct and most up to date version to use?\r\n\r\nI'm using version S110 V8.0, along with version 8.0 of the SDK. The nRF51 module I'm using is based off a revision 2 silicon package (CE AA) .\r\n\r\nI've tried the libraries included in the following devzone posts, all of which cause a system reset when I engage the TWI bus:\r\n\r\nhttps://devzone.nordicsemi.com/question/12230/twi-with-s110-on-nrf51822/ \r\n\r\nhttps://devzone.nordicsemi.com/question/309/best-place-to-get-started/#reply-316\r\n\r\nhttps://devzone.nordicsemi.com/question/1826/ble-stack-server-receiverlink-loss/#reply-1830\r\n\r\nI have also tried simply using the SW library, but the sensor always returns 0 if the BLE is active.\r\n\r\n\r\nAnd why hasn't a working library been added to the SDK yet?\r\n\r\nThanks",
    "tag": "twi"
  },
  {
    "text": "Unable to Run timer1 with S110 I'm developing application on nrf51 for that i'm using...\r\nSDK\t\t\t\t: nRF51_SDK_8.1.0_b6ed55f\r\nBoard                        : PCA10028\r\nI'm trying to run code from SDK examples C:\\nRF51_SDK_8.1.0_b6ed55f\\examples\\peripheral\\timer\\pca10028\\armgcc  in SDK with s110 softdevice. it is compiling well but at run time, leds are not blinking. it seems like execution stuck anywhere or changing value of timer delay in variable time_ms is not being reflected. I have used timer1. without using s110 softdevice it blinks well..my code look like\r\n\r\n    \r\n    \r\n    \r\n    /** @file\r\n     * @defgroup nrf_dev_timer_example_main main.c\r\n     * @{\r\n     * @ingroup nrf_dev_timer_example\r\n     * @brief Timer Example Application main file.\r\n     *\r\n     * This file contains the source code for a sample application using Timer1.\r\n     *\r\n     */\r\n    \r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    #include \"nrf.h\"\r\n    #include \"bsp.h\"\r\n    \r\n    #include \"nrf_drv_timer.h\"\r\n    #include \"bsp.h\"\r\n    #include \"app_error.h\"\r\n    \r\n    const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(1);\r\n    \r\n    const uint8_t leds_list[LEDS_NUMBER] = LEDS_LIST;\r\n    \r\n    /**\r\n     * @brief Handler for timer events.\r\n     */\r\n    void timer_led_event_handler(nrf_timer_event_t event_type, void* p_context)\r\n    {\r\n        static uint32_t i;\r\n        uint32_t led_to_invert = (1 << leds_list[(i++) % LEDS_NUMBER]);\r\n        \r\n        switch(event_type)\r\n        {\r\n            case NRF_TIMER_EVENT_COMPARE1:\r\n                LEDS_INVERT(led_to_invert);\r\n                break;\r\n            \r\n            default:\r\n                //Do nothing.\r\n                break;\r\n        }    \r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief Function for main application entry.\r\n     */\r\n    int main(void)\r\n    {\r\n        uint32_t time_ms = 500; //Time(in miliseconds) between consecutive compare events.\r\n        uint32_t time_ticks;\r\n        uint32_t err_code = NRF_SUCCESS;\r\n        \r\n        //Configure all leds on board.\r\n        LEDS_CONFIGURE(LEDS_MASK);\r\n        LEDS_OFF(LEDS_MASK);\r\n        \r\n        //Configure TIMER_LED for generating simple light effect - leds on board will invert his state one after the other.\r\n        err_code = nrf_drv_timer_init(&TIMER_LED, NULL, timer_led_event_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        time_ticks = nrf_drv_timer_ms_to_ticks(&TIMER_LED, time_ms);\r\n        \r\n        nrf_drv_timer_extended_compare(\r\n             &TIMER_LED, NRF_TIMER_CC_CHANNEL1, time_ticks, NRF_TIMER_SHORT_COMPARE1_CLEAR_MASK, true);\r\n        \r\n        nrf_drv_timer_enable(&TIMER_LED);\r\n    \r\n        while(1)\r\n        {\r\n            __WFI();\r\n        }\r\n    }\r\ncan anyone help for this..?\r\nthank you....\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "trouble reading ADC on nrf51422 I am trying to perform a simple ADC measurement using polling rather than using an interrupt.  I have looked at examples and read the ADC section in the reference manual, but I am still not having luck getting this to work.\r\n\r\nI have added a zip file containing the ADC code module and some log output.\r\n\r\nThe problem I am experiencing is that the result is always a constant value (0x313), but the voltage at the AINx pin is changing.  The voltage at the AIN2 pin is 2.45 V when the battery monitor circuit is enabled (GPIO pin 28 = 1) and 0 V when the monitor circuit is disabled.\r\n\r\nLikewise, the SENS1 and SENSE2 circuits are both enabled when GPIO pin 7 = 1.  When the circuits are enabled, the measured voltage at the AIN3 and AIN5 inputs are both at 810 mV.  When those circuits are disabled, the voltage drops to 3 mV.\r\n\r\nBut in all cases, the result I get is 0x313.  I am sure that there must be something wrong with the software, but I have scrutinized it and it looks nearly identical to the examples, except for the polling instead of interrupt operation.\r\n\r\nNote, I am not using a soft device.  I am also not doing any GPIO configuration on the AINx inputs that I am using.\r\n\r\nIs there something else required for the ADC to operate properly (e.g. a system clock setting, AINx inputs need a GPIO configuration, etc.)?\r\n\r\nThanks for any help you can provide.\r\n\r\n--ken\r\n\r\n[adc_test.zip](/attachment/b8103e820a70bfc873a4752ba1365190)\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Beginner's questions on nRF51822 timers I have two questions: \r\n\r\n**Question 1**: \r\nWhat is the timer timeout limit on nRF51822? \r\n\r\nThe reason I ask is that I want to update the advertising packet periodically. Below are part of the related code in main.c:\r\n\r\n    #define APP_TIMER_PRESCALER             0\r\n    #define APP_TIMER_MAX_TIMERS            (2+BSP_APP_TIMERS_NUMBER)    \r\n    #define APP_TIMER_OP_QUEUE_SIZE         4      \r\n    \r\n    #define ADV_INTERVAL_IN_MS              (5*60000)\r\n    #define ADV_INTERVAL                    MSEC_TO_UNITS(ADV_INTERVAL_IN_MS, UNIT_0_625_MS) \r\n    #define ADVDATA_UPDATE_INTERVAL         APP_TIMER_TICKS(ADV_INTERVAL_IN_MS, APP_TIMER_PRESCALER)\r\n    \r\n    static app_timer_id_t m_advdata_update_timer;\r\n    \r\n    static void timers_init(void)\r\n    {\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        \r\n        uint32_t err_code = app_timer_create(&m_advdata_update_timer, APP_TIMER_MODE_REPEATED, advdata_update_timer_timeout_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    static void timers_start(void)\r\n    {\r\n        uint32_t err_code = app_timer_start(m_advdata_update_timer, ADVDATA_UPDATE_INTERVAL, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    void advdata_update_timer_timeout_handler(void * p_context)\r\n    {\r\n        advertising_init();\r\n    }\r\n\r\nIn this code I use the internal RC oscillator, and the timer timeout handler will execute once every 5 minutes. However, if the timer is 16 bit, and timer prescaler is set to 0, the timeout limit will be 2^16/32e3 ~ 2s, which is far less than 5 minutes. At the same time, if I change it to longer value (like 20 minutes), the advertising packet will not get updated and will remain the initial value when nRF51822 was first powered on. I am a little confused. \r\n\r\n**Question 2**: \r\nI want to make nRF51822 only advertise for 1 minute every hour and sleep for the rest of the time. I read RTCs and timers may be able to do this while RTC is more power efficient. Is there any example available? Another question is, if the system is in deep sleep mode, can it be waken up by RTC rather than an external GPIO interrupt? (How?) \r\n\r\n\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "timer beacon I'm using nRF51822 Beacon v1.1.0.\r\nIt seems interrupt has ocurred every 256msec.\r\nI want to change timing of interrupt interval.(like a 512msec, 1024msec etc.)\r\n\r\nIs it possible to be changed where settings is.\r\n\r\nthanks Mik",
    "tag": "timer"
  },
  {
    "text": "Timer Prescaler I have a nRF51 DK board and its flashed with the SD 110\r\n\r\nI want to have a timer which will interrupt every 50us.\r\n\r\n\r\nThis is how I set up the timer:\r\n\r\n    #define APP_TIMER_PRESCALER             4                                           \r\n    #define APP_TIMER_MAX_TIMERS            (3 + BSP_APP_TIMERS_NUMBER)                \r\n    #define APP_TIMER_OP_QUEUE_SIZE         4                                          \r\n    #define MEIN_50us_INTERVAL\t\t        APP_TIMER_TICKS(50,APP_TIMER_PRESCALER)\r\n\r\nWith this set up I will have an interrupt every 50ms. Now if I change the prescaler nothing will change. I will still get interrupts every 50ms.\r\n\r\nBut if I change the prescaler, the time for interrupts should also change....\r\n\r\nOr what I have to change when I need faster interrupts?\r\n\r\nThis is how the protocol looks like: \r\n\r\n![image description](/attachment/a9923b1811f1d6a90eaf91db0caad3bc)\r\n\r\nI need to be able, to set every single bit. Is this possible with the new nRF52 preview board?",
    "tag": "timer"
  },
  {
    "text": "Acquired event doesn't happen in NRF51822 as spi slave Hey everyone.,\r\nI was trying to use nrf51822 as  spi slave and just a heads up to know that i use Nrf51822 as  master. I see that when chip select CS gets low SPI needs to acquire semaphore in spi But when i was trying to debug. My program doesn't hit NRF_ACQUIRE. \r\nSo where am i going wrong?",
    "tag": "spi"
  },
  {
    "text": "SPI Multiple Masters Hello, I am tryong to use to masters to communicate with two accelerometers.\r\nQ1_ I found the following image from Nordic's website that shows SPI0 pins but there is no indication for SPI1's pins . Can someone point this out to me? ![image description](/attachment/3d31f55f2540ce22569fc8e1758a111d)\r\n\r\nQ2_ I am using the following code and so far Im getting the clock the MOSI and the Chip Select pins right. However my MISO is noisy for both slaves that I am using. What could be the problem beside the connections? Thank You\r\n\r\n    static void spi_master_init(spi_master_hw_instance_t   spi_master_instance,\r\n                                spi_master_event_handler_t spi_master_event_handler,\r\n                                const bool                 lsb)\r\n    {\r\n        uint32_t err_code = NRF_SUCCESS;\r\n    \r\n        switch (spi_master_instance)\r\n        {\r\n            \r\n            case SPI_MASTER_0:\r\n            {\r\n    \t\t\t\t\t  spi_master_config_t spi_config0 = SPI_MASTER_INIT_DEFAULT;\r\n    \r\n                spi_config0.SPI_Pin_SCK  = 29;\r\n                spi_config0.SPI_Pin_MISO = 28;\r\n                spi_config0.SPI_Pin_MOSI = 25;\r\n                spi_config0.SPI_Pin_SS   = 24;\r\n    \t\t\t\t\t spi_config0.SPI_CONFIG_ORDER = (lsb ? SPI_CONFIG_ORDER_LsbFirst : SPI_CONFIG_ORDER_MsbFirst);\r\n    \r\n        err_code = spi_master_open(spi_master_instance, &spi_config0);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n            }\r\n            break;\r\n    \t\t\t\t\r\n    \t\t\t\t case SPI_MASTER_1:\r\n            {\r\n    \t\t\t\t\t\tspi_master_config_t spi_config1 = SPI_MASTER_INIT_DEFAULT1;\r\n                spi_config1.SPI_Pin_SCK  = 19;\r\n                spi_config1.SPI_Pin_MISO = 28;\r\n                spi_config1.SPI_Pin_MOSI = 25;\r\n                spi_config1.SPI_Pin_SS   = 20;\r\n    \t\t\t\t\t spi_config1.SPI_CONFIG_ORDER = (lsb ? SPI_CONFIG_ORDER_LsbFirst : SPI_CONFIG_ORDER_MsbFirst);\r\n    \r\n        err_code = spi_master_open(spi_master_instance, &spi_config1);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n            }\r\n            break;\r\n            \r\n    \r\n            default:\r\n                break;\r\n        }\r\n    \r\n    .....\r\n    \r\n    \r\n    int main(void)\r\n    {// @brief Function for main application entry.\r\n    \r\n        // Setup bsp module.\r\n      bsp_configuration();\r\n      spi_master_init(SPI_MASTER_0, spi_master_0_event_handler, false);\r\n    \tspi_master_send_recv(SPI_MASTER_0, Powermode_Set, 2, m_rx_data_spi, 2);\r\n    \t\tspi_master_send_recv(SPI_MASTER_0, Data_Format, 2, m_rx_data_spi, 2);\r\n    \r\n    \t//nrf_delay_ms(10);\r\n      spi_master_init(SPI_MASTER_1, spi_master_1_event_handler, false);\r\n    \tspi_master_send_recv(SPI_MASTER_1, Powermode_Set, 2, m_rx_data_spi, 2);\r\n      spi_master_send_recv(SPI_MASTER_1, Data_Format, 2, m_rx_data_spi, 2);\r\n    \r\n    \t\r\n    \ttx_DARA0=(0x80 | 0x32);//spi_master_close(SPI_MASTER_0);\r\n      tx_DARA0=(tx_DARA0|0x40);\r\n    \r\n        for (;; )\r\n        {\r\n    \t\t\t\r\n    \t\r\n           // if (m_transfer_completed)\r\n           // {\r\n    \t\t // spi_master_send_recv(SPI_MASTER_0, Device, 2, ID,2 );\r\n    \r\n    \t\t\t\r\n    \t\t\r\n    \t\t\r\n    \t    \r\n    \t\t  \r\n    \t\t\t\r\n    \t\t\r\n    \t\t\tspi_master_send_recv(SPI_MASTER_0, &tx_DARA0, 1, m_rx_data_spi,8 );\r\n    \t\t\t\r\n    \t\t\t\r\n    \t\t\tnrf_delay_ms(1);\r\n    \t\t\t\r\n    \t\t\tspi_master_send_recv(SPI_MASTER_1, &tx_DARA0, 1, m_rx_data_spi1,8 );\r\n    \t\t\t\r\n    \t\t\tnrf_delay_ms(1);\r\n    \r\n    \r\n    \t\t\t\r\n    \t\t\t\t\r\n    \t\t\t\t\r\n        }\r\n    }\r\n\t\r\n",
    "tag": "spi"
  },
  {
    "text": "how to use mpu6050 interrupts to sample the sensor values ? Hey I am a beginner and I want to use mpu-6050 interrupts to sample the sensor values. I am able to read and write values through i2c but I want to read values only when any interrupt is generated. Is there any code or any kind of help will be appreciated ? \r\n\r\nNOTE: I want to use this code in keil not in arduino.",
    "tag": "interrupt"
  },
  {
    "text": "SPI with HID protocol Hi,\r\n\r\nI want to use SPI with HID protocol.\r\n\r\nI transmit from external MCU to my nrf51822 over SPI (nrf is a slave),I used a spi_slave example that works perfect.\r\n\r\nNow i just want to add it to HID protocol, what i need to  do on SDK8.1? It is a \"app_sched \" on HID, how i manage a SPI interrupts? \r\n\r\nThanks",
    "tag": "spi"
  },
  {
    "text": "No TWI connection with s100, Dev Kit and BLE Dear all,\r\n\r\nI'm trying to connect the NRF51-DK (PCA10028) with a LSM330DLC accelerometer over TWI (I2C). I'm using the ble_app_uart example, included the `twi_master.h` file and selected the twi_master (software) in the Run-Time environment. \r\n\r\nI call `twi_master_init()` in the main function. I used the `i2c.c` wrapper I found here on the forum and using its `readI2cReg` i'm trying to read a register from the LSM330DLC in order to verify the connection. However, the first `twi_master_transfer` function returns false, indicating that no data was transferred successfully. I get no further errors and the UART demo still works correctly while running the application. \r\n\r\nCan someone please point me in the right direction? Without a clear error I find it very difficult to look in the right place. I added the KEIL5 folder to the post if someone wants to check out the files: [ble_app_uart.zip](/attachment/999e8ff00a4b68de30f84a350f1bec6c)",
    "tag": "twi"
  },
  {
    "text": "No TWI connection with s100, Dev Kit and BLE Dear all,\r\n\r\nI'm trying to connect the NRF51-DK (PCA10028) with a LSM330DLC accelerometer over TWI (I2C). I'm using the ble_app_uart example, included the `twi_master.h` file and selected the twi_master (software) in the Run-Time environment. \r\n\r\nI call `twi_master_init()` in the main function. I used the `i2c.c` wrapper I found here on the forum and using its `readI2cReg` i'm trying to read a register from the LSM330DLC in order to verify the connection. However, the first `twi_master_transfer` function returns false, indicating that no data was transferred successfully. I get no further errors and the UART demo still works correctly while running the application. \r\n\r\nCan someone please point me in the right direction? Without a clear error I find it very difficult to look in the right place. I added the KEIL5 folder to the post if someone wants to check out the files: [ble_app_uart.zip](/attachment/999e8ff00a4b68de30f84a350f1bec6c)",
    "tag": "i2c"
  },
  {
    "text": "Getting I2C/TWI working? There seems to be 3 different libraries that can be used to access TWI: nrf_drv_twi, twi_hw_master, twi_sw_master.  (please correct if i am wrong).\r\n\r\ni am using SDK8.1.  Which library is the most stable?\r\n\r\nIs there any example code i could learn from?\r\n\r\nthank you.",
    "tag": "twi"
  },
  {
    "text": "1 micro second interrupt using timer1? Softdevice is enabled. Is it possible to have 1micro second interrupt using timer 1?\r\n\r\nI am unable to achieve it.\r\n\r\nIf I try for 4micro second, I observe toggling of pin at 8 micro seconds?\r\n\r\nWhy so?\r\n\r\ninit:\r\n\r\n    TIMER1->TASKS_STOP = 1;   /* Stop timer */ \r\n   \r\n    TIMER1->MODE = TIMER_MODE_MODE_Timer;  /* taken from Nordic dev zone */\r\n    \r\n    TIMER1->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n    \r\n    TIMER1->PRESCALER = TIMER_PRESCALER;\r\n    \r\n    TIMER1->CC[0] = 64;  /*for 4 micro second*/\r\n    \r\n    TIMER1->TASKS_CLEAR = 1; /* Clear timer */\t\r\n\r\n    TIMER1->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n    \r\n    TIMER1->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\t\t\r\n    \t\t\t\t\r\n    NVIC_SetPriority(TIMER1_IRQn, 1);\r\n    \r\n    NVIC_EnableIRQ(TIMER1_IRQn);\t\t\t\t\r\n    \r\n    TIMER1->TASKS_START = 1;\r\n\r\ninside irq routine:\r\n\r\n    if(TIMER1->EVENTS_COMPARE[0])\r\n    {\r\n        \r\n        TIMER1->EVENTS_COMPARE[0] = 0;\r\n    \t\t\t\r\n        nrf_gpio_pin_toggle(17);\r\n    \t\t\t\r\n        TIMER1->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk;\r\n    }",
    "tag": "timer"
  },
  {
    "text": "1 micro second interrupt using timer1? Softdevice is enabled. Is it possible to have 1micro second interrupt using timer 1?\r\n\r\nI am unable to achieve it.\r\n\r\nIf I try for 4micro second, I observe toggling of pin at 8 micro seconds?\r\n\r\nWhy so?\r\n\r\ninit:\r\n\r\n    TIMER1->TASKS_STOP = 1;   /* Stop timer */ \r\n   \r\n    TIMER1->MODE = TIMER_MODE_MODE_Timer;  /* taken from Nordic dev zone */\r\n    \r\n    TIMER1->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n    \r\n    TIMER1->PRESCALER = TIMER_PRESCALER;\r\n    \r\n    TIMER1->CC[0] = 64;  /*for 4 micro second*/\r\n    \r\n    TIMER1->TASKS_CLEAR = 1; /* Clear timer */\t\r\n\r\n    TIMER1->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n    \r\n    TIMER1->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\t\t\r\n    \t\t\t\t\r\n    NVIC_SetPriority(TIMER1_IRQn, 1);\r\n    \r\n    NVIC_EnableIRQ(TIMER1_IRQn);\t\t\t\t\r\n    \r\n    TIMER1->TASKS_START = 1;\r\n\r\ninside irq routine:\r\n\r\n    if(TIMER1->EVENTS_COMPARE[0])\r\n    {\r\n        \r\n        TIMER1->EVENTS_COMPARE[0] = 0;\r\n    \t\t\t\r\n        nrf_gpio_pin_toggle(17);\r\n    \t\t\t\r\n        TIMER1->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk;\r\n    }",
    "tag": "interrupt"
  },
  {
    "text": "Size of SoftDevice and bootloader Hi!\r\n\r\nWe are using the 51822 with S110. I'm currently writing a very simple bootloader which fetches the new application from an xternal SPI flash. \r\n\r\nMy plan was to place the bootloader at the end of the 51822s flash, the Softdevice @0x0 and the application right after the SoftDevice. When upgrading, I was hoping we could bundle both the SoftDevice and the application in one binary file, and write the whole thing to flash with the bootloader. My problem then is, if the SD-size change, how can the bootloader figure out where the application is?",
    "tag": "spi"
  },
  {
    "text": "Get the size of SoftDevice in bootloader Hi!\r\n\r\nWe are using the 51822 with S110. I'm currently writing a very simple bootloader which fetches the new application from an external SPI flash. \r\n\r\nMy plan is to place the bootloader at the end of the 51822s flash, the Softdevice @0x0 and the application right after the SoftDevice. When upgrading, I was hoping we could bundle both the SoftDevice and the application in one binary file, and write the whole thing to flash with the bootloader. My problem then is, if the SD-size change, how can the bootloader figure out where the application is? ",
    "tag": "spi"
  },
  {
    "text": "Is there a sample for SDK8 with SD8 for reading 2x ADC inputs, perhaps without busy waiting? Hi everyone,\r\n\r\nI've found a few posts and a lot of info but I'd like to know if there is an existing example that merges a few of the examples found here (https://github.com/NordicSemiconductor/nrf51-ADC-examples) for SDK8.1.0 and SD8.0.0.\r\n\r\nThis is a big ask, but basically an example that has the combined features of:\r\n\r\n 1. adc-example-with-softdevice\r\n 2. simultaneous-adc-sampling-from-two-inputs\r\n 3. rtc0_triggering_ADC_sample_from_GPIO_pin\r\n\r\nNow I must admit that's a bit of a long shot to get all 3 in one, and perhaps avoidind busy waiting (what #3 does) just isn't possible in thisscenarie. \r\nSo something that does #1 and #2 and isn't as basic as the 'adc_simple' that comes with SDK 8.1.0 would be cool.\r\nApologies if I've missed a 8.1.0SDK SoftDevice example, long long days...\r\n\r\nThanks\r\nWayne",
    "tag": "adc"
  },
  {
    "text": "ADC to measure battery voltage setup, I have a 3.3 V battery divided down to the bandgap range using a 56k and 10k resistors, so the voltage at the ADC input is 3.3 * (10/66) = 0.5 V\uff0cbut the fact is 0.498V\r\n\r\nI've configured the ADC to convert at 8 bits, to use no prescaler, and to use the internal VBG as reference.\r\n\r\nThe result i get is 0x6A, or 106, which translates to a measured battery voltage of: (106/256) * 1.2 = 0.497V\r\n\r\nI've configured the ADC to convert at 9 bits, to use no prescaler, and to use the internal VBG as reference.\r\nThe result i get is 0xD3, or 211, which translates to a measured battery voltage of: (211/512) * 1.2 = 0.495V\r\n\r\n\r\nI've configured the ADC to convert at 10 bits, to use no prescaler, and to use the internal VBG as reference.\r\nThe result i get is 0xA7, or 167, which translates to a measured battery voltage of: (167/1024) * 1.2 = 0.196V\r\n\r\nThe experimental results showed that the higher the digits of the ADC, the lower the accuracy\uff0cwho can tell me why\uff1f\r\n\r\nThanks in advance.\r\n![image description](/attachment/bb692506f2a30e07ae1011eac71f2bb4)![image description](/attachment/17a7748282778375e084e0e1c082f4f4)(/attachment/812a68ec1416b4b3bbb18257b6025536)\r\n![image description](/attachment/d411efa0b591ec36446f181f09b3f5ac)![image description](/attachment/0b512d6a751b14f5b44a153e74e79b20)(http://)",
    "tag": "adc"
  },
  {
    "text": "UART reception end Is there a way to know that there is no more data being received via UART? \r\n\r\nOne solution is, of course, to start a timer every time a byte is received via uart_evt_handler->APP_UART_DATA so if it expires we know that nothing was received during the timer period, but is there a more elegant solution?\r\n\r\nEDIT:\r\n\r\nAryan's solution is viable, but if some reason using the API is not possible, a simple (and obvious in the hindsight) solution is to use a flag:\r\n\r\n    void foo(void)\r\n    {\r\n        ...\r\n        while (byte_received)\r\n        {\r\n            byte_received = false;\r\n            nrf_delay_ms(5);\r\n        }\r\n\r\n        // Handle data\r\n    }\r\n\r\n    void uart_evt_handler(app_uart_evt_t *p_app_uart_event)\r\n    {\r\n        switch (p_app_uart_event->evt_type)\r\n        {\r\n            case APP_UART_DATA:\r\n            {\r\n                uint8_t byte;\r\n                if (app_uart_get(&byte) == NRF_SUCCESS)\r\n                {\r\n                    rx_buffer[rx_buffer_index++] = byte;\r\n                    byte_received = true;\r\n                }\r\n            }\r\n            ...\r\n        }\r\n    }",
    "tag": "timer"
  },
  {
    "text": "Example of I2C(TWI) with s120 Hello everyone!\r\n\r\nI'm having a hard time trying to use I2C with SoftDevice s120 and I am not able to find any example of it.\r\n\r\nI already used TWI in many boards with s110 and works just fine. But with s120 I am not able to make it run. \r\n\r\nSince now I used the twi_master.c and twi_sw_master.c libs. But now, twi_master_init() returns true but all twi_master_transfer() are returning false.\r\n\r\nPins are set properly on my board (SDA 28 and SCL 29) which are the same in other boards and works properly. I also checked them with a logic analyzer and all ok.\r\n\r\nI saw in the s120 documentation a simple code to write a sequence through I2C using nrf_drv_twi or TWI Driver but I am not able to create an TWI instance and try it. \r\n\r\nIs there anywhere I can find a simple example on how to use I2C with Softdevice s120? \r\n\r\nThanks in advance for your help!\r\n\r\nGabriel.",
    "tag": "twi"
  },
  {
    "text": "Example of I2C(TWI) with s120 Hello everyone!\r\n\r\nI'm having a hard time trying to use I2C with SoftDevice s120 and I am not able to find any example of it.\r\n\r\nI already used TWI in many boards with s110 and works just fine. But with s120 I am not able to make it run. \r\n\r\nSince now I used the twi_master.c and twi_sw_master.c libs. But now, twi_master_init() returns true but all twi_master_transfer() are returning false.\r\n\r\nPins are set properly on my board (SDA 28 and SCL 29) which are the same in other boards and works properly. I also checked them with a logic analyzer and all ok.\r\n\r\nI saw in the s120 documentation a simple code to write a sequence through I2C using nrf_drv_twi or TWI Driver but I am not able to create an TWI instance and try it. \r\n\r\nIs there anywhere I can find a simple example on how to use I2C with Softdevice s120? \r\n\r\nThanks in advance for your help!\r\n\r\nGabriel.",
    "tag": "twi"
  },
  {
    "text": "Example of I2C(TWI) with s120 Hello everyone!\r\n\r\nI'm having a hard time trying to use I2C with SoftDevice s120 and I am not able to find any example of it.\r\n\r\nI already used TWI in many boards with s110 and works just fine. But with s120 I am not able to make it run. \r\n\r\nSince now I used the twi_master.c and twi_sw_master.c libs. But now, twi_master_init() returns true but all twi_master_transfer() are returning false.\r\n\r\nPins are set properly on my board (SDA 28 and SCL 29) which are the same in other boards and works properly. I also checked them with a logic analyzer and all ok.\r\n\r\nI saw in the s120 documentation a simple code to write a sequence through I2C using nrf_drv_twi or TWI Driver but I am not able to create an TWI instance and try it. \r\n\r\nIs there anywhere I can find a simple example on how to use I2C with Softdevice s120? \r\n\r\nThanks in advance for your help!\r\n\r\nGabriel.",
    "tag": "i2c"
  },
  {
    "text": "Example of I2C(TWI) with s120 Hello everyone!\r\n\r\nI'm having a hard time trying to use I2C with SoftDevice s120 and I am not able to find any example of it.\r\n\r\nI already used TWI in many boards with s110 and works just fine. But with s120 I am not able to make it run. \r\n\r\nSince now I used the twi_master.c and twi_sw_master.c libs. But now, twi_master_init() returns true but all twi_master_transfer() are returning false.\r\n\r\nPins are set properly on my board (SDA 28 and SCL 29) which are the same in other boards and works properly. I also checked them with a logic analyzer and all ok.\r\n\r\nI saw in the s120 documentation a simple code to write a sequence through I2C using nrf_drv_twi or TWI Driver but I am not able to create an TWI instance and try it. \r\n\r\nIs there anywhere I can find a simple example on how to use I2C with Softdevice s120? \r\n\r\nThanks in advance for your help!\r\n\r\nGabriel.",
    "tag": "twi"
  },
  {
    "text": "NRF52, S132 interrupt latency Hi,\r\nThe s120 may have very long latency in response to an interruption (1400us). \r\n\r\nWhat is the latency with NRF52/S132?",
    "tag": "interrupt"
  },
  {
    "text": "SPI interface with LCD nrf51 Hello World! \r\n\r\nI am trying to interface an LCD with nrf51-DK. I basically need to send 3 signals - SCLK, MOSI and SS to the LCD. I have modified the spi_master example from the nrf51SDK. The code compiles error free but I do not see any output on the LCD. I have tried debugging and it seem to be stuck in spi_master sending function. Any suggestions/ideas on how to develop code for interfacing LCD with the nrf51 specifically  how should I set the RX buffer since I am only transmitting to LCD and not returning and all the SDK example have both TX and RX?\r\n\r\nAny inputs will be greatly appreaciated! :)\r\nThanks a lot!",
    "tag": "spi"
  },
  {
    "text": "PWM Library and RTC Compatibility? Are there any known issues with using the PWM library in the 8.1.0 SDK and an RTC?\r\n\r\nWhen I init an RTC my PWM signal stops working...\r\n\r\nThanks,\r\nTom",
    "tag": "pwm"
  },
  {
    "text": "nrf51 Dongle I2C Pin Map So after reading some material it seems like I can pretty much define which pins are responsible for I2C communication. Is there any limitation to which pins I can set? Does this work for basically all serial communication the nrf51 series chips are capable of? ",
    "tag": "i2c"
  },
  {
    "text": "Read data from sensor i2c Hi,\r\n\r\nI want read accel data from BNO055 sensor to NRF51 DK board, but SCL and SDA pins are 1 always.\r\n\r\nMy code is the next one:\r\n\r\n    #include \"twi_master.h\"\r\n    #include \"twi_master_config.h\"\r\n    \r\n    #define TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER_2 \t(7U)\r\n    #define TWI_MASTER_CONFIG_DATA_PIN_NUMBER_2 \t(30U)\r\n    \r\n    static bool twi_master_clear_bus(void)\r\n    {\r\n        uint32_t twi_state;\r\n        bool     bus_clear;\r\n        uint32_t clk_pin_config;\r\n        uint32_t data_pin_config;\r\n    \r\n        // Save and disable TWI hardware so software can take control over the pins.\r\n        twi_state        = NRF_TWI1->ENABLE;\r\n        NRF_TWI1->ENABLE = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos;\r\n    \r\n        clk_pin_config = \\\r\n            NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER];\r\n        NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER] =      \\\r\n            (GPIO_PIN_CNF_SENSE_Disabled  << GPIO_PIN_CNF_SENSE_Pos) \\\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1    << GPIO_PIN_CNF_DRIVE_Pos)   \\\r\n          | (GPIO_PIN_CNF_PULL_Pullup   << GPIO_PIN_CNF_PULL_Pos)    \\\r\n          | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)   \\\r\n          | (GPIO_PIN_CNF_DIR_Output    << GPIO_PIN_CNF_DIR_Pos);\r\n    \r\n        data_pin_config = \\\r\n            NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_DATA_PIN_NUMBER];\r\n        NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_DATA_PIN_NUMBER] =       \\\r\n            (GPIO_PIN_CNF_SENSE_Disabled  << GPIO_PIN_CNF_SENSE_Pos) \\\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1    << GPIO_PIN_CNF_DRIVE_Pos)   \\\r\n          | (GPIO_PIN_CNF_PULL_Pullup   << GPIO_PIN_CNF_PULL_Pos)    \\\r\n          | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)   \\\r\n          | (GPIO_PIN_CNF_DIR_Output    << GPIO_PIN_CNF_DIR_Pos);\r\n    \r\n        TWI_SDA_HIGH();\r\n        TWI_SCL_HIGH();\r\n        TWI_DELAY();\r\n    \r\n        if ((TWI_SDA_READ() == 1) && (TWI_SCL_READ() == 1))\r\n        {\r\n            bus_clear = true;\r\n        }\r\n        else\r\n        {\r\n            uint_fast8_t i;\r\n            bus_clear = false;\r\n    \r\n            // Clock max 18 pulses worst case scenario(9 for master to send the rest of command and 9\r\n            // for slave to respond) to SCL line and wait for SDA come high.\r\n            for (i=18; i--;)\r\n            {\r\n                TWI_SCL_LOW();\r\n                TWI_DELAY();\r\n                TWI_SCL_HIGH();\r\n                TWI_DELAY();\r\n    \r\n                if (TWI_SDA_READ() == 1)\r\n                {\r\n                    bus_clear = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    \r\n        NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER] = clk_pin_config;\r\n        NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_DATA_PIN_NUMBER]  = data_pin_config;\r\n    \r\n        NRF_TWI1->ENABLE = twi_state;\r\n    \r\n        return bus_clear;\r\n    }\r\n    \r\n    bool twi_master_init_2(void)\r\n    {\r\n        /* To secure correct signal levels on the pins used by the TWI\r\n           master when the system is in OFF mode, and when the TWI master is\r\n           disabled, these pins must be configured in the GPIO peripheral.\r\n        */\r\n        NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER] =     \\\r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos) \\\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos) \\\r\n          | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)  \\\r\n          | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos) \\\r\n          | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos);\r\n    \r\n        NRF_GPIO->PIN_CNF[TWI_MASTER_CONFIG_DATA_PIN_NUMBER] =      \\\r\n            (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos) \\\r\n          | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos) \\\r\n          | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)  \\\r\n          | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos) \\\r\n          | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos);\r\n    \r\n        NRF_TWI1->EVENTS_RXDREADY = 0;\r\n        NRF_TWI1->EVENTS_TXDSENT  = 0;\r\n        NRF_TWI1->PSELSCL         = TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER_2;\r\n        NRF_TWI1->PSELSDA         = TWI_MASTER_CONFIG_DATA_PIN_NUMBER_2;\r\n        NRF_TWI1->FREQUENCY       = 400000; //TWI_FREQUENCY_FREQUENCY_K100 << TWI_FREQUENCY_FREQUENCY_Pos\r\n        NRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n        NRF_PPI->CH[0].TEP        = (uint32_t)&NRF_TWI1->TASKS_SUSPEND;\r\n        NRF_PPI->CHENCLR          = PPI_CHENCLR_CH0_Msk;\r\n        NRF_TWI1->ENABLE          = TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos;\r\n    \r\n        return twi_master_clear_bus();\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n        twi_master_init_2(); \r\n    \t\t\r\n        while (true)\r\n        {\r\n    //i2c\r\n    \t\t\t\t//uint8_t addW = (addr<<1); \r\n    \t\t\t\t//uint8_t addR = (addr<<1)|0x01; \r\n    \t\t\t\tuint8_t addR = (0x52)|0x01; \r\n    \t\t\t\tuint8_t dataW[2] = {0x3D, 0x01}; \r\n    \t\t\t\tuint8_t dataR[2] = {0x00};\r\n    \t\t\t\r\n    \t\t\t\t//twi_master_transfer(addW,dataW,2,1); \r\n    \t\t\t\ttwi_master_transfer(0X52,dataW,2,1);\r\n    \t\t\t\tnrf_delay_us(400); \r\n    \t\t\t\t\r\n    \t\t\t\tdataW[0] = 0x08;\r\n    \t\t\t\ttwi_master_transfer(0X52,dataW,1,1);\r\n    \t\t\t\t//twi_master_transfer(addW,&dataW[0],1,0); \r\n    \t\t\t\t//nrf_delay_us(400); \r\n    \t\t\t\t//twi_master_transfer(addR,dataR,1,1); \r\n    \t\t\t\ttwi_master_transfer(addR,dataR,2,1); \r\n    \t\t\t\tnrf_delay_us(400);\r\n    \t\t\t\t\r\n    \t\t\t\tprintf(\"\\n\\rAccel L: %d\\n\\r\",dataR[0]);\r\n    \t\t\t\tprintf(\"\\n\\rAccel M: %d\\n\\r\",dataR[1]);\r\n    \t\t\t\t\r\n    \t\t\t\tnrf_delay_us(1000000);\r\n        }\r\n    }\r\n\r\nThe connection is the next:\r\n\r\nThis is the pin connection:\r\n\r\nNRF51-P07 with BNO055-18 (SCL). NRF51-P30 with BNO055-17 (SDA). NRF51-VDD with BNO055-1,2 and 22 (i2c adr mode). NRF51-GND with BNO055-3. PS0 and PS1 to GND to activate the I2C interface.\r\n\r\nRpull1 are connected between VDD and 18. Rpull2 are connected between VDD and 17.\r\n\r\nwhat can be wrong?\r\n\r\n\r\nThanks",
    "tag": "i2c"
  },
  {
    "text": "restricted functionalities in ISR context Hi, \r\n\r\nI've noticed that the following s110 API work in my application, when called from the main context, but fail when called from an ISR context (button press interrupt or system event) :\r\n\r\n- pstorage_clear()\r\n- pstorage_store()\r\n- bootloader_app_start()\r\n\r\nAny suggestions as for what I may be missing ?",
    "tag": "interrupt"
  },
  {
    "text": "High background current after disabling PWM in SoftDevice The question is: how to completely turn off PWM in SoftDevice?\r\n\r\nI am using the libraries nrf_pwm.h and nrf_pwm.c in [this repo](https://github.com/NordicSemiconductor/nrf51-pwm-library) for PWM with SoftDevice. Everything seems to work fine (e.g., I can enable up to 4 PWM channels through PPI) except that there is ~ 0.3mA continuous background current after I disable PWM with the function call\r\n \r\n\r\n    nrf_pwm_set_enabled(false); \r\n\r\n\r\nThe content of nrf_pwm_set_enabled() can be found [here](https://github.com/NordicSemiconductor/nrf51-pwm-library/blob/master/nrf_pwm.c). I can confirm the background current was only a few uAs before I enabled and disabled PWM, so this ~0.3mA should be related to PWM. I can see the PWM timers are turned off in nrf_pwm_set_enabled(false). Is there anything else that should be turned off to eliminate this 0.3mA current? ",
    "tag": "pwm"
  },
  {
    "text": "Abnormal ADC read with SoftDevice I have a simple nRF51822 BLE application where a voltage is read by ADC periodically, and several values are sampled and averaged. However, from time to time, I get another erroneous ADC value. I have two relevant timers: data update timer (repeated mode, times out every few minutes) and ADC read interval timer (single-shot mode, times out in 100 ms). A global variable n is used to track the number of ADC read. The logic goes as follows: \r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nInit: global n=0; constant N=8\r\n\r\nData timer times out --> \r\n\r\nData timer handler which starts ADC read interval timer --> \r\n\r\nADC read interval timer times out --> \r\n\r\nADC read interval timer handler: Get ADC value; n increments by 1. Is n less than N? If yes, restart ADC read interval timer; if no, set n=0, and calculate the averaged ADC value. \r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nThe ADC read function is inside ADC read interval timer handler, and is pasted [here](http://pastebin.com/anAS5Rud), or as follows:\r\n\r\n       static uint16_t adc10_data_get(void)  \r\n        {\r\n        \t  uint16_t adc_read; \r\n         \r\n        \t  NRF_ADC->INTENSET= 0;   // disable interrupt\r\n        \t  NRF_ADC->EVENTS_END = 0;\r\n        \t  NRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;    // Enable ADC\r\n        \t\tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n        \t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput5 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< Use analog input X as analog input. */\r\n        \t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n        \t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with prescaling used as input for the conversion. */\r\n        \t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 10bit ADC resolution. */ \r\n        \t\tNRF_ADC->TASKS_START = 1;\t\t\t//Start ADC sampling\r\n        \t\twhile (!NRF_ADC->EVENTS_END) {}   // wait till ADC sampling finishes\r\n        \t\tNRF_ADC->EVENTS_END = 0;\t  \r\n        \t\tadc_read = NRF_ADC->RESULT;   // read ADC result\r\n            NRF_ADC->TASKS_STOP = 1;   //Use the STOP task to save current. Workaround for PAN_028 rev1.5 anomaly 1.\r\n        \t\treturn adc_read;\r\n        }\r\n\r\nYou can see I am not using ADC interrupt. The background BLE advertising interval is 1s. \r\n\r\nFor a given voltage, for majority of time, the ADC reads 0x224 which is the correct value. But from time to time, it also reads 0x287 which is 99 higher, and is obviously an incorrect value. Moreover, the erroneous value seems to be fairly independent on the number of ADC averaging. For example, it is 0x287 for both N=1 and N=5. The appearance of such anomaly seems to be less frequent if the averaging number N is lower, but I haven't done enough tests to strictly confirm this observation. \r\n\r\nI just wonder which part of the code may cause such a behavior, and how to fix that. \r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "nRF51822 as peripheral to central iPhone iOS app AND central to i2c chipset peripherals Hi Everyone,\r\n\r\nI have what I hope is a simple questions. I am creating a piece of hardware that will act as the peripheral to a central iOS app in regards to a standard BLE communication. This same nRF51822 will then need to act as the central i2c eeprom chipsets in an i2c databus inside of the hardware.\r\n\r\nIn short: App (central) -> nRF51822 (peripheral) -> nRF51822 (central) -> i2c eeprom (peripherals) \r\n\r\nIs this possible? If yes, does creating the distinction of central/peripheral from moment to moment simply live in the way the chipset is programed? If no, why will this not work and do you have any suggestions for how to make a set up like this work utilizing different tools and/or data transfer protocol.\r\n\r\nThank you so much for any help you are able to provide!",
    "tag": "i2c"
  },
  {
    "text": "TWI sending address with no data I need to send the following sequence of bits through TWI\r\n\r\nstart bit | 7 bit address | write | slave ACK | stop bit\r\n\r\nI looked through the twi_hw_master.c and it seems that when you issue the TASKS_STARTTX both the ADDRESS and the TXD would be sent.\r\n\r\nHow do I manually issue a stop bit right after the slave ACKed the address?",
    "tag": "twi"
  },
  {
    "text": "Meaning of TWI overrun flag in master mode What is the purpose of the TWI overrun flag given that the TWI peripheral only supports master mode?\r\n\r\nI have the following code in an ISR for my TWI acting as master.\r\n\r\n    if(0 != I2C_TWIX->EVENTS_ERROR)\r\n    {\r\n        /* An error has occurred. Clear all the flags because the hardware\r\n         * can set multiple flags when an error occurs (for instance\r\n         * TXDSENT and ERROR if an error occurs during transmit) but we\r\n         * only want to handle this once. */\r\n        I2C_TWIX->EVENTS_ERROR = 0;\r\n        I2C_TWIX->EVENTS_TXDSENT = 0;\r\n        I2C_TWIX->EVENTS_RXDREADY = 0;\r\n\r\n        /* What type of error? */\r\n        if(I2C_TWIX->ERRORSRC & ((TWI_ERRORSRC_ANACK_Present <<\r\n                                  TWI_ERRORSRC_ANACK_Pos) |\r\n                                 (TWI_ERRORSRC_DNACK_Present <<\r\n                                  TWI_ERRORSRC_DNACK_Pos)))\r\n        {\r\n            /* Handle missing ACK. */\r\n        }\r\n        else\r\n        {\r\n            /* The datasheet lists an over-run error too; we don't check\r\n             * for this since it should only apply to slaves. */\r\n            FAIL(\"TWI error from unknown source.\");\r\n        }\r\n    }\r\n\r\nThe driver will happily perform thousands of readings from the slave (a pressure sensor). Very rarely, however, the FAIL line is being hit, suggesting that the overrun flag is being set. In what circumstances can this flag be set? The datasheet says the following:\r\n\r\n    Overrun error\r\n    A start condition is received while the previous data still lies in\r\n    RXD (Previous data is lost)\r\n\r\nBut a start condition should never be received on a single-master bus when this device is the master. Could this be caused by a transient low pulse on the line between transmissions? Or bad slave behaviour?\r\n\r\nI'm using S110 v7.1.0 on nRF51822QFAB.\r\n\r\nThanks,\r\nCarl",
    "tag": "twi"
  },
  {
    "text": "Meaning of TWI overrun flag in master mode What is the purpose of the TWI overrun flag given that the TWI peripheral only supports master mode?\r\n\r\nI have the following code in an ISR for my TWI acting as master.\r\n\r\n    if(0 != I2C_TWIX->EVENTS_ERROR)\r\n    {\r\n        /* An error has occurred. Clear all the flags because the hardware\r\n         * can set multiple flags when an error occurs (for instance\r\n         * TXDSENT and ERROR if an error occurs during transmit) but we\r\n         * only want to handle this once. */\r\n        I2C_TWIX->EVENTS_ERROR = 0;\r\n        I2C_TWIX->EVENTS_TXDSENT = 0;\r\n        I2C_TWIX->EVENTS_RXDREADY = 0;\r\n\r\n        /* What type of error? */\r\n        if(I2C_TWIX->ERRORSRC & ((TWI_ERRORSRC_ANACK_Present <<\r\n                                  TWI_ERRORSRC_ANACK_Pos) |\r\n                                 (TWI_ERRORSRC_DNACK_Present <<\r\n                                  TWI_ERRORSRC_DNACK_Pos)))\r\n        {\r\n            /* Handle missing ACK. */\r\n        }\r\n        else\r\n        {\r\n            /* The datasheet lists an over-run error too; we don't check\r\n             * for this since it should only apply to slaves. */\r\n            FAIL(\"TWI error from unknown source.\");\r\n        }\r\n    }\r\n\r\nThe driver will happily perform thousands of readings from the slave (a pressure sensor). Very rarely, however, the FAIL line is being hit, suggesting that the overrun flag is being set. In what circumstances can this flag be set? The datasheet says the following:\r\n\r\n    Overrun error\r\n    A start condition is received while the previous data still lies in\r\n    RXD (Previous data is lost)\r\n\r\nBut a start condition should never be received on a single-master bus when this device is the master. Could this be caused by a transient low pulse on the line between transmissions? Or bad slave behaviour?\r\n\r\nI'm using S110 v7.1.0 on nRF51822QFAB.\r\n\r\nThanks,\r\nCarl",
    "tag": "i2c"
  },
  {
    "text": "Random PWM dutycycle inversion in SoftDevice 8.0 I am using the PWM library in [this repository](https://github.com/NordicSemiconductor/nrf51-pwm-library) for a nRF51822. I write the following code to generate a ~ 30% dutycycle 500 kHz PWM output: \r\n\r\n    #define V_CLK  5\r\n    \r\n    static void v_clock_start(void)\r\n    {   \r\n        // Init PWM\r\n        nrf_pwm_config_t pwm_config = PWM_DEFAULT_CONFIG;\r\n        pwm_config.mode             = PWM_MODE_500kHz; // PRESCALER of 0, pwm_max_value of 31\r\n        pwm_config.num_channels     = 1;\r\n        pwm_config.gpio_num[0]      = V_CLK;\r\n        // Initialize the PWM library\r\n        nrf_pwm_init(&pwm_config);\r\n    \t\r\n       // Start PWM\r\n       nrf_pwm_set_value(0, 10); \r\n    }\r\n\r\nAnd I use \r\n\r\n    nrf_pwm_set_enabled(false); \r\n\r\nto stop PWM. The enum type PWM_MODE_500kHz (self-defined) corresponds to PRESCALER of 0 and pwm_max_value of 31, making the PWM frequency 500 kHz. I enable and disable PWM periodically based on a timer, and monitor the output with an oscilloscope. I can see for the majority of time, the PWM has correct dutycycle ~30%. However, from time to time, the dutycycle is inversed (~70%), and I can see the complementary PWM waveform. It happens regularly and randomly. I am just wondering what can cause such a problem. ",
    "tag": "pwm"
  },
  {
    "text": "Why I will restart the ADC is used to measure the voltage is greater than 1.2 V Why I will restart the ADC is used to measure the voltage is greater than 1.2 V\r\n\r\n    void battery_start(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n        // Configure ADC\r\n        NRF_ADC->INTENSET   = ADC_INTENSET_END_Msk;\r\n        NRF_ADC->CONFIG     = ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos    |\r\n                              ADC_CONFIG_INPSEL_AnalogInputNoPrescaling  << ADC_CONFIG_INPSEL_Pos |\r\n                              ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos |\r\n                              ADC_CONFIG_PSEL_AnalogInput3 << ADC_CONFIG_PSEL_Pos;\r\n        NRF_ADC->EVENTS_END = 0;\r\n        NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Enabled;\r\n    \r\n        // Enable ADC interrupt\r\n        err_code = sd_nvic_ClearPendingIRQ(ADC_IRQn);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        err_code = sd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t//NVIC_SetPriority(ADC_IRQn,1);\r\n    \t\r\n        err_code = sd_nvic_EnableIRQ(ADC_IRQn);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t//NVIC_EnableIRQ(ADC_IRQn);\r\n    \r\n        NRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.\r\n        NRF_ADC->TASKS_START = 1;\r\n    \r\n    \r\n        \r\n        \r\n    }\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "ADC disable and enable Do I need to re-initial the ADC when I want to start the ADC again after I disable the ADC?\r\n",
    "tag": "adc"
  },
  {
    "text": "NRF51 sine wave with pwm and timer Hi,\r\n\r\nI want to generate a sine wave using the nrf pwm library and a timer CC instead of a delay that is used in the sine example [here](https://github.com/NordicSemiconductor/nrf51-pwm-library) to get better accuracy.\r\n\r\nIt basically works but I keep getting strange \"jumps\" in the signal. Here is an image of the signal after an RC filter (5kOhm, 100nF).\r\n\r\n![image description](/attachment/52000f7c6df912179326609c76a7b68e)\r\n\r\nIt seems like the phase variable changes value randomly sometimes and I cannot understand why.\r\n\r\nBelow is my code:\r\n\r\n   \r\n\r\n     #include <msp/ble-peripheral/BluetoothPeripheral.h>\r\n    #include <msp/drivers/delay.h>\r\n    #include <msp/drivers/board_ViTheSSG4rev1.h>\r\n    \r\n    // timer stuff\r\n    #include <components/drivers_nrf/hal/nrf_gpiote.h>\r\n    #include <components/drivers_nrf/hal/nrf51.h>\r\n    #include <components/softdevice/s110/headers/nrf_soc.h>\r\n    #include <components/drivers_nrf/hal/nrf51_bitfields.h>\r\n    \r\n    extern \"C\" {\r\n    #include <msp/drivers/nrf_pwm.h>\r\n    }\r\n    \r\n    using namespace msp::drivers;\r\n    \r\n    namespace {\r\n    \r\n    uint8_t phase = 0;\r\n    \r\n    bool active = false;\r\n    \r\n    const uint8_t sine26[] = {0, 4, 16, 35, 59, 88, 120, 152, 182, 210, 232, 247,\r\n        255, 255, 247, 232, 210, 182, 152, 120, 88, 59, 35, 16, 4, 0};\r\n    \r\n    }\r\n    \r\n    extern \"C\" {\r\n    \r\n    void TIMER1_IRQHandler(void) {\r\n      if (active) {\r\n        nrf_pwm_set_value(0, sine26[phase]);\r\n        if (phase < 26) {\r\n          phase += 1;\r\n        } else {\r\n          phase = 0;\r\n        }\r\n      }\r\n    \r\n    //pinToggle(LED_RED);\r\n    \r\n      NRF_TIMER1->EVENTS_COMPARE[0] = 0; // Clear compare match register\r\n    \r\n      NRF_TIMER1->TASKS_CLEAR = 1; // Reset timer\r\n    \r\n    }\r\n    } // end of extern C\r\n    \r\n    void initPWM(uint8_t pin, nrf_pwm_mode_t nrfPwmMode);\r\n    void initTimer(uint16_t frequency);\r\n    \r\n    int main() {\r\n      setupLEDPins();\r\n    \r\n      pinOutput(PIEZO_PWM_PIN);\r\n    \r\n    // Init softdevice\r\n      BluetoothPeripheral::instance().initialize();\r\n    \r\n    // init pwm\r\n    //PWM_MODE_VITHESS_VIBRATOR is 0-255 (8-bit) resolution, 62.5 kHz PWM frequency, 16 MHz timer frequency (prescaler 0)\r\n      initPWM(PIEZO_PWM_PIN, PWM_MODE_VITHESS_VIBRATOR);\r\n    \r\n      initTimer(128);\r\n    \r\n      pinClear(LED_GREEN);\r\n      active = true;\r\n      NRF_TIMER1->TASKS_START = 1;               // Start timer.\r\n    \r\n      while (1) {\r\n        delayMs(1000);\r\n        pinSet(LED_GREEN);\r\n        NRF_TIMER1->TASKS_STOP = 1;\r\n        active = false;\r\n        nrf_pwm_set_value(0, 0);\r\n        delayMs(1000);\r\n        pinClear(LED_GREEN);\r\n        active = true;\r\n        NRF_TIMER1->TASKS_START = 1;               // Start timer.\r\n      }\r\n    \r\n      return 0;\r\n    }\r\n    \r\n    void initPWM(uint8_t pin, nrf_pwm_mode_t nrfPwmMode) {\r\n      nrf_pwm_config_t\r\n      pwm_config = PWM_DEFAULT_CONFIG;\r\n    \r\n      pwm_config.mode = nrfPwmMode;\r\n      pwm_config.num_channels = 1;\r\n      pwm_config.gpio_num[0] = pin;\r\n    \r\n    // Initialize the PWM library\r\n      nrf_pwm_init (&pwm_config);\r\n    \r\n    // Start the external 16 MHz clock for a more accurate PWM frequency\r\n      NRF_CLOCK->TASKS_HFCLKSTART = 1;\r\n    }\r\n    \r\n    void initTimer(uint16_t frequency) {\r\n      NRF_TIMER1->MODE = TIMER_MODE_MODE_Timer;  // Set the timer in Counter Mode\r\n      NRF_TIMER1->TASKS_CLEAR = 1;  // clear the task first to be usable for later\r\n      NRF_TIMER1->PRESCALER = 5; //Set prescaler. Higher number gives slower timer. Prescaler = X gives 16MHz/2^X Hz timer\r\n      NRF_TIMER1->BITMODE = TIMER_BITMODE_BITMODE_16Bit; //Set counter to 16 bit resolution\r\n    //NRF_TIMER1->CC[0] = 500000 / (frequency * 26); //Set value for timer compare register 0, timer period is 2us, pwm period is (1/(freq*255)), pwm period/timer period is 15\r\n      NRF_TIMER1->CC[0] = 150; //Set value for timer compare register 0 to 150 as test value\r\n    \r\n    // Enable interrupt on Timer 1,for CC[0]\r\n      NRF_TIMER1->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled\r\n          << TIMER_INTENSET_COMPARE0_Pos);\r\n      sd_nvic_SetPriority(TIMER1_IRQn, 3);\r\n      sd_nvic_EnableIRQ(TIMER1_IRQn);\r\n    }\r\n\r\nDoes anyone understand this behaviour?\r\n\r\nThanks!",
    "tag": "pwm"
  },
  {
    "text": "nRF51822 SPI limitations (send/recv from timer) Hello Everyone,\r\n\r\nI am trying to use a display (through SPI) in a custom board with nRF51822 and SoftDevice S120. All works great as long as I call the SPI methods from main, and I am able to set up the screen properly and write everything I want in it. \r\n\r\nThe problem comes whenever I try to send/receive data through SPI outside main. Either I try to call it from a timer handler or an event handler, it only send 2 bytes max. through SPI. \r\n\r\nTo configure or write the screen I need to send a large amount of bytes, so when I am limited to 2 bytes from outside main I am not able to make it work. (Checked with Saleae Logic Analyzer)\r\n\r\nIs there any kind of limitation of SPI I missed? Is it working only from main? \r\n\r\nI already tried to send byte by byte with timing in between, send the full byte array at once, initialize the SPI in the timer, etc... but there is no way I can make it work.\r\n\r\nAny advice or solution would be much appreciated. \r\n\r\nThanks in advance,\r\n\r\nGabriel.",
    "tag": "spi"
  },
  {
    "text": "nRF51822 SPI limitations (send/recv from timer) Hello Everyone,\r\n\r\nI am trying to use a display (through SPI) in a custom board with nRF51822 and SoftDevice S120. All works great as long as I call the SPI methods from main, and I am able to set up the screen properly and write everything I want in it. \r\n\r\nThe problem comes whenever I try to send/receive data through SPI outside main. Either I try to call it from a timer handler or an event handler, it only send 2 bytes max. through SPI. \r\n\r\nTo configure or write the screen I need to send a large amount of bytes, so when I am limited to 2 bytes from outside main I am not able to make it work. (Checked with Saleae Logic Analyzer)\r\n\r\nIs there any kind of limitation of SPI I missed? Is it working only from main? \r\n\r\nI already tried to send byte by byte with timing in between, send the full byte array at once, initialize the SPI in the timer, etc... but there is no way I can make it work.\r\n\r\nAny advice or solution would be much appreciated. \r\n\r\nThanks in advance,\r\n\r\nGabriel.",
    "tag": "spi"
  },
  {
    "text": "Is it possible to emulate a usb serial on nrf51x22 ? Hi.\r\n\r\nnrf51x22 has 32 IOs. can we assign 2 pin to usb d+, d-, and listen interrupt.\r\n\r\nyes, nrf51x22 has uart support, but many host device only have usb port. serial port has miss a long time. \r\n\r\nUSB have power supply, and could communication with host device. it is very important. \r\n\r\nthere have any idea to implement USB in nrf51x22?\r\n",
    "tag": "adc"
  },
  {
    "text": "gpiote config for PWM with softdevice I need a PWM signal as outoput from the nRF51-DK. And I do need the softdevice. So I decided to pick the code from the nrf51-pwm-library-master and add it to my project(SKD 8.1). \r\n\r\nThe problem is, when I add the nrf_pwm.c file to my project I will get these errors:\r\n\r\nError: L6218E: Undefined symbol nrf_gpiote_unconfig (referred from nrf_pwm.o).\r\n\r\nError: L6218E: Undefined symbol nrf_gpiote_task_config (referred from nrf_pwm.o).\r\n\r\n**nrf_gpiote_unconfig** and **nrf_gpiote_task_config** are defined in the nrf_gpiote.h file.\r\n\r\nThe nrf_gpiote.h file from SDK 7.0 is not the same as for 8.1.\r\n\r\nIs there a pwm libray for SDK 8.1 available?\r\n\r\nIf not I will place the project in the SDK 7.0 then the error should be solved.",
    "tag": "pwm"
  },
  {
    "text": "PWM Always Busy Hello,\r\n\r\nI am currently working on a project where I need to be able to control an RGB by writing the PWM duty cycle to a custom BLE Service and Characteristic. I am using SDK 8.1 and s110 SoftDevice 8.0. I am also using the app_pwm library from the SDK. I init the PWM module in the following way: \r\n    \r\n    APP_PWM_INSTANCE(PWM1,1);\r\n    APP_PWM_INSTANCE(PWM2,2);\r\n\r\n    bool pwm_1_ready_flag;\r\n    bool pwm_2_ready_flag;\r\n\r\n    void pwm_1_ready_callback(uint32_t pwm_id)\r\n    {\r\n      pwm_1_ready_flag = true;\r\n    }\r\n\r\n    void pwm_2_ready_callback(uint32_t pwm_id)   \r\n    {\r\n      pwm_2_ready_flag = true;\r\n    }\r\n\r\n    void pwm_init(void)\r\n    {\r\n\t  ret_code_t err_code;\r\n\r\n\t  /* 2-channel PWM, 100Hz, output on LED pins. */\r\n\t  app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(10000L, 21, 22);\r\n\t  app_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_1CH(10000L, 23);\r\n\r\n\t  // Set the polarity of the channel. \r\n\t  pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\t  pwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\t  pwm2_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\r\n\t  // Initialize and enable PWM.\r\n\t  err_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm_1_ready_callback);\r\n\t  APP_ERROR_CHECK(err_code);\r\n\t  err_code = app_pwm_init(&PWM2,&pwm2_cfg,pwm_2_ready_callback);\r\n\t  APP_ERROR_CHECK(err_code);\r\n\r\n\t  app_pwm_enable(&PWM1);\r\n\t  app_pwm_enable(&PWM2);\r\n    }\r\n\r\nI can successfully get the desired values to the write handler for the characteristic and I set the values in the following way:\r\n\r\n \r\n\r\n    void set_rgb(uint8_t red_val, uint8_t green_val, uint8_t blue_val)\r\n    {\t\r\n\t  while (app_pwm_channel_duty_set(&PWM1, 0, red_val) == NRF_ERROR_BUSY);\r\n\t  while (app_pwm_channel_duty_set(&PWM1, 1, green_val) == NRF_ERROR_BUSY);\r\n\t  while (app_pwm_channel_duty_set(&PWM2, 0, blue_val) == NRF_ERROR_BUSY);\t\t\r\n    }\r\n\r\nMy PWM module always hangs and gives me a NRF_ERROR_BUSY code when I attempt to set the PWM value of the second channel of PWM1. The first channel of PWM1 can be written and the only channel of PWM2 can be written but when I attempt to write all three simultaneously as I do in the above code, the code gets trapped in the while loop trying to write the green_val to the PWM1 channel 0 and I can only recover by using the reset button on my nRF51-DK.\r\n\r\nIf I dont use the while loop to wait for the PWM module to be ready, I will sometimes be unsuccessful when writing to the RGB characteristic over BLE but I can at least recover and attempt to rewrite the RGB value instead of being trappen in a while loop while my PWM module gives me an NRF_ERROR_BUSY return code.\r\n\r\nAny help you can offer is greatly appreciated.\r\n\r\nEdit: It appears as though the problem is being caused when I try to write to both channels of the PWM1 instance sequentially. If I write to channel 0 of PWM1 and channel 0 of PWM2 there are no issues. If i write to channel 1 of PWM1 and channel 0 of PWM2, still there are no problems. If I write to channel 0 of PWM1 and then channel 1 of PWM1 I get the above mentioned error of endlessly waiting for the PWM module to be ready.\r\n\r\nAre there any reasons why writing to both channels of a single instance would have this effect?\r\n\r\nThanks and Best Regards,\r\n\r\nCory Mast",
    "tag": "pwm"
  },
  {
    "text": "SPI master disable recieve So I've been using the SPI master driver supplied via the SDK. I'm currently trying to use the nrf51822 to control an LCD screen so I can display some information. I don't need to read anything from the LCD driver and my LCD refresh rate is slower than I would like. However when I go through and try to remove any use of the receive buffer in an attempt to speed up my screen refresh rate the SPI driver just stops working. Is there some way for me to do this?\r\n\r\nThank you",
    "tag": "spi"
  },
  {
    "text": "SPI master disable recieve So I've been using the SPI master driver supplied via the SDK. I'm currently trying to use the nrf51822 to control an LCD screen so I can display some information. I don't need to read anything from the LCD driver and my LCD refresh rate is slower than I would like. However when I go through and try to remove any use of the receive buffer in an attempt to speed up my screen refresh rate the SPI driver just stops working. Is there some way for me to do this?\r\n\r\nThank you",
    "tag": "spi"
  },
  {
    "text": "Adding a payload to the beacon advertising packet? Is it possible to add a payload (1-2 bytes) to the beacon advertising packet? \r\n\r\nI intend place an ADC output to the payload. For now, I'm using nRF51-DK but later wants to use nRF51 beacon. \r\n\r\nIf this is possible, I will also write an Android app to read the payload. \r\n\r\nThanks.\r\n",
    "tag": "adc"
  },
  {
    "text": "51822 interrupt miss issue when sharing one GPIOTE Hi expert,\r\n\r\nI am developing 51822 under SDK 6.1,  and we have one button and some sensors' interrupt lines as input GPIOs in our platform. In my code, after calling gpiote_init, I put button's handler and sensor interrup's handler into one app_button_cfg_t, like this:\r\n\r\n    static void buttons_init(void)\r\n    {\r\n        static app_button_cfg_t buttons[] =\r\n        {  \r\n            {BOND_DELETE_ALL_BUTTON_ID, false, BUTTON_PULL, button_event_handler},\r\n            {LIS3DSH_INT1_PIN, APP_BUTTON_ACTIVE_HIGH, BUTTON_PULL, sensor_event_handler},\r\n        };\r\n        \r\n        APP_BUTTON_INIT(buttons, sizeof(buttons) / sizeof(buttons[0]), BUTTON_DETECTION_DELAY, true);\r\n    }\r\n\r\nSeen from debugging O/P, i can see both work well. Sensor's interrup rate is 1Hz, button's push action is random. The issue is when I am pushing button quickly, I found some sensor's interrupt is miss-handled. Would you help me how to resolve this issue? Sensor data is exactly important for us, we dont like anyone is lost. The same to the button.\r\n\r\nThanks a lot!\r\n\r\n ",
    "tag": "interrupt"
  },
  {
    "text": "How do I measure battery level on an Nrf51422 without external components? I have a custom PCB with an nrf51422 powered by a coin cell battery.  The EE who designed the board assured me that the battery voltage could be measured internally through the ADC.  That EE is now tied up and cannot help.  \r\n\r\nWhat is the proper method for measuring this voltage?  It is a standard feature in nearly all devices, yet the inclusion of a resistor set will leak current.  Any direction would be appreciated.  Thanks.\r\n\r\nEdit:\r\nI am able to find examples of battery service updates, but these updates are based on a simulated battery as per the code below.  I have not yet found an example of configuring of the ADC to VCC.\r\n\r\n    static void battery_level_update(void)\r\n    {\r\n        uint32_t err_code;\r\n        uint8_t  battery_level;\r\n    \r\n        battery_level = (uint8_t)sensorsim_measure(&m_battery_sim_state, &m_battery_sim_cfg);\r\n    \r\n        err_code = ble_bas_battery_level_update(&m_bas, battery_level);\r\n        if ((err_code != NRF_SUCCESS) &&\r\n            (err_code != NRF_ERROR_INVALID_STATE) &&\r\n            (err_code != BLE_ERROR_NO_TX_BUFFERS) &&\r\n            (err_code != BLE_ERROR_GATTS_SYS_ATTR_MISSING)\r\n            )\r\n        {\r\n            APP_ERROR_HANDLER(err_code);\r\n        }\r\n    }",
    "tag": "adc"
  },
  {
    "text": "Getting current radio status nRF51 Hello,\r\n\r\nI've overcome most of my problems using this wonderful Q&A system from other people. Recently I've moved from a nRF8001 + MCU to a nRF51\r\n\r\nUsing SDK 8.1.1, keil and the ble_uart example (S110) I've implemented an RTC (app_timer) on LCD just fine but when the advertising packet syncs up with  SPI to LCD communication it glitches the display until the next write one second later. I'm advertising every 2 seconds with no timeout and writing to SPI every second. \r\n\r\nIn my two chip nRF8001 system I could just RDY line interrupt in the middle of any part of the user code. What am I missing with the SoftDevice ?\r\n\r\nWhat is the best way to overcome this problem? either by pausing the radio until my application has finished or by pausing the application until a known space is available between radio events. If so what are the useful bits or SoftDevice event calls I should know. Nordic documentation is great but a little chewy for a beginner who never worked with anything like a SoftDevice \r\n\r\nMany Thanks.\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "Getting current radio status nRF51 Hello,\r\n\r\nI've overcome most of my problems using this wonderful Q&A system from other people. Recently I've moved from a nRF8001 + MCU to a nRF51\r\n\r\nUsing SDK 8.1.1, keil and the ble_uart example (S110) I've implemented an RTC (app_timer) on LCD just fine but when the advertising packet syncs up with  SPI to LCD communication it glitches the display until the next write one second later. I'm advertising every 2 seconds with no timeout and writing to SPI every second. \r\n\r\nIn my two chip nRF8001 system I could just RDY line interrupt in the middle of any part of the user code. What am I missing with the SoftDevice ?\r\n\r\nWhat is the best way to overcome this problem? either by pausing the radio until my application has finished or by pausing the application until a known space is available between radio events. If so what are the useful bits or SoftDevice event calls I should know. Nordic documentation is great but a little chewy for a beginner who never worked with anything like a SoftDevice \r\n\r\nMany Thanks.\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "NRF51 Dongle I2C Example SDK_8.1.0 Hi,\r\n\r\nAfter looking around it seems like the I2C example that used to be in the older SDK is currently not available anymore. I was wondering if it was replaced with anything or do I have to write an I2C test program from scratch?\r\n\r\nRegards,\r\nJoe",
    "tag": "i2c"
  },
  {
    "text": "Ask for TWI example Hi there,\r\n\r\nBefore I asked this question, I have searched similar question about TWI example, but it seems there were some guys looking for such example as well. Not sure finally what they were referring for their project, could anyone point out where I can get the example about TWI + SD110?\r\n\r\nAny feedback will be appreciated.\r\n\r\nRegards,\r\nStanley",
    "tag": "twi"
  },
  {
    "text": "Slow interrupt by using internal RTC Hi,\r\n\r\nI have two nRF51822 Module one of them has an external RTC and another one hasn't\r\n\r\nI'm trying to count a clock in a specific period of time\r\n\r\n\r\nfor first one i use: NRF_CLOCK_LFCLKSRC_XTAL_250_PPM\r\n\r\nfor second one i use: NRF_CLOCK_LFCLKSRC_RC_250_PPM_TEMP_4000MS_CALIBRATION or NRF_CLOCK_LFCLKSRC_RC_250_PPM_4000MS_CALIBRATION\r\n\r\nEvery thing is OK when I'm using external RTC but when i try to use the module without external RTC i see a lot of interrupt missed\r\n\r\nfor example my clock has 244 High to Low when i use module with external RTC but when i use module without external RTC i just count 44 High to Low\r\n\r\nCan you help me to find out what's going on?\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "ADC_IRQHandler specific calling Hi,\r\nI am new to nordic n51822, i have implemented adc and timer independently. \r\nNow, what i want to do is read the adc values on a specific time when the timer overflows for 500ms.\r\nI am little confused that void ADC_IRQHandler(void) continually polls and reads the value and displays the value on UART. Can anyone guide me through the steps on how to read adc with specific time, like when enabling timing interrupt timer starts and reads value and every time when the value is read , the interrupt is stopped and values are processed then again the interrupt is activated and timer is started. What i want is to create a specific sample rate in which it reads adc,process values,print and repeat.\r\n\r\n        #define UART_TX_BUF_SIZE 256 /**< UART TX buffer size. */\r\n    \r\n       #define UART_RX_BUF_SIZE 1 /**< UART RX buffer size. */ \r\n      #define GPIO_TOGGLE_PIN 4 /*!< gpio pin to toggle after delay. */ \r\n     #ifndef NRF_APP_PRIORITY_HIGH #define NRF_APP_PRIORITY_HIGH 1\r\n      #endif\r\n    \r\n    /** @TIMER2\r\n    * \r\n    *\r\n    */\r\n    \r\n    void start_timer(void)\r\n    {\t\t\r\n      NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;  // Set the timer in Counter Mode\r\n      NRF_TIMER2->TASKS_CLEAR = 1;               // clear the task first to be usable for later\r\n    \tNRF_TIMER2->PRESCALER = 8;                             //Set prescaler. Higher number gives slower timer. Prescaler = 0 gives 16MHz timer\r\n    \tNRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\t\t //Set counter to 16 bit resolution\r\n    \tNRF_TIMER2->CC[0] = 31250;                             //Set value for TIMER2 compare register 0\r\n    \t\t\r\n      // Enable interrupt on Timer 2, both for CC[0] and CC[1] compare match events\r\n    \tNRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos)\t;\r\n    \t//| (TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos);\r\n      NVIC_EnableIRQ(TIMER2_IRQn);\r\n    \tNRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos) & TIMER_SHORTS_COMPARE0_CLEAR_Msk;\t\r\n      NRF_TIMER2->TASKS_START = 1;               // Start TIMER2\r\n    }\r\n    \t\t\r\n    /** TIMTER2 peripheral interrupt handler. This interrupt handler is called whenever there it a TIMER2 interrupt\r\n     */\r\n    void TIMER2_IRQHandler(void)\r\n    {\r\n    \tif(NRF_TIMER2->EVENTS_COMPARE[0])\r\n        {\r\n    \t\t\t\tNRF_TIMER2->EVENTS_COMPARE[0] = 0;           //Clear compare register 0 event\t\r\n    \t    \tnrf_gpio_pin_toggle(GPIO_TOGGLE_PIN);\r\n     \r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief UART events handler.\r\n     */\r\n    void uart_events_handler(app_uart_evt_t * p_event)\r\n    {\r\n        switch (p_event->evt_type)\r\n        {\r\n            case APP_UART_COMMUNICATION_ERROR: APP_ERROR_HANDLER(p_event->data.error_communication);\r\n                break;\r\n    \r\n            case APP_UART_FIFO_ERROR:          APP_ERROR_HANDLER(p_event->data.error_code);\r\n                break;\r\n    \r\n            case APP_UART_TX_EMPTY:            printf(\"RESULT= %1.1f\\r\\n\", (float)adc_sample); // out ADC result\r\n                break;\r\n    \r\n            default: break;\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief ADC interrupt handler.\r\n     */\r\n    void ADC_IRQHandler(void)\r\n    {\r\n        nrf_adc_conversion_event_clean();\r\n    \r\n        adc_sample = nrf_adc_result_get();\r\n    \r\n        // trigger next ADC conversion\r\n        nrf_adc_start();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief UART initialization.\r\n     */\r\n    void uart_config(void)\r\n    {\r\n        uint32_t                     err_code;\r\n        const app_uart_comm_params_t comm_params =\r\n        {\r\n            RX_PIN_NUMBER,\r\n            TX_PIN_NUMBER,\r\n            RTS_PIN_NUMBER,\r\n            CTS_PIN_NUMBER,\r\n            APP_UART_FLOW_CONTROL_DISABLED,\r\n            false,\r\n            UART_BAUDRATE_BAUDRATE_Baud38400\r\n        };\r\n    \r\n        APP_UART_FIFO_INIT(&comm_params,\r\n                           UART_RX_BUF_SIZE,\r\n                           UART_TX_BUF_SIZE,\r\n                           uart_events_handler,\r\n                           APP_IRQ_PRIORITY_LOW,\r\n                           err_code);\r\n    \r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief ADC initialization.\r\n     \r\n     */\r\n    void adc_config(void)\r\n    {\r\n        const nrf_adc_config_t nrf_adc_config = NRF_ADC_CONFIG_DEFAULT;\r\n    \r\n        // Initialize and configure ADC\r\n        nrf_adc_configure( (nrf_adc_config_t *)&nrf_adc_config);\r\n        nrf_adc_input_select(NRF_ADC_CONFIG_INPUT_7);\r\n        nrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n    \t\t//ADC INTERRUPT ENABLE\r\n        NVIC_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);\r\n        NVIC_EnableIRQ(ADC_IRQn);\r\n    }\r\n    \r\n    /*void adc_init(void)\r\n    {\r\n     const nrf_adc_config_t nrf_adc_config = NRF_ADC_CONFIG_DEFAULT;\r\n    \r\n    \t// Enable interrupt on ADC sample ready event\t\r\n    \tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n    \tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n    \tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    \t\r\n    \r\n    }\r\n    */\r\n    \r\n    /**\r\n     * @brief Function for main application entry.\r\n     */\r\n    int main(void)\r\n    {\r\n        adc_config();\r\n    \t\t//adc_init();\r\n        uart_config();\r\n    \r\n        printf(\"\\n\\rADC HAL simple example\\r\\n\");\r\n    \r\n        printf(\"Current sample value:\\r\\n\");\r\n    \r\n        nrf_adc_start();\r\n    \r\n        while (true)\r\n        {\r\n            // enter into sleep mode\r\n            __WFI();\t//WAIT FOR INTERRUPT\r\n    \t\t\t  //__SEV();\r\n            //__WFE();\r\n            //__WFE();\r\n        }\r\n    }\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "ADC_IRQHandler specific calling Hi,\r\nI am new to nordic n51822, i have implemented adc and timer independently. \r\nNow, what i want to do is read the adc values on a specific time when the timer overflows for 500ms.\r\nI am little confused that void ADC_IRQHandler(void) continually polls and reads the value and displays the value on UART. Can anyone guide me through the steps on how to read adc with specific time, like when enabling timing interrupt timer starts and reads value and every time when the value is read , the interrupt is stopped and values are processed then again the interrupt is activated and timer is started. What i want is to create a specific sample rate in which it reads adc,process values,print and repeat.\r\n\r\n        #define UART_TX_BUF_SIZE 256 /**< UART TX buffer size. */\r\n    \r\n       #define UART_RX_BUF_SIZE 1 /**< UART RX buffer size. */ \r\n      #define GPIO_TOGGLE_PIN 4 /*!< gpio pin to toggle after delay. */ \r\n     #ifndef NRF_APP_PRIORITY_HIGH #define NRF_APP_PRIORITY_HIGH 1\r\n      #endif\r\n    \r\n    /** @TIMER2\r\n    * \r\n    *\r\n    */\r\n    \r\n    void start_timer(void)\r\n    {\t\t\r\n      NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;  // Set the timer in Counter Mode\r\n      NRF_TIMER2->TASKS_CLEAR = 1;               // clear the task first to be usable for later\r\n    \tNRF_TIMER2->PRESCALER = 8;                             //Set prescaler. Higher number gives slower timer. Prescaler = 0 gives 16MHz timer\r\n    \tNRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\t\t //Set counter to 16 bit resolution\r\n    \tNRF_TIMER2->CC[0] = 31250;                             //Set value for TIMER2 compare register 0\r\n    \t\t\r\n      // Enable interrupt on Timer 2, both for CC[0] and CC[1] compare match events\r\n    \tNRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos)\t;\r\n    \t//| (TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos);\r\n      NVIC_EnableIRQ(TIMER2_IRQn);\r\n    \tNRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos) & TIMER_SHORTS_COMPARE0_CLEAR_Msk;\t\r\n      NRF_TIMER2->TASKS_START = 1;               // Start TIMER2\r\n    }\r\n    \t\t\r\n    /** TIMTER2 peripheral interrupt handler. This interrupt handler is called whenever there it a TIMER2 interrupt\r\n     */\r\n    void TIMER2_IRQHandler(void)\r\n    {\r\n    \tif(NRF_TIMER2->EVENTS_COMPARE[0])\r\n        {\r\n    \t\t\t\tNRF_TIMER2->EVENTS_COMPARE[0] = 0;           //Clear compare register 0 event\t\r\n    \t    \tnrf_gpio_pin_toggle(GPIO_TOGGLE_PIN);\r\n     \r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief UART events handler.\r\n     */\r\n    void uart_events_handler(app_uart_evt_t * p_event)\r\n    {\r\n        switch (p_event->evt_type)\r\n        {\r\n            case APP_UART_COMMUNICATION_ERROR: APP_ERROR_HANDLER(p_event->data.error_communication);\r\n                break;\r\n    \r\n            case APP_UART_FIFO_ERROR:          APP_ERROR_HANDLER(p_event->data.error_code);\r\n                break;\r\n    \r\n            case APP_UART_TX_EMPTY:            printf(\"RESULT= %1.1f\\r\\n\", (float)adc_sample); // out ADC result\r\n                break;\r\n    \r\n            default: break;\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief ADC interrupt handler.\r\n     */\r\n    void ADC_IRQHandler(void)\r\n    {\r\n        nrf_adc_conversion_event_clean();\r\n    \r\n        adc_sample = nrf_adc_result_get();\r\n    \r\n        // trigger next ADC conversion\r\n        nrf_adc_start();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief UART initialization.\r\n     */\r\n    void uart_config(void)\r\n    {\r\n        uint32_t                     err_code;\r\n        const app_uart_comm_params_t comm_params =\r\n        {\r\n            RX_PIN_NUMBER,\r\n            TX_PIN_NUMBER,\r\n            RTS_PIN_NUMBER,\r\n            CTS_PIN_NUMBER,\r\n            APP_UART_FLOW_CONTROL_DISABLED,\r\n            false,\r\n            UART_BAUDRATE_BAUDRATE_Baud38400\r\n        };\r\n    \r\n        APP_UART_FIFO_INIT(&comm_params,\r\n                           UART_RX_BUF_SIZE,\r\n                           UART_TX_BUF_SIZE,\r\n                           uart_events_handler,\r\n                           APP_IRQ_PRIORITY_LOW,\r\n                           err_code);\r\n    \r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief ADC initialization.\r\n     \r\n     */\r\n    void adc_config(void)\r\n    {\r\n        const nrf_adc_config_t nrf_adc_config = NRF_ADC_CONFIG_DEFAULT;\r\n    \r\n        // Initialize and configure ADC\r\n        nrf_adc_configure( (nrf_adc_config_t *)&nrf_adc_config);\r\n        nrf_adc_input_select(NRF_ADC_CONFIG_INPUT_7);\r\n        nrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n    \t\t//ADC INTERRUPT ENABLE\r\n        NVIC_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);\r\n        NVIC_EnableIRQ(ADC_IRQn);\r\n    }\r\n    \r\n    /*void adc_init(void)\r\n    {\r\n     const nrf_adc_config_t nrf_adc_config = NRF_ADC_CONFIG_DEFAULT;\r\n    \r\n    \t// Enable interrupt on ADC sample ready event\t\r\n    \tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n    \tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n    \tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    \t\r\n    \r\n    }\r\n    */\r\n    \r\n    /**\r\n     * @brief Function for main application entry.\r\n     */\r\n    int main(void)\r\n    {\r\n        adc_config();\r\n    \t\t//adc_init();\r\n        uart_config();\r\n    \r\n        printf(\"\\n\\rADC HAL simple example\\r\\n\");\r\n    \r\n        printf(\"Current sample value:\\r\\n\");\r\n    \r\n        nrf_adc_start();\r\n    \r\n        while (true)\r\n        {\r\n            // enter into sleep mode\r\n            __WFI();\t//WAIT FOR INTERRUPT\r\n    \t\t\t  //__SEV();\r\n            //__WFE();\r\n            //__WFE();\r\n        }\r\n    }\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "How to make sure, that a compare event will be generated Hello,\r\nI want to generate timer events as exact as possible, based on a time base that is defined by a runing timer. For example, I've setup timer0 to count up every 1\u00b5s and the time point, where I've started the timer is my anchor/T0 in time. When I want to have an interrupt that is 600\u00b5s after T0, I could simply load 600 into a capture/compare register and wait for the coresponding compare event.\r\n\r\nWhen the value of the counter is already very close to my target time, it could be that I load the capture/compare register with a value that is smaller than the counter value. Checking for the counter  before loading the capture compare register would introduce a race condition.\r\n\r\nWhat would be the best / idomatic way to prevent a race condition here? Best without stopping the timer, disabling interrupts and so on.... How about this:\r\n\r\n    NRF_TIMER0->EVENTS_COMPARE[ 0 ] = 0;\r\n    NRF_TIMER0->CC[ 0 ]             = target_time;\r\n    NRF_TIMER0->TASKS_CAPTURE[ 1 ]  = 1;\r\n\r\n    /* manually triggering event for timer beeing already behind target time */\r\n    NRF_TIMER0->EVENTS_COMPARE[ 0 ] = NRF_TIMER0->EVENTS_COMPARE[ 0 ] || NRF_TIMER0->CC[ 1 ] >= NRF_TIMER0->CC[ 0 ];\r\n    NRF_TIMER0->INTENSET            = TIMER_INTENSET_COMPARE0_Msk;\r\n\r\nwould that work? Does someone of you have a better approache to cope with possible race conditions here?\r\n\r\nBest regards,\r\nTorsten",
    "tag": "timer"
  },
  {
    "text": "How do I interface external IO pins when app_button is used? I would like to support app_button, however I need to configure a pin as NOPULL and trigger on a low to high transition without debouncing.\r\n\r\nI don't see a way this can co-exist with the app_button modile. I tried using nrf_drv_gpiote but was confused when it would not let me register new event handlers.\r\n\r\nWhat is the recommended way of interfacing external interrupts with an application already using app_button?\r\n\r\n--\r\nIs this sufficient if I use the gpiote merge fix to use both app_gpiote and nrf_drv_gpiote?\r\n\r\n    \r\n\t\tAPP_GPIOTE_INIT(2);\r\n\t\tapp_gpiote_user_register(&userid, (1<<16), 0, evt_hdl);\r\n\t\tapp_gpiote_user_enable(userid);",
    "tag": "interrupt"
  },
  {
    "text": "Proper sequence to initialize PWM? I'm having difficulty with using PWM library with softdevice. The app_pwm_init function returns \r\n\r\nNRF_SUCCESS but call to app_pwm_enable does not generate an output.\r\n\r\n    //PWM sound generation\r\n    APP_PWM_INSTANCE(PWMpiezo,1);\r\n    \r\n    void pwm_ready_callback(uint32_t pwm_id)    // PWM callback function\r\n    {\r\n    \r\n    }\r\n    \r\n    void UI_pwm_init()\r\n    {\r\n        ret_code_t err_code;\r\n    \r\n        app_pwm_config_t piezo_config = APP_PWM_DEFAULT_CONFIG_1CH(250UL,PIEZO); //4KHz \r\n        // Initialize the PWM library\r\n        err_code = app_pwm_init(&PWMpiezo,&piezo_config,pwm_ready_callback);\r\n        if(err_code == NRF_SUCCESS)\r\n        {\r\n    \tapp_pwm_enable(&PWMpiezo);\r\n         }\r\n    }\r\n\r\nDocumentation **doesn't** detail where init should take place but an answer to a question here says it should be before the ble_stack_init. Are there other restrictions on where it should be done?\r\n\r\nOr do I have an error in the code that I can't see?\r\nThanks!\r\nNeil\r\n",
    "tag": "pwm"
  },
  {
    "text": "PWM Library documentation error The documentation shows return codes for app_pwm_enable and _disable but they do not return anything.",
    "tag": "pwm"
  },
  {
    "text": "PWM Resolution in app_pwm.c Hi all,\r\n\r\nI was looking into using a PWM for LED dimming, and in an attempt to smooth out transitions between light states, I found that there was visible flicker as the internal LED value was quantized to the 0-100% PWM duty cycle. \r\n\r\nFortunately, since the PWM duty cycle was implemented as a uint16_t, I was able to change the following lines to improve PWM resolution -\r\n\r\n    uint32_t app_pwm_channel_duty_set(app_pwm_t const * const p_instance,\r\n                                      uint8_t channel, app_pwm_duty_t duty)\r\n    {\r\n        uint32_t ticks = (nrf_drv_timer_capture_get(p_instance->p_timer,\r\n                          (nrf_timer_cc_channel_t) PWM_MAIN_CC_CHANNEL) * (uint32_t)duty) / **1000UL**;\r\n        return app_pwm_channel_pulsewidth_ticks_set(p_instance, channel, ticks);\r\n    }\r\n    \r\n    \r\n    app_pwm_duty_t app_pwm_channel_duty_get(app_pwm_t const * const p_instance, uint8_t channel)\r\n    {\r\n        uint32_t value = (nrf_drv_timer_capture_get(p_instance->p_timer,\r\n                                                    (nrf_timer_cc_channel_t)(channel)) * **1000UL**) \\\r\n                         / nrf_drv_timer_capture_get(p_instance->p_timer,\r\n                                                     (nrf_timer_cc_channel_t) PWM_MAIN_CC_CHANNEL);\r\n    \r\n        return (app_pwm_duty_t)value;\r\n    }\r\n\r\n\r\nWhile this works for my application, I was wondering - \r\n\r\n1. Are there any technical reasons why the duty cycle was limited to 0-100 while the allocated space was 16bit (and then casted to 32bit anyway?) Seems like one would use a uint8_t then. \r\n2. Was it removed to solve any errata I am missing?\r\n3. If none of the above, would it be possible to implement maybe a PWM units enumeration to allow someone to use a higher-resolution PWM duty? I would prefer to avoid using a modified SDK. \r\n\r\nThanks,\r\n-Alex",
    "tag": "pwm"
  },
  {
    "text": "Bug in APP_PWM_INSTANCE() in SDK 9.0.0 I've been fighting this bug for a few days now and I thought I'd share what I discovered in the process.  \r\n\r\nI wanted to set up a couple PWM channels to control a few LEDs, so I did what was suggested in the documentation (modified for my uses):\r\n\r\n    APP_PWM_INSTANCE(PWM1, 1);\r\n\r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(500L, 2, 6);\r\n    ret_code_t err_code = app_pwm_init(&PWM1, &pwm1_cfg, pwm_ready_callback);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nBut the LEDs never did anything.  I ran the debugger and traced the problem down to `app_pwm_init()` always returning `NRF_ERROR_INVALID_STATE`, subsequently causing `APP_ERROR_CHECK()` to trigger a reboot.  The only place inside of `app_pwm_init()` that throws that error is this code:\r\n\r\n    ...\r\n\r\n    app_pwm_cb_t * p_cb = p_instance->p_cb;\r\n\r\n    if (p_cb->state != NRF_DRV_STATE_UNINITIALIZED)\r\n    {\r\n        return NRF_ERROR_INVALID_STATE;\r\n    }\r\n\r\n    ...\r\nIt seemed absurd to me that this condition would be met because I literally just started initializing the only PWM instance in my code, i.e., the PWM driver should not be in any state except uninitialized.  So I dug a little deeper.  Look at `APP_PWM_INSTANCE()`:\r\n\r\n    const nrf_drv_timer_t m_pwm_PWM1_timer = { \r\n        .p_reg                = ((NRF_TIMER_Type          *) 0x40009000UL),\r\n        .irq                  = TIMER1_IRQn,\r\n        .instance_id          = (0), \r\n    }; \r\n\r\n    app_pwm_cb_t m_pwm_PWM1_cb;  // <------  Never initialized\r\n\r\n    /*lint -e{545}*/      \r\n    const app_pwm_t PWM1 = {  \r\n        .p_cb    = &m_pwm_PWM1_cb, \r\n        .p_timer = &m_pwm_PWM1_timer, \r\n    }\r\n\r\nNotice anything?  I did.  The value that `app_pwm_init()` is checking (`m_pwm_PWM1_cb.state`) to make sure the PWM driver is not initialized is, well... not initialized.  For me that value, for whatever reason, was being randomly set to `NRF_DRV_STATE_INITIALIZED` (1), instead of being intentionally set to the much more sensible value of `NRF_DRV_STATE_UNINITIALIZED` (0).  \r\n\r\nA quick change to my code fixed the problem:\r\n\r\n    APP_PWM_INSTANCE(PWM1, 1);\r\n    \r\n    PWM1.p_cb->state = NRF_DRV_STATE_UNINITIALIZED; // The fix\r\n    \r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(500L, 2, 6);\r\n    ret_code_t err_code = app_pwm_init(&PWM1, &pwm1_cfg, pwm_ready_callback);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nEither the source code for the PWM library has a flaw, or the SDK documentation is missing a step.  In either case this needs to be fixed!",
    "tag": "pwm"
  },
  {
    "text": "nRF51 DK mbed I2C/TWI Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE.\r\nI succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "i2c"
  },
  {
    "text": "nRF51 DK mbed I2C/TWI Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE.\r\nI succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "twi"
  },
  {
    "text": "mbed i2c bmp180 Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE.\r\nI succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "i2c"
  },
  {
    "text": "mbed i2c bmp180 Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE.\r\nI succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "twi"
  },
  {
    "text": "mbed i2c bmp180 Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE.\r\nI succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "i2c"
  },
  {
    "text": "nRF51 DK mbed I2C/TWI Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE. I succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "i2c"
  },
  {
    "text": "nRF51 DK mbed I2C/TWI Hi,\r\n\r\nI'm currently building a BLE multi-sensors device, with mbed online IDE. I succeed in implementing BLE API, and releasing a first .hex firmware with multiple services and characteristics.\r\n\r\nNow, I want to replace my fake characteristic values by sensor values.\r\n\r\nI plug a BMP180 on my nRF51 dev board, with SCL and SDA connected to P0.24 and P0.25, but I don't know how to retrieve sensor values in order to broadcast them over BLE.\r\n\r\nAny ideas on how to implement I2C communication to 77 address, and convert arduino library for mbed ?",
    "tag": "twi"
  },
  {
    "text": "add timer in ble_app_uart I am working on adding a timer in the ble_app_uart sample, aiming on disconnect with device which doesn't send any data in specific time, such as 5 seconds.  \r\n\r\nNow I have found an example \"timer_pca10028\", and try to insert useful part into my application. \r\nhere is my mofified main function:\r\n\r\n    int main(void)\r\n    {\r\n        uint32_t err_code;\r\n        bool erase_bonds;\r\n        uint8_t  start_string[] = START_STRING;\r\n        \r\n        // Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        uart_init();\r\n        buttons_leds_init(&erase_bonds);\r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n        \r\n        printf(\"%s\",start_string);\r\n    \r\n    \t\terr_code = nrf_drv_timer_init(&TIMER_LED, NULL, timer_data_receive_event_handler);\r\n        //APP_ERROR_CHECK(err_code);\r\n        \r\n    \t\tuint32_t time_ticks;\r\n        time_ticks = nrf_drv_timer_ms_to_ticks(&TIMER_LED, DATA_RECEIVE_TIMEOUT);\r\n        \r\n        nrf_drv_timer_extended_compare(\r\n             &TIMER_LED, NRF_TIMER_CC_CHANNEL0, DATA_RECEIVE_TIMEOUT, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, true);\r\n        \r\n    \t\terr_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n        // Enter main loop.\r\n        for (;;)\r\n        {\r\n            power_manage();\r\n        }\r\n    }\r\n\r\ntimer_data_receive_event_handler is my timer event handler, when I find the time is out and it doesn't get any message, 51822 terminates connection, :\r\n\r\n    void timer_data_receive_event_handler(nrf_timer_event_t event_type, void* p_context)\r\n    { \r\n        switch(event_type)\r\n        {\r\n    \t\t\t\tuint32_t  err_code;\r\n            case NRF_TIMER_EVENT_COMPARE0:\r\n    \t\t\t\t\t\tif (!is_received_data){\r\n    \t\t\t\t\t\t\terr_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);\r\n    \t\t\t\t\t\t\tAPP_ERROR_CHECK(err_code);\r\n    \t\t\t\t\t\t\tnrf_drv_timer_disable(&TIMER_LED);\r\n    \t\t\t\t\t\t}\r\n                \r\n                break;\r\n            default:\r\n                //Do nothing.\r\n                break;\r\n        }    \r\n    }\r\n\r\nis_received_data is used for marking if I have received the data in nus_data_handler()\r\n\r\nwhen the connection is established, I will start a timer like that:\r\n\r\n    static void on_ble_evt(ble_evt_t * p_ble_evt)\r\n    {\r\n        uint32_t                         err_code;\r\n        \r\n        switch (p_ble_evt->header.evt_id)\r\n        {\r\n            case BLE_GAP_EVT_CONNECTED:\r\n    \t\t\t\t\t\t\r\n                err_code = bsp_indication_set(BSP_INDICATE_CONNECTED);\r\n                APP_ERROR_CHECK(err_code);\r\n                m_conn_handle = p_ble_evt->evt.gap_evt.conn_handle;\r\n    \t\t\t\t\t\tprintf(\"%s\",\"Device Connected:\");\r\n    \t\t\t\t\t\tnrf_drv_timer_enable(&TIMER_LED);\r\n                break;\r\n                ...\r\n                ...\r\n\r\nNow I have two problem:\r\n\r\n 1. Does the sample \"timer_pca10028\" match my purpose? Can I set a timer imitating the sample code?\r\n 2. nrf_drv_timer_enable(&TIMER_LED) in on_ble_evt cause the disconnection with mobile phone. If I remove this line, my application works as a normal ble_app_uart application at least. \r\nHowever when I enable it, the nrf UART app connects to the 51822 and disconnect automatically at the same time. But the LED on the dongle shows it is in a connected mode. \r\n\r\nCould anyone help me? Thanks in advance!",
    "tag": "timer"
  },
  {
    "text": "Best way to do high frequency writes to SPI - using ticker? I'm using the mbed platform and have been battling hard faults as I try to find the best way to write with high frequency to SPI to update a series of LEDs while still allowing for intermittent data to come in on BLE to change settings for the LEDs, (color, speed, etc). \r\n\r\nAfter quite a bit of experimentation I\u2019m doing this by setting up a ticker in the main loop of the program which consistently calls the LEDupdate function that sends LED data via SPI. In my BLE onDataWrittenCallback the very first line uses a pointer to my ticker to disable the ticker. Then I parse the data written, put it in the correct spots so that it can change whatever LED settings it needs to change and set a flag that my ticker needs to be turned back on. Once I hit the main BLE wait loop again the ticker is re attached, the ticker flag is set to false since the ticker is now active and my LEDs resume updating.\r\n\r\nThe issue at first was that if I had my ticker on too short an interval then trying to write to the BLE would hard fault the chip.  By making the ticker a longer interval I was able to get things to stabilize, but I would have thought there would be no default since the ticker isnt turned back on until the data has been processed.  \r\n\r\n\u2022 My question then is whether this is the best approach to writing at high frequency to the SPI?\r\n\r\n\u2022 Furthermore, are the hard faults because when I restart my ticker the soft device is not quite done doing what it needs to do behind the scenes after receiving data and so my ticker is bumping into the soft device?\r\n\r\nAlong those lines I had a relatively stable implementation of this setup working but then I added another characteristic to my service and it caused the chip to lock after receiving data via BLE.  After many tests I was able to solve this by making the ticker interval much slower.  To me this is strange, the new characteristic is never referenced or written too, just initialized, but still it seems to be slowing down how quickly the soft device finishes its work after getting data and forces me to slow my ticker.  Additionally writing one byte to the BLE device or writing a full 20 bytes didn't seem to make any difference to locking the chip up, while simply having the extra characteristic made a big difference.\r\n\r\nHere is the simple code I'm using\r\n\r\n    void onDataWrittenCallback(const GattWriteCallbackParams *params) {\r\n    \r\n    ptrTicker->detach();\r\n    \r\n    if (params->handle == ledServicePtr->getColorHandle()) {\r\n        currentSettings.color[0].r = params->data[0];\r\n        currentSettings.color[0].g = params->data[1];\r\n        currentSettings.color[0].b = params->data[2];\r\n    } else if (params->handle == ledServicePtr->getColorRawHandle()) {\r\n        currentSettings.color[0].r = params->data[0];\r\n        currentSettings.color[0].g = params->data[1];\r\n        currentSettings.color[0].b = params->data[2];    \r\n    }\r\n    OLEDdirty = true; \r\n    TICKERdirty = true;}\r\n\r\n\r\n\r\n    Ticker ticker;\r\n    ptrTicker = &ticker;     \r\n   \r\n    while (true) {\r\n        if (OLEDdirty) {redrawOled();}\r\n        if (LEDdirty) {\r\n            LEDdirty = false;\r\n            LEDs.update();\r\n            }\r\n        if (TICKERdirty) {    \r\n             TICKERdirty = false;\r\n             ticker.attach_us(LEDupdate, 8000);  //8ms ticker\r\n           }  \r\n        ble.waitForEvent();\r\n    }}\r\n\r\nA couple weird formatting issues with the code embed but this is the gist of it, I can get it to be stable but when I am right on the edge of too short a ticker interval I'll lock up after a couple writes.  I'll report back if I get any traction on the mbed forum or if I discover a solution.",
    "tag": "spi"
  },
  {
    "text": "ADC HAL power management Our chip seems to be running at ~500uA and I'm trying to narrow it down.\r\n\r\nI'm doing periodic battery level checks on a timer using the ADC HAL.  So at init I call nrf_adc_configure() and then in the timeout handler call nrf_adc_convert_single().  Doc for nrf_adc_convert_single says it puts ADC in STOP state.  Is that sufficient or do I need to disable it also?",
    "tag": "adc"
  },
  {
    "text": "PWM documentation Hello.\r\nWhere's the documentation for PWM? I've seen poeople using \"app_pwm\" whatever that is but I wasn't able to find any information on it.\r\n\r\nThanks",
    "tag": "pwm"
  },
  {
    "text": "nrf51 to nrf52 issues I'm trying to compile a project I have for nrf51 on nrf52. I am running into errors with macros not being set.\r\n\r\nFor example:\r\nerror:  #20: identifier \"ADC_CONFIG_RES_10bit\" is undefined\r\nerror:  #20: identifier \"ADC_CONFIG_RES_Pos\" is undefined\r\nerror:  #20: identifier \"ADC_CONFIG_PSEL_Disabled\" is undefined\r\n\r\n\r\nI also have this issue:\r\nerror:  #20: identifier \"ble_gap_enable_params_t\" is undefined\r\nerror:  #136: struct \"<unnamed>\" has no field \"gap_enable_params\"",
    "tag": "adc"
  },
  {
    "text": "NRF51822 Print Issue Hi,\r\nHere is the piece of code that is bugging me. \r\nThe code algo is at every 500ms timer2 interrupts, and the adc captures 1500 samples and stores it in an array .I always have to stop the timer2 for printing and calculations and then start when it is done.\r\nHere newsamples is array; datatype is float and \"ts\" is integer defined as 1500 and IDE used is KEIL uVision 5.0.\r\n\r\nKINDLY VERIFY WHAT IS THE PROBLEM AND HAVE I ENABLED/DISABLED TIMER2 INTERRUPTS CORRECTLY?\r\n\r\nThe following is the timer2 configuration\r\n\r\n    void start_timer(void)\r\n    {\t\t\r\n      NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;  // Set the timer in Counter Mode\r\n      NRF_TIMER2->TASKS_CLEAR = 1;               // clear the task first to be usable for later\r\n    \tNRF_TIMER2->PRESCALER = 8;                             //Set prescaler. \r\n    \tNRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\t\t //Set counter to 16 bit resolution\r\n    \tNRF_TIMER2->CC[0] = 31250;                             //Set value for TIMER2 compare register 0\r\n    \t\t\r\n      // Enable interrupt on Timer 2, both for CC[0] and CC[1] compare match events\r\n    \tNRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos)\t;\r\n    \t//| (TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos);\r\n      NVIC_EnableIRQ(TIMER2_IRQn);\r\n    \tNRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos) & TIMER_SHORTS_COMPARE0_CLEAR_Msk;\t\r\n      NRF_TIMER2->TASKS_START = 1;               // Start TIMER2\r\n    }\r\n\r\n\r\nFollowing is timer2 IRQ\r\n\r\n\r\n    void TIMER2_IRQHandler(void)\r\n    {\r\n    \tif(NRF_TIMER2->EVENTS_COMPARE[0])\r\n        {\r\n    \t\t\tNRF_TIMER2->EVENTS_COMPARE[0] = 0;           //Clear compare register 0 event\t\r\n    \t\t\t\t  \r\n    \t\t\tnrf_adc_conversion_event_clean();\r\n    \t\t\t\r\n    \t\t\ti=0;\r\n    \t\t\tif(send==0)\r\n    \t\t\t{\t\t\r\n    \t\t\t\twhile(i < ts)\r\n    \t\t\t\t{\r\n    \t\t\t\t\tadc_sample = nrf_adc_result_get();\r\n    \t\t\t\t\tnrf_delay_us(10);\r\n    \t\t\t\t\tnewsamples[i]=adc_sample;\r\n    \t\t\t\t\ti++;\r\n    \t\t\t\t}\r\n    \t\t\t\tif(i >= ts)\r\n    \t\t\t\t{\r\n    \t\t\t\t\tsend=1; \t//States samples are captured\r\n    \t\t\t\t}\t\r\n    \t\t\t}\t\t\r\n    \t\t\t// trigger next ADC conversion\r\n    \t\t\tnrf_adc_start();\r\n    \t\t\t\r\n    \t}\r\n    }\r\n\r\n\r\nFollowing is the Main loop\r\n\r\n    while (true)\r\n    {\r\n    \t\t\tif (send==1)\r\n    \t\t\t{\r\n    \t\t\t\t//Stop Timer2 to do calculations\r\n    \t\t\t\t NRF_TIMER2->TASKS_STOP = 1;\t  \r\n    \t\t\t\t//PASSING ARRAY OF DATA TO \tLPF FILTER\t\r\n    \t\t\t\tfilter(newsamples,ts);      \r\n    \t\t\t\t//NVIC_DisableIRQ(ADC_IRQn);\r\n    \t\t\t\t\r\n    \t\t\t\tprintf(\"Going in While\\n\\r\");\r\n    \t\t\t\twhile(j <ts)\r\n    \t\t\t\t{ \t\r\n    \t\t\t\t\t//printf(\"S: %06.0f , %d\\r\\n\",newsamples[j],j);\r\n    \t\t\t\t\tnewsamples[j]*=newsamples[j];      //Squaring each datapoint\r\n    \t\t\t\t\taccval+=newsamples[j];             //Adding squared values \r\n    \t\t\t\t\tj++;\r\n    \t\t\t\t\t}      printf(\"Going out of while\\n\\r\"); send=0;j=0; NRF_TIMER2->TASKS_START = 1;   \r\n    \t\t\t }\r\n\r\nIt does not print all the newsamples values and instead prints garbage after 15th value and doesnt show the statement \"Going out of while\".\r\nHere is the output \r\n[while1.png](/attachment/8da80afcb9267929878c8bd8efa433e1)\r\n\r\nBut when I don't print newsamples it shows both the statements.\r\n\r\n[while2.png](/attachment/7c34a32ba8964b991db74a8505e672f0)\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Running out of scheduler's queue size with app_timer I've been experiencing this bug for a while now. What happens is that a app_timer's overflow handler can't put any more messages into the queue because the queue is full, which is surprising considering my queue size is 15.\r\n\r\nI run two userspace timers using the app_timer module.\r\n\r\nThis is the function call order:\r\n\r\n\ttimeout_handler_exec() -> app_timer_evt_schedule() -> app_sched_event_put() -> app_sched_queue_full() == true -> next_index(index) == m_queue_size == 15\r\n\r\nMy `APP_TIMER_OP_QUEUE_SIZE` is 5 (not sure if this one matters), `SCHED_QUEUE_SIZE` is 15.\r\n\r\nNow I'm just hoping that someone has run into this issue and solved it because I know that my explanation is lacking.",
    "tag": "timer"
  },
  {
    "text": "spi clock problem Hi,\r\n\r\nI'm trying to use winbond spi flash (w25q64fv)\r\n\r\nbut i have a problem with spi as you can see in below image clock stop before receiving data from spi flash, do you have any idea why???\r\n\r\n![image description](/attachment/557db7dd3be91a9d5065f422ef705f64)\r\n\r\nhere is what should i see based on datasheet\r\n\r\n![image description](/attachment/c3696540337749fd786a8d3c2f908ab8)\r\n\r\n\r\nhere is my code for spi_master_init()\r\n\r\n    static void spi_master_init()\r\n    {\r\n        uint32_t err_code = NRF_SUCCESS;\r\n    \r\n        // Configure SPI master.\r\n        spi_master_config_t spi_config = SPI_MASTER_INIT_DEFAULT;\r\n    \r\n    \tspi_config.SPI_Pin_SCK  \t= SPIM0_SCK_PIN;\r\n    \tspi_config.SPI_Pin_MISO \t= SPIM0_MISO_PIN;\r\n    \tspi_config.SPI_Pin_MOSI \t= SPIM0_MOSI_PIN;\r\n    \tspi_config.SPI_Pin_SS   \t= SPIM0_SS_PIN;\r\n    \r\n    \tspi_config.SPI_CONFIG_CPHA\t= SPI_CONFIG_CPHA_Leading;\r\n    \tspi_config.SPI_CONFIG_CPOL\t= SPI_CONFIG_CPOL_ActiveHigh;\r\n    \t\r\n    \tspi_config.SPI_Freq\t\t\t= SPI_FREQUENCY_FREQUENCY_K500;\r\n    \t\r\n        spi_config.SPI_CONFIG_ORDER = SPI_CONFIG_ORDER_MsbFirst;\r\n    \t\r\n        err_code = spi_master_open(SPI_MASTER_0, &spi_config);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // Register event handler for SPI master.\r\n        spi_master_evt_handler_reg(SPI_MASTER_0, spi_master_0_event_handler);\r\n    }\r\n\r\n    void spi_master_0_event_handler(spi_master_evt_t spi_master_evt)\r\n    {\r\n    \t// nothing\r\n    }\r\n\r\n\r\nAnd here is my code for reading Status Register 1 (w25q64fv)\r\n\r\n    uint8_t readSR1() \r\n    { \r\n    \tuint8_t rx_data = 0x00;\r\n    \tuint8_t tx_data[2] = {0x05, 0xff};\r\n    \t\r\n    \tspi_master_send_recv(SPI_MASTER_0, tx_data, 2, &rx_data, 1);\r\n    \t\r\n        return rx_data;\r\n    }",
    "tag": "spi"
  },
  {
    "text": "nrf 51 spi master i've got problem with spi master connection, im trying to set leds via SPI on DWM1000 module, i've checked through advertising that spi_master_send_recv() sends correct values, however when i try to read all registers contain zeros, any idea why?\r\n\r\n(sorry for my bad english)",
    "tag": "spi"
  },
  {
    "text": "I should how to transplant the official DMP mpu6050 library to nrf51822 ? hi,\r\n   I should how to transplant the official DMP mpu6050 library to nrf51822 above?I don't know how to transplant it and could you tell me how to transplant it?",
    "tag": "twi"
  },
  {
    "text": "Is it possible to make 5 PWM outputs on NRF51422 (or NRF51822)? I know that it is possible to make 4 PWM outputs, but I need to generate 5. I will be using SoftDevice 110 and BLE. Is there any possible way to generate a 5th PWM output?\r\n\r\nAny advice would be much appreciated.",
    "tag": "pwm"
  },
  {
    "text": "ADXL 345 Tutorial Hello all, this tutorial goes to a fellow named Emil who helped me with this project.\r\n\r\nNumber 1_ Make sure you set up the terminal viewer For debugging with real.You need it to see the values coming outta your ADXL 345 chip  in the case you don't have an osciliscope or a Logical unit.  Click [here](https://devzone.nordicsemi.com/tutorials/6/debugging-with-real-time-terminal/) \r\n\r\nNumber 2_ How does the ADXL 345 work?\r\nADXL 345 [datasheet](https://www.sparkfun.com/datasheets/Sensors/Accelerometer/ADXL345.pdf) says there are two ways you could read x, y and z information from the registers. \r\nI call the first one \"serial mode\",  in which you send (0x80| 0x40 | 0x31) to the ADXL345's address 31 register and get a serial output from register's 32 (LSB of x axis), 33 (MSB of x axis), 34 (LSB of Y axis), 35 (MSB of Y axis), 36 (LSB of Z axis) and 37 (MSB of Z axis). \r\n\r\nMY RECOMMENDATION IS NOT TO USE THIS MODE IF YOU ARE USING PCA 1008 since the TX and RX buffer are two bytes only so the rest of the data send back from the serial mode will be lost as your TX and RX buffers get empty and full. \r\nMode 2 of operation is like [this](https://www.youtube.com/watch?v=Dc0a2TLm2_U)  :)  Basically you send in one byte of ((the read command)=0x80 | the address of the register you are interested in= let's say 32 which is for x LSB) + one byte of dummy data like 0x00, and get back two bytes from the accelerometer. ATTENTION (THE FIRST BYTE RECEIVED SHOULD BE IGNORED AND THE SECOND ONE SHOULD BE USED). but why? [SPI](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi) communication has one dedicated line (MOSI/ Master Out Slave In) for sending commands and a dedicated line for receiving informations from slave (MISO/ Master in Slave out); thus, while the master (nRF chip or a microelectronic) sends information it simotanesly receives information too. But what information is it receiving ? JUNK . Therfore we ignore the first byte received from the slave. Now, one might ask why do we send a dummy byte to the slave? Well, of you red the SPI communication you see that in order for any communcation to happen we need to activate the clock shared between the master and slave and by sending a dummy byte we make sure that the clock is active so that the slave could send the master its information. The one on left is the MOSI signal and the one on right is the mosi. Sorry its a bit missy its just for you to get a general idea. Do not compare the to pictures literally.  \r\n\r\n![image description](/attachment/8a2dd010d1d8f582d36809f6dcd8c8f6) ![image description](/attachment/cdb200096616ca3cdd78b82148680dc2)\r\n\r\n\r\n\r\nNow that you know these lets get to the coding. First, Take a look at this from Spark Fun as the code they have (not the advanced) for the arduino gives you an idea of how stuff work in general. Do not try to get everything at once as it needs time to soak in to mind :) so good luck.\r\n\r\nWhen it come to ADXL 345 codding you should configure the SPI_MASTER_INIT_DEFAULT under the spi_master.h header file like this:\r\n\r\n    #define SPI_MASTER_INIT_DEFAULT                                             \\\r\n    {                                                                           \\\r\n        SPI_FREQUENCY_FREQUENCY_M4, /**< Serial clock frequency 1 Mbps. */      \\\r\n        SPI_PIN_DISCONNECTED,       /**< SCK pin DISCONNECTED. */               \\\r\n        SPI_PIN_DISCONNECTED,       /**< MISO pin DISCONNECTED. */              \\\r\n        SPI_PIN_DISCONNECTED,       /**< MOSI pin DISCONNECTED. */              \\\r\n        SPI_PIN_DISCONNECTED,       /**< Slave select pin DISCONNECTED. */      \\\r\n        APP_IRQ_PRIORITY_LOW,       /**< Interrupt priority LOW. */             \\\r\n        SPI_CONFIG_ORDER_MsbFirst,   //or you could make it MsbFirst within your main function                  \\\r\n        SPI_CONFIG_CPOL_ActiveLow, \r\n        SPI_CONFIG_CPHA_TRAILING,           \r\n        0                           /**< Don't disable all IRQs. */             \\\r\n    };\r\n      \r\nOnce you have done that\r\n\r\n    uint8_t\ttx_DARA0={0x80 | 0x32};\r\n    uint8_t\ttx_DARA1={0x80 | 0x33};\r\n    uint8_t\ttx_DARA2={0x80 | 0x34};\r\n    uint8_t\ttx_DARA3={0x80 | 0x35};\r\n    uint8_t\ttx_DARA4={0x80 | 0x36};\r\n    uint8_t\ttx_DARA5={0x80 | 0x37};     \r\n             \r\n    switch (spi_master_instance)\r\n                    {\r\n                        \r\n                        case SPI_MASTER_0:\r\n                        {\r\n                \t\t\t\t\t spi_master_config_t spi_config0 = SPI_MASTER_INIT_DEFAULT;\r\n                \r\n                            spi_config0.SPI_Pin_SCK  = 4;\r\n                            spi_config0.SPI_Pin_MISO = 3;\r\n                            spi_config0.SPI_Pin_MOSI = 2;\r\n                            spi_config0.SPI_Pin_SS   = pinnum;\r\n                \t\t\t\t\t spi_config0.SPI_CONFIG_ORDER = (lsb ? SPI_CONFIG_ORDER_LsbFirst : SPI_CONFIG_ORDER_MsbFirst);\r\n                \r\n                    err_code = spi_master_open(spi_master_instance, &spi_config0);\r\n                    APP_ERROR_CHECK(err_code);\r\n                \r\n                        }\r\n                        break;\r\n                \r\n                ..........\r\n                          \r\n                    \r\n                    static inline uint8_t* Adxl362_SpiTransfer(uint8_t * const txBuffer, const uint16_t txBufferLength,\r\n                    \tuint8_t * const rxBuffer, const uint16_t rxBufferLength, uint8_t sub)\r\n                    {\t\r\n                    \twhile (_isTransferring)\r\n                    \tnrf_delay_ms(1);\r\n                    \r\n                    \tuint32_t result = spi_master_send_recv(SPI_MASTER_0, txBuffer, txBufferLength, rxBuffer, rxBufferLength);\r\n                    \tAPP_ERROR_CHECK(result);\r\n                    \t\r\n                    \tnrf_delay_ms(1);\r\n                    \treturn &_rec[sub];\r\n                    }\r\n               \r\n            .............     \r\n            \r\n            void main(){\r\n            \r\n            bsp_configuration();\r\n                          spi_master_init(SPI_MASTER_0, spi_master_0_event_handler, false,pin );\r\n                          spi_master_send_recv(SPI_MASTER_0, Powermode_Set, 2, m_rx_data_spi, 2);\r\n                          spi_master_send_recv(SPI_MASTER_0, Data_Format, 2, m_rx_data_spi, 2);\r\n            for(;;){\r\n            \r\n                    uint8_t num8[20]={0,0,0,0};\r\n                    _buf[0] = tx_DARA0;\r\n                    _buf[1] = 1;\r\n                    _buf[2] = tx_DARA1;\r\n                    _buf[3] = 2;\r\n                    _buf[4] = tx_DARA2;\r\n                    _buf[5] = 3;\r\n                    _buf[6] = tx_DARA3;\r\n                    _buf[7] = 4;\r\n                    _buf[8] = tx_DARA4;\r\n                    _buf[9] = 5;\r\n                    _buf[10] = tx_DARA5;\r\n                    _buf[11] = 6; \r\n                    \t\r\n                    \r\n                   _rec[0]=0;\r\n                   _rec[1]=0;\r\n                   _rec[2]=0;\r\n                  _rec[3]=0;\r\n                   _rec[4]=0;\r\n                   _rec[5]=0;\t\r\n                   _rec[6]=0;\r\n                   _rec[7]=0;\r\n                   _rec[8]=0;\r\n                   _rec[9]=0;\r\n                   _rec[10]=0;\r\n                   _rec[11]=0;\t\t\r\n                   \t\r\n                    \t\r\n                      pin=5;\r\n                    \t\t\r\n                      spi_master_init(SPI_MASTER_0, spi_master_0_event_handler, false,pin );\r\n                    \r\n                     uint8_t* x1=Adxl362_SpiTransfer(&_buf[0],2,\t&_rec[0],2,1);\r\n                     uint8_t* x2=Adxl362_SpiTransfer(&_buf[2],2,\t&_rec[2],2,3);\r\n                     uint8_t* y1=Adxl362_SpiTransfer(&_buf[4],2,\t&_rec[4],2,5);\r\n                     uint8_t* y2=Adxl362_SpiTransfer(&_buf[6],2,\t&_rec[6],2,7);\r\n                     uint8_t* z1=Adxl362_SpiTransfer(&_buf[8],2,\t&_rec[8],2, 9);           \r\n                     uint8_t* z2=Adxl362_SpiTransfer(&_buf[10],2,\t&_rec[10],2, 11);\t\r\n            }}\r\n        \r\n        Good Luck All.",
    "tag": "spi"
  },
  {
    "text": "ADXL 345 Tutorial Hello all, this tutorial goes to a fellow named Emil who helped me with this project.\r\n\r\nNumber 1_ Make sure you set up the terminal viewer For debugging with real.You need it to see the values coming outta your ADXL 345 chip  in the case you don't have an osciliscope or a Logical unit.  Click [here](https://devzone.nordicsemi.com/tutorials/6/debugging-with-real-time-terminal/) \r\n\r\nNumber 2_ How does the ADXL 345 work?\r\nADXL 345 [datasheet](https://www.sparkfun.com/datasheets/Sensors/Accelerometer/ADXL345.pdf) says there are two ways you could read x, y and z information from the register. \r\n1 I call it serial mode in which you send (0x80| 0x40 | 0x31) to the ADXL345's address 31 register and get a serial output from register's 32 (LSB of x axis), 33 (MSB of x axis), 34 (LSB of Y axis), 35 (MSB of Y axis), 36 (LSB of Z axis) and 37 (MSB of Z axis). \r\n\r\nMY RECOMMENDATION IS NOT TO USE THIS MODE IF YOU ARE USING PCA 1008 since the TX and RX buffer are two bytes only so the rest of the data send back from the serial mode will be lost as your TX and RX buffers get empty and full. \r\nMode 2 of operation is like [this](https://www.youtube.com/watch?v=Dc0a2TLm2_U)  :)  Basically you send in one byte of ((the read command)=0x80 | the address of the register you are interested in= let's say 32 which is for x LSB) + one byte of dummy data like 0x00, and get back two bytes from the accelerometer. ATTENTION (THE FIRST BYTE RECEIVED SHOULD BE IGNORED AND THE SECOND ONE SHOULD BE USED). but why? [SPI](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi) communication has one dedicated line (MOSI/ Master Out Slave In) for sending commands and a dedicated line for receiving informations from slave (MISO/ Master in Slave out); thus, while the master (nRF chip or a microelectronic) sends information it simotanesly receives information too. But what information is it receiving ? JUNK . Therfore we ignore the first byte received from the slave. Now, one might ask why do we send a dummy byte to the slave? Well, of you red the SPI communication you see that in order for any communcation to happen we need to activate the clock shared between the master and slave and by sending a dummy byte we make sure that the clock is active so that the slave could send the master its information. The one on left is the MOSI signal and the one on right is the mosi. Sorry its a bit missy its just for you to get a general idea. Do not compare the to pictures literally.  \r\n\r\n![image description](/attachment/8a2dd010d1d8f582d36809f6dcd8c8f6) ![image description](/attachment/cdb200096616ca3cdd78b82148680dc2)\r\n\r\n\r\n\r\nNow that you know these lets get to the coding. First, Take a look at this from Spark Fun as the code they have (not the advanced) for the arduino gives you an idea of how stuff work in general. Do not try to get everything at once as it needs time to soak in to mind :) so good luck.\r\n\r\nWhen it come to ADXL 345 codding you should configure the SPI_MASTER_INIT_DEFAULT like this:\r\n\r\n  \r\n\r\n              switch (spi_master_instance)\r\n                {\r\n                    \r\n                    case SPI_MASTER_0:\r\n                    {\r\n            \t\t\t\t\t spi_master_config_t spi_config0 = SPI_MASTER_INIT_DEFAULT;\r\n            \r\n                        spi_config0.SPI_Pin_SCK  = 4;\r\n                        spi_config0.SPI_Pin_MISO = 3;\r\n                        spi_config0.SPI_Pin_MOSI = 2;\r\n                        spi_config0.SPI_Pin_SS   = pinnum;\r\n            \t\t\t\t\t spi_config0.SPI_CONFIG_ORDER = (lsb ? SPI_CONFIG_ORDER_LsbFirst : SPI_CONFIG_ORDER_MsbFirst);\r\n            \r\n                err_code = spi_master_open(spi_master_instance, &spi_config0);\r\n                APP_ERROR_CHECK(err_code);\r\n            \r\n                    }\r\n                    break;\r\n            \r\n            ..........\r\n                      \r\n                \r\n                static inline uint8_t* Adxl362_SpiTransfer(uint8_t * const txBuffer, const uint16_t txBufferLength,\r\n                \tuint8_t * const rxBuffer, const uint16_t rxBufferLength, uint8_t sub)\r\n                {\t\r\n                \twhile (_isTransferring)\r\n                \tnrf_delay_ms(1);\r\n                \r\n                \tuint32_t result = spi_master_send_recv(SPI_MASTER_0, txBuffer, txBufferLength, rxBuffer, rxBufferLength);\r\n                \tAPP_ERROR_CHECK(result);\r\n                \t\r\n                \tnrf_delay_ms(1);\r\n                \treturn &_rec[sub];\r\n                }\r\n           \r\n        .............     \r\n        \r\n        void main(){\r\n        \r\n        bsp_configuration();\r\n                      spi_master_init(SPI_MASTER_0, spi_master_0_event_handler, false,pin );\r\n                      spi_master_send_recv(SPI_MASTER_0, Powermode_Set, 2, m_rx_data_spi, 2);\r\n                      spi_master_send_recv(SPI_MASTER_0, Data_Format, 2, m_rx_data_spi, 2);\r\n        for(;;){\r\n        \r\n                uint8_t num8[20]={0,0,0,0};\r\n                _buf[0] = tx_DARA0;\r\n                _buf[1] = 1;\r\n                _buf[2] = tx_DARA1;\r\n                _buf[3] = 2;\r\n                _buf[4] = tx_DARA2;\r\n                _buf[5] = 3;\r\n                _buf[6] = tx_DARA3;\r\n                _buf[7] = 4;\r\n                _buf[8] = tx_DARA4;\r\n                _buf[9] = 5;\r\n                _buf[10] = tx_DARA5;\r\n                _buf[11] = 6; \r\n                \t\r\n                \r\n    _rec[0]=0;\r\n                _rec[1]=0;\r\n                \t_rec[2]=0;\r\n                \t_rec[3]=0;\r\n                \t_rec[4]=0;\r\n                \t_rec[5]=0;\t\r\n                    _rec[6]=0;\r\n                \t_rec[7]=0;\r\n                \t_rec[8]=0;\r\n                \t_rec[9]=0;\r\n                \t_rec[10]=0;\r\n                \t_rec[11]=0;\t\t\r\n                \t\r\n                \t\r\n                  pin=5;\r\n                \t\t\r\n                  spi_master_init(SPI_MASTER_0, spi_master_0_event_handler, false,pin );\r\n                \r\n                  uint8_t* x1=Adxl362_SpiTransfer(&_buf[0],2,\t&_rec[0],2,1);\r\n                  uint8_t* x2=Adxl362_SpiTransfer(&_buf[2],2,\t&_rec[2],2,3);\r\n                  uint8_t* y1=Adxl362_SpiTransfer(&_buf[4],2,\t&_rec[4],2,5);\r\n                  uint8_t* y2=Adxl362_SpiTransfer(&_buf[6],2,\t&_rec[6],2,7);\r\n                  uint8_t* z1=Adxl362_SpiTransfer(&_buf[8],2,\t&_rec[8],2, 9);           \r\n                  uint8_t* z2=Adxl362_SpiTransfer(&_buf[10],2,\t&_rec[10],2, 11);\t\r\n        }}\r\n    \r\n    Good Luck All.",
    "tag": "spi"
  },
  {
    "text": "Led Flashing Hello,\r\n\r\nI want to use timer with my app. I want to make led on my beacon flash for 1 second when it recieves a value. How can i set timer to turn of led after 1 sec?\r\n\r\nI'm using dual mode example, with RTC timer.",
    "tag": "timer"
  },
  {
    "text": "nrf_drv_twi.c - many warnings about the order of volatile accesses is undefined     Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined in this statement C:\\Projects\\..\\lib\\nrf_drv_twi.c 273 \r\n\r\n\r\n21 the same warnings. No errors. I believe, I forgot to connect one of the headers? But which one?\r\n\r\nmain.c headers\r\n\r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    #include <stdio.h>\r\n    #include \"app_uart.h\"\r\n    #include \"app_error.h\"\r\n    #include \"nrf_delay.h\"\r\n    #include \"nrf.h\"\r\n    #include \"bsp.h\"\r\n    #include \"nordic_common.h\"\r\n    #include \"nrf_drv_twi.h\"\r\n\r\nlibs:\r\n![project .c files](/attachment/ab597f138c88265483f814e607a91be2)\r\n\r\nsoftdevice S210 are programmed.\r\n\r\nThanks for answers!",
    "tag": "twi"
  },
  {
    "text": "Connect nRF51822 with DWM1000 Hi, \r\nI'm trying to connect DWM1000 with SPI using spi_master.h.\r\nWhen I have written to registry e.g. 0x11, 0x12 and read it I've got bytes: 0xFF, 0x11.\r\nIf I read three bytes I've got 0xFF, 0x11, 0x12.\r\nWhen I connect with DWM1000 on Raspberry using wiringPi library it works great, and there isn't any byte 0xFF.\r\n\r\nCould be 0xFF some kind of DWM's header?\r\n\r\nTo write I'm using: \r\n\r\n    spi_master_send_recv(SPI_MASTER_0, tx_buffer, headerLength+bodyLength, NULL, 0);\r\n\r\nTo read: \r\n\r\n    spi_master_send_recv(SPI_MASTER_0, tx_buffer, headerLength, rx_buffer, readLength);\r\n\r\nTo make header I'm using function given by DecaWave.\r\nMy settings of SPI:\r\n\r\n    config.SPI_Pin_SCK = (uint32_t) SPI_SCK; // 24\r\n    config.SPI_Pin_MISO = (uint32_t) SPI_MISO; // 23\r\n    config.SPI_Pin_MOSI = (uint32_t) SPI_MOSI; // 22\r\n    config.SPI_Pin_SS = (uint32_t) SPI_SS; // 21\r\n    config.SPI_Freq = SPI_FREQUENCY_FREQUENCY_M2;\r\n    config.SPI_CONFIG_ORDER =  SPI_CONFIG_ORDER_MsbFirst;\r\n    config.SPI_CONFIG_CPOL = SPI_CONFIG_CPOL_ActiveHigh;\r\n    config.SPI_CONFIG_CPHA = SPI_CONFIG_CPHA_Leading;\r\n    config.SPI_DisableAllIRQ = 1;\r\n    config.SPI_PriorityIRQ = 1;",
    "tag": "spi"
  },
  {
    "text": "Change in GPIO to start/stop timer and fire interrupt Hello all,\r\n\r\nThis is my first post to the developer zone.\r\n\r\nI'm creating a product using RFduino, which uses the nRF51822 chip for Bluetooth LE. (See http://www.rfduino.com/wp-content/uploads/2014/03/rfduino.datasheet.pdf )\r\n\r\nI'm an iOS developer with some legacy assembler experience but no experience programming the nRF51822 chip, so I apologize for the simple questions but would appreciate some guidance in finding a solution or at least where to find the documentation that would help me learn.\r\n\r\nThe product I'm developing measures the speed of a moving object and sends the result to an iOS app via Bluetooth LE for display and analysis . The object is 11 inches in diameter and it passes through a laser beam that is aimed at a phototransistor that is connected to a GPIO pin on the RFduino. I need to be able to accurately measure the time that the object breaks the beam and then calculate the speed as the distance travelled (the diameter of the object, 11 inches) divided by the time (the duration the beam was broken).\r\n\r\nMy current implementation is not accurate and, therefore, unacceptable. The RFduino provides the Arduino IDE for programming the chip. My loop routine basically watches for the phototransistor GPIO analog value to drop below a threshold value (i.e. laser beam is broken), saves the current time when it does, then watches for the value to rise above the threshold value (i.e. laser beam restored) and, again, save the current time. The duration the beam was broken is calculated as endTime - startTime and the speed is then calculated as 11 inches divided by the duration. Typical durations range from 75-250 milliseconds. My code looks something like this:\r\n\r\n    void loop() {\r\n    \t\r\n    \tcurrentPhototransistorValue = analogRead(photoResistorPin);\r\n    \t\r\n    \tif (currentPhototransistorValue < thresholdValue && beamCurrentlyOn == 1) {\r\n    \t\t\r\n    \t\tstartTime = millis();\r\n    \t\tbeamCurrentlyOn = 0;\r\n    \r\n    \t} else if (currentPhototransistorValue > thresholdValue && beamCurrentlyOn == 0) {\r\n    \t\t\r\n    \t\tendTime = millis();\r\n    \t\tbeamCurrentlyOn = 1;\r\n    \t\t\r\n    \t\tunsigned long duration = endTime - startTime;\r\n    \t\t\r\n    \t\tfloat speed = 11.0 / duration;\r\n    \r\n    \t\t// Send speed to iOS app ...\r\n    \r\n    \t}\r\n    \r\n    }\r\n\r\nThe problem is that the duration, as measured by the above method, is not accurate because the BT radio can pre-empt my loop and at random cause a 5 ms or so hiccup. This is unacceptable for my application.\r\n\r\nI'm hopeful that a viable solution is to use timer2 of the chip to do the timing. I've looked at some examples here and on the RFduino forum that show how to use the timers, but they all just program the timer to fire at a precise interval. For example, the code below calls the interrupt routine TIMER2_Interrupt every 500 milliseconds.\r\n\r\n      NRF_TIMER2->TASKS_STOP = 1;\t// Stop timer\r\n      NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;  // taken from Nordic dev zone\r\n      NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n      NRF_TIMER2->PRESCALER = 9;\t// 32us resolution\r\n      NRF_TIMER2->TASKS_CLEAR = 1; // Clear timer\r\n      // With 32 us ticks, we need to multiply by 31.25 to get milliseconds\r\n      NRF_TIMER2->CC[0] = 500 * 31; // 500 is milliseconds to fire interrupt\r\n      NRF_TIMER2->CC[0] += 500 / 4;  // 500 is milliseconds to fire interrupt\r\n      NRF_TIMER2->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;  // taken from Nordic dev zone\r\n      NRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\r\n      attachInterrupt(TIMER2_IRQn, TIMER2_Interrupt);    // also used in variant.cpp to configure the RTC1 \r\n      NRF_TIMER2->TASKS_START = 1;\t// Start TIMER\r\n\r\nSo I'm trying to determine whether or not the following is possible, and if it is, if it will be more accurate than my current implementation.\r\n\r\nI need to program timer2 to start when the phototransistor GPIO pin value transitions down past a threshold value, then stop when the pin value transitions up past the threshold value. Then the code needs to call an interrupt in my sketch (like the above sample calls TIMER2_interrupt).  Then my interrupt routine (TIMER2_interrupt) needs to read the timer value to get the duration that the beam was broken, then reset the timer to wait for the next transition down of the GPIO pin value.\r\n\r\nIf this is all possible, could I expect greater precision compared to my current approach? Plus/minus 1 ms for measuring the duration would be acceptable accuracy.\r\n\r\nIf this is possible, I need to learn how to:\r\n\r\n- start and stop a timer based on the change of the analog value of a GPIO pin\r\n- read the current timer value\r\n- reset the timer to wait for the next drop in GPIO pin value\r\n\r\nI would be delighted if this is relatively simple and someone could just show me the code. Otherwise I'm happy to learn by reading the appropriate documentation. Note that I don't have the nRF51822 development kit so I don't have access to the resources (documentation and otherwise) that comes with the purchase of the kit.\r\n\r\nWhew ... I hope this is a reasonable and clear question. I appreciate your understanding that I'm new to this.\r\n\r\nMany thanks to anyone who can offer me some help.\r\n\r\nTim\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "Change in GPIO to start/stop timer and fire interrupt Hello all,\r\n\r\nThis is my first post to the developer zone.\r\n\r\nI'm creating a product using RFduino, which uses the nRF51822 chip for Bluetooth LE. (See http://www.rfduino.com/wp-content/uploads/2014/03/rfduino.datasheet.pdf )\r\n\r\nI'm an iOS developer with some legacy assembler experience but no experience programming the nRF51822 chip, so I apologize for the simple questions but would appreciate some guidance in finding a solution or at least where to find the documentation that would help me learn.\r\n\r\nThe product I'm developing measures the speed of a moving object and sends the result to an iOS app via Bluetooth LE for display and analysis . The object is 11 inches in diameter and it passes through a laser beam that is aimed at a phototransistor that is connected to a GPIO pin on the RFduino. I need to be able to accurately measure the time that the object breaks the beam and then calculate the speed as the distance travelled (the diameter of the object, 11 inches) divided by the time (the duration the beam was broken).\r\n\r\nMy current implementation is not accurate and, therefore, unacceptable. The RFduino provides the Arduino IDE for programming the chip. My loop routine basically watches for the phototransistor GPIO analog value to drop below a threshold value (i.e. laser beam is broken), saves the current time when it does, then watches for the value to rise above the threshold value (i.e. laser beam restored) and, again, save the current time. The duration the beam was broken is calculated as endTime - startTime and the speed is then calculated as 11 inches divided by the duration. Typical durations range from 75-250 milliseconds. My code looks something like this:\r\n\r\n    void loop() {\r\n    \t\r\n    \tcurrentPhototransistorValue = analogRead(photoResistorPin);\r\n    \t\r\n    \tif (currentPhototransistorValue < thresholdValue && beamCurrentlyOn == 1) {\r\n    \t\t\r\n    \t\tstartTime = millis();\r\n    \t\tbeamCurrentlyOn = 0;\r\n    \r\n    \t} else if (currentPhototransistorValue > thresholdValue && beamCurrentlyOn == 0) {\r\n    \t\t\r\n    \t\tendTime = millis();\r\n    \t\tbeamCurrentlyOn = 1;\r\n    \t\t\r\n    \t\tunsigned long duration = endTime - startTime;\r\n    \t\t\r\n    \t\tfloat speed = 11.0 / duration;\r\n    \r\n    \t\t// Send speed to iOS app ...\r\n    \r\n    \t}\r\n    \r\n    }\r\n\r\nThe problem is that the duration, as measured by the above method, is not accurate because the BT radio can pre-empt my loop and at random cause a 5 ms or so hiccup. This is unacceptable for my application.\r\n\r\nI'm hopeful that a viable solution is to use timer2 of the chip to do the timing. I've looked at some examples here and on the RFduino forum that show how to use the timers, but they all just program the timer to fire at a precise interval. For example, the code below calls the interrupt routine TIMER2_Interrupt every 500 milliseconds.\r\n\r\n      NRF_TIMER2->TASKS_STOP = 1;\t// Stop timer\r\n      NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;  // taken from Nordic dev zone\r\n      NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n      NRF_TIMER2->PRESCALER = 9;\t// 32us resolution\r\n      NRF_TIMER2->TASKS_CLEAR = 1; // Clear timer\r\n      // With 32 us ticks, we need to multiply by 31.25 to get milliseconds\r\n      NRF_TIMER2->CC[0] = 500 * 31; // 500 is milliseconds to fire interrupt\r\n      NRF_TIMER2->CC[0] += 500 / 4;  // 500 is milliseconds to fire interrupt\r\n      NRF_TIMER2->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;  // taken from Nordic dev zone\r\n      NRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\r\n      attachInterrupt(TIMER2_IRQn, TIMER2_Interrupt);    // also used in variant.cpp to configure the RTC1 \r\n      NRF_TIMER2->TASKS_START = 1;\t// Start TIMER\r\n\r\nSo I'm trying to determine whether or not the following is possible, and if it is, if it will be more accurate than my current implementation.\r\n\r\nI need to program timer2 to start when the phototransistor GPIO pin value transitions down past a threshold value, then stop when the pin value transitions up past the threshold value. Then the code needs to call an interrupt in my sketch (like the above sample calls TIMER2_interrupt).  Then my interrupt routine (TIMER2_interrupt) needs to read the timer value to get the duration that the beam was broken, then reset the timer to wait for the next transition down of the GPIO pin value.\r\n\r\nIf this is all possible, could I expect greater precision compared to my current approach? Plus/minus 1 ms for measuring the duration would be acceptable accuracy.\r\n\r\nIf this is possible, I need to learn how to:\r\n\r\n- start and stop a timer based on the change of the analog value of a GPIO pin\r\n- read the current timer value\r\n- reset the timer to wait for the next drop in GPIO pin value\r\n\r\nI would be delighted if this is relatively simple and someone could just show me the code. Otherwise I'm happy to learn by reading the appropriate documentation. Note that I don't have the nRF51822 development kit so I don't have access to the resources (documentation and otherwise) that comes with the purchase of the kit.\r\n\r\nWhew ... I hope this is a reasonable and clear question. I appreciate your understanding that I'm new to this.\r\n\r\nMany thanks to anyone who can offer me some help.\r\n\r\nTim\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Why doesn't twi_master_init(); reconfigure GPIO pins? Keil uV5, nRF51822, TWI hardware version\r\nI'm trying to use twi_hw_master.c and I have made one simple change to define the CLOCK and DATA pins to  1U and 2U for my target board (vs 24U and 25U as defined in twi_master_config.h but using Keil uV5 debugging, I can see that those GPIO pins were not programmed at all, when I call twi_master_init();\r\n\r\nInstead of #include \"twi_master_config.h\" I pasted the definitions in-line into my main.c file.\r\n\r\n    #ifndef TWI_MASTER_CONFIG\r\n    #define TWI_MASTER_CONFIG\r\n    #define TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER (1U)\r\n    #define TWI_MASTER_CONFIG_DATA_PIN_NUMBER (2U)\r\n    #endif\r\n\r\nI'm trying to modify existing Example code from the SDK for a quick  'proof of concept' demonstration.\r\nThank you. \r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "What AIN is sampled when nrf_adc_input_select() is NOT called? In [this ADC example from Nordic](https://github.com/NordicSemiconductor/nrf51-ADC-examples/blob/master/rtc0-triggering-adc-sample/main.c) on GitHub, it does not appear an AIN has been selected (e.g.: no call to nrf_adc_input_select() ).  I don't understand.  I have been assuming the AIN is selected, then samples are read in.  How does this actually work?  When the AIN is selected and when it is not?",
    "tag": "adc"
  },
  {
    "text": "Interrupt from timer2 at  0.5 ms using Softdevice Hi,I have need to set TIMER2 interrupt at high priority because I need a interrupt  at   0.5ms.\r\nThis interrupt must  comes while Softdevice is enable and my device(nrf51822 beacon) is  connect with NRF51822 dongle.I set timer period right,and  timer2 function ok if I dont't have another interrupts.\r\nI have tried with NVIC_SetPriority(TIMER2_IRQn, 1),but don't work.Interrup comes at 0.5 ms but sometimes comes at 2-3 ms.\r\nHow can I fix that interrupt to come at  0.5ms?\r\n",
    "tag": "interrupt"
  },
  {
    "text": "disable interrupts and enable interrupts if they where enabled Hello,\r\n\r\nI'm not sure if this was already asked before. I didn\u2019t found a similar question, so here it is: When I have a function that manipulates a data structure to communicate with an interrupt service routine and if that manipulation can not be done atomically, an usual approach is to disable all interrupts, do the manipulation and enable all interrupts again (`__disable_irq(); manipulation(); __enable_irq() ).\r\n\r\nThe problem with this approach is that it would enable interrupts, if interrupts where already disabled. Is there a disable function, that returns the previous irq disable status?\r\n\r\n    bool was_enabled = __disable_irq();\r\n    manipulation();\r\n    if ( was_enabled )\r\n        __enable_irq();\r\n\r\nI don\u2019t ask this in the context of a soft device. I\u2019m aware that disabling interrupts is not reasonable, when using one of the soft devices.\r\n\r\nCheers,\r\nTorsten",
    "tag": "interrupt"
  },
  {
    "text": "How to enable and disable peripheral like twi to save power? Now with the twi_hw_master.c with softdevice, I enable the twi on the start of twi_master_transfer and disable it at the end of twi_master_transfer, but I found the twi can not transfer data correctly sometime.",
    "tag": "twi"
  },
  {
    "text": "real-time task :: sample ADC and store at close to maximal 50khz Hello, I've searched the forum for information regarding handling real-time tasks with the nrf51822.  I've found this post -- https://devzone.nordicsemi.com/question/574/supporting-a-real-time-task/ -- which is similar to my situation.\r\n\r\nI'm analyzing a real time process which requires me to sample analog voltages at 40khz.  The logical way to go about this is to sample the ADC ( 20us conversion at 8 bit ) and save the value using DMA (direct memory access).  This process can start at any time, and doesn't need to last more than 1ms, but it's absolutely critical that the real-time nature is not interrupted by anything during this time.\r\n\r\nWhat are the best practices here?\r\n\r\nIf ADC and DMA is the **only** thing that i'm doing during this time frame do I need to be generating interrupts with an RTC to trigger or is there something simpler?  Are there any benchmark implementations validating the maximum rate at which the nRF51822 can fill a buffer using the ADC?\r\n\r\nThanks",
    "tag": "adc"
  },
  {
    "text": "Is it a bug in app_pwm.c? Hi, as I tried out the example code for PWM in SDK 9, it didn't worked for me. A closer look showed that in method app_pwm_init the method app_pwm_channel_duty_ticks_set will be called before initialization is completed. This will fail because the latter method checks for p_cb->state != NRF_DRV_STATE_POWERED_ON which will be set by app_pwm_enable. But this must be called after initialization. If you comment this check, the ready_callback function will be called, which at this time is not yet initialized and therefore crashes. This leads to the conclusion, that the early call of app_pwm_channel_duty_ticks_set during initialization might be unwanted.",
    "tag": "pwm"
  },
  {
    "text": "NRF51822 Interrupt Service Routine handling Hello,\r\nI was using wiringPiSPI() to connect via SPI and so i was using wiringPiISR function to create an interupt handler that will do callback to the user suplied function. Now I moved to module with NRF architecture. How can I handle interuptions the way i was doing it on the Raspberry PI? I'm using spi_master.h to connect via SPI. Is there any ready to use ISR handle the way it was made on Raspberry?",
    "tag": "spi"
  },
  {
    "text": "NRF51822 Interrupt Service Routine handling Hello,\r\nI was using wiringPiSPI() to connect via SPI and so i was using wiringPiISR function to create an interupt handler that will do callback to the user suplied function. Now I moved to module with NRF architecture. How can I handle interuptions the way i was doing it on the Raspberry PI? I'm using spi_master.h to connect via SPI. Is there any ready to use ISR handle the way it was made on Raspberry?",
    "tag": "interrupt"
  },
  {
    "text": "spi_master causing Hard_fault() So I'm using the spi_master.c from SDK 6.1 to communicate with an LCD driver. I'm using an nrf51822 with s110 softdevice. My system has been sporadically hardfaulting on me. I've traced the hard_fault to the spi_master.c driver. Specifically the function spi_master_send_recv(). The fault occurs when the function tries to execute this line\r\n\r\n//Disable interrupt SPI.\r\n        \r\nAPP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type));\r\n\r\nbelow I've attached a screen shot of the register values while inside the HardFault_Handler().\r\n\r\n![image description](/attachment/61f975c72b2d923b7d013e3777ee318c)\r\n\r\nI'm not certain if this is relevent however they could be linked so I figured I should mention it.I just tried to erase and reprogram the softdevice using nrfgoStudio and now I am having a fault generated by the following line in softdevice_handler.c\r\n\r\n        // Initialize SoftDevice.\r\n    err_code = sd_softdevice_enable(clock_source, softdevice_assertion_handler);\r\n\r\nThe fault is triggered via a call to the app_error_handler() function which only contains a call to NVIC_SystemReset(). Below are the register values while inside app_error_handler()\r\n\r\n![image description](/attachment/dcde0476248496ce7b9d629ef5fe7dbc)\r\n\r\n\r\nI'm not sure how to overcome these issues and would really appreciate any suggestions on overcoming them.\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "spi_master causing Hard_fault() So I'm using the spi_master.c from SDK 6.1 to communicate with an LCD driver. I'm using an nrf51822 with s110 softdevice. My system has been sporadically hardfaulting on me. I've traced the hard_fault to the spi_master.c driver. Specifically the function spi_master_send_recv(). The fault occurs when the function tries to execute this line\r\n\r\n//Disable interrupt SPI.\r\n        \r\nAPP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type));\r\n\r\nbelow I've attached a screen shot of the register values while inside the HardFault_Handler().\r\n\r\n![image description](/attachment/61f975c72b2d923b7d013e3777ee318c)\r\n\r\nI'm not certain if this is relevent however they could be linked so I figured I should mention it.I just tried to erase and reprogram the softdevice using nrfgoStudio and now I am having a fault generated by the following line in softdevice_handler.c\r\n\r\n        // Initialize SoftDevice.\r\n    err_code = sd_softdevice_enable(clock_source, softdevice_assertion_handler);\r\n\r\nThe fault is triggered via a call to the app_error_handler() function which only contains a call to NVIC_SystemReset(). Below are the register values while inside app_error_handler()\r\n\r\n![image description](/attachment/dcde0476248496ce7b9d629ef5fe7dbc)\r\n\r\n\r\nI'm not sure how to overcome these issues and would really appreciate any suggestions on overcoming them.\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "How to make Nrf51822 wake up by button, increment variable then sleep I've just started working with Nrf51822, I'm trying to make this scenario for weeks but i failed.\r\n\r\nPlz help me!\r\n\r\nHow to make Nrf51822 wake up by a button click, increment a variable then go back to sleep?\r\ni've tested  __WFI()  and __WFE() but it doesnt work.\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Temperature coefficient of ADC in nRF51822 I am wondering where I can find the temperature dependent behavior of the ADCs on nRF51822. I observe the ADC readings vary noticeably even when the die temperature reading shows difference of only 4 degree Celsius. I am trying to figure out whether the variation is from nRF51822 itself or external circuit, assuming that the die temperature reading is accurate enough. Knowing the temperature behavior of ADC (such as the reference voltage) can be very useful. ",
    "tag": "adc"
  },
  {
    "text": "ADC read is not completeing I'm working with an nrf51822 with the s110 softdevice. So I'm trying to read an analog signal from multiple pins. My program will run fine for quite some time. Eventually though for some reason the program gets caught up in the while loop of my get_adc function. So for some reason the adc is not completing its reading. I've seen a couple of other people with similar problems however I haven't found any solutions that worked.  Below I've included my get_adc() function. I tried placing a delay between my configure and start as that was suggested however that didn't do the trick. Does anyone have any clue why the adc is not completing the read?\r\n\r\n    static uint16_t get_adc(uint8_t analogInput)\r\n    {\r\n    \tuint16_t adc_result = 0;\r\n    \t\r\n    \tNRF_ADC->INTENSET = 0;   // disable interrupt\r\n    \tNRF_ADC->EVENTS_END = 0;\r\n      NRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;    // Enable ADC\r\n    \t\r\n    \t// config ADC\r\n    \tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) \t\t\t\t\t\t\t\t\t\t/* Bits 17..16 : ADC external reference pin selection. */\r\n    \t\t\t\t\t\t\t\t\t| (analogInput << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/*!< Use analog input X as analog input. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) \t/*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n    \t\r\n    \t// start ADC conversion\r\n    \tNRF_ADC->TASKS_START = 1;\r\n    \t\r\n    \t// wait for conversion to end\r\n    \twhile (!NRF_ADC->EVENTS_END) {};\r\n    \t\r\n    \tNRF_ADC->EVENTS_END = 0;\r\n    \t\r\n    \t// save results\r\n    \tadc_result = NRF_ADC->RESULT;\r\n    \t\r\n    \t// stop ADC conversion to save power\r\n    \tNRF_ADC->TASKS_STOP = 1;\r\n    \t\t\r\n    \treturn adc_result;\r\n    }",
    "tag": "adc"
  },
  {
    "text": "Bitbanging from TIMER1 when using SoftDevice Hello,\r\n\r\nI know I'm not supposed to use TIMER1 with IRQ 0 when using a SoftDevice but I want to try anyway :) I want to do some bit banging with timing that is timing sensitive and can't be delayed by the SoftDevice interrupts.\r\n\r\nDid anyone try this? Is there any tolerance at all or is the SoftDevice guaranteed to fail with a timer running at priority 0?\r\n\r\nThanks",
    "tag": "timer"
  },
  {
    "text": "BUG: Race condition in SPI driver Hi,\r\n\r\nI noticed that I'd occasionally hit an error when calling into `nrf_drv_spi_transfer` using the SPIM driver (SPI0_USE_EASY_DMA set).  `nrf_drv_spi_transfer` was returning `NRF_ERROR_BUSY`:\r\n\r\n    if (p_cb->transfer_in_progress)\r\n    {\r\n        return NRF_ERROR_BUSY;\r\n    }\r\n\r\nThe problem turned out to be a race condition, where `transfer_in_progress` was set *after* the SPIM module was started; thus, occasionally it would complete the SPI transaction (and clear `transfer_in_progress` and call the callback) before the `transfer_in_progress` flag was set.  Thus, `transfer_in_progress` was essentially getting set when the transaction was complete, thus preventing further transactions from occurring.\r\n\r\nI could reproduce this issue very easily by setting the compiler optimization to `-O0`.  It would occasionally happen with `-O3`.  \r\n\r\nAttached is a patch which I believe fixes the issue - it sets the flag *before* initiating the transfer.\r\n\r\nIf you could, please confirm this is the correct patch - thanks!\r\n[diff.txt](/attachment/65172caeb5f7cb44682df6dc6a7b0123)",
    "tag": "spi"
  },
  {
    "text": "ADC_IRQn trouble I am having trouble with setting priority of ADC_IRQn.\r\n\r\n    void ADC_init(void)\r\n    {\r\n    nrf_adc_config_t nrf_adc_config;\r\n\tnrf_adc_config.reference = NRF_ADC_CONFIG_REF_VBG;\r\n\tnrf_adc_config.resolution = NRF_ADC_CONFIG_RES_8BIT;\r\n\tnrf_adc_config.scaling = NRF_ADC_CONFIG_SCALING_INPUT_ONE_THIRD;\r\n\tnrf_adc_configure(&nrf_adc_config);\r\n\tnrf_adc_input_select(NRF_ADC_CONFIG_INPUT_DISABLED);\r\n\tnrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n\tsd_nvic_SetPriority(ADC_IRQn, 2);\r\n\tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    }\r\n \r\n    void ADC_init(void)\r\n    {\r\n\tnrf_adc_config_t nrf_adc_config;\r\n\tnrf_adc_config.reference = NRF_ADC_CONFIG_REF_VBG;\r\n\tnrf_adc_config.resolution = NRF_ADC_CONFIG_RES_8BIT;\r\n\tnrf_adc_config.scaling = NRF_ADC_CONFIG_SCALING_INPUT_ONE_THIRD;\r\n\tnrf_adc_configure(&nrf_adc_config);\r\n\tnrf_adc_input_select(NRF_ADC_CONFIG_INPUT_DISABLED);\r\n\tnrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n\tsd_nvic_SetPriority(ADC_IRQn, 2);\r\n\tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    }\r\n\r\n    static uint8_t adc_result = 0;\r\n\r\n    static void ADC_IRQHandler(void)\r\n    {\r\n\tnrf_adc_conversion_event_clean();\r\n\tadc_result = nrf_adc_result_get();\r\n\t//isBattLow = (adc_result < 200);\r\n\tisBattLow = true;\r\n    }\r\n\r\nBoth `nrf_adc_start()` and `NRF_ADC->TASKS_START = 1` don't trigger `ADC_IRQHandler()` with above setting.\r\n \r\n\r\n    sd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);\r\n    sd_nvic_SetPriority(ADC_IRQn, 3);\r\n    sd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_HIGH);\r\n    sd_nvic_SetPriority(ADC_IRQn, 1);\r\n\r\nBoth `nrf_adc_start()` and `NRF_ADC->TASKS_START = 1` make the system unresponsive with above 4 settings.\r\nI don't understand why it is happening.",
    "tag": "adc"
  },
  {
    "text": "How to have 3 PWMs by using app_pwm.c ? Hi All,\r\n\r\nI want to have 3 PWMs by using app_pwm.c lib (in SDK 9.0.0).\r\nBut from doc each instance takes 2 ppi plus 2 plus per channel.\r\n\r\nMeans 3 PWMS needs 2 instances.\r\n\r\nfirst instance: 2 + 2 x 2 = 6\r\n2nd instacne: 2+ 2 x 1 = 4\r\n\r\nso when i init 2nd PWM instance I got NO_MEM error.\r\n\r\nAny good idea about this ?\r\n\r\n\r\n\r\n  ",
    "tag": "pwm"
  },
  {
    "text": "Deigning BLE sensor Network I want to extend the ble_app_multilink_central for pca10028 Example to be able to communicate with a sensor via SPI and then initiate a connection with another pca10028.\r\nbut I have a problem with the SPI driver, after testing i found out that this function bsp_configuration() stops the program from executing.\r\n\r\nin another attempt to solve the problem i tried to make this example spi_master_with_spi_slave as my template. it is a peripheral example that doesn't require a softdevice but when i tried to program the SoftDevice first (because i will need it later for designing the NW) but then while flashing the program i get Error in Keil: Flash download Failed cortex M0 and i cant figure out the reason for that.\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "Wrong computation in BSP_MS_TO_TICK  macro Hi,\r\n\r\nI noticed  a possible issue in BSP_MS_TO_TICK macro computation.\r\nIn bsp.c, the macro is defined as:\r\n\r\n    #define BSP_MS_TO_TICK(MS) (m_app_ticks_per_100ms * (MS / 100))\r\n\r\nThis macro is used many places in BSP to start timers.\r\nBut due to the places of parenthesis, it forbid the usage of timers shorter than 100ms.\r\nIt does a division of MS by 100, leading to 0 if MS < 100.\r\n\r\nRather than:\r\n\r\n    #define BSP_MS_TO_TICK(MS) ((m_app_ticks_per_100ms * MS) / 100)\r\n\r\nIt shall be (mind the place of the parenthesis):\r\n\r\n    #define BSP_MS_TO_TICK(MS) (m_app_ticks_per_100ms * (MS / 100))\r\n\r\n \r\nMultiply before divide is probably better to avoid 0 tick computation when MS < 100ms.\r\n\r\nIs it on-purpose ?\r\nCan you confirm there is no issue setting timers shorter than 100ms ? (I think/hope not).\r\n\r\nRegards.\r\nDjamil\r\n\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "Utilizing multiple ADCs on one channel for high sample rate. Hello everybody,\r\n\r\nI searched the forums and saw numerous questions regarding sampling multiple ADCs but none for this exact use case.\r\n\r\nThe question is simple - is it possible to sample one channel of analog output using multiple ADCs and high-z selectors/enable (are the selectors even necessary?) to cycle through the 6 ADCs and produce 6 times the sampling frequency of a single ADC?\r\n\r\nI'm assuming this will be an incredibly timing intensive problem (allow time for each ADC capacitor to respond).  I haven't tried to implement this because I think there are two many variables I simply don't have knowledge of - and perhaps it's not be possible.\r\n\r\nThank you!",
    "tag": "adc"
  },
  {
    "text": "4 PWM channels with micro ESB? Hi everyone,\r\nI'd like to use the micro-esb radio interface to let to nRF's talk to each other.  One of them will be generating 4 PWM outputs based on data received.\r\n\r\nI have PWM working.  I have uESB working.  However....they aren't working together because PWM uses Timer 1 and 2.  uESB uses Timer 0 and 2.\r\n\r\nI'll tear into it and see if I can combine timers, etc, but at first glance it looks difficult to have 4 PWM and the uESB running.  \r\n\r\nAny suggestions (besides moving to BLE and softdevice)...?\r\n\r\nThanks! ",
    "tag": "pwm"
  },
  {
    "text": "Hardware TWI/I2C Example The latest TWI example I can find is from 4 SDK revisions ago and uses old libraries. Is there a sample using the nrf_drv_twi library that is recommended for current development?\r\n",
    "tag": "twi"
  },
  {
    "text": "Interrupt issue when button is pressed Hello, I am getting an issue regarding interrupt, below is my code and the problem is when I press the button, UART stop printing my value, I think my code is stuck somewhere kindly need help. Awaiting a positive reply\r\n\r\n\r\n    #define GREEN_LED 5\r\n    #define RED_LED 4\r\n    #define BUTTON 15\r\n    \r\n    \r\n    #define UART_TX_BUF_SIZE 256 /**< UART TX buffer size. */\r\n    #define UART_RX_BUF_SIZE 1   /**< UART RX buffer size. */\r\n    \r\n    #ifndef NRF_APP_PRIORITY_HIGH\r\n    #define NRF_APP_PRIORITY_HIGH 1\r\n    #endif\r\n    \r\n    void in_pin_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)\r\n    {\r\n        nrf_drv_gpiote_out_toggle(RED_LED);\r\n    }\r\n    static void gpio_init(void)\r\n    {\r\n        ret_code_t err_code;\r\n    \r\n        err_code = nrf_drv_gpiote_init();\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_gpiote_out_config_t out_config = GPIOTE_CONFIG_OUT_SIMPLE(false);\r\n    \r\n        err_code = nrf_drv_gpiote_out_init(RED_LED, &out_config);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t\r\n        nrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n        in_config.pull = NRF_GPIO_PIN_NOPULL;\r\n    \r\n        err_code = nrf_drv_gpiote_in_init(BUTTON, &in_config, in_pin_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_in_event_enable(BUTTON, true);\r\n    }\r\n    void uart_events_handler(app_uart_evt_t * p_event)\r\n    {\r\n        switch (p_event->evt_type)\r\n        {\r\n            case APP_UART_COMMUNICATION_ERROR: APP_ERROR_HANDLER(p_event->data.error_communication);\r\n                break;\r\n    \r\n            case APP_UART_FIFO_ERROR:          APP_ERROR_HANDLER(p_event->data.error_code);\r\n                break;\r\n    \r\n            default: break;\r\n        }\r\n    }\r\n    \r\n    void uart_config(void)\r\n    {\r\n        uint32_t                     err_code1;\r\n        const app_uart_comm_params_t comm_params =\r\n        {\r\n            RX_PIN_NUMBER,\r\n            TX_PIN_NUMBER,\r\n            RTS_PIN_NUMBER,\r\n            CTS_PIN_NUMBER,\r\n            APP_UART_FLOW_CONTROL_DISABLED,\r\n            false,\r\n            UART_BAUDRATE_BAUDRATE_Baud38400\r\n        };\r\n    \r\n        APP_UART_FIFO_INIT(&comm_params,\r\n                           UART_RX_BUF_SIZE,\r\n                           UART_TX_BUF_SIZE,\r\n                           uart_events_handler,\r\n                           APP_IRQ_PRIORITY_HIGH,\r\n                           err_code1);\r\n    \r\n        APP_ERROR_CHECK(err_code1);\r\n    }\r\n    \r\n    int main(void)\r\n    {   \r\n        uart_config();\t\r\n        gpio_init();\r\n        \r\n        while (true)\r\n        {\r\n    \t\t\tprintf(\"\\r\\nNo interrupt1\");\r\n    \t\t\tnrf_delay_ms(100);\r\n    \r\n        }\r\n    }",
    "tag": "interrupt"
  },
  {
    "text": "Can I transmit clock signal directly to GPIO pin without using timers? Hi!\r\n\r\nI am using nrf51DK with s110 soft device loaded on it to read data from Bosch BMA180 accelerometer using I2C interface. I would like to use clock prescaller and transmit a signal from it directly to the pin P07 (clock signal for I2C). The only resolution i found is this code:\r\n\r\n    #include \"nrf.h\"\r\n    #include \"nrf_gpiote.h\"\r\n    #include \"bsp.h\"\r\n    \r\n    #define OUTPUT_PIN_NUMBER (1)\r\n    \r\n    int main(void)\r\n    {\r\n        // Configure OUTPUT_PIN_NUMBER as an output.\r\n        nrf_gpio_cfg_output(OUTPUT_PIN_NUMBER);\r\n    \r\n        // Configure GPIOTE channel 0 to toggle the pin state\r\n        nrf_gpiote_task_config(0, OUTPUT_PIN_NUMBER, \\\r\n                               NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n    \r\n        // Configure PPI channel 0 to toggle OUTPUT_PIN on every TIMER2 COMPARE[0] match.\r\n        NRF_PPI->CH[0].EEP = (uint32_t)&NRF_TIMER2->EVENTS_COMPARE[0];\r\n        NRF_PPI->CH[0].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n    \r\n        // Enable PPI channel 0\r\n        NRF_PPI->CHEN = (PPI_CHEN_CH0_Enabled << PPI_CHEN_CH0_Pos);\r\n    \r\n        // Start 16 MHz crystal oscillator .\r\n        NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n        NRF_CLOCK->TASKS_HFCLKSTART    = 1;\r\n    \r\n        // Wait for the external oscillator to start up.\r\n        while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0){}\r\n    \r\n        // Configure timer 2\r\n        NRF_TIMER2->MODE      = TIMER_MODE_MODE_Timer;\r\n        NRF_TIMER2->BITMODE   = TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n        NRF_TIMER2->PRESCALER = 0;\r\n        NRF_TIMER2->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\r\n    \r\n        // Clears the timer, sets it to 0.\r\n        NRF_TIMER2->TASKS_CLEAR = 1;\r\n    \r\n        // Load the initial values to TIMER2 CC registers.\r\n        NRF_TIMER2->CC[0] = 2;\r\n    \r\n        // Start the timer\r\n        NRF_TIMER2->TASKS_START = 1;\r\n    \r\n        for(;;){}\r\n    }\r\n\r\nIs it possible to do not use any timers, just pure clock signal, prescale it and transmit it to P07 pin? I saw on block diagram of LPC1102/1104 processor that the clock has its own divider which i could use:\r\n![image description](/attachment/7172491d92b5cb15ee8dd2d35de573c8)\r\n\r\nbut i dont know if it is the same model as used in nrf51DK.\r\n\r\nI just want to know if i have to use timers or can i use just divided clock signal, and if it is possible, how can i do it, which functions should i use? And if anyone could tell me the exact model of processor in nrf51DK so i could find it block diagram? it would make my work much easier.\r\n\r\nThank you in advance",
    "tag": "i2c"
  },
  {
    "text": "nRF52 ADC ENOB Dear All\r\n\r\nIn my application we could not use the ADC inside the nRF51822 because 10bit are under our requirements. But now with the new nRF52xxx with a built-in 12bit ADC I hoped to get the job done by the new chip. ...BUT... In the [specs.](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fnrf52.v1.7%2FChunk1203547610.html&cp=1_1_0_33_11_0&anchor=unique_614473105) there are only 9bit ENOB specified after calibration. Are those 9ENOB a \"secured value\", meaning: probably the ENOB is higher? Our requirements are 10ENOB+.\r\nI'm a little bit disappointed, because a ADC sold as 12bit with only 9ENOB is not that stunning.\r\n\r\nThanks for any replys, Tim",
    "tag": "adc"
  },
  {
    "text": "why pin_change_int_pca10028 draws too much current ? hi everyone,\r\n\r\nwe are migrating to nrf51 ble chips from blugiga modules ( based Texas CC2541 chips). so i m pretty new. we needs to set pin interrupt in ble application. so i used pin_change_interupt example to implement it. but i noticed it draws current about 4.60 mA and it is very high for battery used projects. is there any solution for this ? or can someone share a simple code low power simple pin interrupt example?\r\nmy best regards.![image description](/attachment/6ff37456912e932cb666f2d5d33d3cc3)",
    "tag": "interrupt"
  },
  {
    "text": "Can I reduce the negotiation time of Bluetooth nRF51822 ![image description](/attachment/ce7aad6e13619ac90805e134c4a5002c)\r\n\r\nFollow up this image. I want to reduce the negotiation time.\r\n\r\n10:44:43.655 --> Connected to D6:9E...\r\n\r\n10:44:45.123 --> Services Discovered\r\n\r\n= 45.123 - 43.655 = 1.468 Sec\r\n\r\nI want reduce to 300ms. How can I do?\r\n\r\nThank you in advance.",
    "tag": "adc"
  },
  {
    "text": "Software ACK failed in NRF24LE1. Hi all,\r\n\r\nI tried to implement a software ACK between two NRF24LE1 devices, but failed.\r\nIn my tick_interrupt_ISR, I send a frame from device_A to device_B, and I want to wait for the ACK from device_B still in the tick_interrupt_ISR. To the detail, there is a flag variable in RF_IRQ(RF ISR), if a new RF frame is received, it will be set. And then the code in tick_interrupt_ISR will read the flag variable and check the received RF data, to determine whether it is a wanted ACK frame.\r\n\r\nThe simplified RF_IRQ ISR code is shown below:\r\n\r\n    void RF_IRQ(void) interrupt INTERRUPT_RFIRQ\r\n    {\r\n      uint8_t irq_flags;\r\n    \r\n      irq_flags = hal_nrf_get_clear_irq_flags();// Read and clear IRQ flags from radio\r\n    \t\r\n      switch(irq_flags)\r\n      {\r\n    \t// If data received\r\n    \tcase (1 << (uint8_t)HAL_NRF_RX_DR):\r\n    \t    // Read payload\r\n            while(!hal_nrf_rx_fifo_empty())\r\n    \t     {\r\n    \t\t\thal_nrf_read_rx_payload(RX_buffer);\r\n    \t     }\r\n    \t    // Flush RX FIFO\r\n    \t    hal_nrf_flush_rx();\r\n    \t    radio_receive_ready = true;       //The flag is set here!!!\r\n            LED3 = ~LED3;\r\n    \t    break;\r\n    \t\t\r\n    \t// If Transmission success\r\n        case (1 << (uint8_t)HAL_NRF_TX_DS):\r\n           radio_send_busy = false;\r\n           break;\r\n    \t\r\n        // Transmission failed (maximum re-transmits)\r\n        case (1 << (uint8_t)HAL_NRF_MAX_RT):\r\n           hal_nrf_flush_tx();\r\n           radio_send_busy = false;\r\n           break;\r\n         default:\r\n           break;\r\n      }\r\n    }\r\n\r\nThe simplified tick ISR is shown below:\r\n\r\n    void rtc2_isr(void) interrupt INTERRUPT_TICK\r\n    {\r\n    \tRTC2CON &= 0xfe;\t//Disable RTC2 function 1111 1110\r\n        TX_buffer[7] = 0x12;\t//control data to device_B\r\n\t\t\r\n    \tRF_Send(TX_buffer, RF_PLOAD_WIDTH);\t//Send a control frame to device_B\r\n\r\n           //Try to wait the ACK here\r\n    //        while(!radio_receive_ready );         // line121   \r\n        if( radio_receive_ready == true)\r\n        {\r\n             LED4 = ~LED4;    //The LED4 never changed status!!!\r\n        }\r\n    }\r\n\r\n> My test results are shown below:\r\n\r\n1) If \"line121\" is commented out, the LED3 always changes each time I send a frame, but LED4 never changes;\r\n\r\n2) If \"line121\" is NOT commented, the device seems to be gotten stuck, and BOTH LED3 & LED4 never changes.\r\nThe tick interrupt has a lower priority than RF interrupt, and I wonder if the interrupt nesting error happend.\r\n\r\nCould you please help me analyze this problem, thanks in advance!\r\n\r\nBest Regards,\r\nJunma\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Enable pwm with button click I would like to start a pwm signal on PIN 15 while BUTTON_1 or BUTTON_2 is pressed. If BUTTON_1 or BUTTON_2 is released, than there should be no signal(low) on PIN 15. \r\n\r\nSetup is:\r\n\r\n-SoftDevice 8.0\r\n\r\n-SDK 8.1\r\n\r\n-nRF51DK\r\n\r\nThere is a related post to this topic: https://devzone.nordicsemi.com/question/41179/how-to-stop-pwm-and-set-pin-to-clear/\r\n\r\nThe problem is, if I comment out ***app_pwm_enable(&PWM1);*** in the PWMinit function then I cannot connect to the board and the buttons are also not working. \r\n\r\nIf I enable the pwm in the PWMinit function, then the pwm will start immediately. But the pwm should only start when BUTTON_1 or BUTTON_2 are pressed. \r\n\r\n\r\n    static void PWMinit(void)\r\n    {\r\n      app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(9000L, 15);\r\n      pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n      app_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n      app_pwm_enable(&PWM1);\r\n    }\r\n\r\n    void pwm_stop(void)\r\n    {\r\n       app_pwm_disable(&PWM1);\r\n       nrf_drv_gpiote_out_task_disable(15);\r\n       nrf_gpio_pin_clear(15);\r\n    }\r\n\r\n    void pwm_start(void)\r\n    {   \r\n        nrf_drv_gpiote_out_task_enable(15); \r\n        app_pwm_enable(&PWM1);\r\n\t    while (app_pwm_channel_duty_set(&PWM1, 0, 50) == NRF_ERROR_BUSY);\r\n    }\r\n\r\n    static void button_event_handler(uint8_t pin_no, uint8_t button_action)\r\n    {\r\n\t    if(button_action == APP_BUTTON_PUSH)\r\n\t    {\r\n\t\t    switch (pin_no)\r\n            {\r\n                case \tSwitch_up:\r\n\t\t\t\t\t\t\t\t\tpwm_start();\r\n\t\t\t\t\t\t\t\t\tnrf_gpio_pin_set(23);\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \tSwitch_down:\r\n\t\t\t\t\t\t\t\t\tpwm_start();\r\n\t\t\t\t\t\t\t\t\tnrf_gpio_pin_set(24);\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n            \r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n            }\r\n\t    }\r\n\t\t\r\n\t    else if (button_action == APP_BUTTON_RELEASE)\r\n        {\r\n            switch (pin_no)\r\n            {\r\n                case \tSwitch_up:\r\n\t\t\t\t\t\t\t\t\tpwm_stop();\r\n\t\t\t\t\t\t\t\t\tnrf_gpio_pin_clear(23);\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcase \tSwitch_down:\r\n\t\t\t\t\t\t\t\t\tpwm_stop();\r\n\t\t\t\t\t\t\t\t\tnrf_gpio_pin_clear(24);\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n            default:\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n            }\r\n        }\r\n     }\r\n\r\n[Motorsteurung.zip](/attachment/f622a718a2859da51a27698a26a89d04)",
    "tag": "pwm"
  },
  {
    "text": "Interrupt when Signal is low-to-high I have a project, where I try to trigger an interrupt when I get a low-to-high tranistion and high-to low transition.\r\n\r\nMy setup:\r\n\r\n-nRF51DK\r\n\r\n-SDK8.1\r\n\r\n-SoftDevice 8.0 \r\n\r\n    #define low_to_high                25                                         \r\n    #define high_to_low                28\r\n\r\nBoth are defined as inputs, but one as PULLDOWN(low_to_high) and the other PULLUP(high_to_low).\r\n\r\n    nrf_gpio_cfg_input(low_to_high,NRF_GPIO_PIN_PULLDOWN);\r\n    nrf_gpio_cfg_input(high_to_low,NRF_GPIO_PIN_PULLUP);\r\n\r\nAt the beginning I just want to control two leds with this Signals:\r\n\r\n    if(button_action == APP_BUTTON_PUSH) -> nrf_gpio_pin_set(LED_1)\r\n\r\n    else if (button_action == APP_BUTTON_RELEASE) -> nrf_gpio_pin_clear(LED_2)\r\n\r\n\r\nThe buttons are initialized like this:\r\n\r\n    static void buttons_init(void)\r\n    {\r\n\t    uint32_t err_code;\r\n    \r\n        static app_button_cfg_t buttons[] =\r\n        {\r\n            {Switch_up, APP_BUTTON_ACTIVE_HIGH, BUTTON_PULL, button_event_handler},\r\n\t\t\t{Switch_down, false, BUTTON_PULL, button_event_handler}\r\n        };\r\n\r\n        app_button_init(buttons, sizeof(buttons) / sizeof(buttons[0]), BUTTON_DETECTION_DELAY);\r\n\t\t\r\n\t\terr_code = app_button_enable();\r\n        APP_ERROR_CHECK(err_code);\r\n\t\t\r\n    }\r\n\r\nThe high_to_low interrupt works fine. PIN 28 is on 2.8V and when I change it to 0V, the Interrupt will occur and the LED will change the state.\r\n\r\nThe problem is, PIN 25 is also on 2.8V even when I defined it as PULLDOWN. And the interrupt is also not working. Maybe the interrupt is not working because there is no rising edge. But why is on PIN 25 2.8V?\r\n\r\nNothing is connected on PIN 25. So it has to be a problem with the configuration of the PIN\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Cannot load nrf51822 firmware anymore! Hi,\r\nI have been using the nrf51822 successfully for a few months. But yesterday after I uploaded a new file the device no longer shows up on my computer** (see below for details of the setup and tools).  So now I cannot load any code onto the device any more. The device is not dead \u2013 it runs my code just fine but when I connect it to the computer it is not recognized. I have 2 computers and 2 programming dongles and the same problem now happens on all of them.\r\n\r\nI suspect that something in my code is somehow preventing the device from going into the firmware loading mode when connected to my computer.  Is that possible? \r\nMy code is based on the ble_app_hrs example with S110, but I added a TWI interface using nrf_drv_twi (TWI0_ENABLED, TWI0_CONFIG_FREQUENCY NRF_TWI_FREQ_100K,  TWI0_CONFIG_SCL  5,  TWI0_CONFIG_SDA  4, TWI0_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_HIGH). The TWI is writing data to a monochrome OLED display.  Could any of these settings prevent the device from being detected when connected to the computer via the programming interface?\r\n\r\nI also have a second nrf51822 device that I decided to use for another test. The second device was working properly \u2013 it was recognized by the computer so I uploaded Blinky and it worked fine. I unplugged it, plugged it back in, and everything was still good. So next I uploaded the same code (.hex file) that messed up my first device. It uploaded with no problem.  But then, just like the first one, it is no longer recognized, so I can no longer load a new  .hex file! \r\n\r\nYour advice would be appreciated!\r\n\r\n**I am using the BLE Nano from RedBearLab with the nrf51822, 16kB (see https://developer.mbed.org/platforms/RedBearLab-BLE-Nano/) For uploading firmware I use the MK20 USB programming dongle (I drag and drop the .hex file onto the \u201cmbed\u201d drive that appears when inserted into the computer USB port). For tools, I use SDK 8.1, Softdevice S110 V8.0.0, and the gcc compiler with Makefile.\r\n",
    "tag": "twi"
  },
  {
    "text": "Calling TWI driver from multiple files using nrf_drv_twi Hi,\r\nI use nrf51822 with SDK8.1, S110 and gcc with Makefile. I want to use nrf_drv_twi in both my main \u201c.c\u201d file as well as a library \u201c.c\u201d file that is included in the build. So in my main file I have:\r\n\r\n    #include <nrf_drv_twi.h>\r\n    //create TWI hardware object (see ../../../config/nrf_drv_config.h)\r\n    const nrf_drv_twi_t twi = NRF_DRV_TWI_INSTANCE(0);\r\n...\r\n\r\n    int main(void)\r\n    {\r\n        // Initialize.\r\n    \r\n    ...\t\r\n    \tnrf_drv_twi_init(&twi,NULL,NULL);\r\n    \tnrf_drv_twi_enable(&twi);\t\r\n    ...\r\n    }\r\nThen my main calls my library function, and the library function tries to use the same &twi like:\r\n\r\n    disp_success = nrf_drv_twi_tx(&twi,HW_I2C_DISPLAY_ADDRESS, data_buffer, 2, false);\r\nbut at complile time there is an error that 'twi is undeclared' in the library function. I can make the error go away if I add the following code to my library file and change the twi variable to twi2 in the library file:\r\n\r\n    #include <nrf_drv_twi.h>\r\n    const nrf_drv_twi_t twi2 = NRF_DRV_TWI_INSTANCE(0); \r\n    disp_success = nrf_drv_twi_tx(&twi2,HW_I2C_DISPLAY_ADDRESS, data_buffer, 2, false);\r\nBut I expect this is not the proper way to use a TWI instance that I set up and initialized in the main file. For instance, if I decided to change the TWI instance from 0 to 1 in main, I would need to remember to also change it in my library file.\r\nSo I would appreciate it if someone can advise the proper way to call the TWI in my second \".c\" file after I have declared and enabled it in my main \".c\" file. Thanks!!\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Calling TWI driver from multiple files using nrf_drv_twi Hi,\r\nI use nrf51822 with SDK8.1, S110 and gcc with Makefile. I want to use nrf_drv_twi in both my main \u201c.c\u201d file as well as a library \u201c.c\u201d file that is included in the build. So in my main file I have:\r\n\r\n    #include <nrf_drv_twi.h>\r\n    //create TWI hardware object (see ../../../config/nrf_drv_config.h)\r\n    const nrf_drv_twi_t twi = NRF_DRV_TWI_INSTANCE(0);\r\n...\r\n\r\n    int main(void)\r\n    {\r\n        // Initialize.\r\n    \r\n    ...\t\r\n    \tnrf_drv_twi_init(&twi,NULL,NULL);\r\n    \tnrf_drv_twi_enable(&twi);\t\r\n    ...\r\n    }\r\nThen my main calls my library function, and the library function tries to use the same &twi like:\r\n\r\n    disp_success = nrf_drv_twi_tx(&twi,HW_I2C_DISPLAY_ADDRESS, data_buffer, 2, false);\r\nbut at complile time there is an error that 'twi is undeclared' in the library function. I can make the error go away if I add the following code to my library file and change the twi variable to twi2 in the library file:\r\n\r\n    #include <nrf_drv_twi.h>\r\n    const nrf_drv_twi_t twi2 = NRF_DRV_TWI_INSTANCE(0); \r\n    disp_success = nrf_drv_twi_tx(&twi2,HW_I2C_DISPLAY_ADDRESS, data_buffer, 2, false);\r\nBut I expect this is not the proper way to use a TWI instance that I set up and initialized in the main file. For instance, if I decided to change the TWI instance from 0 to 1 in main, I would need to remember to also change it in my library file.\r\nSo I would appreciate it if someone can advise the proper way to call the TWI in my second \".c\" file after I have declared and enabled it in my main \".c\" file. Thanks!!\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Calling TWI driver from multiple files using nrf_drv_twi Hi,\r\nI use nrf51822 with SDK8.1, S110 and gcc with Makefile. I want to use nrf_drv_twi in both my main \u201c.c\u201d file as well as a library \u201c.c\u201d file that is included in the build. So in my main file I have:\r\n\r\n    #include <nrf_drv_twi.h>\r\n    //create TWI hardware object (see ../../../config/nrf_drv_config.h)\r\n    const nrf_drv_twi_t twi = NRF_DRV_TWI_INSTANCE(0);\r\n...\r\n\r\n    int main(void)\r\n    {\r\n        // Initialize.\r\n    \r\n    ...\t\r\n    \tnrf_drv_twi_init(&twi,NULL,NULL);\r\n    \tnrf_drv_twi_enable(&twi);\t\r\n    ...\r\n    }\r\nThen my main calls my library function, and the library function tries to use the same &twi like:\r\n\r\n    disp_success = nrf_drv_twi_tx(&twi,HW_I2C_DISPLAY_ADDRESS, data_buffer, 2, false);\r\nbut at complile time there is an error that 'twi is undeclared' in the library function. I can make the error go away if I add the following code to my library file and change the twi variable to twi2 in the library file:\r\n\r\n    #include <nrf_drv_twi.h>\r\n    const nrf_drv_twi_t twi2 = NRF_DRV_TWI_INSTANCE(0); \r\n    disp_success = nrf_drv_twi_tx(&twi2,HW_I2C_DISPLAY_ADDRESS, data_buffer, 2, false);\r\nBut I expect this is not the proper way to use a TWI instance that I set up and initialized in the main file. For instance, if I decided to change the TWI instance from 0 to 1 in main, I would need to remember to also change it in my library file.\r\nSo I would appreciate it if someone can advise the proper way to call the TWI in my second \".c\" file after I have declared and enabled it in my main \".c\" file. Thanks!!\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Generate two PWM waves with delay in nRF51822 I want to generate 2 fast PWM waves with 25% duty cycles from nRF51822. They have same frequency of 4MHz but there is half a cycle delay between them. I checked the [nrf_pwm library](https://github.com/NordicSemiconductor/nrf51-pwm-library/) but couldn't find a function can do that. Is there a way around? ",
    "tag": "pwm"
  },
  {
    "text": "maximum interrupt frequency? GPIO vs GPIOTE Hi folks,\r\n\r\nWhat's the maximum interrupt frequency the nRF51822 can support? I am looking to do an interrupt burst of about 4000 interrupts at a rate 2MHZ or 4MHz. In the ISR, I just want to read 8 GPIO input lines simultaneously.\r\n\r\nIs this possible? Would I be better served with raw GPIO vs GPIOTE? I am thinking the GPIOTE driver will add some overhead?\r\n\r\nI will be using a s110 soft device, but i could turn that off during this phase if it helps.\r\n\r\nThoughts?\r\n\r\nThanks\r\n\r\n-ujwal",
    "tag": "interrupt"
  },
  {
    "text": "PWM resolution of nRF51822 What is the maximum resolution I can achieve with the 4 PWMs of the nRF51822?\r\n\r\nIs it the same for each one of the 4 or are they different?",
    "tag": "pwm"
  },
  {
    "text": "UART reading not working when the device isn't connect to a BLE unit Hello,\r\n\r\nI have a nrf51822 chip using s110 SD. I am trying to read a serie of 14 bytes from UART. If the device is connected to a phone with BLE I receive the correct values every time but if the device isn't connected the values is corrupted. The program also uses the same pin as an ADC input in another senario. \r\nWhat I have tried so far:\r\n\r\n- I have tried to remove the ADC code to ensure that the two events wouldn't occur at the same time.\r\n- I have also tried removing the BLE code.\r\n\r\nUnfortunately I can't post the code here due to confidentiality.\r\n\r\nDoes anyone have a clue what the problem could be? Could it be in the library for connecting to BLE perhaps?",
    "tag": "adc"
  },
  {
    "text": "SPI couldn't read after update SDK 9.0 Hi. All.\r\n\r\nI am in the process of update SDK 9.0 from 5.2.\r\nMeanwhile, SPI couldn't read from external flash's data.\r\nUnusually SPI works well before infinite loop, I tested several times read and write before infinite loop, but it couldn't read on interrupt or APP_TIMER(I just tested in this module, but I think it doesn't work every time except before infinite loop).\r\nThe reason why I express \"couldn't read\" is I checked signals by using Logic Analyzer.\r\nThe write signals are occurred correctly that from nRF51822 to external flash, after that the other side signals are also occurred correctly.\r\nBut variable p_rx_buf is still '0', so I think SPI couldn't read that signals.\r\nWhat can I do for this problem?\r\nPlease give a advice.\r\n\r\nBest Regards.\r\n\r\nJongkyu.\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "Critical region called in handlers freeze app I am trying to enable a critical section in handler. I need to update a sensitive global variable when a button event occurs, and the fact to enable/disable the interrupt freeze the app. \r\n\r\nMy code in the button event handler, the first APP_ERROR_CHECK is never reached and the app is freezed. For this test, I disabled all other places where I enable/disable interrupts :\r\n\r\n    static void gpiote_event_watch_button_1_toggle(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)\r\n    {\r\n\t\tif(nrf_drv_gpiote_in_is_set(pin))\r\n\t\t{\r\n\t\t\t//Event was triggered on low-to-high signal\r\n\t\t\r\n\t\t\tuint32_t err_code;\r\n\t\t\tuint8_t is_nested_critical_region;\r\n\t\t\r\n\t\t\t//Disable interrupt\r\n\t\t\terr_code = sd_nvic_critical_region_enter(&is_nested_critical_region);\r\n            //Following lines are never reached\r\n\t\t\tAPP_ERROR_CHECK(err_code);      \r\n\t\t\r\n\t\t\tm_signal |= SIGNAL_REL_1;   // setting the requested bit\r\n\t\t\r\n\t\t\t//Enable interrupt\r\n\t\t\terr_code = sd_nvic_critical_region_exit(is_nested_critical_region);\r\n\t\t\tAPP_ERROR_CHECK(err_code);\r\n\t\t}\r\n    }\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Any examples of direct read & write of nRF51822 registers? Hi, are there any examples in C for how to directly access the registers on the chip? I realize this is a super basic question, but all the register access in the examples is wrapped in functions and macros that are not accessible, and I haven't found any code for this.\r\n\r\nSpecifically, I want to access the ADC and SPI registers directly with SD110 enabled. I'm using SDK v9.0.0\r\n\r\nThanks!",
    "tag": "spi"
  },
  {
    "text": "Any examples of direct read & write of nRF51822 registers? Hi, are there any examples in C for how to directly access the registers on the chip? I realize this is a super basic question, but all the register access in the examples is wrapped in functions and macros that are not accessible, and I haven't found any code for this.\r\n\r\nSpecifically, I want to access the ADC and SPI registers directly with SD110 enabled. I'm using SDK v9.0.0\r\n\r\nThanks!",
    "tag": "adc"
  },
  {
    "text": "Reasoning behind nrf51-pwm-library implementation Greetings,\r\n\r\nKudos for implementing a no glitch version of PWM with and without using timeslot.\r\n\r\nhttps://github.com/NordicSemiconductor/nrf51-pwm-library/blob/master/nrf_pwm_noglitch.c. \r\n\r\nCould the reasoning for the following be explained with the above PWM driver:\r\n\r\n - Why is `pwm_max_value` and `pwm_value` multiplied by 2 used for the timer instead of just these values?\r\n -  Disabling of the PPI channels done in the IRQ routine? Could waiting for 1.5 or 2 times the PWM cycle work?\r\n\r\nAlso does this implementation have the infamous bug of the polarity inverting at times as mentioned in other posts in this forum?\r\nThanks!",
    "tag": "pwm"
  },
  {
    "text": "nRF52 realtime interrupts? With the nRF51, it was not possible to run a high frequency realtime task due to the SoftDevice running with the highest interrupt priority, is this different for the nRF52? I couldn't find anything definite in the docs so far, did this change?\r\n\r\n(Specifically I'm looking to run a pulse generator interrupt in the 50kHz region, for stepper motor control. It's a showstopper against the nRF51, with the TI CC2640 being the alternative.)",
    "tag": "interrupt"
  },
  {
    "text": "Multiple SPI chained devices Hi.\r\n\r\nI need to use multiple SPI devices and I'm not sure which is the proper way to handle this, should I open/close each time the SPI port with different SS pin configurations for each device or is there a way to set multiple SS pins at once and select which one to use?\r\n\r\nCheers.",
    "tag": "spi"
  },
  {
    "text": "What is the timer0 frequency used by the softdevice? It's said that timer0 is used by softdevice and the current consumption differentiates for the defferent timer frequency (PS V3.1 table 22 and table 52).\r\nBut I don't find anywhere reads the timer0 frequecy used by the softdevice?",
    "tag": "timer"
  },
  {
    "text": "Not sure if understand APP_TIMER_TICKS macro. Hi,\r\n\r\nI know that there is documentation, and that there are some answered questions abaut this, but still i dont think i understood how macro APP_TIMER_TICKS works. I need to read adc with frequency 500hz, and i2c with frequency 20hz. i am using NRF51DK with s110 soft device on it. \r\n\r\nThis is my code:\r\n\r\n    #define APP_TIMER_PRESCALER              0     \r\n    #define ADC_SAMPLING_INTERVAL                APP_TIMER_TICKS(2, APP_TIMER_PRESCALER)\r\n    #define I2C_SAMPLING_INTERVAL                APP_TIMER_TICKS(50, APP_TIMER_PRESCALER)\r\n\r\nIs this configuration proper for my needs? If not, could someone simply explain how to use this macro?\r\n\r\nRegards, \r\nIna",
    "tag": "timer"
  },
  {
    "text": "nRF52 - spi_master_with_spi_slave example always faults out I am trying to communicate with a SPI peripheral, using the nRF52 as the master, and the peripheral as the slave. What happens is that it still faults out, and the presence of a delay call changes the point at which the fault occurs.  Since the loopback example works, and also calls the delay function, I suspect the delay is fine, but omitting it allows the first call to spi_send_recv() to return when it otherwise would fault out. \r\n\r\nI have done is two things:\r\n\r\n1) Tried the standard loopback example, spi_master, with my pin definitions in pca10036.h, **it works.**\r\n\r\n2) Since I want to connect to a slave, I am using **spi_master_with_spi_slave**, which has no such check_buf_equal() call.  The following modifications have been made to this example:\r\n\r\n   i) Changed the pin settings as per my peripheral connections.  This is in pca10036.h:\r\n\r\n    #define SPIM0_SCK_PIN   4 /*29*/  // SPI clock GPIO pin number.\r\n    #define SPIM0_MOSI_PIN  29 /*25*/  // SPI Master Out Slave In GPIO pin number.\r\n    #define SPIM0_MISO_PIN  28  // SPI Master In Slave Out GPIO pin number.\r\n    #define SPIM0_SS_PIN    30 /*12*/  // SPI Slave Select GPIO pin number.\r\n\r\n   ii)Set the chip select line to low in the main():\r\n\r\n    nrf_gpio_cfg_output(30); //for the CS pin\r\n    nrf_drv_gpiote_out_clear(30);   //This should assert the CS for the SPI peripheral\r\n\r\n   iii) Commented out the call to init_buffers() - no idea why this is even here as it annoyingly overwrites the data you're trying to send, so I removed it in the spi_send_recv() call:\r\n\r\n    static void spi_send_recv(uint8_t * const p_tx_data,\r\n                              uint8_t * const p_rx_data,\r\n                              const uint16_t  len)\r\n    {\r\n        // Initalize buffers.\r\n       // init_buffers(p_tx_data, p_rx_data, len); //comment this out since I want to send certain bytes\r\n        // Start transfer.\r\n        uint32_t err_code = nrf_drv_spi_transfer(&m_spi_master,\r\n            p_tx_data, len, p_rx_data, len);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t//From what I can see it is this call to nrf_delay_ms() that is causing the processor to fault out\r\n      nrf_delay_ms(DELAY_MS);     \t\r\n    }\r\n\r\n\r\n\r\n  iv)Set the ss_pin setting to NRF_DRV_SPI_PIN_NOT_USED to prevent the driver from setting this line high again **(it's an active low CS on the peripheral**). \r\n\r\n    nrf_drv_spi_config_t const config =\r\n    {\r\n        #if (SPI0_ENABLED == 1)\r\n            .sck_pin  = SPIM0_SCK_PIN,\r\n            .mosi_pin = SPIM0_MOSI_PIN,\r\n            .miso_pin = SPIM0_MISO_PIN,\r\n            .ss_pin   = SPIM0_SS_PIN,\r\n        #elif (SPI1_ENABLED == 1)\r\n            .sck_pin  = SPIM1_SCK_PIN,\r\n            .mosi_pin = SPIM1_MOSI_PIN,\r\n            .miso_pin = SPIM1_MISO_PIN,\r\n            .ss_pin   = SPIM1_SS_PIN,\r\n        #elif (SPI2_ENABLED == 1)\r\n            .sck_pin  = SPIM2_SCK_PIN,\r\n            .mosi_pin = SPIM2_MOSI_PIN,\r\n            .miso_pin = SPIM2_MISO_PIN,\r\n            .ss_pin   = SPIM2_SS_PIN,\r\n        #endif\r\n        .irq_priority = APP_IRQ_PRIORITY_LOW,\r\n        .orc          = 0xCC,\r\n        .frequency    = NRF_DRV_SPI_FREQ_1M,\r\n        .mode         = NRF_DRV_SPI_MODE_0,\r\n        .bit_order    = NRF_DRV_SPI_BIT_ORDER_LSB_FIRST,\r\n    \t.ss_pin       = NRF_DRV_SPI_PIN_NOT_USED, //if not specified, the nrf_drv_spi_init() will set this to high, which is wrong, CS is active low for this slave  peripheral\r\n    };\r\n\r\n\r\nTO BE CLEAR:  I am not concerned with the lack of response data, what I am concerned with is **WHY THIS PERSISTENTLY FAULTS OUT.  WHAT AM I DOING WRONG?**  \r\n\r\n**What I know for sure:** \r\n\r\na)  The **EVENT HANDLER IS NOT BEING CALLED AT ALL**\r\n\r\nb) The behavior of the fault is such that when I comment out the delay call in  spi_send_recv(), the fault does not occur until after the next call to spi_send_recv().  What I mean is not calling the delay seems to allow it to return from the first call to  spi_send_recv(), but not the second one.  \r\n\r\nHere is all my code in main.c:\r\n\r\n    /* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.\r\n     *\r\n     * The information contained herein is property of Nordic Semiconductor ASA.\r\n     * Terms and conditions of usage are described in detail in NORDIC\r\n     * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.\r\n     *\r\n     * Licensees are granted free, non-transferable use of the information. NO\r\n     * WARRANTY of ANY KIND is provided. This heading must NOT be removed from\r\n     * the file.\r\n     *\r\n     */\r\n    \r\n    /**@file\r\n     * @defgroup spi_master_example_with_slave_main main.c\r\n     * @{\r\n     * @ingroup spi_master_example\r\n     *\r\n     * @brief SPI master example application to be used with the SPI slave example application.\r\n     */\r\n    \r\n    #include <stdio.h>\r\n    #include <stdbool.h>\r\n    #include \"app_error.h\"\r\n    #include \"app_util_platform.h\"\r\n    #include \"nrf_delay.h\"\r\n    #include \"bsp.h\"\r\n    #include \"app_timer.h\"\r\n    #include \"nrf_drv_spi.h\"\r\n    #include \"nordic_common.h\"\r\n    \r\n    #include \"nrf_drv_gpiote.h\" //added to get the GPIO clear workinf- DS\r\n    \r\n    /*\r\n     * This example uses only one instance of the SPI master.\r\n     * Please make sure that only one instance of the SPI master is enabled in config file.\r\n     */\r\n    \r\n    #define APP_TIMER_PRESCALER      0                      /**< Value of the RTC1 PRESCALER register. */\r\n    #define APP_TIMER_MAX_TIMERS     BSP_APP_TIMERS_NUMBER  /**< Maximum number of simultaneously created timers. */\r\n    #define APP_TIMER_OP_QUEUE_SIZE  2                      /**< Size of timer operation queues. */\r\n    \r\n    #define DELAY_MS                 1000                /**< Timer Delay in milli-seconds. */\r\n    \r\n    #define TX_RX_BUF_LENGTH         16u                 /**< SPI transaction buffer length. */\r\n    #define TX_RX_BUF_LENGTH_CUSTOM  2                   //Added for AS3911 read register command\r\n    #define AS3911_READ_MODE   (1 << 6)\r\n    \r\n    #if (SPI0_ENABLED == 1)\r\n        static const nrf_drv_spi_t m_spi_master = NRF_DRV_SPI_INSTANCE(0);\r\n    #elif (SPI1_ENABLED == 1)\r\n        static const nrf_drv_spi_t m_spi_master = NRF_DRV_SPI_INSTANCE(1);\r\n    #elif (SPI2_ENABLED == 1)\r\n        static const nrf_drv_spi_t m_spi_master = NRF_DRV_SPI_INSTANCE(2);\r\n    #else\r\n        #error \"No SPI enabled.\"\r\n    #endif\r\n    \r\n    // Data buffers.\r\n    //static uint8_t m_tx_data[TX_RX_BUF_LENGTH] = {0}; /**< A buffer with data to transfer. */\r\n    //static uint8_t m_rx_data[TX_RX_BUF_LENGTH] = {0}; /**< A buffer for incoming data. */\r\n    \r\n    static uint8_t m_tx_data[TX_RX_BUF_LENGTH_CUSTOM] = {0}; /**< A buffer with data to transfer. */\r\n    static uint8_t m_rx_data[TX_RX_BUF_LENGTH_CUSTOM] = {0}; /**< A buffer for incoming data. */\r\n    \r\n    static volatile bool m_transfer_completed = true; /**< A flag to inform about completed transfer. */\r\n    \r\n    \r\n    /**@brief Function for error handling, which is called when an error has occurred.\r\n     *\r\n     * @param[in] error_code  Error code supplied to the handler.\r\n     * @param[in] line_num    Line number where the handler is called.\r\n     * @param[in] p_file_name Pointer to the file name.\r\n     */\r\n    void app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name)\r\n    {\r\n        UNUSED_VARIABLE(bsp_indication_set(BSP_INDICATE_FATAL_ERROR));\r\n    \r\n        for (;;)\r\n        {\r\n            // No implementation needed.\r\n        }\r\n    }\r\n    \r\n    \r\n    /**@brief Function for checking if data coming from a SPI slave are valid.\r\n     *\r\n     * @param[in] p_buf     A pointer to a data buffer.\r\n     * @param[in] len       A length of the data buffer.\r\n     * \r\n     * @note Expected ASCII characters from: 'a' to: ('a' + len - 1).\r\n     *\r\n     * @retval true     Data are valid.\r\n     * @retval false    Data are invalid.\r\n     */\r\n    static __INLINE bool buf_check(uint8_t * p_buf, uint16_t len)\r\n    {\r\n        uint16_t i;\r\n    \r\n        for (i = 0; i < len; i++)\r\n        {\r\n            if (p_buf[i] != (uint8_t)('a' + i))\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n    \r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**@brief Function for SPI master event callback.\r\n     *\r\n     * Upon receiving an SPI transaction complete event, checks if received data are valid.\r\n     *\r\n     * @param[in] spi_master_evt    SPI master driver event.\r\n     */\r\n    static void spi_master_event_handler(nrf_drv_spi_event_t event)\r\n    {\r\n        uint32_t err_code = NRF_SUCCESS;\r\n        bool result = false;\r\n    \r\n        switch (event)\r\n        {\r\n            case NRF_DRV_SPI_EVENT_DONE:\r\n                // Check if data are valid.\r\n                result = buf_check(m_rx_data, TX_RX_BUF_LENGTH);\r\n                APP_ERROR_CHECK_BOOL(result);\r\n    \r\n                err_code = bsp_indication_set(BSP_INDICATE_RCV_OK);\r\n                APP_ERROR_CHECK(err_code);\r\n    \r\n                // Inform application that transfer is completed.\r\n                m_transfer_completed = true;\r\n                break;\r\n    \r\n            default:\r\n                // No implementation needed.\r\n                break;\r\n        }\r\n    }\r\n    \r\n    \r\n    /**@brief The function initializes TX buffer to values to be sent and clears RX buffer.\r\n     *\r\n     * @note Function initializes TX buffer to values from 'A' to ('A' + len - 1)\r\n     *       and clears RX buffer (fill by 0).\r\n     *\r\n     * @param[in] p_tx_data     A pointer to a buffer TX.\r\n     * @param[in] p_rx_data     A pointer to a buffer RX.\r\n     * @param[in] len           A length of the data buffers.\r\n     */\r\n    static void init_buffers(uint8_t * const p_tx_data,\r\n                             uint8_t * const p_rx_data,\r\n                             const uint16_t  len)\r\n    {\r\n        uint16_t i;\r\n    \r\n        for (i = 0; i < len; i++)\r\n        {\r\n            p_tx_data[i] = (uint8_t)('A' + i);\r\n            p_rx_data[i] = 0;\r\n        }\r\n    }\r\n    \r\n    \r\n    /**@brief Functions prepares buffers and starts data transfer.\r\n     *\r\n     * @param[in] p_tx_data     A pointer to a buffer TX.\r\n     * @param[in] p_rx_data     A pointer to a buffer RX.\r\n     * @param[in] len           A length of the data buffers.\r\n     */\r\n    static void spi_send_recv(uint8_t * const p_tx_data,\r\n                              uint8_t * const p_rx_data,\r\n                              const uint16_t  len)\r\n    {\r\n        // Initalize buffers.\r\n       // init_buffers(p_tx_data, p_rx_data, len); //comment this out since I want to read a register\r\n    \r\n        // Start transfer.\r\n        uint32_t err_code = nrf_drv_spi_transfer(&m_spi_master,\r\n            p_tx_data, len, p_rx_data, len);\r\n        APP_ERROR_CHECK(err_code);\r\n      nrf_delay_ms(DELAY_MS); //not having this delay allows the function to return at least once\r\n    }\r\n    \r\n    \r\n    /**@brief Function for initializing bsp module.\r\n     */\r\n    void bsp_configuration()\r\n    {\r\n        uint32_t err_code = NRF_SUCCESS;\r\n    \r\n        NRF_CLOCK->LFCLKSRC            = (CLOCK_LFCLKSRC_SRC_Xtal << CLOCK_LFCLKSRC_SRC_Pos);\r\n        NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;\r\n        NRF_CLOCK->TASKS_LFCLKSTART    = 1;\r\n    \r\n        while (NRF_CLOCK->EVENTS_LFCLKSTARTED == 0)\r\n        {\r\n            // Do nothing.\r\n        }\r\n    \r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, NULL);\r\n            \r\n        err_code = bsp_init(BSP_INIT_LED, APP_TIMER_TICKS(100, APP_TIMER_PRESCALER), NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**@brief Function for application main entry. Does not return. */\r\n    int main(void)\r\n    {\r\n    \t\tunsigned char reg = 0x3F; //IC Identity Register\r\n    \t\tnrf_gpio_cfg_output(30); //for the CS pin\r\n        nrf_drv_gpiote_out_clear(30);   //This should assert the CS for the SPI peripheral\r\n    \t\r\n    \t  m_tx_data[0] = reg | AS3911_READ_MODE;\r\n        m_tx_data[1] = 0x00;\r\n    \r\n        m_rx_data[0] = 0x00;\r\n        m_rx_data[1] = 0x00;\r\n    \t\r\n        // Setup bsp module.\r\n        bsp_configuration();\r\n    \r\n        nrf_drv_spi_config_t const config =\r\n        {\r\n            #if (SPI0_ENABLED == 1)\r\n                .sck_pin  = SPIM0_SCK_PIN,\r\n                .mosi_pin = SPIM0_MOSI_PIN,\r\n                .miso_pin = SPIM0_MISO_PIN,\r\n                .ss_pin   = SPIM0_SS_PIN,\r\n            #elif (SPI1_ENABLED == 1)\r\n                .sck_pin  = SPIM1_SCK_PIN,\r\n                .mosi_pin = SPIM1_MOSI_PIN,\r\n                .miso_pin = SPIM1_MISO_PIN,\r\n                .ss_pin   = SPIM1_SS_PIN,\r\n            #elif (SPI2_ENABLED == 1)\r\n                .sck_pin  = SPIM2_SCK_PIN,\r\n                .mosi_pin = SPIM2_MOSI_PIN,\r\n                .miso_pin = SPIM2_MISO_PIN,\r\n                .ss_pin   = SPIM2_SS_PIN,\r\n            #endif\r\n            .irq_priority = APP_IRQ_PRIORITY_LOW,\r\n            .orc          = 0xCC,\r\n            .frequency    = NRF_DRV_SPI_FREQ_1M,\r\n            .mode         = NRF_DRV_SPI_MODE_0,\r\n    \t\t\t.bit_order    = NRF_DRV_SPI_BIT_ORDER_LSB_FIRST,\r\n    \t\t\t\t.ss_pin       = NRF_DRV_SPI_PIN_NOT_USED, //added by DS - if not specified, the nrf_drv_spi_init() will set this to high, which is wrong, CS for AS3911 is active low\r\n        };\r\n        ret_code_t err_code = nrf_drv_spi_init(&m_spi_master, &config, spi_master_event_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        for (;;)\r\n        {\r\n            if (m_transfer_completed)\r\n            {\r\n                m_transfer_completed = false;\r\n    \r\n                // Set buffers and start data transfer.\r\n                spi_send_recv(m_tx_data, m_rx_data, TX_RX_BUF_LENGTH_CUSTOM);\r\n    \t\t\t\t\t spi_send_recv(m_tx_data, m_rx_data, TX_RX_BUF_LENGTH_CUSTOM);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /** @} */",
    "tag": "spi"
  },
  {
    "text": "hardware timer driver problem Hello everybody,\r\nI'm trying to make TIMER1 working on nRF51822 together with softdevice.\r\nIn particular I would like to drive an interrupt line that goes to another microcontroller and I need to drive it low 100-200us after an SPI event occour. Then I've decided to use an hardware timer that is started by the SPI event, when the timer ends the ISR has to be executed and inside ISR the pin is driven to zero level. Nothing complicated...\r\n\r\nI've started from Timer example and I've copied almost all that main.c inside my project (adding references and includes that was missing in my main). I've changed the timer form 0 to 1 (if I'm not wrong timer0 is used by the softdevice) and i've enabled timer1 in ble_drv_config.h.\r\n\r\nBut I'm getting an error, during linking nrf_drv_common_irw_enable symbol is undefined.\r\n\r\nAny idea how to fix? Do I forget to do something?\r\nThanks,\r\nDavide.\r\n\r\nPS: I'm using keil and 8.0 skd",
    "tag": "timer"
  },
  {
    "text": "Problems when counting pulses using GPIOTE and TIMER via PPI in the presence of SoftDevice I am trying to implement frequency counting on nRF51822 by counting number of pulses in a given period. I create a PPI channel with a GPIOTE event on rising edge linked to TIMER counting task. The relevant code is as follows: \r\n\r\n\r\n    #define USE_WITH_SOFTDEVICE     1\r\n    \r\n    #define FC_GPIO   2\r\n    #define FC_TIMER  NRF_TIMER0 \r\n    #define FC_GPIOTE_CH  0 \r\n    #define FC_PPI_CH  0\r\n    \r\n    static void ppi_enable_channel(uint32_t ch_num, volatile uint32_t *event_ptr, volatile uint32_t *task_ptr)\r\n    {\r\n        if(ch_num >= 16) return;\r\n        else\r\n        {\r\n    #if(USE_WITH_SOFTDEVICE == 1)\r\n            sd_ppi_channel_assign(ch_num, event_ptr, task_ptr);\r\n            sd_ppi_channel_enable_set(1 << ch_num);\r\n    #else\r\n            // Otherwise we configure the channel and return the channel number\r\n            NRF_PPI->CH[ch_num].EEP = (uint32_t)event_ptr;\r\n            NRF_PPI->CH[ch_num].TEP = (uint32_t)task_ptr;    \r\n            NRF_PPI->CHENSET = (1 << ch_num);   \r\n    #endif\r\n        }\r\n    }\r\n    \r\n    \r\n    // Create a PPI channel: GPIOTE event from low to high --> FC_TIMER count up by 1 \r\n    static void counting_init(void)\r\n    { \r\n    \tnrf_gpio_cfg_input(FC_GPIO, NRF_GPIO_PIN_NOPULL);   // frequency counting input\r\n    \t\r\n    \t// Init timer\r\n      FC_TIMER->TASKS_CLEAR = 1;\r\n      FC_TIMER->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n    \tFC_TIMER->MODE = TIMER_MODE_MODE_Counter;\r\n    \tFC_TIMER->PRESCALER = 0; \r\n    \tFC_TIMER->TASKS_CAPTURE[0] = 0;\r\n    \t\r\n    \t// Init GPIOTE\r\n    \tnrf_gpiote_event_config(FC_GPIOTE_CH, FC_GPIO, NRF_GPIOTE_POLARITY_LOTOHI);\r\n    \t\r\n    \t// enable PPI\r\n    \tppi_enable_channel(FC_PPI_CH, &NRF_GPIOTE->EVENTS_IN[FC_GPIOTE_CH], &FC_TIMER->TASKS_COUNT);\r\n    \t\r\n    }\r\n    \r\n    // Destructor \r\n    static void counting_deinit(void)\r\n    {\r\n    \tFC_TIMER->TASKS_STOP = 1;\r\n    \tFC_TIMER->TASKS_SHUTDOWN = 1;\r\n    \tnrf_gpiote_unconfig(FC_GPIOTE_CH);\r\n    \tnrf_gpio_cfg_output(FC_GPIO);\r\n    \tnrf_gpio_pin_clear(FC_GPIO);\r\n    }\r\n    \r\n    static uint16_t count_get(void)\r\n    {\r\n    \tuint16_t count;\r\n    \tcounting_init();\r\n    \tFC_TIMER->TASKS_START = 1;\r\n    \tnrf_delay_ms(1);  // try busy wait\r\n    \tFC_TIMER->TASKS_CAPTURE[0] = 1;\r\n      count = FC_TIMER->CC[0];\r\n    \tcounting_deinit();\r\n    \treturn count;\r\n    }\r\n\r\nThe last function count_get() returns the number of counts. However, when I call the function in the code, the program results in hard default. If I don't call the function, the code runs fine. So there should be something wrong with the way I implement in. Please advise.  \r\n",
    "tag": "timer"
  },
  {
    "text": "MCP2515 with NRF51-DK Hi,<br>\r\nI am trying to interface MCP2515 with nrf51-dk. MCP2515 talks over SPI, so I have taken SPI_master as my base code. I have used MCP with arduino, so I thought it would be best to modify that library which can be found [here](https://github.com/Seeed-Studio/CAN_BUS_Shield).<br>\r\nBut when I'm trying to configure it, it is not giving correct data. So, I have following questions:<br>\r\n\r\n 1. Are the pins on the DK 5V tolerant? I haven't tried to give 5V signal, thinking it might get damaged.\r\n 2. I'm supplying power to MCP using VDD of the board which provides around 2.9V when connected via USB. Will it damage the DK as I don't know how much current MCP will draw, although it works fine with arduino 5V.\r\n 3. I've also changed the default SPI pins to my own as the Product Sheet states that the SPI pins are not fixed. I hope its alright. I'm using the following configuration:<br>\r\n> SCK->4, MISO->2, MOSI->3, SS->1\r\n 4. When I do spi_send_rcv, the received data is the previously buffered data or data according to the current command?\r\n 5. Finally the last question, can someone help me debug the code or give me hints on how to? <br>\r\nI've used RTT to debug the code, and I am now stuck at a point, I know where the issue is but I'm unable to figure out what to do with that? If someone needs more details, I can provide that too. Till then I'll refrain from making this post messy. I'm attaching the code if it can help.<br>\r\nI apologize if the question is too much specific. I've been at the same position for over a week. Thanks in advance for the help :)<br>\r\n[spi_master.zip](/attachment/bb29eb18fd1e7e875acd17e9fed9818f)\r\n\r\nEdit:\r\nWhen I don't write the rx_buf from spi_send_rcv to RTT terminal, application doesn't get into the function spi_send_rcv after 3 times. I think this is related to some memory issue, what can I do regarding this, as most of the times rx_buf is of no use to me. I tried replacing it with NULL but no success.",
    "tag": "spi"
  },
  {
    "text": "nRF51822 PWM strange behavior Hi. \r\n\r\nI'm using latest version of [nrf51-pwm-library](https://github.com/NordicSemiconductor/nrf51-pwm-library) to test if PWM works fine, but unfortunately, it's not. I have very simple program which should fade LED from 255 to 0 in infinite loop, but instead fading, I can see LED light on 100% and then turn off (blink instead fade). When I debug, I notice, LED is on (without any fading) when i > 0 and LED is off when i == 0. \r\n\r\nAny suggestions? Btw no softdevice is used so far.\r\n\r\nThis is how my code look like:\r\n\r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    #include \"nrf.h\"\r\n    #include \"nrf_gpio.h\"\r\n    #include \"nrf_delay.h\"\r\n    #include \"nrf_pwm.h\"\r\n    #include \"boards.h\"\r\n    \r\n    int main(void)\r\n    {\r\n        nrf_pwm_config_t pwm_config = PWM_DEFAULT_CONFIG;\r\n        \r\n        pwm_config.mode             = PWM_MODE_LED_255;\r\n        pwm_config.num_channels     = 1;\r\n        pwm_config.gpio_num[0]      = 9;   \r\n        \r\n        // Initialize the PWM library\r\n        nrf_pwm_init(&pwm_config);\r\n    \r\n    \t\tfor(uint8_t i = 255; i >= 0; i--){\r\n    \t\t\tnrf_pwm_set_value(0, i);\r\n    \t\t\tnrf_delay_ms(100);\r\n    \t\t}\r\n    }",
    "tag": "pwm"
  },
  {
    "text": "Unable to generate PWM pulse \r\nHi, I am trying to generate PWM pulse based on sample application in GitHub. However instead of using different modes and multiple channels, I tried to simplify it to just configuring Timer2, one channel, and one output pin. I am trying to set the duty cycle value in BLE data handler, using 2 PPI channels to toggle a pin once when it reaches CC[0] (to set the duty cycle) and once to finish a complete period CC[1].\r\nI'm not getting any pulse on my oscilloscope.\r\nAttached PWM part of the code below, any hint on what might be wrong?\r\nCould there be any dependencies with other peripherals initialization?\r\n\r\n    // PWM Timer Definitions\r\n    #define PWM_TIMER\t\t\tNRF_TIMER2\r\n    #define PWM_IRQHandler\t\tTIMER2_IRQHandler\r\n    #define PWM_IRQn\t\t\tTIMER2_IRQn\r\n    #define GPIOTE_CHANNEL_NO\t2\r\n    #define PWM_MAX_VALUE\t\t1000UL      // 1 tick equals 1\u00b5 , multiply by 1000 for ms value\r\n    uint16_t pwm_value;\r\n    uint8_t pwm_running;\r\n    \r\n    /**@brief Function for Starting PWM timer.\r\n     */\r\n    static void pwm_init(void)\r\n    {\r\n    \tnrf_gpio_cfg_output(REGULATOR_PIN);\t\t// Set regulator pin as output\r\n    \t// Configure GPIOTE_CHANNEL_NUMBER to toggle the GPIO pin state with input.\r\n    \t// nrf_gpiote_task_configure(GPIOTE_CHANNEL_NO, REGULATOR_PIN, NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);                \r\n    \tpwm_running = 0;\r\n    \r\n    \t// Configure TIMER2 for compare[0] event every 1 ms.\r\n    \tPWM_TIMER->PRESCALER = 3;            // Prescaler 4 results in 1 tick equals 1 microsecond.\r\n    \tPWM_TIMER->TASKS_CLEAR = 1;\r\n    \tPWM_TIMER->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\t// 16 bit mode.\r\n    \tPWM_TIMER->CC[1]     = PWM_MAX_VALUE;       // 1 tick equals 1\u00b5 , multiply by 1000 for ms value\r\n    \tpwm_value = 300;\r\n    \tPWM_TIMER->CC[0] = pwm_value;\r\n    \tPWM_TIMER->MODE = TIMER_MODE_MODE_Timer;\t// Set the timer in Timer Mode.\r\n    \tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE1_CLEAR_Msk;\r\n    \tPWM_TIMER->EVENTS_COMPARE[0] = PWM_TIMER->EVENTS_COMPARE[1] = 0;\r\n    \t\r\n    \t// Configure PPI channel 0 to toggle REGULATOR_PIN on every TIMER2 COMPARE[0] match\r\n    \tsd_ppi_channel_assign(0, &(PWM_TIMER->EVENTS_COMPARE[0]), &(NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NO]));\r\n    \t// Enable PPI channel 0\r\n    \tsd_ppi_channel_enable_set(1 << 0);\r\n    \t// Configure PPI channel 1 to toggle REGULATOR_PIN on every TIMER2 COMPARE[1] match\r\n    \tsd_ppi_channel_assign(1, &(PWM_TIMER->EVENTS_COMPARE[1]), &(NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NO]));\r\n    \t// Enable PPI channel 1\r\n    \tsd_ppi_channel_enable_set(1 << 1);\r\n    \r\n    \tsd_nvic_SetPriority(PWM_IRQn, 1);\t//must have to set the priority\r\n    //\tsd_nvic_ClearPendingIRQ(PWM_IRQn);\r\n    \tsd_nvic_EnableIRQ(PWM_IRQn);\r\n      __enable_irq();\r\n    \t\r\n    \t/* Start clock */\r\n    \tPWM_TIMER->TASKS_START = 1;\r\n    }\r\n    \r\n    /**@brief   Sets the value for PWM\r\n     *\r\n     * @details Sets the variable for PWM value\r\n     * In next interrupt the value is updated to the timer register\r\n     * \r\n     */\r\n    static void pwm_set_value(uint16_t value)\r\n    {\r\n    \tif(value <= PWM_MAX_VALUE)\r\n    \t{\r\n    \t\tpwm_value = value;\r\n    \t\tPWM_TIMER->EVENTS_COMPARE[1] = 0;\r\n    \t\tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE1_CLEAR_Msk | TIMER_SHORTS_COMPARE1_STOP_Msk;\r\n    \t\tif((PWM_TIMER->INTENSET & TIMER_INTENSET_COMPARE1_Msk) == 0)\r\n    \t\t{\r\n    \t\t\tPWM_TIMER->TASKS_STOP = 1;\r\n    \t\t\tPWM_TIMER->INTENSET = TIMER_INTENSET_COMPARE1_Msk;  \r\n    \t\t}\r\n    \t\tPWM_TIMER->TASKS_START = 1;\r\n    \t}\r\n    }\r\n    \r\n    /**@brief   Function for handling Timer2 interrupt.\r\n     *\r\n     * @details This function will set the PWM value to CC register\r\n     * keeps the GPIO pin high/low at the max/min value of PWM respectively\r\n     * \r\n     */\r\n    void PWM_IRQHandler(void)\r\n    {\r\n    \tPWM_TIMER->EVENTS_COMPARE[1] = 0;\r\n    \tPWM_TIMER->INTENCLR = 0xFFFFFFFF;\r\n    \r\n    \tif(pwm_value == 0)\r\n    \t{\r\n    //\t\tnrf_gpiote_unconfig(2);   Can anyone suggest what should be done here\r\n    //\t\tnrf_gpiote_task_disable(0);\r\n    \t\tnrf_gpio_pin_write(REGULATOR_PIN, 0);\r\n    \t\tpwm_running = 0;\r\n    \t}\r\n    \telse if (pwm_value >= PWM_MAX_VALUE)\r\n    \t{\r\n    //\t\tnrf_gpiote_unconfig(2);   Can anyone suggest what should be done here\r\n    //\t\tnrf_gpiote_task_disable(0);\r\n    \t\tnrf_gpio_pin_write(REGULATOR_PIN, 1); \r\n    \t\tpwm_running = 0;\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tPWM_TIMER->CC[0] = pwm_value;\r\n    \t\tif(pwm_running == 0)\r\n    \t\t{\r\n    \t\t\t// Configure GPIOTE_CHANNEL_NUMBER to toggle the GPIO pin state with input.\r\n    \t\t\tnrf_gpiote_task_configure(GPIOTE_CHANNEL_NO, REGULATOR_PIN, NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);                \r\n    \t\t\tpwm_running = 1;\r\n    \t\t}\r\n    \t}\r\n    \r\n    \tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE1_CLEAR_Msk;\r\n    \tPWM_TIMER->TASKS_START = 1;\r\n    }\r\n    \r\n    \r\n    /**@brief Application main function.\r\n     */\r\n    int main(void)\r\n    {\r\n        uint32_t err_code;\r\n        bool erase_bonds;\r\n        uint8_t  start_string[] = START_STRING;\r\n        \r\n        //  Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        uart_init();\r\n        buttons_leds_init(&erase_bonds);\r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n        pwm_init();\r\n        \r\n        printf(\"%s\",start_string);\r\n    \r\n        err_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        // Enter main loop.\r\n        for (;;)\r\n        {\r\n          power_manage();\r\n        }\r\n    }\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Unable to generate PWM pulse \r\nHi, I am trying to generate PWM pulse based on sample application in GitHub. However instead of using different modes and multiple channels, I tried to simplify it to just configuring Timer2, one channel, and one output pin. I am trying to set the duty cycle value in BLE data handler, using 2 PPI channels to toggle a pin once when it reaches CC[0] (to set the duty cycle) and once to finish a complete period CC[1].\r\nI'm not getting any pulse on my oscilloscope.\r\nAttached PWM part of the code below, any hint on what might be wrong?\r\nCould there be any dependencies with other peripherals initialization?\r\n\r\n    // PWM Timer Definitions\r\n    #define PWM_TIMER\t\t\tNRF_TIMER2\r\n    #define PWM_IRQHandler\t\tTIMER2_IRQHandler\r\n    #define PWM_IRQn\t\t\tTIMER2_IRQn\r\n    #define GPIOTE_CHANNEL_NO\t2\r\n    #define PWM_MAX_VALUE\t\t1000UL      // 1 tick equals 1\u00b5 , multiply by 1000 for ms value\r\n    uint16_t pwm_value;\r\n    uint8_t pwm_running;\r\n    \r\n    /**@brief Function for Starting PWM timer.\r\n     */\r\n    static void pwm_init(void)\r\n    {\r\n    \tnrf_gpio_cfg_output(REGULATOR_PIN);\t\t// Set regulator pin as output\r\n    \t// Configure GPIOTE_CHANNEL_NUMBER to toggle the GPIO pin state with input.\r\n    \t// nrf_gpiote_task_configure(GPIOTE_CHANNEL_NO, REGULATOR_PIN, NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);                \r\n    \tpwm_running = 0;\r\n    \r\n    \t// Configure TIMER2 for compare[0] event every 1 ms.\r\n    \tPWM_TIMER->PRESCALER = 3;            // Prescaler 4 results in 1 tick equals 1 microsecond.\r\n    \tPWM_TIMER->TASKS_CLEAR = 1;\r\n    \tPWM_TIMER->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\t// 16 bit mode.\r\n    \tPWM_TIMER->CC[1]     = PWM_MAX_VALUE;       // 1 tick equals 1\u00b5 , multiply by 1000 for ms value\r\n    \tpwm_value = 300;\r\n    \tPWM_TIMER->CC[0] = pwm_value;\r\n    \tPWM_TIMER->MODE = TIMER_MODE_MODE_Timer;\t// Set the timer in Timer Mode.\r\n    \tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE1_CLEAR_Msk;\r\n    \tPWM_TIMER->EVENTS_COMPARE[0] = PWM_TIMER->EVENTS_COMPARE[1] = 0;\r\n    \t\r\n    \t// Configure PPI channel 0 to toggle REGULATOR_PIN on every TIMER2 COMPARE[0] match\r\n    \tsd_ppi_channel_assign(0, &(PWM_TIMER->EVENTS_COMPARE[0]), &(NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NO]));\r\n    \t// Enable PPI channel 0\r\n    \tsd_ppi_channel_enable_set(1 << 0);\r\n    \t// Configure PPI channel 1 to toggle REGULATOR_PIN on every TIMER2 COMPARE[1] match\r\n    \tsd_ppi_channel_assign(1, &(PWM_TIMER->EVENTS_COMPARE[1]), &(NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NO]));\r\n    \t// Enable PPI channel 1\r\n    \tsd_ppi_channel_enable_set(1 << 1);\r\n    \r\n    \tsd_nvic_SetPriority(PWM_IRQn, 1);\t//must have to set the priority\r\n    //\tsd_nvic_ClearPendingIRQ(PWM_IRQn);\r\n    \tsd_nvic_EnableIRQ(PWM_IRQn);\r\n      __enable_irq();\r\n    \t\r\n    \t/* Start clock */\r\n    \tPWM_TIMER->TASKS_START = 1;\r\n    }\r\n    \r\n    /**@brief   Sets the value for PWM\r\n     *\r\n     * @details Sets the variable for PWM value\r\n     * In next interrupt the value is updated to the timer register\r\n     * \r\n     */\r\n    static void pwm_set_value(uint16_t value)\r\n    {\r\n    \tif(value <= PWM_MAX_VALUE)\r\n    \t{\r\n    \t\tpwm_value = value;\r\n    \t\tPWM_TIMER->EVENTS_COMPARE[1] = 0;\r\n    \t\tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE1_CLEAR_Msk | TIMER_SHORTS_COMPARE1_STOP_Msk;\r\n    \t\tif((PWM_TIMER->INTENSET & TIMER_INTENSET_COMPARE1_Msk) == 0)\r\n    \t\t{\r\n    \t\t\tPWM_TIMER->TASKS_STOP = 1;\r\n    \t\t\tPWM_TIMER->INTENSET = TIMER_INTENSET_COMPARE1_Msk;  \r\n    \t\t}\r\n    \t\tPWM_TIMER->TASKS_START = 1;\r\n    \t}\r\n    }\r\n    \r\n    /**@brief   Function for handling Timer2 interrupt.\r\n     *\r\n     * @details This function will set the PWM value to CC register\r\n     * keeps the GPIO pin high/low at the max/min value of PWM respectively\r\n     * \r\n     */\r\n    void PWM_IRQHandler(void)\r\n    {\r\n    \tPWM_TIMER->EVENTS_COMPARE[1] = 0;\r\n    \tPWM_TIMER->INTENCLR = 0xFFFFFFFF;\r\n    \r\n    \tif(pwm_value == 0)\r\n    \t{\r\n    //\t\tnrf_gpiote_unconfig(2);   Can anyone suggest what should be done here\r\n    //\t\tnrf_gpiote_task_disable(0);\r\n    \t\tnrf_gpio_pin_write(REGULATOR_PIN, 0);\r\n    \t\tpwm_running = 0;\r\n    \t}\r\n    \telse if (pwm_value >= PWM_MAX_VALUE)\r\n    \t{\r\n    //\t\tnrf_gpiote_unconfig(2);   Can anyone suggest what should be done here\r\n    //\t\tnrf_gpiote_task_disable(0);\r\n    \t\tnrf_gpio_pin_write(REGULATOR_PIN, 1); \r\n    \t\tpwm_running = 0;\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tPWM_TIMER->CC[0] = pwm_value;\r\n    \t\tif(pwm_running == 0)\r\n    \t\t{\r\n    \t\t\t// Configure GPIOTE_CHANNEL_NUMBER to toggle the GPIO pin state with input.\r\n    \t\t\tnrf_gpiote_task_configure(GPIOTE_CHANNEL_NO, REGULATOR_PIN, NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);                \r\n    \t\t\tpwm_running = 1;\r\n    \t\t}\r\n    \t}\r\n    \r\n    \tPWM_TIMER->SHORTS = TIMER_SHORTS_COMPARE1_CLEAR_Msk;\r\n    \tPWM_TIMER->TASKS_START = 1;\r\n    }\r\n    \r\n    \r\n    /**@brief Application main function.\r\n     */\r\n    int main(void)\r\n    {\r\n        uint32_t err_code;\r\n        bool erase_bonds;\r\n        uint8_t  start_string[] = START_STRING;\r\n        \r\n        //  Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        uart_init();\r\n        buttons_leds_init(&erase_bonds);\r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n        pwm_init();\r\n        \r\n        printf(\"%s\",start_string);\r\n    \r\n        err_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        // Enter main loop.\r\n        for (;;)\r\n        {\r\n          power_manage();\r\n        }\r\n    }\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Programming TMP102/TMP112 using TWI Has anyone had any success setting the configuration register on TMP102/112 temperature sensors via I2C? I'd like to switch the sensor to one-shot mode to further minimise current usage - I'm on a mission to hit 3uA when sleeping and next step is shutdown the temp sensor between reads. \r\n\r\nI would really benefit from a coded example to work with to bridge the gap between the TWI documentation and the sensor datasheets\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "SPI MASTER INSIDE BLE EVENT I have nrf51822 s130 sdk v8. When I use spi master in main loop the it works fine. When I start to use SPI master inside ble event then I dont get start, cancel or complete event. My code will wait until complete or cancel event. Is the spi master irq not working when ble event is in progress?",
    "tag": "spi"
  },
  {
    "text": "Advertising and Fast ADC Sampling Hi,\r\nI am a newbie. I understand that a similar question was asked earlier, but I couldn't get an answer specific to my questions. My goal is to sample an analog signal at 40 KHz with 8 bit resolution, do some processing and advertise one integer value as manufacturer specific data. I understand from S110_SoftDevice_Specification_2.0 that the CPU halts during BLE events and there is advertising latency. Without the SoftDevice, I can do this as the ADC of nrf51822 (Rev3) can sample at 50KHz with 8 bit resolution. With the SoftDevice however, I can only sample at 1KHz. Is it possible to actually sample at 40 KHz with the SoftDevice? If not, what's the maximum sampling rate that I can get? Will the Time Slot API help?\r\nThanks in advance!",
    "tag": "adc"
  },
  {
    "text": "nRF24LU1+: Erasing pages does not work I'm trying to erase the page 32 of a nRF24LU1+ via SPI (using a Bus Pirate).\r\n\r\nWhat I did so far:  \r\n 1. Display the first 16 bytes of content of page 32: `0x03 0x40 0x00 0x10`  \r\n 2. Enable writing flag (WREN): `0x06`  \r\n 3. Check if setting the write flag was successful: `0x05 0x01`  \r\n 4. Erase page nr. 32: `0x52 0x20`  \r\n 5. Display the first 16 bytes of content of page 32: `0x03 0x40 0x00 0x10`\r\n\r\nResult: The content is still there. Also the WREN flag is still enabled.\r\n\r\nWhat did I do wrong? Did I miss something obvious? Is the chip really a nRF24LU1+? The marking says \"NRF 0 LU1PA 1410NR\".\r\n\r\nAny help is welcome!",
    "tag": "spi"
  },
  {
    "text": "Unable to Toggle PWM Module Off and On Hello,\r\n\r\nI have an issue that I can't seem to sort out involving the PWM module. I am currently using SDK9.0 and SoftDevice S110 V8.0 and I am using the stock PWM files from the SDK. The problem I am having is that I can't seem to disable and then re-enable the PWM module. I want to turn the PWM module off when I don't need it to save on battery life and power consumption. I am using a total of three PWM channels on 2 instances that I Init in the following way:\r\n\r\n    APP_PWM_INSTANCE(PWM1,1);\r\n    APP_PWM_INSTANCE(PWM2,2);\r\n\r\n    bool pwm_1_ready_flag;\r\n    bool pwm_2_ready_flag;\r\n\r\n    void pwm_1_ready_callback(uint32_t pwm_id)\r\n    {\r\n      pwm_1_ready_flag = true;\r\n    }\r\n\r\n    void pwm_2_ready_callback(uint32_t pwm_id)   \r\n    {\r\n      pwm_2_ready_flag = true;\r\n    }\r\n\r\n    void pwm_init(void)\r\n    {\r\n      ret_code_t err_code;\r\n\r\n      /* 2-channel PWM, output on LED pins. */\r\n      app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(10000L, LED_RED, LED_GREEN);\r\n      app_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_1CH(10000L, LED_BLUE);\r\n\r\n\t  /* Set the polarity of the channel. */\r\n\t  pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\t  pwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\t  pwm2_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\r\n\t  /* Initialize and enable PWM. */\r\n\t  err_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm_1_ready_callback);\r\n\t  APP_ERROR_CHECK(err_code);\r\n\t  err_code = app_pwm_init(&PWM2,&pwm2_cfg,pwm_1_ready_callback);\r\n      APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\nThen I enable the PWM module using:\r\n\r\n    void enable_pwm(void)\r\n    {\r\n      app_pwm_enable(&PWM1);\r\n      app_pwm_enable(&PWM2);\r\n    }\r\n\r\nNext I display some blinking LED patterns using PWM and then I turn off the PWM module with:\r\n\r\n    void disable_pwm(void)\r\n    {\r\n      app_pwm_disable(&PWM1);\r\n      app_pwm_disable(&PWM2);\r\n    }\r\n\r\nI then verify that the power consumption is a lot lower. Everything is good up until this point. I then try to turn the PWM module back on using:\r\n\r\n    enable_pwm()\r\n\r\nand then I execute the following:\r\n\r\n    for(int i =0; i < 100; i=i+5)\r\n\t{\r\n\t\tif(i <= red_led_value)\r\n\t\t{\r\n\t\t\twhile (app_pwm_channel_duty_set(&PWM1, 0, i) == NRF_ERROR_BUSY);\r\n\t\t}\r\n\t\tif(i <= green_led_value)\r\n\t\t{\r\n\t\t\twhile (app_pwm_channel_duty_set(&PWM1, 1, i) == NRF_ERROR_BUSY);\r\n\t\t}\r\n\t\tif(i <= blue_led_value)\r\n\t\t{\r\n\t\t\twhile (app_pwm_channel_duty_set(&PWM2, 0, i) == NRF_ERROR_BUSY);\r\n\t\t}\t\r\n\t\tnrf_delay_ms(10);\r\n\t}\r\n\r\nThis should make the RGB LED that I have on my board glow to a bright white. Instead my RGB turns yellow and gets stuck at:\r\n\r\n    while (app_pwm_channel_duty_set(&PWM2, 0, i) == NRF_ERROR_BUSY);\r\n\r\nIts almost as if the app_pwm_enable(&PWM2) call didn't turn the second channel of my PWM module back on.\r\n\r\nHere is the Timers section of the nrf_drv_config.h file for reference:\r\n\r\n    /* TIMER */\r\n    #define TIMER0_ENABLED 0\r\n\r\n    #if (TIMER0_ENABLED == 1)\r\n    #define TIMER0_CONFIG_FREQUENCY    NRF_TIMER_FREQ_16MHz\r\n    #define TIMER0_CONFIG_MODE         TIMER_MODE_MODE_Timer\r\n    #define TIMER0_CONFIG_BIT_WIDTH    TIMER_BITMODE_BITMODE_32Bit\r\n    #define TIMER0_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n    #define TIMER0_INSTANCE_INDEX      0\r\n    #endif\r\n\r\n    #define TIMER1_ENABLED 1\r\n\r\n    #if (TIMER1_ENABLED == 1)\r\n    #define TIMER1_CONFIG_FREQUENCY    NRF_TIMER_FREQ_16MHz\r\n    #define TIMER1_CONFIG_MODE         TIMER_MODE_MODE_Timer\r\n    #define TIMER1_CONFIG_BIT_WIDTH    TIMER_BITMODE_BITMODE_16Bit\r\n    #define TIMER1_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n    #define TIMER1_INSTANCE_INDEX      (TIMER0_ENABLED)\r\n    #endif\r\n \r\n    #define TIMER2_ENABLED 1\r\n\r\n    #if (TIMER2_ENABLED == 1)\r\n    #define TIMER2_CONFIG_FREQUENCY    NRF_TIMER_FREQ_16MHz\r\n    #define TIMER2_CONFIG_MODE         TIMER_MODE_MODE_Timer\r\n    #define TIMER2_CONFIG_BIT_WIDTH    TIMER_BITMODE_BITMODE_16Bit\r\n    #define TIMER2_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n    #define TIMER2_INSTANCE_INDEX      (TIMER1_ENABLED+TIMER0_ENABLED)\r\n    #endif\r\n\r\n    #define TIMER_COUNT (TIMER0_ENABLED + TIMER1_ENABLED + TIMER2_ENABLED)\r\n\r\n\r\nDo you have any thoughts or suggestions as to why my PWM module isn't working as expected? Any help or advice you can offer is greatly appreciated. I also need to mention that I am executing all of the LED patterns, PWM Enable, and PWM Disable calls using the scheduler.\r\n\r\nThanks for your help and support!\r\n\r\n-Cory",
    "tag": "pwm"
  },
  {
    "text": "IoT SDK connect  TWI(I2C) ?? **[Dev Env]**\r\n\r\nnRF51 DK\r\n\r\nIoT SDK 0.8\r\n\r\nIoT SoftDevice\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**[Question]**\r\n\r\nanybody help me.\r\n\r\nIn Iot SDK  can't access TWI interface? \r\nany Sample ??\r\n\r\n**[HardFault_Handler](/attachment/e9caf731369ef125740099da8e67e3b9)(/attachment/fbd403f1c1c47dcb2a8365c80f82a589)** \r\n\r\nbool twi_master_init(void)\r\n{\r\n.\r\n.\r\nNRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n.\r\n.\r\n}\r\n\r\n\r\nlike :: \r\nhttps://devzone.nordicsemi.com/blogs/710/iot-contest-mini-weather-station-project/",
    "tag": "i2c"
  },
  {
    "text": "IoT SDK connect  TWI(I2C) ?? **[Dev Env]**\r\n\r\nnRF51 DK\r\n\r\nIoT SDK 0.8\r\n\r\nIoT SoftDevice\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**[Question]**\r\n\r\nanybody help me.\r\n\r\nIn Iot SDK  can't access TWI interface? \r\nany Sample ??\r\n\r\n**[HardFault_Handler](/attachment/e9caf731369ef125740099da8e67e3b9)(/attachment/fbd403f1c1c47dcb2a8365c80f82a589)** \r\n\r\nbool twi_master_init(void)\r\n{\r\n.\r\n.\r\nNRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n.\r\n.\r\n}\r\n\r\n\r\nlike :: \r\nhttps://devzone.nordicsemi.com/blogs/710/iot-contest-mini-weather-station-project/",
    "tag": "twi"
  },
  {
    "text": "IoT SDK connect with TWI(I2C) ?? **[Dev Env]**\r\n\r\nnRF51 DK\r\n\r\nIoT SDK 0.8\r\n\r\nIoT SoftDevice\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**[Question]**\r\n\r\nanybody help me.\r\n\r\nIn Iot SDK  can't access TWI interface? \r\nany Sample ??\r\n\r\n**[HardFault_Handler]** \r\n\r\nbool twi_master_init(void)\r\n{\r\n.\r\n.\r\nNRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n.\r\n.\r\n}\r\n\r\n\r\nlike :: \r\nhttps://devzone.nordicsemi.com/blogs/710/iot-contest-mini-weather-station-project/\r\n\r\n(/attachment/e9caf731369ef125740099da8e67e3b9)(/attachment/fbd403f1c1c47dcb2a8365c80f82a589)",
    "tag": "i2c"
  },
  {
    "text": "IoT SDK connect with TWI(I2C) ?? **[Dev Env]**\r\n\r\nnRF51 DK\r\n\r\nIoT SDK 0.8\r\n\r\nIoT SoftDevice\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**[Question]**\r\n\r\nanybody help me.\r\n\r\nIn Iot SDK  can't access TWI interface? \r\nany Sample ??\r\n\r\n**[HardFault_Handler]** \r\n\r\nbool twi_master_init(void)\r\n{\r\n.\r\n.\r\nNRF_PPI->CH[0].EEP        = (uint32_t)&NRF_TWI1->EVENTS_BB;\r\n.\r\n.\r\n}\r\n\r\n\r\nlike :: \r\nhttps://devzone.nordicsemi.com/blogs/710/iot-contest-mini-weather-station-project/\r\n\r\n(/attachment/e9caf731369ef125740099da8e67e3b9)(/attachment/fbd403f1c1c47dcb2a8365c80f82a589)",
    "tag": "twi"
  },
  {
    "text": "Using twi_hw_master.c to read from an I2C device Hello everyone, I'm severely struggling to perform a simple task. I must be missing a very simple answer and, I hope with your help that I resolve the issue.\r\n\r\nI am trying to perform write and read commands to my i2c device. I am using the twi_hw_master.c file to perform some of the low level handling. I have my i2c device hooked up to pins 5 (sda) and 6 (scl). I am relying on the internal pull up resistors within the nrf51 for communication. \r\n\r\nAt the moment, I am seeing that the i2c device becomes unable to read from the device (possibly locking up). It then performs a hardware reinitialization for the twi device on the nrf51. \r\n\r\nIf I understand the twi_hw_master file and my i2c device, I believe that I have to call the twi_master_transfer() function twice for a i2c read command. \r\n\r\nOnce, to write the address+W bit followed by the register address that I want to read (with out a stop bit) and, then \r\nA second time to read a byte from the I2c Device (followed by a stop bit).\r\n\r\nTo make this neat and handle problems during mid messages, I created a class to perform a combination of read and write commands. This way, if I failed during the first or second twi_master_transfer function call, I can repeat the process to get the data that I want. \r\n\r\nThe problem I am experiencing is that the TWI1->ERROR event is being set every time it performs the i2c read command.\r\n\r\nSorry for the long description, I feel like I've been banging my head on this problem for far too long. \r\n\r\nUpdated: 9/28/15 - 11:31am\r\nAs requested, Here is more information. \r\n\r\nWhen I used the new drivers, I was getting stuck in an NRF_BUSY_ERROR loop. It could be how I am implementing the driver. After trying for weeks trying to resolve, it's hard for me to think of the things that I haven't tried. I looked into the sample that you provided. The differences that I saw was that most of my code is c++. Which is fine, I added some extern \"C\" definitions and, I was able to implement the provided code. I'm still looking into implementing the sample code, so more information on this later.\r\n\r\nMy slave device is an ITG3701 gyroscope from invensense.\r\n\r\nI am using the nrf51 DK. pca10028. I believe its the nrf51822. Upon further inspection, the nrf chip itself reads nrf51422 which I found surprising. \r\n\r\nI have the S130 softdevice loaded on the chip, however, I am not using it. I have two different programs that I working developing. One involves me communicating over BLE and, one that just needs to communicate to a pc (USB) via UART. I understand that it may be excessive to load the softdevice but, my code doesn't like to compile (more like link) without the correct linking script.\r\n\r\nI'll have to consider the pull up resistors. However, before I started this morning changing my code to the nrf sdk drivers, I remember that I was successful in writing to the device. On a side note, I was able to get the read functionality working intermittently by adding a small delay. I added the delay after writing to the device the register that I want data from and before the i2c read command. I.e. ...\r\n\r\n        do{\r\n\t\t    do{\r\n\t\t\t   bSuccess = twi_master_transfer(((slaveAddr<<1)&0xfe), message, 1, false);\r\n\t\t    }while( bSuccess != true );\t\r\n\t\tnrf_delay_us(5);\r\n\t\tbSuccess = twi_master_transfer(((slaveAddr<<1)|0x1),data,length,true);\r\n\t}while( bSuccess != true);\t\t\t//start a read i2c sequence\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "TWI read issue Hello,\r\n\r\nI am using nRF51822 EK board with SDK 9.0 and wrote a eeprom driver using I2C driver without softdevice.\r\n\r\nI am able to write the data to the specified address (checked the signals on data lines) and but not able to read back.\r\n\r\nCode for write and read are as follows:\r\n\r\n    void write_eeprom(uint8_t Slave_ID, uint16_t address, uint8_t * pucBuffer, uint32_t ulLength)\r\n    {\r\n     ret_code_t ret_code; \r\n     const nrf_drv_twi_t           p_twi_instance = NRF_DRV_TWI_INSTANCE(1);\r\n     Slave_ID |= 0x00;\r\n     tx_buffer[0] = (address  >> 8) & 0xFF;\r\n     tx_buffer[1] = address & 0xFF;\r\n     memcpy(&tx_buffer[2], pucBuffer, ulLength);\r\n     ret_code = nrf_drv_twi_tx(&p_twi_instance, Slave_ID, tx_buffer, ulLength + 2, false);\r\n     }\r\n\r\n    void read_eeprom(uint8_t Slave_ID, uint16_t address, uint8_t * pucBuffer, uint32_t ulLength)\r\n    {\r\n      ret_code_t ret_code; \r\n      const nrf_drv_twi_t           p_twi_instance = NRF_DRV_TWI_INSTANCE(1);\r\n      uint8_t temp_ID;\r\n      temp_ID = Slave_ID | 0x00;\r\n      tx_buffer[0] = (address  >> 8) & 0xFF;\r\n      tx_buffer[1] = address & 0xFF;\r\n   \r\n      ret_code = nrf_drv_twi_tx(&p_twi_instance, temp_ID, tx_buffer, 3, false);   \r\n      nrf_delay_ms(50); \r\n      temp_ID = Slave_ID | 0x01;\r\n      ret_code = nrf_drv_twi_rx(&p_twi_instance, temp_ID, rx_buffer, ulLength + 1, false);\r\n    }\r\n\r\nFor read, after address written with slave id, slave id with read data has to be sent. But I am not getting the byte (address + Read).\r\n\r\nCan anyone help me with I2C read operation?\r\n\r\nRegards,\r\n\r\nSowmya\r\n",
    "tag": "twi"
  },
  {
    "text": "TWI read issue Hello,\r\n\r\nI am using nRF51822 EK board with SDK 9.0 and wrote a eeprom driver using I2C driver without softdevice.\r\n\r\nI am able to write the data to the specified address (checked the signals on data lines) and but not able to read back.\r\n\r\nCode for write and read are as follows:\r\n\r\n    void write_eeprom(uint8_t Slave_ID, uint16_t address, uint8_t * pucBuffer, uint32_t ulLength)\r\n    {\r\n     ret_code_t ret_code; \r\n     const nrf_drv_twi_t           p_twi_instance = NRF_DRV_TWI_INSTANCE(1);\r\n     Slave_ID |= 0x00;\r\n     tx_buffer[0] = (address  >> 8) & 0xFF;\r\n     tx_buffer[1] = address & 0xFF;\r\n     memcpy(&tx_buffer[2], pucBuffer, ulLength);\r\n     ret_code = nrf_drv_twi_tx(&p_twi_instance, Slave_ID, tx_buffer, ulLength + 2, false);\r\n     }\r\n\r\n    void read_eeprom(uint8_t Slave_ID, uint16_t address, uint8_t * pucBuffer, uint32_t ulLength)\r\n    {\r\n      ret_code_t ret_code; \r\n      const nrf_drv_twi_t           p_twi_instance = NRF_DRV_TWI_INSTANCE(1);\r\n      uint8_t temp_ID;\r\n      temp_ID = Slave_ID | 0x00;\r\n      tx_buffer[0] = (address  >> 8) & 0xFF;\r\n      tx_buffer[1] = address & 0xFF;\r\n   \r\n      ret_code = nrf_drv_twi_tx(&p_twi_instance, temp_ID, tx_buffer, 3, false);   \r\n      nrf_delay_ms(50); \r\n      temp_ID = Slave_ID | 0x01;\r\n      ret_code = nrf_drv_twi_rx(&p_twi_instance, temp_ID, rx_buffer, ulLength + 1, false);\r\n    }\r\n\r\nFor read, after address written with slave id, slave id with read data has to be sent. But I am not getting the byte (address + Read).\r\n\r\nCan anyone help me with I2C read operation?\r\n\r\nRegards,\r\n\r\nSowmya\r\n",
    "tag": "i2c"
  },
  {
    "text": "AIN2: Switch between ADC and LPCOMP, AIN4: Battery **Situation:**\r\n    We are building BLE device that have GATT service showing a analog sensor value.\r\n    AIN2 is connected to the sensor. AIN4 is connected to battery.\r\n    We would like to stop BLE advertising while the sensor value continue to be low, and restart when the value raise. So, we switch to LPCOMP peripheral for AIN2 when the sensor value become low.\r\n\r\n   We are using nrf51822 on SDK 8.0.0.\r\n\r\n**Problem:**\r\n   The switching between ADC and LPCOMP itself works well. However, while LPCOMP is on, AIN4 do not measure battery value correctly. And it seems to be the sensor value.\r\n\r\n\r\nI read [this article](https://devzone.nordicsemi.com/question/22244/can-i-really-not-use-lpcomp-and-adc-at-the-same-time/). But I think it is a little bit different situation. It does not switch the functions on the same pin.\r\n\r\nWe are happy if you have any advice.\r\nIf you need sample code, I am preparing simple version for this situation.\r\n",
    "tag": "adc"
  },
  {
    "text": "Does the SPIS clear its END interrupt when a new transaction starts? Dear all,\r\n\r\nI have written some code that controls the SPIS and allows it to transfer data as if it were a master. I am generating the SPIS clock from one timer, and I am looping back a pin to control the CSN line for the SPIS. The CSN is controlled by a high priority interrupt source, and my SPIS interrupt is a low priority interrupt. In the high priority interrupt source I am deasserting the CSN line, grabbing the read data and putting it in a FIFO and then reasserting the CSN pin. I know in this interrupt that all the data will be transferred.\r\n\r\nIn doing this I do not get an SPIS interrupt being generated. I do see it if the CSN pin is not toggled quite so fast n other sections of my code. I do get repeating transfers of data using this method.\r\n\r\nIs this a known issue? I was expecting the END interrupt to be latching, not dependent on whether a new transaction had been started. Similarly, I am releasing the semaphore in this high level interrupt too.\r\n\r\nInterested in your response,\r\n\r\nPeter",
    "tag": "interrupt"
  },
  {
    "text": "interrupt based i2c with softdevice Hello,\r\n\r\nI am using SDK 9.0 and softdevice 8.0 and testing on Evaluation board.\r\nI referred the i2c example driver suggested by Torbjorn in [this link](https://devzone.nordicsemi.com/question/13447/interrupt-driven-twi-master/)\r\n\r\nI wrote a simple driver for eeprom and succeeded without the softdevice.\r\nBut when I integrate with the softdevice, data is neither writing nor reading from eeprom. I am not getting i2c interrupts.\r\n\r\nCan anyone help me procedure for i2c driver with softdevice?\r\n\r\nUpdate: It is working when I commented the sd_nvic_SetPriority(SPI0_TWI0_IRQn, 1); and enabled using NVIC. \r\nI am using template application workspace and integrated i2c driver. But now BT is not advertising. The voltage on the board is 3.3V. Can anyone help me regarding drivers with BT stack?\r\n\r\n\r\nRegards,\r\nSowmya",
    "tag": "twi"
  },
  {
    "text": "NRF51822 SPI SS PIN control Dear all:\r\n\r\nI want to use nrf51822's spi function to communicate with slave device.\r\nI use  SPI_master.c  And  use  oscilloscope to check the pin's timing.\r\nThe SS PIN's signal  goes low when start to SPI ,and goes high as SPI end.\r\nIt works good.But my device  works in  the contrary way.\r\nIt needs SS PIN goes high when SPI start to communicate ,and goes low when SPI ended.\r\n\r\n\r\nI check the code in the example, SPI_master.c  in the function  spi_master_send_recv\r\n\r\nuint32_t spi_master_send_recv(const spi_master_hw_instance_t spi_master_hw_instance,\r\n                              uint8_t * const p_tx_buf, const uint16_t tx_buf_len,\r\n                              uint8_t * const p_rx_buf, const uint16_t rx_buf_len)\r\n{\r\n    #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)\r\n\r\n    volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(\r\n        spi_master_hw_instance);\r\n    APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);\r\n\r\n    uint32_t err_code   = NRF_SUCCESS;\r\n    uint16_t max_length = 0;\r\n    \r\n    uint8_t nested_critical_region = 0;\r\n    \r\n    //Check if disable all IRQs flag is set\r\n    if (p_spi_instance->disable_all_irq)\r\n    {\r\n        //Disable interrupts.\r\n        APP_ERROR_CHECK(sd_nvic_critical_region_enter(&nested_critical_region));\r\n    }\r\n    else\r\n    {\r\n        //Disable interrupt SPI.\r\n        APP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type));\r\n    }\r\n\t\t//nrf_gpio_pin_write(24,0);\r\n    //Initialize and perform data transfer\r\n    if (p_spi_instance->state == SPI_MASTER_STATE_IDLE)\r\n    {\r\n        max_length = (rx_buf_len > tx_buf_len) ? rx_buf_len : tx_buf_len;\r\n\r\n        if (max_length > 0)\r\n        {\r\n            p_spi_instance->state        = SPI_MASTER_STATE_BUSY;\r\n            p_spi_instance->bytes_count  = 0;\r\n            p_spi_instance->started_flag = false;\r\n            p_spi_instance->max_length   = max_length;\r\n\r\n            /* Initialize buffers */\r\n            spi_master_buffer_init(p_tx_buf,\r\n                                   tx_buf_len,\r\n                                   &(p_spi_instance->p_tx_buffer),\r\n                                   &(p_spi_instance->tx_length),\r\n                                   &(p_spi_instance->tx_index));\r\n            spi_master_buffer_init(p_rx_buf,\r\n                                   rx_buf_len,\r\n                                   &(p_spi_instance->p_rx_buffer),\r\n                                   &(p_spi_instance->rx_length),\r\n                                   &(p_spi_instance->rx_index));\r\n\r\n            nrf_gpio_pin_clear(p_spi_instance->pin_slave_select);\r\n            spi_master_send_initial_bytes(p_spi_instance);\r\n        }\r\n        else\r\n        {\r\n            err_code = NRF_ERROR_INVALID_PARAM;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        err_code = NRF_ERROR_BUSY;\r\n    }\r\n    //\tnrf_gpio_pin_write(24,1);\r\n    //Check if disable all IRQs flag is set.\r\n    if (p_spi_instance->disable_all_irq)\r\n    {   \r\n        //Enable interrupts.\r\n        APP_ERROR_CHECK(sd_nvic_critical_region_exit(nested_critical_region));\r\n    }\r\n    else\r\n    {\r\n        //Enable SPI interrupt.\r\n        APP_ERROR_CHECK(sd_nvic_EnableIRQ(p_spi_instance->irq_type));\r\n    }\r\n\r\n    return err_code;\r\n    #else\r\n    return NRF_ERROR_NOT_SUPPORTED;\r\n    #endif\r\n}\r\n\r\n\r\n\r\nThere is  nrf_gpio_pin_clear(p_spi_instance->pin_slave_select);\r\nbut where is the command that make  pin_slave_select goes high?\r\n\r\nCould someone tell me,please. I have looking for it for couple  of days...Thank you all.\r\n",
    "tag": "spi"
  },
  {
    "text": "The upper limit of incoming signal frequency when using NRF_TIMER1 as counter I am using NRF_TIMER1 with 16-bit mode and prescaler of 0 as a counter, to count the pulses of an incoming square wave signal in a given time window. What is the upper limit of the incoming frequency for NRF_TIMER1 acting stably? ",
    "tag": "timer"
  },
  {
    "text": "nRF52 vs nRF51 we will do some measurments and answer when we get some time to spare for this. Others are welcome to answer/comment freely about their experiences/knowledge.",
    "tag": "pwm"
  },
  {
    "text": "Timer under 5ms Hello,\r\n\r\nI have added a timer to my code, which I need to be of 1ms. The handler of the timer is correctly called when the timer is 5ms or above. However, if I change it to less than 5ms the handler is never called.\r\n\r\nHere is some of the code I used (using softdevice):\r\n\r\n\r\n    [...]\r\n\r\n    static app_timer_id_t timtecil;\r\n    uint32_t counter=0;\r\n    \r\n    void timtecil_handler(void * p_context)\r\n    {\r\n    \tUNUSED_PARAMETER(p_context);\r\n    \tcounter++;\r\n    }\r\n\r\n    [...]\r\n\r\n    int main(void)\r\n    {\r\n    [...]\r\n        \r\n    err_code=app_timer_create(&timtecil,APP_TIMER_MODE_REPEATED,timtecil_handler);\r\n    err_code=app_timer_start(timtecil,APP_TIMER_MULTIPLICADOR*0.001,NULL);\r\n    \r\n    [...]\r\n    \r\n        for (;;)\r\n        {\r\n            app_sched_execute();\r\n            power_manage(); \r\n    \t\t\t\t\r\n        }\r\n    \r\n    }\r\n\r\n\r\nThe constant APP_TIMER_MULTIPLICADOR (= 1024) is used to match the necessary number of ticks so I write only the period in seconds. I use APP_TIMER_PRESCALER = 31  (so the shortest timer possible is 0,000976563 seconds).\r\n\r\n\r\nAny explanation?\r\n\r\nThank you very much.",
    "tag": "timer"
  },
  {
    "text": "Problem with timer less than 5ms Hello,\r\n\r\nI have added a timer to my code, which I need to be of 1ms. The handler of the timer is correctly called when the timer is 5ms or above. However, if I change it to less than 5ms the handler is never called.\r\n\r\nHere is some of the code I used (using softdevice):\r\n\r\n\r\n    [...]\r\n\r\n    static app_timer_id_t timtecil;\r\n    uint32_t counter=0;\r\n    \r\n    void timtecil_handler(void * p_context)\r\n    {\r\n    \tUNUSED_PARAMETER(p_context);\r\n    \tcounter+;\r\n    }\r\n\r\n    [...]\r\n\r\n    int main(void)\r\n    {\r\n    [...]\r\n        \r\n    err_code=app_timer_create(&timtecil,APP_TIMER_MODE_REPEATED,timtecil_handler);\r\n    err_code=app_timer_start(timtecil,APP_TIMER_MULTIPLICADOR*0.001,NULL);\r\n    \r\n    [...]\r\n    \r\n        for (;;)\r\n        {\r\n            app_sched_execute();\r\n            power_manage(); \r\n    \t\t\t\t\r\n        }\r\n    \r\n    }\r\n\r\n\r\nThe constant APP_TIMER_MULTIPLICADOR is used to match the necessary number of ticks so I write only the period in seconds. I use APP_TIMER_PRESCALER = 31  (so the shortest timer possible is 0,000976563 seconds).\r\n\r\n\r\nAny explanation?\r\n\r\nThank you very much.",
    "tag": "timer"
  },
  {
    "text": "nRF51822 SPI master Hi!\r\n\r\nI have custom board with nRF51822 and I need to communicate with serial flash W25X40 using SPI master example with SoftDevice enabled (S110 is used). I worked with serial flashes before but didn't encountered the problems described below.\r\n\r\nDuring debugging I figured out that after first execution of the **spi_master_send_recv** function all subsequent transfers use original values of the TX buffer.\r\n\r\nHere's example that explains what I mean:\r\n\r\nTX and RX buffers are declared as global arrays:\r\n\r\n    uint8_t tx_data[5] = {0x00, 0x00, 0x00, 0x00, 0x00}  // Transmit buffer\r\n    uint8_t rx_data[4]; // Receive buffer\r\n\r\nThen after standard procedures I initialize SPI interface:\r\n\r\n    leds_init();\r\n    buttons_init();\r\n    ble_stack_init();\r\n\r\n    timers_init();\r\n    device_manager_init();\r\n    gap_params_init();\r\n    advertising_init();\r\n    services_init();\r\n    sensor_sim_init();\r\n    conn_params_init();\r\n\r\n    // Start execution.\r\n    application_timers_start();\r\n    advertising_start();\t\r\n    spi_master_init(SPI_MASTER_0, spi_master_event_handler, false);\r\n\r\nAfter that two transfers are being executed in endless loop, the first one reads chip info and the second should read one byte located at address 0x000000:\r\n\r\n    for (;; )\r\n\t\t{\t\r\n\t\t\ttx_data[0] = 0x9F;\r\n\t\t\tspi_master_send_recv(SPI_MASTER_0, tx_data, 1, rx_data, 4);\r\n\t\t\ttx_data[0] = 0x03;\r\n\t\t\tspi_master_send_recv(SPI_MASTER_0, tx_data, 4, rx_data, 1);\r\n\t\t\tpower_manage();\t\t\t\r\n\t\t}\r\n\r\nThe first transfer returns correct values according to the datasheet. The problem I mentioned above is that the second transfer uses value 0x9F rather than 0x03 as if SPI master instance references to the saved copy of original array - this was revealed when I stepped in the function and watched actual TX buffer values.\r\n\r\nSo far I have two questions:\r\n\r\n1. How should I modify values of the TX buffer after first using of **spi_master_send_recv** function?\r\n2. Do I use **spi_master_send_recv** function correctly for reading data from serial flash?\r\n\r\nThanks!",
    "tag": "spi"
  },
  {
    "text": "is byte boundary/ suspend necessary for twi ? I'm struggling in implemented interrupt driven twi.\r\n\r\nI found it always returned a overrun error after a successful RXD.\r\n\r\nI saw an implementation by nordic employee in the devzone. I found they use byte boundary and resume mechanism.\r\n\r\nSo I  ask this BB/ Resume mechanism is what the CPU clock stretching mentioned in Reference Manual? So BB / Resume is required for RX ?\r\n\r\nMy sequences :\r\n\r\n    TXD:75\r\n    byte boundary\r\n    txd sent\r\n    byte boundary\r\n    rxdready\r\n    issuing stop  // I2C_REG->TASKS_STOP = 1;\r\n    RXD:0x68    // uint8_t d = I2C_REG->RXD;\r\n    rxdready     // I think this is the wrong status due to read RXD, regardless if I set stop flag \r\n    stopped      // EVENTS_STOP\r\n    error src: OVERRUN\r\n    I2C_EVENT_ERROR\r\n    byte boundary",
    "tag": "twi"
  },
  {
    "text": "Question about strange behavior of Timer0 I want to use timer0 to get exact time delay (without soft device used). \r\n\r\nTimer0 configuration is as\r\n\r\n    void timer0_initialization(void)\r\n    {\r\n      NRF_TIMER0->MODE = TIMER_MODE_MODE_Timer;\r\n      NRF_TIMER0->PRESCALER = 0;\r\n      NRF_TIMER0->BITMODE = TIMER_BITMODE_BITMODE_32Bit;\r\n      NRF_TIMER0->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\r\n      NRF_TIMER0->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;\r\n      NRF_TIMER0->TASKS_STOP = 1;\r\n    }\r\n\r\nthe test main function is as \r\n\r\n    int main(void)\r\n    {\r\n      uint32_t i;\r\n      uint32_t time_capture[10];\r\n      \r\n     /* UART and RTC0 initialization */\r\n      \r\n      printf (\"---------------------------------- Start ---------------------------------- \\r\\n\");\r\n      timer0_initialization( );      \r\n      \r\n      NRF_TIMER0->CC[0] = 1000 * 16;\r\n      NRF_TIMER0->TASKS_START = 1;\r\n            \r\n      for (i=0; i<10; i++)\r\n      {  \r\n        NRF_TIMER0->EVENTS_COMPARE[0] = 0;\r\n        time_capture[i] = NRF_RTC0->COUNTER;\r\n        while (NRF_TIMER0->EVENTS_COMPARE[0] == 0)\r\n        {    \r\n           /* delay 1ms */    \r\n        }\r\n      }\r\n      for (i=1; i<10; i++)\r\n      {\r\n        printf(\"i = %ld, time delay = %ld, \\r\\n\", i, time_capture[i] - time_capture[i - 1]); \r\n      }\r\n      \r\n      while(1);\r\n    }\r\n\r\nSince RTC0's frequency is 32K, so the output of \"printf\" time delay should be about 30 (1000/32.768), moreover, each time delay should be the same. However, the first time delay is much difference than others. the output of above code is like\r\n\r\n    ---------------------------------- Start --------------------------------------- \r\n    i = 1, time delay = 8, \r\n    i = 2, time delay = 34, \r\n    i = 3, time delay = 34, \r\n    i = 4, time delay = 34, \r\n    i = 5, time delay = 34, \r\n    i = 6, time delay = 34, \r\n    i = 7, time delay = 34, \r\n    i = 8, time delay = 34, \r\n    i = 9, time delay = 34, \r\n\r\nIf add some time daly right after timer0 started like\r\n\r\n      NRF_TIMER0->CC[0] = 1000 * 16;\r\n      NRF_TIMER0->TASKS_START = 1;\r\n          \r\n    /* add some time delay */\r\n      nrf_delay_ms(10);\r\n      \r\n      for (i=0; i<10; i++)\r\n      {  \r\n        NRF_TIMER0->EVENTS_COMPARE[0] = 0;\r\n        time_capture[i] = NRF_RTC0->COUNTER;\r\n        while (NRF_TIMER0->EVENTS_COMPARE[0] == 0)\r\n        {        \r\n        }\r\n      }\r\n\r\nThe program output is like \r\n\r\n    ---------------------------------- Start --------------------------------------- \r\n    i = 1, time delay = 0, \r\n    i = 2, time delay = 34, \r\n    i = 3, time delay = 34, \r\n    i = 4, time delay = 34, \r\n    i = 5, time delay = 34, \r\n    i = 6, time delay = 34, \r\n    i = 7, time delay = 34, \r\n    i = 8, time delay = 34, \r\n    i = 9, time delay = 34, \r\n\r\nThe first time delay is 0, means no any time delay. \r\n\r\nFor \"nrf_delay_ms(100);\", \"nrf_delay_ms(1000);\", \"nrf_delay_ms(2000);\", the output are like following:\r\n\r\n    ---------------------------------- Start --------------------------------------- \r\n    i = 1, time delay = 2, \r\n    i = 2, time delay = 34, \r\n    i = 3, time delay = 34, \r\n    i = 4, time delay = 34, \r\n    i = 5, time delay = 34, \r\n    i = 6, time delay = 34, \r\n    i = 7, time delay = 34, \r\n    i = 8, time delay = 34, \r\n    i = 9, time delay = 34, \r\n    ---------------------------------- Start --------------------------------------- \r\n    i = 1, time delay = 27, \r\n    i = 2, time delay = 32, \r\n    i = 3, time delay = 33, \r\n    i = 4, time delay = 32, \r\n    i = 5, time delay = 33, \r\n    i = 6, time delay = 32, \r\n    i = 7, time delay = 33, \r\n    i = 8, time delay = 32, \r\n    i = 9, time delay = 33, \r\n    ---------------------------------- Start --------------------------------------- \r\n    i = 1, time delay = 21, \r\n    i = 2, time delay = 33, \r\n    i = 3, time delay = 32, \r\n    i = 4, time delay = 33, \r\n    i = 5, time delay = 32, \r\n    i = 6, time delay = 33, \r\n    i = 7, time delay = 32, \r\n    i = 8, time delay = 33, \r\n    i = 9, time delay = 32, \r\n\r\nIt seems the first time delay is a random number. These result is obtained from nRF52832 preview DK board, the similar result is obtain with nRF51822 board.\r\n\r\nHow to understand this results of timer0?  is there any bug in my code?\r\n\r\nThanks a lot!",
    "tag": "timer"
  },
  {
    "text": "Best way to implement system clock on nRF51 Hi everybody,\r\n\r\na while ago I used the approach proposed here https://devzone.nordicsemi.com/question/6540/nrf51822-long-time-timekeeping/ to keep the date and time on a NRF51822 device while using Softdevice S110 and the Timeslot advertiser-scanner (https://github.com/NordicSemiconductor/nRF51-multi-role-conn-observer-advertiser).\r\n\r\nIn practice I created an app_timer timer that executes every 250 milliseconds (this is the resolution I wanted) and inside the handler I incremented some variables accordingly to keep date and time.\r\nThe problem is that I noticed that the time was not accurate, it was wrong, sometimes of several seconds, already after 1 hour. Here is the first question: I think that the time was wrong mainly because the app_timer handler gets delayed by the BLE stack, am I correct?\r\n\r\nMy idea to improve this is to connect an RTC1 COMPARE event to the TIMER1 COUNT task through PPI. The RTC1 will be configured to fire the event every second. This way I could keep the time in TIMER1 as a Unix timestamp (seconds since 1970-01-01) and I could read the number of milliseconds from RTC1 (I will use the number of ticks together with the prescaler to compute the milliseconds). This way there is no software handler involved and therefore it could not get delayed, is it correct? Is this going to be more precise than the solution using the app_timer? Will this solution consume more power? Do I need to keep on the 16MHz clock?\r\n\r\nThe implication of this solution is that I cannot use the app_timer library anymore or I could modify it to connect the RTC COMPARE event with the TIMER COUNT task and this should not interfere with the normal operation of the library, right?\r\n\r\nI could try to implement the solution but since I am not sure it will work I would like some feedback from you.\r\n\r\nThanks a lot.\r\nAlessandro",
    "tag": "timer"
  },
  {
    "text": "ADC result not changing I'm trying to set up the ADC to read a battery voltage but am unable to get the adc result to change regardless of whether the input line is connected to VDD or GND.  I'm using the nRF51-DK, and am configuring AIN5 for my ADC input.  I'm reading the ADC on a timer interrupt.  The timer works fine and I can set a breakpoint there to verify the ADC read occurs every 10 seconds.  Every ADC read gives me a result of around 0xCC whether AIN5 is connected to GND or VDD (~2.9V).  Looking at the nRF51422 Product Spec, it says that AIN5 is P0.04.  This is the pin that I am switching between GND and VDD.  I've also verified that LPCOMP is disabled so there is no contention here.  I'm using SDK9 with the S110 SoftDevice.  Here's my ADC configuration code - battery_init() is called from main(). \r\n  Am I missing a configuration somewhere?\r\n  Thanks.\r\n\r\n    #include <stdint.h>\r\n    #include \"nordic_common.h\"\r\n    #include \"nrf.h\"\r\n    #include \"nrf_soc.h\"\r\n    #include \"nrf_adc.h\"\r\n    #include \"app_error.h\"\r\n    #include \"nrf51_bitfields.h\"\r\n    #include \"app_timer.h\"\r\n\r\n    #define ADC_REF_VOLTAGE_IN_MILLIVOLTS   1200                                         /**< Reference voltage (in milli volts) used by ADC while doing conversion. */\r\n    #define ADC_PRE_SCALING_COMPENSATION    3                                            /**< The ADC is configured to use VDD with 1/3 prescaling as input. And hence the result of conversion is to be multiplied by 3 to get the actual value of the battery voltage.*/\r\n    #define BATTERY_LEVEL_MEAS_INTERVAL     APP_TIMER_TICKS(10000, APP_TIMER_PRESCALER) /**< Battery level measurement interval (ticks). This value corresponds to 10 seconds. */\r\n    #define ADC_RESULT_IN_MILLI_VOLTS(ADC_VALUE)\\\r\n        ((((ADC_VALUE) * ADC_REF_VOLTAGE_IN_MILLIVOLTS) / 255) * ADC_PRE_SCALING_COMPENSATION)\r\n\r\n    static app_timer_id_t _battery_timer_id;\r\n\r\n    static void adc_configure(void);\r\n    static void battery_level_meas_timeout_handler(void * p_context);\r\n\r\n\r\n    void battery_init(void)\r\n    {\r\n        uint32_t err_code;\r\n\r\n        // Create battery timer.\r\n        err_code = app_timer_create(&_battery_timer_id,\r\n                                APP_TIMER_MODE_REPEATED,\r\n                                battery_level_meas_timeout_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n\r\n        adc_configure();\r\n\r\n        // Start battery timer\r\n        err_code = app_timer_start(_battery_timer_id, BATTERY_LEVEL_MEAS_INTERVAL, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\n    static void adc_configure(void)\r\n    {\r\n        uint32_t err_code;\r\n        nrf_adc_config_t adc_config = NRF_ADC_CONFIG_DEFAULT;\r\n\r\n        // Configure ADC\r\n        adc_config.reference  = NRF_ADC_CONFIG_REF_VBG;\r\n        adc_config.resolution = NRF_ADC_CONFIG_RES_8BIT;\r\n        adc_config.scaling    = NRF_ADC_CONFIG_SCALING_SUPPLY_ONE_THIRD;\r\n        nrf_adc_configure(&adc_config);\r\n\r\n        // Select the battery level input\r\n        nrf_adc_input_select(NRF_ADC_CONFIG_INPUT_5);\r\n\r\n        // Enable ADC interrupt\r\n        nrf_adc_int_enable(ADC_INTENSET_END_Msk);\r\n        err_code = sd_nvic_ClearPendingIRQ(ADC_IRQn);\r\n        APP_ERROR_CHECK(err_code);\r\n\r\n        err_code = sd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);\r\n        APP_ERROR_CHECK(err_code);\r\n\r\n        err_code = sd_nvic_EnableIRQ(ADC_IRQn);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\n    static void battery_level_meas_timeout_handler(void * p_context)\r\n    {\r\n        UNUSED_PARAMETER(p_context);\r\n        nrf_adc_start();\r\n    }\r\n\r\n    void ADC_IRQHandler(void)\r\n    {\r\n        if (nrf_adc_conversion_finished())\r\n        {\r\n            uint8_t  adc_result;\r\n            static volatile uint16_t batt_lvl_in_milli_volts;\r\n\r\n            nrf_adc_conversion_event_clean();\r\n\r\n            adc_result = nrf_adc_result_get();\r\n\r\n            batt_lvl_in_milli_volts = ADC_RESULT_IN_MILLI_VOLTS(adc_result);\r\n        }\r\n    }\r\n\r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "nRF51822 ADC sensitivity Now, we are checking nRF51822 ADC sample program in SDK.\r\n\r\nWhen P0.1 input is lower than 0.7V, outputs is 0.\r\nWe are wondering if the performance is correct. \r\n\r\nCould you please make a comment ?\r\nIs ADC performance correct?\r\nOr, our hard ware have something wrong setting?\r\n\r\nThanks in advance.",
    "tag": "adc"
  },
  {
    "text": "Maximum notifications frequency Hello everyone,\r\n\r\nI am doing a project in which a nRF58122 is getting data of an accelerometer and an ADC. Those can be set a really high frequencies. The problem is, when I want to send the information through BLE to an android device. I send notifications of two characteristics (one 6 bytes and the other one 2 bytes).\r\n\r\nIf I take, for example, a frequency data rate of 20 Hz, I lose lots of packets. Is it normal? Which should be the maximum notification frequency before beginning to lose packets?\r\n\r\nThis is some code I use for the notification. This timer handler is called every time I want o send the notification again, for example every 0.05s (at 20Hz).\r\n\r\n        void timer_iforce_handler(void * p_context)\r\n    {\r\n    \t\r\n    \tUNUSED_PARAMETER(p_context);\r\n    \t\r\n    \tuint16_t len;\r\n    \t\r\n    \t\r\n    \t// Accelerometre notification\r\n    \tlen=6;\r\n    \treadAccelData();\r\n    \t\r\n    \t//Notification\r\n    \tble_gatts_hvx_params_t hvx_params;\r\n        memset(&hvx_params, 0, sizeof(hvx_params));\r\n    \r\n        hvx_params.handle = m_iforce.iforce_accelerometer_handles.value_handle;\r\n        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\r\n        hvx_params.offset = 0;\r\n        hvx_params.p_len  = &len;\r\n        hvx_params.p_data = accelData;\r\n    \r\n        sd_ble_gatts_hvx(m_zipconfig.conn_handle, &hvx_params);\r\n    \t\r\n    \t// ADC notification\r\n    \t\r\n    \tlen=2;\r\n    \tADS1120_check_and_read();\r\n    \t\r\n       //Notification\r\n\r\n        memset(&hvx_params, 0, sizeof(hvx_params));\r\n    \r\n        hvx_params.handle = m_iforce.iforce_straingauge_handles.value_handle;\r\n        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\r\n        hvx_params.offset = 0;\r\n        hvx_params.p_len  = &len;\r\n        hvx_params.p_data = rx_buffer;\r\n    \r\n        sd_ble_gatts_hvx(m_zipconfig.conn_handle, &hvx_params);\r\n    \t\r\n    }\r\n\r\nThank you very much!",
    "tag": "adc"
  },
  {
    "text": "pwm stop is not working First I want to mention, that I know about the pwm inverted issue.\r\n\r\nAbout my project:\r\n\r\nI have a switch which will start and stop a pwm signal. And I use a softdevice, because I also start and stop the pwm signal trough BLE.\r\n\r\nMy setup is:\r\n\r\n-nRF51DK\r\n\r\n-SDK 8.1\r\n\r\n-SoftDevice 8.0\r\n\r\nI have two functions(pwm_stop and pwm_start) for controling the pwm:\r\n\r\n    void pwm_stop(void)\r\n    {\r\n        app_pwm_disable(&PWM1);\t\t\t\t\t\t\t\t\r\n    }\r\n\r\n    void pwm_start(void)\r\n    {\r\n        app_pwm_enable(&PWM1);\r\n        while (app_pwm_channel_duty_set(&PWM1, 0, duty_cycle) == NRF_ERROR_BUSY); \r\n    }\r\n\r\nThe start and stop functions work perfectly.\r\n\r\nI know, that the first pwm after the initializiation can be inverted. So I will start the pwm in the PWMinit function:\r\n\r\n    static void PWMinit(void)\r\n    {\r\n        app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(9000L, 15);\r\n        pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH; \r\n        app_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n        app_pwm_enable(&PWM1);\r\n        while (app_pwm_channel_duty_set(&PWM1, 0, duty_cycle) == NRF_ERROR_BUSY);\r\n    }\r\n\r\nbut in the main, I stop the pwm after all initializations:\r\n\r\n    int main(void)\r\n    {\r\n        ...\r\n        // Start execution\r\n        timers_start();\r\n        err_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n        pwm_stop();\r\n    }\r\n\r\nThe problem is, that the pwm signal wont be stopped after the pwm_stop function. Strange is, this function is working fine, when I call it after a switch interrupt.\r\n\r\nHere you can see, that the pwm_stop function will be called.\r\n\r\n![image description](/attachment/8a51096ef51e84a9abdcaa92963cab38)\r\n\r\nAnd here you can see, that the pwm wont stop after the pwm_stop function\r\n\r\n![image description](/attachment/9c47f3653d95f9ce72717d40825b4944)\r\n\r\nCould somebody explain me, why the pwm wont stop when I call the pwm_stop function in the main. And why is it working when I change the switch? Its the same routine...\r\n\r\nIf there is an newer app_pwm library for SDK 8.0, could somebody attach it? ",
    "tag": "pwm"
  },
  {
    "text": "Timer Prescaler I have a problem enabling TIMER1:\r\nIf the prescaler is set between 16MHz and 2 MHz the firmware fails to enable the SoftDevice, even if I didn't manage TIMER0, but TIMER1 which should be dedicated to the softDevice.\r\nUsing a lower prescaler instead it works.\r\nI enable the timer before enabling SoftDevice.\r\n\r\nI am working on NRF51822 with softdevice S110 8.0.0.\r\n\r\nAm I doing ssomething wrong or not alloweed?\r\n\r\nThank you",
    "tag": "timer"
  },
  {
    "text": "Problem in twi/i2c communication receiving data Hi<br>\r\nI'm trying to communicate between nrf51-DK and arduino using twi. I was able to send data from nrf51-DK to arduino using nrf_drv_twi_tx but when I'm trying to send the data from arduino to DK, I'm unable to receive the data. Debugging on arduino side, I'm able to see that the data is being requested on the twi bus and arduino is sending it, but that data is not being displayed on DK side. I'm using the following code to receive the data.\r\n\r\n    uint32_t err_code;\r\n    nrf_drv_twi_config_t p_twi_config = NRF_DRV_TWI_DEFAULT_CONFIG(1);\r\n\t\r\n\terr_code = nrf_drv_twi_init(&p_twi, &p_twi_config, twi_event_handler);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\t\r\n\tnrf_drv_twi_enable(&p_twi);\r\n\r\n\tuint8_t tx_data[1] = {0x0D};\r\n\tuint8_t* rx_data;\r\n    while(1)\r\n    {    \r\n\t\terr_code = nrf_drv_twi_rx(&p_twi, 0x08, rx_data, 1, false);\r\n\t\tAPP_ERROR_CHECK(err_code);\r\n\t\t\r\n\t\tSEGGER_RTT_printf(0, \"rx_data is %x\\r\\n\", rx_data[0]);\r\n    }\r\n\r\nWhile debugging in Keil on DK side, I can see that EVENTS_RXDREADY is being set but there is no option to see the RXD buffer in the Keil debug window.<hr>\r\nOne odd thing is that I am using TI's TM75 temp sensor which uses twi and I'm able to read and write without any problem whereas in case of arduino i'm receiving only 0. Also I've tried different pullups with no success.\r\n**Where can I see the RXD buffer in Keil debug window? How can I view the err_code variale, debug window says \"not in scope\"? Also any ideas what I might be doing wrong**.<br>\r\n\r\n<hr>Here is the arduino code for reference\r\n\r\n    bool state = 0;\r\n    #include <Wire.h>\r\n\r\n    void setup()\r\n    {\r\n    Serial.begin(9600);\r\n    Wire.begin(0x08);                // join i2c bus with address #8\r\n    Wire.onRequest(requestEvent); // register event\r\n    pinMode(8, OUTPUT);\r\n    }\r\n\r\n    void loop()\r\n    {\r\n      delay(100);\r\n    }\r\n\r\n    // function that executes whenever data is requested by master\r\n    // this function is registered as an event, see setup()\r\n    void requestEvent()\r\n    {\r\n      Wire.write(\"abcd\"); // respond with message of 6 bytes\r\n      digitalWrite(8, state);\r\n      state = !state;\r\n      // as expected by master\r\n    }\r\nFor those who don't know what arduino is, it is a board based on atmega328, this code is given as an example code with twi library, so I' think that the code should be working without fail.<hr>",
    "tag": "twi"
  },
  {
    "text": "Where should the SPI master enable definition be set? (nRF51 SDK v9) The nRF51 SDK (version 9) documentation tells to activate SPI using the SPI_MASTER_0_ENABLE and SPI_MASTER_1_ENABLE macros. Where should these definitions be made? Other components seem to use nrf_drv_config.h for their configuration but spi_master does not include this file. Why is SPI treated differently?\r\n\r\n**Update:** In the meantime, SDK version 10 was released. There, the issue has been resolved and the new SPI driver offers a very easy way of configuration and usage. Further, both synchronous (blocking) and asynchronous (callback event) SPI operations are supported an SS handling of the driver can be disabled.",
    "tag": "spi"
  },
  {
    "text": "Timer 2 not working with Softdevice Hello,\r\n\r\nI have written a timer driver with timer 0 without SD and used 24 bit mode and it is working.\r\n\r\nBut when I used the same driver with softdevice and Timer 2 and 16 bit and changed the prescaler for one second interval, it is not working.\r\n\r\nHere is the code snippet:\r\n\r\n    NRF_TIMER2->TASKS_STOP = 1;   // Stop timer\r\n    NRF_TIMER2->MODE \t\t\t= TIMER_MODE_MODE_Timer;  // Set the timer in Normal Mode\r\n    NRF_TIMER2->BITMODE \t\t= TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n    NRF_TIMER2->PRESCALER \t= 11;\r\n    NRF_TIMER2->TASKS_CLEAR = 1;               // clear the task first to be usable for later\r\n    NRF_TIMER2->CC[1] \t\t= 7813;\t\t\t\t// set for 1 sec \r\n    // Enable interrupt on Timer 2\r\n    NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE1_Enabled\r\n\t\t\t\t\t\t\t\t\t<< TIMER_INTENSET_COMPARE1_Pos);\r\n    NRF_TIMER2->SHORTS \t\t= (TIMER_SHORTS_COMPARE1_CLEAR_Enabled\r\n\t\t\t\t\t\t\t\t\t<< TIMER_SHORTS_COMPARE1_CLEAR_Pos);\r\n    NVIC_EnableIRQ(TIMER2_IRQn);\r\n    NRF_TIMER2->TASKS_START = 1;\r\n\r\n\r\nI am getting the interrupts but not for one seconds.\r\n\r\nRegards,\r\nSowmya",
    "tag": "timer"
  },
  {
    "text": "Application Timer and Scheduler Tutorial files The attached [app_timer_scheduler_tutorial.zip](/attachment/47ea047409ae66faa58fe007845afe04) shall be used with the  [Application Timer and Scheduler Tutorial](https://devzone.nordicsemi.com/tutorials/19/).\r\n\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "SPI Slave CS resets nrf52? I am using the spi slave example code from SDK 0.9.2 and connect the board to an Atmel SAM4S who is the SPI master. I can see that every time the CS signal is released from the Atmel the nrf52 seems to reset. What could be the reason for that behavior?\r\nI'm connecting the SPI as follows:\r\n\r\nSPI CS:\tP0-12\r\n\r\nSPI SCL:\tP0-29\r\n\r\nSPI MOSI:\tP0-25\r\n\r\nSPI MISO:\tP0-28\r\n",
    "tag": "spi"
  },
  {
    "text": "pwm library continuous change with softdevice not working Hi Guys,\r\n\r\nonce again, I have strange behavior of my code.\r\n\r\nIn my code I try in loop after ble_event received change PWM from 0 to 255 for my motor device. In debug logs, I can see continuous change value with 100ms delay (I tried also 500ms), but instead of slowly speed-up I can not see any motor movement. Here comes weird things. Then I change value back from 255 -> 0 (on logs everything looks good) but motor start working at maximum. Based on observations, it seems, PWM react only on 1st change at the time because when I set only one value, it works like charm. \r\n\r\nThis is my setup: \r\n\r\n - nrf51822 rev. 3\r\n - Softdevice 8.0.0\r\n - SDK 9.0.0\r\n - pwm library (latest version), nrf_pwm_noglitch\r\n - PWM working in general\r\n\r\n\r\n\r\nDo you have any idea what is going on, or how should fix this issue?",
    "tag": "pwm"
  },
  {
    "text": "After removing linkloss alarm is not working in button click in android Hello,\r\nI am trying to play alarm in button click using nrf code. I am using Nordic nRF51822 device and trying to integrate with android device. When I am using linkloss then it is working good and when we press button in Nordic nRF51822 device then alarm is playing but when we remove linkloss method from code then it is not triggering alarm from button click.\r\n\r\nKindly help me how to resolve this issue.\r\n\r\n\r\nThanks\r\nAshutosh",
    "tag": "adc"
  },
  {
    "text": "Why SPI_POWER and SPIM with easyDMA appears in nrf51 SDK 9.0.0 ? In reference manual for nrf51x22, there is no SPI_POWER register and easy DMA support for SPI\r\n\r\nSo what is it for ?",
    "tag": "spi"
  },
  {
    "text": "SPI slave data offset I'm using the 0.9.2 SDK SPI slave example to connect to a SPI master (Atmel SAM4S). When I initiate a SPI transfer from the master side I can see that all the data arrives correctly on the nrf52 side (ABCDEFGHIJKLMNOP) every time. However, on the master side I get only ORC (0x55) characters. Now I did some experimenting and if I request less data than the buffer I do get some of the data on the master side but it looks to be offset by the amount minus one. Eg.\r\n\r\n> Sending(amount) - Received data(on\r\n> master):\r\n> \r\n> 1 Byte - a\r\n> \r\n> 2 Bytes - bc\r\n> \r\n> 5 Bytes - efghi\r\n\r\nDue to the fact that I see data on both sides I do not assume the SPI connection is faulty. Otherwise I would just see garbage. This is way to systematic of an issue.\r\nAnybody have an idea what could go wrong here? ",
    "tag": "spi"
  },
  {
    "text": "What can I expect when I set the BITMODE register? I know nrf51 timer0 can be configured for 16,8,24 and 32 bit modes\r\nand timer1 and timer2 can be configured for 16 and 8 bit modes.\r\n\r\nBut what can I expect the value to be when I select bitmode 32bits for timer2?\r\n\r\nwhat I think is happening is that timer1 and 2 only check bit 0 of the BITMODE register and ignore bit 1??\r\nWhen I set 32 bit mode (value 0x3) it will result in a 1 for bit 0.\r\nBut a 1 for bit 0 equals to 8 bit mode. \r\n\r\nIs this correct?",
    "tag": "timer"
  },
  {
    "text": "Play audio snippet via nRF51/52 I am working on a device which also needs to give audio feedback to the user.\r\nThe app on the mobile phone needs to send a wav (or similar) file (mono, speech) to the device and the device needs to play it through a small speaker.\r\n\r\nIs this possible with the nRF51/52 and if so can you direct me in what is needed for it to get it working (DAC, amplifier, how to transfer the data, (external)buffer/memory needed, etc?)\r\n\r\nThanks in advance!",
    "tag": "adc"
  },
  {
    "text": "Sequential calls to nrf_drv_twi_tx fails [SDK9] When calling `nrf_drv_twi_tx()` once like in the snippet below it works, but when the function is called two or more times sequentially, it fails. However running a `nrf_delay_ms()` delay between the calls makes it work again.\r\n\r\n**Works**\r\n\r\n    nrf_drv_twi_init(&twi, NULL, NULL); \r\n    nrf_drv_twi_enable(&twi);\r\n    nrf_drv_twi_tx(&twi, addr, &(buf[0]), buf_size, false);\r\n\r\n**Fails**\r\n\r\n    nrf_drv_twi_init(&twi, NULL, NULL); \r\n    nrf_drv_twi_enable(&twi);\r\n    nrf_drv_twi_tx(&twi, addr, &(buf[0]), buf_size, false);\r\n    nrf_drv_twi_tx(&twi, addt, &(buf[0]), buf_size, false);\r\n\r\n\r\n**Works again**\r\n\r\n    nrf_drv_twi_init(&twi, NULL, NULL); \r\n    nrf_drv_twi_enable(&twi);\r\n    nrf_drv_twi_tx(&twi, addr, &(buf[0]), buf_size, false);\r\n    nrf_delay_ms(10);\r\n    nrf_drv_twi_tx(&twi, addt, &(buf[0]), buf_size, false);\r\n\r\nIt fails simply by running the app_error_handler. Which spits out some corrupted data over the serial interface.\r\n\r\n**__Solved__**\r\n\r\nThe flash IC I'm using requires a 10ms wait between each write. Therefore the IC would NACK the second write if it hasn't been 10ms since the last write.\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "why APP_TIMER_APPSH_INIT not working i'm trying to blink led using timer, but nothing blink. I dont see the error in my  code\r\n\r\n    #define APP_TIMER_PRESCALER             0                                           /**< Value of the RTC1 PRESCALER register. */\r\n    #define APP_TIMER_MAX_TIMERS            6                                           /**< Maximum number of simultaneously created timers. */\r\n    #define APP_TIMER_OP_QUEUE_SIZE         7                                           /**< Size of timer operation queues. */\r\n    \r\n    #define SCHED_MAX_EVENT_DATA_SIZE       sizeof(app_timer_event_t)                 \r\n    #define SCHED_QUEUE_SIZE                10   \r\n    #define LED_BLINK_TIME\t\t\t\t\t\t\t     APP_TIMER_TICKS(1000, APP_TIMER_PRESCALER)  \r\n    void led_blink_timer_handler(void * p_context) {\r\n    \t    // blink code here\r\n    }\r\n    \r\n    \r\n    static void scheduler_init(void)\r\n    {\r\n        APP_SCHED_INIT(SCHED_MAX_EVENT_DATA_SIZE, SCHED_QUEUE_SIZE);\r\n    }\r\n    \r\n    \r\n    static void timers_init(void)\r\n    {\r\n        uint32_t err_code;  \r\n        APP_TIMER_APPSH_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, true);\r\n        err_code = app_timer_create(&m_led_blink_timer_id, APP_TIMER_MODE_REPEATED, led_blink_timer_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    static void timers_start(void)\r\n    {\r\n        uint32_t err_code;\r\n        err_code = app_timer_start(m_led_blink_timer_id, LED_BLINK_TIME, NULL);\r\n        APP_ERROR_CHECK(err_code); \t\r\n    }\r\n    \r\n    \r\n    /**@brief Function for application main entry.\r\n     */\r\n    int main(void)\r\n    {\r\n      nrf_gpio_cfg_output(LED_GREEN);\r\n    \t\t    \t\r\n    \ttimers_init();\r\n    \tnrf_gpio_pin_clear(LED_GREEN);\r\n        \r\n    \tscheduler_init();\r\n        timers_start();\r\n    \r\n          while (1>0) {\r\n    \t\t\t  app_sched_execute();\r\n    \t\t\t}\r\n    \t\r\n    \treturn 0;\r\n\r\n\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "[nRF51422] SPI Slave solution Hello,\r\n\r\nI'm using an external chip that decodes my RF transmission and outputs the data on two pins DAT, and CLK (data and clock). Currently I'm reading the data with GPIOTE, and was thinking about using SPI to collect the output.\r\n\r\nSPI Slave uses CS pin to control the data gathering, so is there any method to \"emulate\" the chip select pin without need of physical pin connected ? I'm trying to lower the current consumption as much as possible and just need to catch several milliseconds of transmission. ",
    "tag": "spi"
  },
  {
    "text": "[nRF51422] SPI Slave solution Hello,\r\n\r\nI'm using an external chip that decodes my RF transmission and outputs the data on two pins DAT, and CLK (data and clock). Currently I'm reading the data with GPIOTE, and was thinking about using SPI to collect the output.\r\n\r\nSPI Slave uses CS pin to control the data gathering, so is there any method to \"emulate\" the chip select pin without need of physical pin connected ? I'm trying to lower the current consumption as much as possible and just need to catch several milliseconds of transmission. ",
    "tag": "spi"
  },
  {
    "text": "GCC using app_pwm with -O0 -g3 (debug mode) cause unknown function Using and GCC with compilation options without optimization `-O0` and with debug `-g3` throw error during compiling for an unknown function `pwm_calculate_timer_frequency`.\r\n\r\nRemoving `inline` statement permits to compile, but I don't know if there is some side effects.\r\n\r\n//app_pwm.c, line 520\r\n\r\n    inline nrf_timer_frequency_t pwm_calculate_timer_frequency(uint32_t period_us)\r\n\r\nto \r\n\r\n    nrf_timer_frequency_t pwm_calculate_timer_frequency(uint32_t period_us)\r\n\r\nIs there someone to explain why?\r\n",
    "tag": "pwm"
  },
  {
    "text": "Very simple SPI bootloader Hi,\r\n\r\nI'm implementing a simple bootloader which will not use BLE.\r\n\r\n- Application will transfer the data from mobile devices using BLE and this data will be stored to external SPI flash memory. I've already managed to make writing/reading data over SPI.\r\n- Custom bootloader should only read and verify data from external SPI flash and write that data to nRF flash. Bootloader should be able to update any address on the chip except itself, meaning that we want this bootloader to be able to update SoftDevice also. After it flashes what it needs to flash, it should go into newly flashed application.\r\n\r\nI have trouble understanding vector mapping and how to do it right.\r\nCan someone please give an example with a bit more explanation?\r\n\r\nThnx!\r\n\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "TWI and MPU6050 Hi,\r\n\r\nI've been searching the devzone for TWI examples, and preferably an example with MPU6050. Here are a conclusion of stuff that I found, but as some of them were for 2013/2014 wanted to check first that no updated versions are available:\r\n\r\n- It seems the TWI example has been removed after SDK 6, but the drivers are still there. I'm using SDK 9 for PCA20006 (Beacon module).\r\n\r\n- There are twi_hw_master.c and twi_sw_master.c in drivers_nrf folder, which it seems the hw one doesn't work with Softdevice, but sw one works. Don't know what are the pro and cons of hw and sw.\r\n\r\n- In https://devzone.nordicsemi.com/question/309/best-place-to-get-started/ Alseth has provided a file named sd_twi_hw_master.c which seems will solve the issue with Softdevice. This was originally posted 2 years ago and re-uploaded one year ago. Don't know if the problem has been solved in future releases.\r\n\r\n- I can see a file named nrf_drv_twi.c in the twi_master folder, which was not mentioned in any of the posts that I looked at. Is this a new addition? \r\n\r\n- There are drivers specifically for MPU6050 as explained in https://devzone.nordicsemi.com/question/23204/how-to-use-acc-gyro-6050-with-nrf51822-and-soft-device/ that provide init, write, read, and verify product id.\r\n\r\nMy goal is read data every 50msec from the sensor and then advertise them whenever they fill a full packet.\r\n\r\nConsidering those functions provided in MPU6050 drivers, should I just go through the registers of MPU6050 and write the correct values to them by using the WRITE function, and then just read with READ function and save data? Meaning that I do not need to face writing any code for TWI and...?\r\n\r\nAny other setting required?\r\n\r\nThanks,\r\nFA\r\n",
    "tag": "twi"
  },
  {
    "text": "SPI dependent on softdevice?  Hi, I am trying to combine SPI, microESB and BLE. BLE and microESB will not be combined in realtime, but rather be two distinct modes, and not run at the same time, and therefore entirely separated.\r\n\r\nMy question is: What should I watch out for? I have seen that NRF_POWER can't be used directly while the soft device is active. Is SPI doing something with the softdevice if I have SOFTDEVICE_PRESENT in the preprocessor? SPI initialization hangs unless I do:\r\n\r\n    SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, NULL);\r\n\r\nIf I only do instead:\r\n\r\n    NRF_CLOCK->LFCLKSRC = (CLOCK_LFCLKSRC_SRC_Xtal << CLOCK_LFCLKSRC_SRC_Pos);\r\n    NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;\r\n    NRF_CLOCK->TASKS_LFCLKSTART = 1;\r\n    while (NRF_CLOCK->EVENTS_LFCLKSTARTED == 0);\r\n\r\nIt will not come past the SPI initialization (spi_master_open).\r\n\r\nI also use app_timer_init (APP_TIMER_INIT), nrf_drv_gpiote_init, GPIOTE_CONFIG_OUT_SIMPLE, set_gpiote_handler, set_wake_on_irq_handler.\r\n\r\nSeems like *APP_ERROR_CHECK(sd_nvic_ClearPendingIRQ(p_spi_instance->irq_type))*; is the one in spi_master.c\r\n\r\nDo I have to use timeslot API to combine microESB library and SPI?",
    "tag": "spi"
  },
  {
    "text": "How many pwm channels can capture? Hello:\r\n    I want use nrf51822's time/ppi/gpiote to capture the pwm rising/falling range duty.I want to know the most numbers of pwm channels duty parameters it can capture? The more the better.\r\nThank you!\r\nPS:Now I've already capture PWM1 by pin1 and PWM2 by pin2.\r\n\r\n    static void gpiote_init(void)\r\n\r\n{\r\n\r\n    // Configure port1 (pins 8-15) as outputs for showing duty cycle.\r\n    //nrf_gpio_range_cfg_output(LED_START, LED_STOP);\r\n\r\n    nrf_gpio_cfg_sense_input(INPUT_PIN_NUMBER, NRF_GPIO_PIN_PULLUP, NRF_GPIO_PIN_SENSE_LOW);\r\n\r\n    // Enable interrupt on input 1 event.\r\n    NRF_GPIOTE->INTENSET = (GPIOTE_INTENSET_IN1_Enabled << GPIOTE_INTENSET_IN1_Pos);\r\n\t\r\n    nrf_gpiote_event_config(0, INPUT_PIN_NUMBER, NRF_GPIOTE_POLARITY_HITOLO);\r\n\t\tnrf_gpiote_event_config(1, INPUT_PIN_NUMBER, NRF_GPIOTE_POLARITY_LOTOHI);\r\n\t\r\n\t  nrf_gpio_cfg_sense_input(8, NRF_GPIO_PIN_PULLUP, NRF_GPIO_PIN_SENSE_LOW);\r\n    NRF_GPIOTE->INTENSET = (GPIOTE_INTENSET_IN3_Enabled << GPIOTE_INTENSET_IN3_Pos);\t\r\n    nrf_gpiote_event_config(2,8, NRF_GPIOTE_POLARITY_HITOLO);\r\n\t\tnrf_gpiote_event_config(3, 8, NRF_GPIOTE_POLARITY_LOTOHI);\r\n}\r\n\r\n    static void ppi_init(void)\r\n\r\n{\r\n\r\n    NRF_PPI->CH[0].EEP = (uint32_t)&NRF_GPIOTE->EVENTS_IN[0];\r\n    NRF_PPI->CH[0].TEP = (uint32_t)&NRF_TIMER1->TASKS_CAPTURE[0];\r\n\r\n    NRF_PPI->CH[1].EEP = (uint32_t)&NRF_GPIOTE->EVENTS_IN[1];\r\n    NRF_PPI->CH[1].TEP = (uint32_t)&NRF_TIMER1->TASKS_CAPTURE[1];\r\n\r\n\t  NRF_PPI->CH[2].EEP = (uint32_t)&NRF_GPIOTE->EVENTS_IN[2];\r\n    NRF_PPI->CH[2].TEP = (uint32_t)&NRF_TIMER2->TASKS_CAPTURE[0];\r\n\r\n    NRF_PPI->CH[3].EEP = (uint32_t)&NRF_GPIOTE->EVENTS_IN[3];\r\n    NRF_PPI->CH[3].TEP = (uint32_t)&NRF_TIMER2->TASKS_CAPTURE[1];\r\n    // Enable only PPI channels 0 and 1.\r\n    NRF_PPI->CHEN = (PPI_CHEN_CH0_Enabled << PPI_CHEN_CH0_Pos)\r\n                  | (PPI_CHEN_CH1_Enabled << PPI_CHEN_CH1_Pos)\r\n\t\t\t\t\t\t\t\t\t|\t(PPI_CHEN_CH2_Enabled << PPI_CHEN_CH2_Pos)\r\n                  | (PPI_CHEN_CH3_Enabled << PPI_CHEN_CH3_Pos);\r\n}\r\n\r\nvoid GPIOTE_IRQHandler(void)\r\n\r\n{\r\n\r\n    static uint32_t prev_cc1_pin1 = 0;\r\n    uint32_t curr_cc1_pin1;\r\n    uint32_t cycle_duration_pin1;\r\n    uint32_t duty_cycle_pin1;\r\n    uint32_t active_time_pin1;\r\n\t  static uint32_t prev_cc1_pin0 = 0;\r\n    uint32_t curr_cc1_pin0;\r\n    uint32_t cycle_duration_pin0;\r\n    uint32_t duty_cycle_pin0;\r\n    uint32_t active_time_pin0;\r\n\t\tif((NRF_GPIOTE->EVENTS_IN[1]==1)&& (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN1_Msk))\r\n\t\t{\t\t\r\n    curr_cc1_pin1 = NRF_TIMER1->CC[1];  \r\n    // Cycle duration is the difference between two low-to-high transitions.\r\n    cycle_duration_pin1 = (curr_cc1_pin1 - prev_cc1_pin1); \r\n    \r\n    active_time_pin1 = cycle_duration_pin1 - ((curr_cc1_pin1 - NRF_TIMER1->CC[0]));\r\n\r\n    if (cycle_duration_pin1 != 0)\r\n    {\r\n        duty_cycle_pin1 = (DUTY_CYCLE_SCALE_VALUE * active_time_pin1) / cycle_duration_pin1;\r\n        //nrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT1, (uint8_t)duty_cycle_pin1);\r\n\t\t\t\tprintf(\"%d\\n\\r\",duty_cycle_pin1);\r\n    }\r\n    else\r\n    {\r\n        // Do nothing.\r\n    }\r\n\r\n    // Clear the event causing the interrupt.\r\n    NRF_GPIOTE->EVENTS_IN[1] = 0;    \r\n    prev_cc1_pin1                 = curr_cc1_pin1;\r\n\t}\r\n\telse if((NRF_GPIOTE->EVENTS_IN[3]==1)&& (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN3_Msk))\r\n\t{\r\n\t\t\tcurr_cc1_pin0 = NRF_TIMER2->CC[1];  \r\n\t\t\t// Cycle duration is the difference between two low-to-high transitions.\r\n\t\t\tcycle_duration_pin0 = (curr_cc1_pin0 - prev_cc1_pin0); \r\n\t\t\t\r\n\t\t\tactive_time_pin0 = cycle_duration_pin0 - ((curr_cc1_pin0 - NRF_TIMER2->CC[0]));\r\n\r\n\t\t\tif (cycle_duration_pin0 != 0)\r\n\t\t\t{\r\n\t\t\t\t\tduty_cycle_pin0 = (DUTY_CYCLE_SCALE_VALUE * active_time_pin0) / cycle_duration_pin0;\r\n\t\t\t\t\t//nrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT1, (uint8_t)duty_cycle_pin0);\r\n\t\t\t\t\tprintf(\"%d\\n\\r\",duty_cycle_pin0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t\t// Do nothing.\r\n\t\t\t}\r\n\r\n\t\t\t// Clear the event causing the interrupt.\r\n\t\t\tNRF_GPIOTE->EVENTS_IN[3] = 0;    \r\n\t\t\tprev_cc1_pin0                 = curr_cc1_pin0;\r\n\t}\r\n}\r\n\r\nstatic void timer1_init(void)\r\n\r\n{\r\n\r\n    // Start 16 MHz crystal oscillator\r\n    NRF_CLOCK->EVENTS_HFCLKSTARTED  = 0;\r\n    NRF_CLOCK->TASKS_HFCLKSTART     = 1;\r\n\r\n    // Wait for the external oscillator to start up\r\n    while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0) \r\n    {\r\n        // Do nothing.\r\n    }\r\n    NRF_TIMER1->MODE        = TIMER_MODE_MODE_Timer;\r\n    NRF_TIMER1->PRESCALER   = 4;\r\n    NRF_TIMER1->BITMODE     = TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n    NRF_TIMER1->TASKS_CLEAR = 1;\r\n    NRF_TIMER1->TASKS_START = 1; // Start clocks\r\n}\r\n\r\nstatic void timer2_init(void)\r\n\r\n{\r\n\r\n    NRF_TIMER2->MODE        = TIMER_MODE_MODE_Timer;\r\n    NRF_TIMER2->PRESCALER   = 4;\r\n    NRF_TIMER2->BITMODE     = TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n    NRF_TIMER2->TASKS_CLEAR = 1;\r\n    NRF_TIMER2->TASKS_START = 1; // Start clocks\r\n}",
    "tag": "timer"
  },
  {
    "text": "TWI problem nrf52 dk I just got the new nrf52 dk, and I was trying to run the default twi_master_with_twis_slave example in sdk 0.9.2. i just ran the default code and shorted TWI_SCL_M - EEPROM_SIM_SCL_S (Pin 3 to 31) and TWI_SDA_M - EEPROM_SIM_SDA_S (Pin 4 to 30). When I load the program I cannot open the Putty session at all. Sorry I am new to this, can you please help if I am doing something wrong.",
    "tag": "twi"
  },
  {
    "text": "Connecting Altimeter to nrf52 dk using i2c. Hi I trying to connect Altimeter ( mpl 3115a2) to the nrf52 development kit. Can someone guide me how to do it (pin connection). I have followed the example given in the sdk but still I am a little unclear.\r\nThank you.",
    "tag": "i2c"
  },
  {
    "text": "TWI sensor example? Hi,\r\n\r\nI don't see in SDK 0.9.x any examples pertaining to accelerometer peripherals. I see a TWI sensor example from the nRF51, but I am working with the nRF52. Are there any examples for a TWI sensor or accelerometer?\r\n\r\nBest Regards.",
    "tag": "twi"
  },
  {
    "text": "TWI sensor example? Hi,\r\n\r\nI don't see in SDK 0.9.x any examples pertaining to accelerometer peripherals. I see a TWI sensor example from the nRF51, but I am working with the nRF52. Are there any examples for a TWI sensor or accelerometer?\r\n\r\nBest Regards.",
    "tag": "i2c"
  },
  {
    "text": "How to get every adc channel conversion result? Hi: I want use all eight ADC channel, But I don't know how to get  different channel conversion result.\r\n\r\nI write my code as follow:\r\n\r\n    void adc_config(void)\r\n{\r\n    const nrf_adc_config_t nrf_adc_config = \r\n{\r\n   ADC_CONFIG_RES_10bit,\r\n   NRF_ADC_CONFIG_SCALING_INPUT_ONE_THIRD,    \r\n   NRF_ADC_CONFIG_REF_VBG \r\n};\r\n\r\n    nrf_adc_configure( (nrf_adc_config_t *)&nrf_adc_config);\r\n    nrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n    NVIC_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_HIGH);\r\n    NVIC_EnableIRQ(ADC_IRQn);\r\n}\r\n\r\n    void ADC_IRQHandler(void)\r\n{\r\n\r\n    nrf_adc_conversion_event_clean();\r\n    adc_sample = nrf_adc_result_get();\r\n    nrf_adc_start();\r\n}\r\n\r\nIn my main funciton \r\nI do like this:\r\n\r\n    nrf_adc_input_select(NRF_ADC_CONFIG_INPUT_2);\r\n\t\t\tprintf(\"%d\",adc_sample);\r\n    nrf_adc_input_select(NRF_ADC_CONFIG_INPUT_3);\r\n\t\t\tprintf(\"%d\",adc_sample);\r\n....\r\nNow, I wonder that :\r\n1.if this funciton is right ?\r\n2.can I get adc result without ADC_Interrput?\r\nthank you!",
    "tag": "adc"
  },
  {
    "text": "using TWI transaction manager with callback Hi,\r\n\r\nI'm using 3rd Generation of the nRF51822 with SoftDevice 8.0.0 and SDK 10.0.\r\n\r\nThere is an example in the SDK installation folder which shows how to use the TWI transaction manager with no callback function.\r\n\r\nI believe using TWI transaction manager without callback function will force the TWI to run in the blocking mode.\r\n\r\nI want to use the TWI transaction manager with the callback function but i don't know that function type should i pass into the transaction manager\r\n\r\nI'm using below code to configure the TWI and perform write operation on the EEPROM\r\n\r\n    app_twi_t m_app_twi = APP_TWI_INSTANCE(0);\r\n    #define MAX_PENDING_TRANSACTIONS    128\r\n    static void twi_config(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n        nrf_drv_twi_config_t const config = {\r\n           .scl                = SCLK,\r\n           .sda                = SDAT,\r\n           .frequency          = NRF_TWI_FREQ_400K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_LOW\r\n        };\r\n    \r\n        APP_TWI_INIT(&m_app_twi, &config, MAX_PENDING_TRANSACTIONS, err_code);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\nWrite to EEPROM memory\r\n\r\n    void AT24C_write_byte(uint32_t address,uint8_t data)\r\n    {\r\n    \t\t\r\n    \t\tuint8_t write_data[3];\r\n    \t\twrite_data[0] = address>>8;\r\n    \t\twrite_data[1] = address&0xFF;\r\n    \t\twrite_data[2] = data;\r\n    \t\r\n    \t\t#define TRANSFER_COUNT \t1\r\n    \t\t\r\n    \t\tapp_twi_transfer_t const transfers[TRANSFER_COUNT] =\r\n    \t\t{\r\n    \t\t\t\tAPP_TWI_WRITE(at24c.address, write_data,sizeof(write_data), 0)\r\n    \t\t};\r\n    \t\t\r\n    \t\tapp_twi_transaction_t const transaction =\r\n    \t\t{\r\n    \t\t\t\t.callback            = NULL,//transaction_callback,\r\n    \t\t\t\t.p_user_data         = NULL,\r\n    \t\t\t\t.p_transfers         = transfers,\r\n    \t\t\t\t.number_of_transfers = sizeof(transfers)/sizeof(transfers[0])\r\n    \t\t};\t\t\r\n    \t\t\r\n    \t\t\r\n    \t\tuint32_t err_code = app_twi_schedule(&m_app_twi, &transaction);\r\n    \t\t\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    }\r\n\r\ni put the write operation in a while loop and after some write operation the HardFault handler is called.\r\n\r\nPlease give me an example on how to use the TWI transaction manager with callback function and also how to find the cause of HardFault.",
    "tag": "twi"
  },
  {
    "text": "PWM inverted when not using Segger I'm rolling my own very simple PWM implementation (I'm not using the PWM example code). My code is below:\r\n\r\n    #define GPIOTE_CHANNEL_NUMBER 0\r\n    #define PCLK16M             16000000\r\n    #define FSK_FREQ            17000\r\n    #define FSK_CC0             (PCLK16M / FSK_FREQ)\r\n    #define FSK_PULSE_PERIOD_US 15\r\n    #define FSK_CC1             ((PCLK16M / 1000000) * FSK_PULSE_PERIOD_US)\r\n\r\n\tnrf_gpiote_task_config(GPIOTE_CHANNEL_NUMBER, 25, \\\r\n\t         NRF_GPIOTE_POLARITY_TOGGLE, NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n\r\n\tuint32_t ppi_ch_num = 0;\r\n    sd_ppi_channel_assign(ppi_ch_num, &NRF_TIMER1->EVENTS_COMPARE[1], &NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NUMBER]);\r\n    sd_ppi_channel_assign(ppi_ch_num + 1, &NRF_TIMER1->EVENTS_COMPARE[0], &NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_NUMBER]);\r\n    sd_ppi_channel_enable_set(1 << ppi_ch_num | 1 << (ppi_ch_num + 1));\r\n\r\n\tNRF_TIMER1->MODE = TIMER_MODE_MODE_Timer;\r\n\tNRF_TIMER1->PRESCALER   = 0;\r\n\tNRF_TIMER1->BITMODE     = TIMER_BITMODE_BITMODE_16Bit;\r\n\tNRF_TIMER1->CC[0]       = FSK_CC0; // 941\r\n\tNRF_TIMER1->CC[1]       = FSK_CC1; // 240\r\n\tNRF_TIMER1->SHORTS      = TIMER_SHORTS_COMPARE0_CLEAR_Enabled;\r\n\tNRF_TIMER1->TASKS_START = 1;\r\n\r\n\r\nThis works fine when I have the SEGGER debugger attached (either in Debug or Run mode). However, as soon as I detach the debugger and reset, the PWM signal randomly inverts itself. I'm using the SoftDevice, BTW. I've heard of PWM signals inverting themselves with a SoftDevice, but I thought that was specific to the PWM example code / changing the pulse width while the timer is running.\r\n\r\nHas anyone else run into this? Any ideas?",
    "tag": "pwm"
  },
  {
    "text": "nRF52 maximum throughput of EasyDMA on PWM device Hello,\r\n\r\nI've been looking a bit into the nRF52 product specification and I was just wondering how powerful EasyDMA is under extreme conditions.\r\n\r\nLet's assume the following scenario: All 12 PWM channels are in use, with a frequency of 1 MHz. The duty cycle shall be set every period, which would result in a bandwith usage of 1MHz * 12 channels * 2 Bytes = 24 MB/s.\r\n\r\n- How many cycles does an EasyDMA operation take?\r\n- Will EasyDMA access the memory with 32 bit width (and update two PWM COMPARE registers at the same time?\r\n- If there is concurrent EasyDMA access, will there be interleaving? Or may one EasyDMA device be blocked by a device of higher priority (e.g. the radio)?\r\n- How will excessive EasyDMA load affect the remaining system? Can I calculate the impact on system performance (application speed)? Might the reliability of Bluetooth communication be affected?\r\n\r\nAnd one more question concerning the PWM specification: Are the COMPARE registers double-buffered (and updated at the beginning of a PWM period)? Or are the new values applied just at the time of loading (which means during a PWM period)? In other words, if 12 COMPARE registers have to be updated through EasyDMA, might it happen that the later channels might use outdated values and it might come to glitches when their COMPARE registers are updated later?\r\n\r\nThanks for your help.\r\n",
    "tag": "pwm"
  },
  {
    "text": "TWI Driver and SVC Handler Missing Error Hello,\r\n\r\nI seem to be having some errors with my current project. I am using SoftDevice S310 Version 3.0 and SDK 9.0. When i try to communicate with one of my I2C sensors I get an SVC Handler Missing Error (0x01). This doesn't appear to be a valid error code for the TWI functions.\r\n\r\nHere is my initialization and transfer:\r\n\r\n    uint32_t err_code;\r\n\t\r\n\tstatic const nrf_drv_twi_config_t twi_config = {\r\n                                                    .frequency = NRF_TWI_FREQ_400K,\r\n\t\t\t\t\t\t                            .scl = I2C_SCL,\r\n\t\t\t\t\t\t                            .sda = I2C_SDA,\r\n\t\t\t\t\t                                .interrupt_priority = APP_IRQ_PRIORITY_LOW\r\n                                                   };\r\n\terr_code = nrf_drv_twi_init(&twi, &twi_config, NULL);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \r\n\tnrf_drv_twi_enable(&twi);\r\n\r\n    err_code = nrf_drv_twi_tx(&twi, 0x68, rtc_data_reg, sizeof(rtc_data_reg), true);\r\n    APP_ERROR_CHECK(err_code);\r\n\t\r\n    err_code = nrf_drv_twi_rx(&twi, 0x68, rtc_data, sizeof(rtc_data), false);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nDoes anyone have any explanation for what could cause the nrf_drv_twi_tx and nrf_drv_twi_rx functions to return with the SVC Handler Missing Error?\r\n\r\nThanks for any solutions you can help me reach,\r\n\r\nCory",
    "tag": "twi"
  },
  {
    "text": "How do do parallel, concurrent operations? I am reading data over the duration of 3 seconds on SPI, but while I'm doing that, I need to send that data over RF using microESB library.\r\n\r\nI need to make sure the read is not blocking RF send and vice versa. The reading is the most imporant. So I imagine some kind of a big buffer that holds all the data I read, where a task independently reads what's filled in the buffer at it's own pace. As you know transfers can fail, and take substantially longer than a quick SPI read. Right now I read from SPI with 10 ms nrf_delay_ms() in a loop over 3 seconds. I also have the possibility to have the SPI interrupting when it's internal ring buffer is full, doing a large read in short bursts.\r\n\r\nThanks!",
    "tag": "spi"
  },
  {
    "text": "Swdio/swclk shared with normal GPIO Hei there!\r\nFirst of all thanks for all the great work here!\r\n\r\nMy question is:\r\n\r\nIn my application, the final device will have 4 pogo pins.\r\nTwo of them are for power, the other two for signal.\r\nThese signal pins coul be connected at the same time to swdio/swclk for programming and to two normal gpio used later for I2C?\r\n\r\nThanks to everybody",
    "tag": "i2c"
  },
  {
    "text": "nRF51822 ADC accuracy without an external crytsal The Product Specification makes it clear that the given levels of accuracy for ADC measurements are only possible when using an external crystal for the HFCLK. We have one of those on our current prototype boards are are now looking to remove it. The cost of the part doesn't justify the power savings for BLE radio operations, in our application. I need to get an idea of the ADC accuracy possible *without* the external crystal.\r\n\r\nOur battery is a lithium ion 18650 that varies in voltage up to 4.3V. Here's a schematic of the circuit we use to drop our Vbatt down to a level appropriate for the ADC.\r\n\r\n[Screen Shot 2015-11-22 at 13.53.18.png](/attachment/bab76ea30be86c91b6aa1d61fb74637b)\r\n\r\nCan we still measure to the nearest millivolt without the crystal?\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Why Vsupply measurement is inaccurate in nRF51? Hello all, to optimize the BOM and size of our device(Tag based on nRF51822), the external divider was replaced by software configuration to measure the battery voltage. In our design the CR2032 cell was used and connected to nRF51 directly. \r\n We have chosen a free AIN pin and configured it with next:\r\n  \r\n    - SupplyOneThirdPrescaling  ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling \r\n    \r\n    - ADC_CONFIG_RES_10bit\r\n    \r\n    - ADC_CONFIG_REFSEL_VBG\r\n\r\nEdited: To be more precise\r\n\r\n\t\tNRF_ADC->CONFIG     = (ADC_CONFIG_RES_10bit<< ADC_CONFIG_RES_Pos)|(ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)|(ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)|(ADC_CONFIG_PSEL_Disabled<<ADC_CONFIG_PSEL_Pos)|(ADC_CONFIG_EXTREFSEL_None<< ADC_CONFIG_EXTREFSEL_Pos);\r\n\r\nSo than I calculate supply voltage as   \r\n\r\n       Vin = (ADCres*1.2V/1024)*3\r\n\r\nIf I power my device from Dev.board (2.95V) the conversion results correctly and device show 2.95V measured. However, if I power the device with cr2032 cell (not new) the voltage measured on inserted in device's slot is 2.86V but ADC conversion results with value 2,73V. \r\nSo I have a few questions:\r\n\r\n 1. How stable is value of VBG?\r\n\r\n 2.  Is    there any circuit between the Vcc pin and divider \"SupplyOneThirdPrescaling\" inside of\r\n    the chip?\r\n\r\n 3. What is SupplyOneThirdPrescaling divider accuracy?\r\n\r\n Please help.\r\n\r\nP.S. The average current consumption of device is about 200uA. The Vcc pin was measured with osciloscope, the voltage ripples are about 1-3mV. \r\n\r\nBest regards,\r\n   \r\n\r\n**Added:** \r\n![CR2032 powered tag. Voltage kink at ADC measurement](/attachment/dd0021953601816633ea5f78900b956a)\r\nI measured battery voltage at igher time resolution and noticed a voltage kink with same period as the ADC measurement occured. It explains the measurement results (bottom part of voltage kink has the same value as measured by ADC). However, that to do next is unclear. To add huge uF cap? The PS says: \"I ADC - Current drawn by ADC during conversion. - 260 \u03bcA\" and it doesnt seem to be so high to make such voltage lowering.\r\n\r\n**Added:**\r\nI also measured the current. Each time when ADC measurement occured the 4mA current pulse noticed. Could internal 1/3 divider cause such current flow?",
    "tag": "adc"
  },
  {
    "text": "PWM driver library does not work well with SoftDevice 8.1.0, What I neet to do ? I use nrf51822 by example ble_peripheral/ble_app_uart with with SoftDevice 8.1.0, at the same time, I use pwm driver library, But it does not work well, What I need to do? or How to fix it?\r\n \r\nI add \r\n> \"#define USE_WITH_SOFTDEVICE     1\"\r\n\r\n as [here](https://devzone.nordicsemi.com/question/44491/pwm-with-soft-device/) said, it does not work well too.\r\n\r\nBelow is the outp capture by logic analyze\r\n![image description](/attachment/5d537a6bf3b5b8529626ae2bdfa147bc)\r\n\r\n\r\nBelow is the code:\r\n\r\n   \r\n\r\n     APP_PWM_INSTANCE(PWM1,1);                   \r\n    \r\n    static volatile bool ready_flag;            \r\n    \r\n    void pwm_ready_callback(uint32_t pwm_id)    \r\n    {\r\n        ready_flag = true;\r\n    }\r\n    \r\n    void pwm_led_init(){\r\n    \tuint32_t err_code;\r\n    \tapp_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(5000L, PWM_LED_WORK);\r\n        \r\n    \tpwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH ; \r\n        \r\n      err_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n      APP_ERROR_CHECK(err_code);\r\n    }\r\n    void pwm_led_start(){\r\n    \t app_pwm_enable(&PWM1);\r\n        \r\n        uint32_t value;\r\n        while(true)\r\n        {\r\n            for (uint8_t i = 0; i < 40; ++i)\r\n            {\r\n                value = (i < 20) ? (i * 5) : (100 - (i - 20) * 5);\r\n                \r\n                ready_flag = false;\r\n                /* Set the duty cycle - keep trying until PWM is ready... */\r\n                while (app_pwm_channel_duty_set(&PWM1, 0, value) == NRF_ERROR_BUSY);\r\n                \r\n                /* ... or wait for callback. */\r\n                while(!ready_flag);\r\n                nrf_delay_ms(25);\r\n            }\r\n        }\r\n    \r\n    }\r\n    void pwm_led_stop(){\r\n    \r\n    }",
    "tag": "pwm"
  },
  {
    "text": "ble_app_uart + pwm Hi. I try to nus + pwm..  I am using https://github.com/NordicSemiconductor/nrf51-pwm-library ..\r\nWhen I combine 'ble_app_template' + nrf_pwm, it works fine.. but 'ble_app_uart' + nrf_pwm is not work... \r\n\r\nstatic void advertising_init(void)\r\n{\r\n    uint32_t      err_code;\r\n    ble_advdata_t advdata;\r\n    ble_advdata_t scanrsp;\r\n    uint8_t       flags = BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE;\r\n    \r\n    ble_uuid_t adv_uuids[] = {{BLE_UUID_NUS_SERVICE, m_nus.uuid_type}};\r\n\r\n    memset(&advdata, 0, sizeof(advdata));\r\n    advdata.name_type               = BLE_ADVDATA_FULL_NAME;\r\n    advdata.include_appearance      = false;\r\n    advdata.flags.size              = sizeof(flags);\r\n    advdata.flags.p_data            = &flags;\r\n\r\n    memset(&scanrsp, 0, sizeof(scanrsp));\r\n    scanrsp.uuids_complete.uuid_cnt = sizeof(adv_uuids) / sizeof(adv_uuids[0]);\r\n    scanrsp.uuids_complete.p_uuids  = adv_uuids;\r\n    \r\n    err_code = ble_advdata_set(&advdata, &scanrsp);\r\n    APP_ERROR_CHECK(err_code);\r\n}\r\n\r\nthis is function of my 'ble_app_uart' + nrf_pwm.. \r\nAt this function, I try to change 'err_code = ble_advdata_set(&advdata, &scanrsp);' -> 'err_code = ble_advdata_set(&advdata, NULL);'. Then, this is work ..  please help me .. \r\n\r\nI am using SDK 6.0.0, s110_nrf51822_7.1.0_softdevice",
    "tag": "pwm"
  },
  {
    "text": "How to control two channes PWM independently? **Maybe I should post my all the code here.**\r\n\r\nI want to generate two kinds of PWM1 and PWM2,used by the code as follows:\r\nstatic volatile bool ready_flag;\r\n\r\nAPP_PWM_INSTANCE(&PWM1,1);\r\nAPP_PWM_INSTANCE(&PWM2,2);\r\n\r\nvoid pwm1_ready_callback(void)\r\n{\r\n   ready_flag = true;//This code may be unuseful,but it comes from the Nordic Demo.\r\n};\r\nvoid pwm2_ready_callback(void)\r\n{\r\n   ready_flag = true;//This code may be unuseful,but it comes from the Nordic Demo.\r\n}; \r\n\r\n**One of them is initialized by the code as follows:**\r\n\r\nvoid pwm_ble_led(void)\r\n{\r\n    static ret_code_t error_code;\r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(1000000,LED_0);\r\n    pwm1_cfg.pin_polarity[0]      = APP_PWM_POLARITY_ACTIVE_LOW;\r\n    error_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm1_ready_callback);\r\n    APP_CHECK_ERROR(error_code);\r\n}\r\n\r\n**The another as the same,the code as follows:**\r\n\r\nvoid pwm_power_ble(void)\r\n{\r\n    static ret_code_t error_code;\r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(1000000,LED_1);\r\n    pwm1_cfg.pin_polarity[0]      = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n    error_code = app_pwm_init(&PWM2,&pwm1_cfg,pwm2_ready_callback);\r\n    APP_CHECK_ERROR(error_code);\r\n}\r\n\r\n**The PWM closed code as follows:**\r\n\r\nvoid pwm_ble_close(void)\r\n{  \r\n   uint32_t err_code;\r\n   app_pwm_disable(&PWM1);\r\n   nrf_drv_gpiote_out_task_disable(LED_0);\r\n   err_code = app_pwm_uninit(&PWM1);\r\n   APP_ERROR_CHECK(err_code);\r\n}\r\n\r\nvoid pwm_power_close(void)\r\n{\r\n   uint32_t err_code;\r\n   app_pwm_disable(&PWM2);\r\n   nrf_drv_gpiote_out_task_disable(LED_1);\r\n   err_code = app_pwm_uninit(&PWM2);\r\n   APP_ERROR_CHECK(err_code);\r\n}\r\n\r\n**The PWM start working code as follows:**\r\n\r\nvoid pwm_ble_led_start(void)\r\n{ \r\n   pwm_ble_close();**//this code is used for guaranting that the PWM is closed,otherwise the system would reset.**\r\n   pwm_ble_led();\r\n   app_pwm_enable(&PWM1);\r\n   nrf_drv_gpiote_out_task_enable(LED_0);\r\n   app_pwm_channel_duty_set(&PWM1,0,50);\r\n}\r\n\r\nvoid pwm_power_led_start(void)\r\n{ \r\n   pwm_power_close();\r\n   pwm_power_led();\r\n   app_pwm_enable(&PWM2);\r\n   nrf_drv_gpiote_out_task_enable(LED_1);\r\n   app_pwm_channel_duty_set(&PWM2,0,50);\r\n}\r\n\r\n**The question is how to control the two PWM independently?I have tried the function of app_pwm_disable() and app_pwm_uninit(),but it does not work result of influencing the another PWM.**",
    "tag": "pwm"
  },
  {
    "text": "Incorporating TWI into Template example I have some custom hardware (nRF51822) with a couple sensors on it and would like to have the data sent via BLE to a smartphone. This may be timer based on triggered by an interrupt from the sensor itself. \r\n\r\nI've opened up a new copy of the template example, thinking this would be a good starting point to slowly tackle the issues. However, I'm not totally sure how I would even begin to go about dealing with integrating I2C communication into it.\r\n\r\nCould anyone give me a brief summary of what approach I might take to achieve this? ",
    "tag": "twi"
  },
  {
    "text": "Incorporating TWI into Template example I have some custom hardware (nRF51822) with a couple sensors on it and would like to have the data sent via BLE to a smartphone. This may be timer based on triggered by an interrupt from the sensor itself. \r\n\r\nI've opened up a new copy of the template example, thinking this would be a good starting point to slowly tackle the issues. However, I'm not totally sure how I would even begin to go about dealing with integrating I2C communication into it.\r\n\r\nCould anyone give me a brief summary of what approach I might take to achieve this? ",
    "tag": "i2c"
  },
  {
    "text": "TIMER and PWL why doesn't TASKS_CLEAR work? I'm trying to generate a 1kHz PWL and call a function every 1ms  the code is below.\r\nMy initial though was to set TASKS_CLEAR once the timer reached the max pwl value.\r\nOddly this worked of the reset value was 32,000 but not 256.  I think I have fixed it\r\nby using the \"SHORTS\" function to clear the timer, but I'd like to know why using clear\r\ndid not work.  The BLE was disabled during the test.\r\n\r\nI want to use this chip to control a sensored brushless motor (with ble off when\r\nthe motor is running,  will I able to get enough through put).\r\n\r\nUsing this chip has become a real pain.  So many poorly documented issues.\r\n\r\n    void timers_init2(void){\r\n      nrf_gpio_cfg_output(3);\r\n      // Start 16 MHz crystal oscillator .                                                                                                       \r\n      NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n      NRF_CLOCK->TASKS_HFCLKSTART    = 1;\r\n    \r\n      // Wait for the external oscillator to start up.                                                                                           \r\n      while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0)\r\n        {\r\n          //Do nothing.                 \r\n        }\r\n    \r\n      NRF_TIMER2->TASKS_STOP = 1;// Stop timer               \r\n      NRF_TIMER2->MODE =TIMER_MODE_MODE_Timer;\r\n    \r\n      NRF_TIMER2->TASKS_CLEAR = 1;\r\n      NRF_TIMER2->PRESCALER = 6; // max=9   6 gives 250khz         \r\n      NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit; // 8 bit mode does not work            \r\n      NRF_TIMER2->CC[0]=256; //reset value                   \r\n      NRF_TIMER2->CC[1]=m.pwm;\r\n               \r\n      NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos)\r\n      |    (TIMER_INTENSET_COMPARE1_Enabled<< TIMER_INTENSET_COMPARE1_Pos);\r\n    \r\n      NRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\r\n    \r\n      NVIC_EnableIRQ(TIMER2_IRQn);\r\n    \r\n      NRF_TIMER2->TASKS_START = 1;\r\n    \r\n    }\r\n    \r\n    void TIMER2_IRQHandler(void){\r\n    \r\n      if((NRF_TIMER2->EVENTS_COMPARE[0] != 0) \r\n           && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE0_Msk) !=0)){\r\n    \r\n        // reset timer and start pulse                  \r\n        NRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n        //NRF_TIMER2->TASKS_CLEAR; // needed to replace this with shorts call above \r\n         call_func_every_ms();\r\n        if(m.pwm> 0) {\r\n          NRF_TIMER2->CC[1]=m.pwm;           \r\n        }\r\n          nrf_gpio_pin_set(3);\r\n      }\r\n    if((NRF_TIMER2->EVENTS_COMPARE[1] !=0) \r\n           && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE1_Msk) !=0)){\r\n    \r\n        // End of pwm pulse            \r\n    \r\n        NRF_TIMER2->EVENTS_COMPARE[1] = 0;\r\n        nrf_gpio_pin_clear(3);\r\n      }",
    "tag": "timer"
  },
  {
    "text": "TIMER and PWL why doesn't TASKS_CLEAR work? I'm trying to generate a 1kHz PWL and call a function every 1ms  the code is below.\r\nMy initial though was to set TASKS_CLEAR once the timer reached the max pwl value.\r\nOddly this worked of the reset value was 32,000 but not 256.  I think I have fixed it\r\nby using the \"SHORTS\" function to clear the timer, but I'd like to know why using clear\r\ndid not work.  The BLE was disabled during the test.\r\n\r\nI want to use this chip to control a sensored brushless motor (with ble off when\r\nthe motor is running,  will I able to get enough through put).\r\n\r\nUsing this chip has become a real pain.  So many poorly documented issues.\r\n\r\n    void timers_init2(void){\r\n      nrf_gpio_cfg_output(3);\r\n      // Start 16 MHz crystal oscillator .                                                                                                       \r\n      NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n      NRF_CLOCK->TASKS_HFCLKSTART    = 1;\r\n    \r\n      // Wait for the external oscillator to start up.                                                                                           \r\n      while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0)\r\n        {\r\n          //Do nothing.                 \r\n        }\r\n    \r\n      NRF_TIMER2->TASKS_STOP = 1;// Stop timer               \r\n      NRF_TIMER2->MODE =TIMER_MODE_MODE_Timer;\r\n    \r\n      NRF_TIMER2->TASKS_CLEAR = 1;\r\n      NRF_TIMER2->PRESCALER = 6; // max=9   6 gives 250khz         \r\n      NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit; // 8 bit mode does not work            \r\n      NRF_TIMER2->CC[0]=256; //reset value                   \r\n      NRF_TIMER2->CC[1]=m.pwm;\r\n               \r\n      NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos)\r\n      |    (TIMER_INTENSET_COMPARE1_Enabled<< TIMER_INTENSET_COMPARE1_Pos);\r\n    \r\n      NRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);\r\n    \r\n      NVIC_EnableIRQ(TIMER2_IRQn);\r\n    \r\n      NRF_TIMER2->TASKS_START = 1;\r\n    \r\n    }\r\n    \r\n    void TIMER2_IRQHandler(void){\r\n    \r\n      if((NRF_TIMER2->EVENTS_COMPARE[0] != 0) \r\n           && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE0_Msk) !=0)){\r\n    \r\n        // reset timer and start pulse                  \r\n        NRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n        //NRF_TIMER2->TASKS_CLEAR; // needed to replace this with shorts call above \r\n         call_func_every_ms();\r\n        if(m.pwm> 0) {\r\n          NRF_TIMER2->CC[1]=m.pwm;           \r\n        }\r\n          nrf_gpio_pin_set(3);\r\n      }\r\n    if((NRF_TIMER2->EVENTS_COMPARE[1] !=0) \r\n           && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE1_Msk) !=0)){\r\n    \r\n        // End of pwm pulse            \r\n    \r\n        NRF_TIMER2->EVENTS_COMPARE[1] = 0;\r\n        nrf_gpio_pin_clear(3);\r\n      }",
    "tag": "pwm"
  },
  {
    "text": "why timer of SDK 9.0 needn't code  to trigger the clock. I read timer example of SDK7.0/6.0, and found that often we write some code to tigger the clock.\r\nbut the same example of SDK9.0  needn't. why ? \r\n\r\nthe code of SDK7.0: NRF_CLOCK->TASKS_HFCLKSTART    = 1; to trigger the clock.\r\n\r\n/**\r\n * @brief Function for timer initialization.\r\n */\r\n\r\nstatic void timer_init()\r\n\r\n{\r\n    // Start 16 MHz crystal oscillator.\r\n    NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n    NRF_CLOCK->TASKS_HFCLKSTART    = 1;\r\n\r\n    // Wait for the external oscillator to start up.\r\n    while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0)\r\n    {\r\n        // Do nothing.\r\n    }\r\n\r\n    NRF_TIMER0->MODE        = TIMER_MODE_MODE_Timer;       // Set the timer in Timer Mode.\r\n    NRF_TIMER0->PRESCALER   = 9;                           // Prescaler 9 produces 31250 Hz timer frequency => 1 tick = 32 us.\r\n    NRF_TIMER0->BITMODE     = TIMER_BITMODE_BITMODE_16Bit; // 16 bit mode.\r\n\r\n}\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "Delay GPIOTE events (synchronize handling of external interrupts) Good morning,\r\n\r\nI am using nRF51 SDK v10.0.0 and I have to synchronize access to a hardware resource shared between two control flows. One flow is an interrupt handler invoked by GPIOTE (high accuracy, using the hardware registers). I can use nrf_drv_gpiote_in_event_enable() and nrf_drv_gpiote_in_event_disable() to enable or disable the interrupt handler.\r\n\r\nMy question is: Can I use these functions to delay the interrupt or will it be completely lost in this case? The GPIOTE driver documentation does not give any information about how to delay interrupts during critical sections.\r\n\r\nExample:\r\n\r\n- nrf_drv_gpiote_in_init() is called\r\n- nrf_drv_gpiote_in_event_enable() is called\r\n- nrf_drv_gpiote_in_event_disable() called\r\n- interrupt is triggered on the disabled GPIOTE pin\r\n- nrf_drv_gpiote_in_event_enable() is called a bit later\r\n\r\nWill the interrupt handler be invoked by GPIOTE in this scenario?\r\n",
    "tag": "interrupt"
  },
  {
    "text": "app_twi Vs. nrf_drv_twi - What's the difference and why would you choose one over the other? I've been trying to get my head around the TWI on the nRF51822 today, using the \"twi_sensor_pca10028\" example to begin with.\r\n\r\nFirstly, I still don't quite understand how that works in non-blocking mode, so some explanation of that would be greatly appreciated.\r\n(Generally I find quite a lot of the example code to be unintuitive and difficult to follow, having some detailed functional description to go along with the example would be very helpful)\r\n\r\nHaving become frustrated at this example code I opted to check out the other example: \"twi_master_using_app_twi_pca10028\". In looking through this I realised the TWI is handled in a completely different manner. Why do two implementations of the same driver exist? Is there a benefit using one over the other? ",
    "tag": "twi"
  },
  {
    "text": "app_twi Vs. nrf_drv_twi - What's the difference and why would you choose one over the other? I've been trying to get my head around the TWI on the nRF51822 today, using the \"twi_sensor_pca10028\" example to begin with.\r\n\r\nFirstly, I still don't quite understand how that works in non-blocking mode, so some explanation of that would be greatly appreciated.\r\n(Generally I find quite a lot of the example code to be unintuitive and difficult to follow, having some detailed functional description to go along with the example would be very helpful)\r\n\r\nHaving become frustrated at this example code I opted to check out the other example: \"twi_master_using_app_twi_pca10028\". In looking through this I realised the TWI is handled in a completely different manner. Why do two implementations of the same driver exist? Is there a benefit using one over the other? ",
    "tag": "i2c"
  },
  {
    "text": "what is the difference between 'twi_sw_master.c' and 'twi_hw_master.c' ? Hi.\r\n\r\nI'm using nRF51 DK for developing a device.\r\n\r\nand, I'm trying to use 24LC01B(external eeprom) by i2c.\r\n\r\nLooking for code used for i2c, there are two *.c files, sw and hw.\r\n\r\nThere are same functions in two *.c files. (like 'bool twi_master_init(void)' and so on...)\r\n\r\nwhat's the difference between them?\r\nand what should I use?",
    "tag": "i2c"
  },
  {
    "text": "Changing PWM frequency (period) I have 2 PWMs working with the version 8 softdevice on an nRF51422, and it's straightforward enough to change the duty cycle with `app_pwm_channel_duty_set()` in the app_pwm library. However, I would like to be able to change the period on-the-fly, as well. Does anyone have a suggestion for the best way to do this, other than uninitializing the PWMs and reinitializing them with the new period? Thanks in advance for any advice.\r\n",
    "tag": "pwm"
  },
  {
    "text": "Sleep current: disabling TWI, pull-ups? I'm developing some simple wireless temperature sensors based on NRF51822s. In essence, they take a temperature measurement from a sensor over TWI, send it to a base-station using the micro_esb libraries, and then go into SYSTEM ON sleep for a period, before waking up and repeating. All without softdevice.\r\n\r\nI've written code to do just the radio / sleeping part, which successfully puts the NRF51822 into SYSTEM ON with a current usage of ~3uA (incl. about 0.5uA for the temp sensor (also sleeping)). When I add into the code to read the temperature, the sleep mode uses ~230uA. I suspect I am not stopping and disabling the TWI correctly. \r\n\r\nThe code includes a command to disable TWI before sleeping:\r\n\r\n    NRF_TWI1->ENABLE= TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos;\r\n\r\nShould I be 'stopping' TWI first? And if so, with what command? Is it:\r\n\r\n    NRF_TWI1->TASKS_STOP=1;\r\n\r\nI have also seen the following command used in some people's code. Is it part of the solution?\r\n\r\n    NRF_TWI1->POWER = 0;\r\n\r\nAny advice on the correct sequence of commands to shutdown TWI (and wake it up after SYSTEM ON sleep) would be really appreciated\r\n\r\nUPDATE: another thought, i'm also using pull-ups on some of the pins - could this cause the additional ~200uA of current drain? If so, what state should I try and leave the pins in before going into SYSTEM ON sleep if I want to minimise current usage?\r\n\r\n\r\n\r\nmain loop code below:\r\n\r\n    \twhile (true)\r\n    {\r\n        ackd=false;\r\n\r\n\t\t\t\t// -------------- SENSE ---------------------\r\n\r\n\t\t\t\ttwi_master_init(); \t\t\r\n\t\t\t\t// Trigger a one-shot conversion from the temperature sensor\r\n\t\t\t\twrite_buffer[0]=1; // i.e. Configuration register\r\n\t\t\t\twrite_buffer[1]=129; // MSB 128=OS bit, 1=SD bit\r\n\t\t\t\twrite_buffer[2]=0; // LSB \t\r\n\t\t\t\tif(twi_master_transfer(TMP102_ADDRESS , write_buffer, 3, TWI_ISSUE_STOP)){\r\n\t\t\t\t}\t\t\t\r\n\t\r\n\t\t\t\t// Wait for OS bit to be re-set to 1 to signal end of conversion\r\n\t\t\t\tdata_buffer[0]=0;\r\n\t\t\t\twhile (data_buffer[0] && 128!=128) {\r\n\t\t\t\t\tif (twi_master_transfer(TMP102_ADDRESS | TWI_READ_BIT, data_buffer, 2, TWI_ISSUE_STOP)) {\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Switch to temperature register (from config register)\r\n\t\t\t\twrite_buffer[0]=0; // i.e. Temperature register\r\n\t\t\t\twrite_buffer[1]=0; // MSB? \r\n\t\t\t\twrite_buffer[2]=0; // LSB? \t\r\n\t\t\t\tif(twi_master_transfer(TMP102_ADDRESS , write_buffer, 3, TWI_ISSUE_STOP)){\r\n\t\t\t\t}\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// Read the temperature and place in the payload ready to send\r\n\t\t\t\tif (twi_master_transfer(TMP102_ADDRESS | TWI_READ_BIT, data_buffer, 2, TWI_ISSUE_STOP)) {\r\n\t\t\t\t\t\t\ttx_payload.data[2] = data_buffer[0];\t\t\r\n\t\t\t\t\t\t\ttx_payload.data[3] = data_buffer[1];\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Disable TWI ready for sleep\r\n\t\t\t\tNRF_TWI1->ENABLE= TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos;\r\n\t\t\t\t\r\n\t\t\t\t// -------------- TRANSMIT ---------------------\r\n\t\t\t\r\n\t\t\t\tif(uesb_write_tx_payload(&tx_payload) == UESB_SUCCESS)\r\n\t\t\t\t{\r\n\t\t\t\t\t\ttx_payload.data[0]++;\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\tnrf_delay_ms(10);\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// --------------- SLEEP ------------------------\r\n\t\t\t\t\r\n\t\t\t\t// define length of sleep according to position of SW_TEST switch\r\n\r\n\t\t\t\tif (nrf_gpio_pin_read(SW_TEST)==0) {\t\r\n\t\t\t\t\t\tNRF_RTC1->CC[0] = 32768;\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\t\t\r\n\t\t\t\t\t\tNRF_RTC1->CC[0] = 32768*60*5;\t\t\t\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// Start the RTC timer\r\n\t\t\t\tNRF_RTC1->TASKS_START = 1;\r\n\r\n\t\t\t\t// shut down the high-frequency clock\r\n\t\t\t\tNRF_CLOCK->TASKS_HFCLKSTOP = 1;\r\n\t\t\t\t\r\n\t\t\t\tawake=false;\r\n\t\t\t\twhile(!awake)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Enter System ON sleep mode\r\n\t\t\t\t\t__WFE();  \r\n\t\t\t\t\t// Make sure any pending events are cleared\r\n\t\t\t\t\t__SEV();\r\n\t\t\t\t\t__WFE();                \r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t// Stop and clear the RTC timer\r\n\t\t\t\tNRF_RTC1->TASKS_STOP = 1;\r\n\t\t\t\tNRF_RTC1->TASKS_CLEAR = 1;\t\r\n\r\n\t\t\t\t// Restart the hi-frequency clock\r\n\t\t\t\tNRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n\t\t\t\tNRF_CLOCK->TASKS_HFCLKSTART = 1;\r\n\t\t\t\twhile(NRF_CLOCK->EVENTS_HFCLKSTARTED == 0);\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n    }\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "High power consumption with I2C G-sensor We are using 51822 through I2C to get G-sensor buffer, every 560ms ( sample every 20ms, buffer for 28), then execute for step counter calculation, which should not consume much power. But the current measurement seeing, peak@4mA, rise to peak and down period last 150ms? sleep is working, but not sure why it took such long time to do so and peak @ 4mA? see picture below\r\n![image description](/attachment/a7363e4515daa1240bb8d0928fb590b8)\r\n\r\n\r\nwe use twi_sw_master reference code\r\n![image description](/attachment/8430147c4f69881c2c194eff4d71a0c4)\r\n\r\n![image description](/attachment/ff450d39c6cd29b2f1b62189f8294efe)",
    "tag": "i2c"
  },
  {
    "text": "Why does PWM consume so much power? According to the nrf52 product specifications, the PWM peripheral consumes 200 uA running at 16MHz. But a TIMER in combination with PPI an GPIOTE consumes 30.1uA max. Why the big difference?",
    "tag": "pwm"
  },
  {
    "text": "How to read multiple sensors over TWI? (nrf_drv_twi) I had slightly modified a TWI example (using nrf_drv_twi) to work with one of my sensors; It's basically the same with a different function called to handle the received data.\r\n\r\nHowever, I have multiple sensors and multiple sets of data I'd like to be able to query from each, but it seems that the TWI interrupt handler doesn't provide much scope to do this. Or at least, I can't figure out how it would.\r\n\r\nI initiate the transfer by making a call to the TWI tx function in my main loop:\r\n\r\n         do\r\n\t{\r\n\t\t__WFE();\r\n\t}while(m_twi_rx_done == false);\r\n\terr_code = nrf_drv_twi_tx(&m_twi_sensors, LSM303_ADDRESS_ACCEL, &test, sizeof(test), true);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\tm_twi_rx_done = false;\r\n\r\nI can see that without much difficulty I could address a different register or sensor in changing this. However, I don't see how I would RECEIVE different data within the TWI interrupt handler:\r\n\r\n    void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n    {\r\n    \tret_code_t err_code;\r\n    \tstatic acc_sample_t m_sample; // \r\n    \t\r\n    \tswitch(p_event->type)\r\n    \t{\r\n    \t\tcase NRF_DRV_TWI_RX_DONE:\r\n    \t\t\tLSM303_read_acc(&m_sample);\r\n    \t\t\tm_twi_rx_done = true;\r\n    \t\t\tbreak;\r\n    \t\t\r\n    \t\tcase NRF_DRV_TWI_TX_DONE:\r\n    \t\t\tif(m_twi_cmd_done != true)\r\n    \t\t\t{\r\n    \t\t\t\tm_twi_cmd_done = true; // IF just a tx command, it's done\r\n    \t\t\t\treturn;\r\n    \t\t\t}\r\n    \t\t\tm_twi_rx_done = false;\r\n    \t\t\t/* read sizeof(m_sample) bytes from the specified address */\r\n    \t\t\terr_code = nrf_drv_twi_rx(&m_twi_sensors, LSM303_ADDRESS_ACCEL, (uint8_t*)&m_sample, sizeof(m_sample), false);\r\n    \t\t\tAPP_ERROR_CHECK(err_code);\r\n    \t\t\tbreak;\r\n    \t\t\t\r\n    \t\tdefault:\r\n    \t\t\tbreak;\r\n    \t}\r\n    \t\r\n    }\r\n\r\nIt doesn't seem like I can manage what happens on an \"NRF_DRV_TWI_RX_DONE\" event if I were to be addressing a different sensor which returned data of a different length; It would always just be set by what happens in the \"NRF_DRV_TWI_TX_DONE\" event, which I also can't change on the fly.\r\n\r\nHow would I go about managing this situation with multiple sensors?\r\n ",
    "tag": "twi"
  },
  {
    "text": "How to read multiple sensors over TWI? (nrf_drv_twi) I had slightly modified a TWI example (using nrf_drv_twi) to work with one of my sensors; It's basically the same with a different function called to handle the received data.\r\n\r\nHowever, I have multiple sensors and multiple sets of data I'd like to be able to query from each, but it seems that the TWI interrupt handler doesn't provide much scope to do this. Or at least, I can't figure out how it would.\r\n\r\nI initiate the transfer by making a call to the TWI tx function in my main loop:\r\n\r\n         do\r\n\t{\r\n\t\t__WFE();\r\n\t}while(m_twi_rx_done == false);\r\n\terr_code = nrf_drv_twi_tx(&m_twi_sensors, LSM303_ADDRESS_ACCEL, &test, sizeof(test), true);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\tm_twi_rx_done = false;\r\n\r\nI can see that without much difficulty I could address a different register or sensor in changing this. However, I don't see how I would RECEIVE different data within the TWI interrupt handler:\r\n\r\n    void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n    {\r\n    \tret_code_t err_code;\r\n    \tstatic acc_sample_t m_sample; // \r\n    \t\r\n    \tswitch(p_event->type)\r\n    \t{\r\n    \t\tcase NRF_DRV_TWI_RX_DONE:\r\n    \t\t\tLSM303_read_acc(&m_sample);\r\n    \t\t\tm_twi_rx_done = true;\r\n    \t\t\tbreak;\r\n    \t\t\r\n    \t\tcase NRF_DRV_TWI_TX_DONE:\r\n    \t\t\tif(m_twi_cmd_done != true)\r\n    \t\t\t{\r\n    \t\t\t\tm_twi_cmd_done = true; // IF just a tx command, it's done\r\n    \t\t\t\treturn;\r\n    \t\t\t}\r\n    \t\t\tm_twi_rx_done = false;\r\n    \t\t\t/* read sizeof(m_sample) bytes from the specified address */\r\n    \t\t\terr_code = nrf_drv_twi_rx(&m_twi_sensors, LSM303_ADDRESS_ACCEL, (uint8_t*)&m_sample, sizeof(m_sample), false);\r\n    \t\t\tAPP_ERROR_CHECK(err_code);\r\n    \t\t\tbreak;\r\n    \t\t\t\r\n    \t\tdefault:\r\n    \t\t\tbreak;\r\n    \t}\r\n    \t\r\n    }\r\n\r\nIt doesn't seem like I can manage what happens on an \"NRF_DRV_TWI_RX_DONE\" event if I were to be addressing a different sensor which returned data of a different length; It would always just be set by what happens in the \"NRF_DRV_TWI_TX_DONE\" event, which I also can't change on the fly.\r\n\r\nHow would I go about managing this situation with multiple sensors?\r\n ",
    "tag": "i2c"
  },
  {
    "text": "using the pwm library with sdk 10 from nordic Hello dev zone.\r\n\r\nI would like to have my nrf51-dk send out pwm signals to an H-bridge IC to control some dc motors and i saw the pwm library you made ([here](https://github.com/NordicSemiconductor/nrf51-pwm-library)) but whenever i try to fit it in my Keil project there comes some errors. I saw that the library was made for sdk 7.0.1 so i went and tried to use that SDK to try and see where the holes were but i couldn't quite get them all. \r\n\r\nThe major problem that's seems to be in nrf_pwm.c when the `nrf_gpiote_unconfig()` and the `nrf_gpiote_config()` are called. I get the \"implicit declaration of function, invalid in C99\" error. Can someone help me to figure out how to resolve this so i can begin experimenting with sending some pwm signals?",
    "tag": "pwm"
  },
  {
    "text": "should I set SPI master priority to NRF_APP_PRIORITY_HIGH when using with SoftDevice I have an application which uses SPI to communicate with ADC. \r\n\r\nwhen I don't use SoftDevice and use `nrf_drv_timer` to start conversion periodically it works\r\n\r\n\r\nbut when I use SoftDevice and use `app_timer` which need the softDevice e**nabled to work** (i'm I mistaken?) I got false conversions\r\n\r\n\r\nwith SoftDevice : when I initialise SPI first and then SoftDevice it doestn work\r\nwhen I initialsie SoftDevice first and then initialsie SPI at the end, the SPI seems to work (the spi_master_evt_handler is executed after `spi_master_send_recv` completed, can see my led toggle) but then I got false  ADC conversion so I think there is something wrong with the SPI\r\n\r\n\r\nI tried to put the `spi_master_evt_handler` code in main code and just just put flag on the handler but still not working\r\n\r\n**now** when I try to set `spi_instance.SPI_PriorityIRQ = NRF_APP_PRIORITY_HIGH;` according to this [link](http://paste.ubuntu.com/9342369/) my program freeze (I think `spi_master_evt_handler` is not called)\r\n\r\n\r\nso is `spi_instance.SPI_PriorityIRQ = NRF_APP_PRIORITY_HIGH` mandatory when using Softdevice and why it's not working in my case\r\n\r\nnotice then in my program I just called `ble_stack_init`and without setting `softdevice_ble_evt_handler_set` (I just enabled soft device (`sd_ble_enable`))",
    "tag": "spi"
  },
  {
    "text": "app_timer not working without softdevice even by initialising it expilicitelly I'm trying to use app_timer without softdevice, I tried to initialise it explicitally but still not working\r\n\r\n    static void lfclk_config(void)\r\n    {\r\n        uint32_t err_code = nrf_drv_clock_init(NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        nrf_drv_clock_lfclk_request();\r\n    }\r\n\r\nwhen I use app_timer without scheduler, should I erase softdevice region??\r\nI called this from main, please see the attachment[main.c](/attachment/e980568208a3457b691405886619169b)  ",
    "tag": "timer"
  },
  {
    "text": "NRF_ERROR_SVC_HANDLER_MISSING on SPI master open I get NRF_ERROR_SVC_HANDLER_MISSING error in spi_open function.\r\n\r\n    uint32_t err = sd_nvic_ClearPendingIRQ(p_spi_instance->irq_type);\r\n    APP_ERROR_CHECK(err);\r\n\r\nI'm using dfu_dual_bank_ble_s110_pca10028 project for my bootloader project.\r\nI understand that SD must be initialized before SPI initialization, but I don't need SD in this moment since I will flash the SD with my functions and not MBR. This bootloader uses SPI external flash to read data which must be flashed, since SD is one of the thing I must update, it should not be initiated.\r\n\r\nAny way to initialize SPI in this example without enabling the SD?\r\n\r\nThank you!\r\n\r\nBr,\r\nMladen\r\n",
    "tag": "spi"
  },
  {
    "text": "app_timer and nrf_drv_timer what's the difference between app_timer api an nrf_drv_timer\r\n\r\nare they using separate timers or the same timers?\r\n\r\nif they are using the same timers, can app_timer_create detect a timer (TIMER1 for example) I used with nrf_drv_timer so that it will not take it as free timer in the // Find free timer loof of `app_timer_create`  function)",
    "tag": "timer"
  },
  {
    "text": "PWM current / power consumption Hello,\r\n\r\nI need help,\r\n\r\nI'am using uvision V5.17, SDK 9.0.0 and SD130.\r\n\r\n\r\nFirst problem is solved,\r\n\r\nIf I don't declare app_pwm_init() in app_pwm.h, the current is 0.4mAh steadily,\r\n\r\nbut If I declare app_pwm_init() the current increase to 1.6mAh.\r\n\r\nSo I reference from this blog I found the answer.\r\n\r\nbut it's not perfect.\r\n\r\n    static void start_servo(void)\r\n    {\t\t\t\t\r\n        nrf_drv_gpiote_out_task_enable(SERVO_PIN);\r\n\t\r\n        /* Initialize and enable PWM. */\r\n        uint32_t err_code = app_pwm_init(m_pwm_t, m_pwm1_cfg, servo_ready_callback);\r\n        APP_ERROR_CHECK(err_code);\r\n\t\r\n        app_pwm_enable(m_pwm_t);\r\n    }\r\n-----------------------------after above start_servo() the current becomes 1.6mAh\r\n\r\n    static void stop_servo(void)\r\n    {\t\r\n\t\tapp_pwm_disable(m_pwm_t);\r\n\t\tnrf_drv_gpiote_out_task_disable(SERVO_PIN);\r\n\t\r\n\t\tuint32_t err_code = app_pwm_uninit(m_pwm_t);\r\n\t\tAPP_ERROR_CHECK(err_code);\r\n\t\r\n\t\tnrf_gpio_cfg_output(SERVO_PIN);\r\n\t\tnrf_gpio_pin_set(SERVO_PIN);\t\t\r\n    }\r\n-----------------------------after above stop_servo() the current becomes 0.3 to 0.9mAh\r\n\r\nThe problem is that before I declare start_servo() first time,\r\n\r\nthe current maintain 0.4mAh steadily, but after start_servo() and stop_servo(),\r\n\r\nthe current maintain 0.3mAh to 0.9mAh rapidly.\r\n\r\nI wanna get 0.4mAh or less when I don't use servo. How can I fix it?\r\n",
    "tag": "pwm"
  },
  {
    "text": "TIMER1->INTENSET cause a ble connection drop problem. Hi,\r\n\r\nI want to use timer1 or 2 interrupt ISR to generate complicated PWM signal.\r\nbut the **timer->intenset** setting cause ble connection drop problem.\r\n\r\nPlease refer to my code below.\r\n\r\n\tNRF_TIMER2->MODE      = TIMER_MODE_MODE_Timer;\r\n\tNRF_TIMER2->BITMODE   = TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos;\r\n\tNRF_TIMER2->PRESCALER = 9;\r\n\r\n\t// Clears the timer, sets it to 0.\r\n\tNRF_TIMER2->TASKS_CLEAR = 1;\r\n\r\n\t// Load the initial values to TIMER2 CC registers.\r\n\tNRF_TIMER2->CC[0] = 10000;\r\n\r\n\t// Interrupt setup.\r\n\t*NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);*\r\n\r\n\r\n\t// Enable interrupt on Timer 2.\r\n\t//NVIC_EnableIRQ(NRF_TIMER2);\r\n\r\n\t// Start the timer.\r\n\tNRF_TIMER2->TASKS_START = 1;\t\r\n\r\n\r\nif I comment out the TIMER2->INTENSET, then no problem.\r\n\r\nPlease let me know why...\r\n\r\nBest regards,\r\nJoy Kang.",
    "tag": "timer"
  },
  {
    "text": "TWI not working on nrf52832 dev board: NRF_DRV_TWI_ERROR Hi,\r\n\r\nI have a pretty hard time to get I2C/TWI running on my 52832 Dev-board (pca 10036).\r\nMy problem is, that i do not get any physical I2C signal out of the board's pins.\r\nI tried nordic's TWI master/slave example from the SDK 0.9.2, shortened the relevant pins, with no success. \r\nThen I wrote a minimal TWI test programm.\r\nE.g.: \r\n\r\n    const nrf_drv_twi_t           p_twi_instance = NRF_DRV_TWI_INSTANCE(1);\r\n\r\n    ret_code = nrf_drv_twi_init(&p_twi_instance, &p_twi_config, twi_event_handler); // Initiate twi driver with instance and configuration values\r\n    APP_ERROR_CHECK(ret_code); // Check for errors in return value\r\n\r\n    nrf_drv_twi_enable(&p_twi_instance); // Enable the TWI instance\r\n\r\n    // Send dummy data on TWI buss on address 0x68\r\n     ret_code = nrf_drv_twi_tx(&p_twi_instance, address, &dummy_data, 1, false);\r\n\r\n\r\n\r\nand handle the twi event:\r\n\r\n\r\n    // TWI event handler. Processing TWI events originating from\r\n    // nrf_drv_twi_tx()\r\n\r\n    static void twi_event_handler(nrf_drv_twi_evt_t *evt){\r\n\r\n       if(evt->type == NRF_DRV_TWI_ERROR)\r\n       {\r\n          /* Error 2 is\r\n          * NRF_TWI_ERROR_ADDRESS_NACK = TWI_ERRORSRC_ANACK_Msk,\r\n          * NACK received after sending the address.\r\n          * as defined in nrf_twi.h\r\n          * So I guess I don't get any response from my external device.\r\n          */\r\n       }\r\n\r\n       if(evt->type == NRF_DRV_TWI_TX_DONE)\r\n       {\r\n          SEGGER_RTT_printf(0,\"TWI event success ...\\r\\n\");\r\n       }\r\n    }\r\n\r\nThe TWI is initiated without any error and the program runs fine, but in the event handler I always get a NRF_DRV_TWI_ERROR, regardless of the TWI slaves.\r\n\r\nThen i attached my Saleae Logic Analyzer into the TWI bus with 10K Ohm pull-up resistors to see, if there are any logic signals. But neither for SCL nor SCA pins was any signal detected. \r\n\r\nThen I  probed every pin on the 52832 Dev-Board with the logic analyzer, just to make sure I don't have misconfigured pins, but i could not get any signal on any pin. \r\n\r\nNext I probed the logic analyzer with a 51822 board, and with this board I can see the SCL and SCA signals, so the logic analyzer is working correctly.\r\n\r\nSo, is TWI (nrf_drv_twi.c, etc.) working on a 52832 Dev-board?\r\n\r\nAny idea, why I don't even get the TWI clock signal on the pin?\r\n\r\nIs my board maybe physically damaged?\r\n\r\nAny help is greatly appreciated!\r\nYours Johannes\r\n\r\n\r\n\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "TWI not working on nrf52832 dev board: NRF_DRV_TWI_ERROR Hi,\r\n\r\nI have a pretty hard time to get I2C/TWI running on my 52832 Dev-board (pca 10036).\r\nMy problem is, that i do not get any physical I2C signal out of the board's pins.\r\nI tried nordic's TWI master/slave example from the SDK 0.9.2, shortened the relevant pins, with no success. \r\nThen I wrote a minimal TWI test programm.\r\nE.g.: \r\n\r\n    const nrf_drv_twi_t           p_twi_instance = NRF_DRV_TWI_INSTANCE(1);\r\n\r\n    ret_code = nrf_drv_twi_init(&p_twi_instance, &p_twi_config, twi_event_handler); // Initiate twi driver with instance and configuration values\r\n    APP_ERROR_CHECK(ret_code); // Check for errors in return value\r\n\r\n    nrf_drv_twi_enable(&p_twi_instance); // Enable the TWI instance\r\n\r\n    // Send dummy data on TWI buss on address 0x68\r\n     ret_code = nrf_drv_twi_tx(&p_twi_instance, address, &dummy_data, 1, false);\r\n\r\n\r\n\r\nand handle the twi event:\r\n\r\n\r\n    // TWI event handler. Processing TWI events originating from\r\n    // nrf_drv_twi_tx()\r\n\r\n    static void twi_event_handler(nrf_drv_twi_evt_t *evt){\r\n\r\n       if(evt->type == NRF_DRV_TWI_ERROR)\r\n       {\r\n          /* Error 2 is\r\n          * NRF_TWI_ERROR_ADDRESS_NACK = TWI_ERRORSRC_ANACK_Msk,\r\n          * NACK received after sending the address.\r\n          * as defined in nrf_twi.h\r\n          * So I guess I don't get any response from my external device.\r\n          */\r\n       }\r\n\r\n       if(evt->type == NRF_DRV_TWI_TX_DONE)\r\n       {\r\n          SEGGER_RTT_printf(0,\"TWI event success ...\\r\\n\");\r\n       }\r\n    }\r\n\r\nThe TWI is initiated without any error and the program runs fine, but in the event handler I always get a NRF_DRV_TWI_ERROR, regardless of the TWI slaves.\r\n\r\nThen i attached my Saleae Logic Analyzer into the TWI bus with 10K Ohm pull-up resistors to see, if there are any logic signals. But neither for SCL nor SCA pins was any signal detected. \r\n\r\nThen I  probed every pin on the 52832 Dev-Board with the logic analyzer, just to make sure I don't have misconfigured pins, but i could not get any signal on any pin. \r\n\r\nNext I probed the logic analyzer with a 51822 board, and with this board I can see the SCL and SCA signals, so the logic analyzer is working correctly.\r\n\r\nSo, is TWI (nrf_drv_twi.c, etc.) working on a 52832 Dev-board?\r\n\r\nAny idea, why I don't even get the TWI clock signal on the pin?\r\n\r\nIs my board maybe physically damaged?\r\n\r\nAny help is greatly appreciated!\r\nYours Johannes\r\n\r\n\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "send pwm to motor via button press I am trying to have the dk (i have the 10036 preview) send pwm signals to a motor controller so that i can direct its speed. I have based a lot of the code below of [this](https://github.com/electronut/nRF51-TB6612FNG-test/blob/master/main.c)utorial as well as some questions here in the dev zone but I can't seem to figure out why there's no signal going out. \r\n\r\nI can get the motors to start, stop, and change direction but that's just by setting the right output pins which only happens if i comment out all the pwm code (init, start(), stop()), the motor spins at the factory default setting which isn't very high. Below is all the code i put in that pertains to pwm. Please point me in the right direction, thank you\r\n\r\n    APP_PWM_INSTANCE(PWM1,1);\r\n    // A flag indicating PWM status.\r\n    static volatile bool pwmReady = false;            \r\n\r\n    // PWM callback function\r\n    void pwm_ready_callback(uint32_t pwm_id)    \r\n    {\r\n        pwmReady = true;\r\n    }\r\n    \r\n    \r\n    // Motor #1\r\n    int PWMA = 1; //Speed control \r\n    int Motor1_1 = 12; //Direction\r\n    int Motor1_2 = 13; //Direction\r\n    \r\n    \r\n    void init_motors(void)\r\n    {\r\n      // set up GPIOs\r\n      nrf_gpio_cfg_output(Motor1_1);\r\n      nrf_gpio_cfg_output(Motor1_2);\r\n    }\r\n    \r\n    \r\n    static void PWMinit(void)\r\n    {\r\n      app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(9000L, 15);\r\n      pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n      app_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n      app_pwm_enable(&PWM1);\r\n    }\r\n    \r\n    void pwm_stop(void)\r\n    {\r\n    \t\t//Stop PWM\r\n    \t\tapp_pwm_disable(&PWM1);\r\n    \t\tnrf_drv_gpiote_out_task_disable(PWMA);\r\n    }\r\n    \r\n    void pwm_start(void)\r\n    {   \r\n        nrf_drv_gpiote_out_task_enable(PWMA); \r\n        app_pwm_enable(&PWM1);\r\n        while (app_pwm_channel_duty_set(&PWM1, 0, 95) == NRF_ERROR_BUSY);\r\n    }\r\n    \r\n    \r\n    // Function for handling the data from the Nordic UART Service.\r\n    static void nus_data_handler(ble_nus_t * p_nus, uint8_t * p_data, \r\n                                 uint16_t length)\r\n    {\r\n      if (strstr((char*)(p_data), RECORD)) {\r\n    \t\t\r\n      }\r\n      else if (strstr((char*)(p_data), SHUFFLE)) {\r\n        \r\n      }\r\n      else if (strstr((char*)(p_data), STOP)) {\r\n        pwm_stop();\r\n    \t\tnrf_drv_gpiote_out_task_disable(Motor1_1);\r\n    \t\tnrf_gpio_cfg_output(Motor1_1);\r\n    \t\tnrf_gpio_pin_clear(Motor1_1);\r\n    \t\tnrf_drv_gpiote_out_task_disable(Motor1_2);\r\n    \t\tnrf_gpio_cfg_output(Motor1_2);\r\n    \t\tnrf_gpio_pin_clear(Motor1_2);\r\n      }\r\n      else if (strstr((char*)(p_data), PLAY)) {\r\n    \t\t\r\n      }\r\n      else if (strstr((char*)(p_data), FORWARD)) {\r\n        pwm_start();\r\n    \t\tnrf_gpio_pin_clear(Motor1_1);\r\n    \t\tnrf_gpio_pin_set(Motor1_2);\r\n      }\r\n      else if (strstr((char*)(p_data), REWIND)) {\r\n        pwm_start();\r\n    \t\tnrf_gpio_pin_set(Motor1_1);\r\n    \t\tnrf_gpio_pin_clear(Motor1_2);\r\n      }\r\n    }\r\n\r\n\r\nThen in main loop\r\n\r\n    #define APP_TIMER_PRESCALER  0    /**< Value of the RTC1 PRESCALER register. */\r\n    #define APP_TIMER_MAX_TIMERS 6    /**< Maximum number of simultaneously created timers. */\r\n    #define APP_TIMER_OP_QUEUE_SIZE 4  /**< Size of timer operation queues. */\r\n    \r\n    // Application main function.\r\n    int main(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n    \t\t\r\n        // set up timers\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, \r\n                       APP_TIMER_OP_QUEUE_SIZE, false);\r\n       \r\n        // initlialize BLE\r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n    \t\r\n    \r\n    \t\tPWMinit();\r\n    \t\r\n        // start BLE advertizing\r\n        err_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // init GPIOTE\r\n        err_code = nrf_drv_gpiote_init();\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // init PPI\r\n        err_code = nrf_drv_ppi_init();\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // intialize UART\r\n        uart_init();\r\n    \r\n        // intitialize motors\r\n        init_motors();\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "count task dont work Hello,\r\n\r\nAfter i disable SD i try to count ticks on TIMER1 from RTC1 via PPI.\r\nTimer1 is configured property but TASK_COUNT don't increment cc.\r\nI see that event TICK on RTC1 is generating. Even if i call NRF_TIMER1->TASK_COUNT=1; cc is not changing.\r\nBefore i make the same scenario without SD and was work property.\r\n\r\nany ideas?\r\n\r\nRegards Michal,",
    "tag": "timer"
  },
  {
    "text": "ADC battery level correct only when debugging I implemented measuring of Lithium battery level with the help of thread [How to measure Lithium battery voltage](https://devzone.nordicsemi.com/question/990/how-to-measure-lithium-battery-voltage/). I am using nRF51422 with SoftDevice 110 and SDK 9.0.0 and Keil uVision IDE. **The problem is that I get right result only when debugging my nRF51 with DevKit.** To work correctly, it is enough to just start the debugging and after it waits to be started on main(), continuing execution. Also, I would prefer to read battery level only on startup.\r\n\r\nWhat could be the reason?\r\n\r\nMy code:\r\n\r\n    void ADC_init(void)\r\n    {\r\n        const nrf_adc_config_t nrf_adc_config = NRF_ADC_CONFIG_DEFAULT;\r\n    \t\r\n        nrf_adc_configure( (nrf_adc_config_t *)&nrf_adc_config);\r\n        nrf_adc_input_select(NRF_ADC_CONFIG_INPUT_3);\r\n        nrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n        NVIC_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_HIGH);\r\n        NVIC_EnableIRQ(ADC_IRQn);\r\n    }\r\n    \r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \tnrf_adc_conversion_event_clean();\r\n    \tfloat adc_sample = nrf_adc_result_get(); // wrong when not debugging\r\n        // getting final value here...\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n        timers_init();\t\r\n        buttons_leds_init(&erase_bonds);\r\n        ble_stack_init();\r\n        ADC_init();\r\n        nrf_adc_start(); // trigger battery level measurement\r\n    \r\n        // other init, advertising, power_manage()..\r\n    }",
    "tag": "adc"
  },
  {
    "text": "nRF51 DK timers Hi,\r\n\r\nFile \"nrf_drv_config.h\" defines both TIMER1_CONFIG_BIT_WIDTH and TIMER2_CONFIG_BIT_WIDTH as \"TIMER_BITMODE_BITMODE_16Bit\", can these timers be configured as 24 bit / 32 bit timers as well?\r\n\r\nI am asking because after changing TIMER1_CONFIG_BIT_WIDTH to \"TIMER_BITMODE_BITMODE_32Bit\", it's not trigger the interrupt handler after 1 second.\r\n\r\nSupposedly, 32 bit and 16 Mhz should be sufficient for 1 second interrupt (Timer0 works using the same settings)\r\n\r\nHere's the code snippet that is not working: (Borrowed from timer example code from Keil pack installer)\r\n\r\n    #if (TIMER1_ENABLED == 1)\r\n    #define TIMER1_CONFIG_FREQUENCY    NRF_TIMER_FREQ_16MHz\r\n    #define TIMER1_CONFIG_MODE         TIMER_MODE_MODE_Timer\r\n    #define TIMER1_CONFIG_BIT_WIDTH    TIMER_BITMODE_BITMODE_32Bit\r\n    #define TIMER1_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n    #define TIMER1_INSTANCE_INDEX      (TIMER0_ENABLED)\r\n    #endif\r\n    \r\n    const nrf_drv_timer_t TIMER_STOP = NRF_DRV_TIMER_INSTANCE(1);\r\n    uint32_t time_stop = 1000;\r\n    err_code = nrf_drv_timer_init(&TIMER_STOP, NULL, timer_stop_event_handler);\r\n    APP_ERROR_CHECK(err_code);\r\n    time_stop_ticks = nrf_drv_timer_ms_to_ticks(&TIMER_STOP, time_stop);\r\n    nrf_drv_timer_extended_compare(\r\n         &TIMER_STOP, NRF_TIMER_CC_CHANNEL1, time_ticks, NRF_TIMER_SHORT_COMPARE1_CLEAR_MASK, true);\r\n    nrf_drv_timer_enable(&TIMER_STOP);\r\n\r\nAlso, what is the preferable way of configuring timer? Some answers on this forum suggest to manipulate the Timer construct directly, like the following:\r\n\r\nhttps://github.com/NordicSemiconductor/nrf51-TIMER-examples/blob/master/timer_example_timer_mode/main.c\r\n\r\nLast question:\r\nThe timer construct shows each timer can have 4 CC, then I assume for each timer, I can use nrf_drv_timer_extended_compare with \"NRF_TIMER_CC_CHANNEL0\", \"NRF_TIMER_CC_CHANNEL1\", \"NRF_TIMER_CC_CHANNEL2\" and \"NRF_TIMER_CC_CHANNEL3\"?\r\n\r\nThanks",
    "tag": "timer"
  },
  {
    "text": "disabling twi/i2c Hey,\r\nI am using twi_hw_master.c and twi_master.h libraries for twi and want to disable i2c to save power when not in use. \r\nI use the following two lines to disable the i2c:\r\n\r\n    NRF_TWI1->ENABLE       = TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos; \r\n\r\n    NRF_TWI1->POWER        = 0;\r\n\r\nbut it still works. What other steps do I need to take in order to disable the twi peripheral?\r\nI'm using nrf51822 on a custom board with sdk9.0.\r\nThanks,\r\nVandita\r\n\r\nCode files:\r\n[main.c](/attachment/da337b2e2d78abc3888618a49bb0fde3)\r\n[latch_i2c.c](/attachment/0cd1c2d800b55683b847b9af47000af1)",
    "tag": "twi"
  },
  {
    "text": "Any example code for OLED sd1306 with TWI/I2C and nrf52 Hi,\r\n\r\n [Here](https://github.com/sincoon/SSD1306_I2C/blob/master/Drivers/u8glib/src/u8g_arm.c) and [here](http://blog.bastelhalde.de/?p=759) are examples of a port of the nice u8glib library to stm32. Based on these, i tried a port to nrf52, but was not successful so far.\r\n\r\nI call the oled display via its DEVICE_ADDRESS 0x78 and\r\n\r\n    ret_code = nrf_drv_twi_tx(&m_twi_master, DEVICE_ADDRESS, buffer, sizeof(buffer), true);\r\n\r\nThe oled does not send a response, so ret_code contains an error code. I not sure if this is an issue, or the initialization of the display itself is not correctly done.\r\n\r\nTherefore, is there any example code available to get an OLED sd1306 module working over TWI/I2C with nrf52?\r\n\r\nYours Johannes",
    "tag": "twi"
  },
  {
    "text": "Any example code for OLED sd1306 with TWI/I2C and nrf52 Hi,\r\n\r\n [Here](https://github.com/sincoon/SSD1306_I2C/blob/master/Drivers/u8glib/src/u8g_arm.c) and [here](http://blog.bastelhalde.de/?p=759) are examples of a port of the nice u8glib library to stm32. Based on these, i tried a port to nrf52, but was not successful so far.\r\n\r\nI call the oled display via its DEVICE_ADDRESS 0x78 and\r\n\r\n    ret_code = nrf_drv_twi_tx(&m_twi_master, DEVICE_ADDRESS, buffer, sizeof(buffer), true);\r\n\r\nThe oled does not send a response, so ret_code contains an error code. I not sure if this is an issue, or the initialization of the display itself is not correctly done.\r\n\r\nTherefore, is there any example code available to get an OLED sd1306 module working over TWI/I2C with nrf52?\r\n\r\nYours Johannes",
    "tag": "i2c"
  },
  {
    "text": "Can not create an SPI connection I've been unsuccessfully trying to serialize BTLE example programs by SPI. I have two PCA10028 boards and I'm using SDK10. In addition to serialization examples, I've tried /peripheral/SPI_master and /peripheral/SPI_master_with_spi_slave. \r\n\r\nThe /peripheral/SPI_master example is fairly basic; it's probably best to troubleshoot with this example. In this example, I connected SPIM MOSI to SPIM MISO. After programming, the program lit up LEDS that symbolize BSP_INDICATE_FATAL_ERROR.\r\n\r\nFor serialization examples, I followed the instructions in the Getting Started --> Running a serialized application documentation. The serialization examples do not show the connectivity board receiving data from the application board. The HRS collector is an example of an serialization program that I've tried.\r\n\r\nHow to I get the board to establish an SPI connection? ",
    "tag": "spi"
  },
  {
    "text": "Can not create an SPI connection I've been unsuccessfully trying to serialize BTLE example programs by SPI. I have two PCA10028 boards and I'm using SDK10. In addition to serialization examples, I've tried /peripheral/SPI_master and /peripheral/SPI_master_with_spi_slave. \r\n\r\nThe /peripheral/SPI_master example is fairly basic; it's probably best to troubleshoot with this example. In this example, I connected SPIM MOSI to SPIM MISO. After programming, the program lit up LEDS that symbolize BSP_INDICATE_FATAL_ERROR.\r\n\r\nFor serialization examples, I followed the instructions in the Getting Started --> Running a serialized application documentation. The serialization examples do not show the connectivity board receiving data from the application board. The HRS collector is an example of an serialization program that I've tried.\r\n\r\nHow to I get the board to establish an SPI connection? ",
    "tag": "spi"
  },
  {
    "text": "S130 2.0.0-7 Alpha not enabling internaly used peripherals Hi\r\n\r\nI've updated our platform to using the S130 2.0.0-7 Alpha (Update1). It turned out, that the initialization in out application failed, because erasing a flash page never triggered a NRF_EVT_FLASH_OPERATION_SUCCESS event.\r\n\r\nI did a lot of tests and finally was able to find the problem source. In our code we disable all peripherals at startup. Later the used peripherals are enabled by the dedicated modules. It turned out, that disabling TIMER0 is a problem for the S130 2.0.0-7, because it doesn't enable the timer itself.\r\n\r\nThe following code snippet shows a test sequence. If the line where the TIMER0 gets disabled is active the end of the code is never reached. If not it works like a charm.\r\n\r\n    /************************************************************************************/\r\n    int main(void)\r\n    {\r\n    \r\n    \tuint32_t error_code;\r\n    \tuint32_t event_id;\r\n    \tbool success_b = false;\r\n    \t\r\n    /*-- Code Statements ---------------------------------------------------------------*/\r\n    \t\r\n    \t// disable TIMER0 before enabling the softdevice\r\n    \tNRF_TIMER0->POWER = 0;\r\n    \r\n      // init softdevice\r\n      sd_softdevice_enable(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, softdevice_assertion_handler_f);\r\n    \t\r\n      // erase to flash\r\n    \terror_code = sd_flash_page_erase(0x3A000 / 1024);\r\n    \tif (error_code != NRF_SUCCESS)\r\n    \t{\r\n    \t\treturn (false);\r\n    \t}\r\n    \t\r\n      // wait for the NRF_EVT_FLASH_OPERATION_SUCCESS in busy loop\r\n      while (!success_b)\r\n      {\r\n    \t\tif (sd_evt_get(&event_id) != NRF_ERROR_NOT_FOUND)\r\n    \t\t{\r\n    \t\t\tif (event_id == NRF_EVT_FLASH_OPERATION_SUCCESS)\r\n    \t\t\t{\r\n    \t\t\t\t// SUCCESS\r\n    \t\t\t\tsuccess_b = true;\r\n    \t\t\t\tbreak;\r\n    \t\t\t}\r\n    \t  }\r\n    \t}\r\n    \t\r\n    \t// code never reached when TIMER0 is powered down at startup\r\n    \twhile (1)\r\n    \t{\r\n    \t}\r\n    \t\r\n    }/* main */\r\n    /************************************************************************************/\r\n\r\nIt's not a problem now as I know the issue. A fix in the upcoming softdevice S130 2.x would be great anyway.\r\n\r\nRegards Adrian\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "Strange values from ADC Hello,\r\n\r\nI am using simple_adc__pca10028 from 8.0.0 SDK to read values from my sensor, its a kind of tensometer. My configurations are:\r\n\r\n- NRF_ADC_CONFIG_RES_10BIT, --- 10 bits of resolution\r\n   \r\n- NRF_ADC_CONFIG_SCALING_INPUT_ONE_THIRD,--- 1/3 of supply value\r\n\r\n- NRF_ADC_CONFIG_REF_SUPPLY_ONE_HALF --- Am I thinking right, is it 3V/2 = 1,5V?\r\n\r\nI suppose my reference voltage should be now 1,5V*3 = 4,5V, right?\r\n\r\nI am sending readings to PC through UART, and my Termite shows values ranging from 175 to 680. I can understand that 680 = (3V/4.5V)*1023, but why 175? Why the lowest values aren't equal to zero? I mean lowest, when the current isn't flowing through my sensor.\r\n\r\nReading the GND values gives me 0, but unplugged wire still 175. please help\r\n\r\nbest regard,\r\ntchitchi\r\n",
    "tag": "adc"
  },
  {
    "text": "C advice with app_twi peripheral configuration I've been trying to wrap my head around the app_twi library by looking at the examples, and I'm slowly getting there.\r\nHowever, for my application I need to send multiple default configuration commands to my accelerometer. \r\n\r\nSo I was wondering, what is the neatest way to implement this? Would I simply make another default_config[] type array and put an additional write into the \"lm75b_init_transfers\" array? Or is there a neater way to include all of the config data in one default_config[] array? My C is a little rusty, but I feel like a struct might be what I need but I'm not sure how I'd implement it in this case.\r\n\r\nThe configuration code as it is in the example is show below.\r\n\r\n    uint8_t const lm75b_conf_reg_addr  = LM75B_REG_CONF;\r\n    uint8_t const lm75b_temp_reg_addr  = LM75B_REG_TEMP;\r\n    uint8_t const lm75b_tos_reg_addr   = LM75B_REG_TOS;\r\n    uint8_t const lm75b_thyst_reg_addr = LM75B_REG_THYST;\r\n    \r\n    \r\n    // Set default configuration of LM75B - write 0 to Conf register.\r\n    static uint8_t const default_config[] = { LM75B_REG_CONF, 0 }; \r\n    ///// I need two config commands \r\n    \r\n    app_twi_transfer_t const lm75b_init_transfers[LM75B_INIT_TRANSFER_COUNT] =\r\n    {\r\n        APP_TWI_WRITE(LM75B_ADDR, default_config, sizeof(default_config), 0)\r\n        /////, Another APP_TWI_WRITE for additional config command here?\r\n    };",
    "tag": "twi"
  },
  {
    "text": "Unable To Generate PWM Signal Hello,\r\n\r\nI am currently trying to generate a PWM signal on P0.00 and am not having success. If I drive P0.00 without PWM, everything works fine. Is there anything that would prevent me from using PWM on P0.00. I am currently on SDK 9 and SoftDevice S110 V8, I have also added the app_pwm.c and app_pwm.h files from SDK 10 to my project.\r\n\r\nI am using two instances  and init them in the following way:\r\n\r\n    void pwm_init(void)\r\n    {\r\n\tret_code_t err_code;\r\n\r\n\tapp_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(400L, LED_RED, LED_GREEN);\r\n\tapp_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_1CH(400L, LED_BLUE);\r\n\r\n\t/* Set the polarity of the channel. */\r\n\tpwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\tpwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\tpwm2_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\r\n\t/* Initialize and enable PWM. */\r\n\terr_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm_1_ready_callback);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\terr_code = app_pwm_init(&PWM2,&pwm2_cfg,pwm_2_ready_callback);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\r\n\tapp_pwm_enable(&PWM1);\r\n\tapp_pwm_enable(&PWM2);\r\n    }\r\n\r\nLED_BLUE is set to P0.00, LED_RED to P0.02, and LED_GREEN to P0.03.\r\n\r\nThe red and green LEDs on my board work great, it is only the blue LED that is having problems.\r\n\r\nI used this same pwm_init function and other functions that set the output of the LED on the previous hardware revision of my custom board and the only thing that has changed is that the blue LED moved from P0.01 to P0.00.\r\n\r\nI probed P0.00 on the chip using my oscilloscope and I didn't see any signal at all.\r\n\r\nAny help anyone can provide is much appreciated.\r\n\r\nThanks!\r\n\r\n-Cory",
    "tag": "pwm"
  },
  {
    "text": "data transfer using timer HI,all,\r\nMERRY CHRISTMAS!!!!\r\ni have an issue when i want to try the  data transfer using timer\r\n\r\ni have a idea about it , but i do not know how to achieve it.\r\n\r\n-my project is the nus project\r\n\r\n-and i have two nrf eva board.\r\n\r\n-one for client and one for server\r\n\r\n-i don't mean that some kind people to help me to code, but a method to try my idea.\r\ni am now confused ,\r\n\r\nthank you all .\r\n\r\n1  i want to init the timer first.\r\n\r\n2 the data received from usart\r\n\r\n3 when the number of the data reached 300 byte, the timer enabled and transfer the data,\r\n  after transferring the data, the timer should hang up for the next 300 bytes data.\r\n\r\n4 if the number of data don't reaches 300 byte,the timer enabled and transfer the data.",
    "tag": "timer"
  },
  {
    "text": "I2C: How do I specify a register address to read from when calling nrf_drv_twi_rx()? I'm using nrf_drv_twi to talk to an accelerometer from an nRF51822 on a custom board. I'm on SDK 10.0.0. I'm following the example from the SDK, peripheral/twi_sensor. And I'm using blocking mode, with no handler.\r\n\r\nIn the calls to nrf_drv_twi_tx(), I see the example code is using a two element array of uint8_t where the first element is the register address and the second is the value.\r\n\r\n\tregister_value_pair[0] = KXTJ2_CTRL_REG1;\r\n\tregister_value_pair[1] = 0b00000000;\r\n\terr_code = nrf_drv_twi_tx(&m_twi_kionix, KIONIX_SLAVE_ADDRESS, register_value_pair,\r\n\t\t\tsizeof(register_value_pair), false);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\r\nSo far so good. But when it comes to the RX, the third param is just data, with no register address. How can the slave device or the driver possibly know which register I'm reading?\r\n",
    "tag": "twi"
  },
  {
    "text": "nrf51822 gpiote and timer capture pulse width Hi:\r\nI want to capture the parameter of a digital wave like this, I want to get every 't' value. The wave is same in a period of time, but the 51822 capture value of 't' is shaking(the right value is 1500us,and 51822 capture value is 1400 to 1600us random ). I use nrf_drv_gpiote and nrf_drv_timer.My code is as follow. Can you give me some suggestions.\r\n\r\n![image description](/attachment/606f0e7ce3d265d11cc55167ff807c59)\r\n\r\nfunction inital\r\n\r\n             const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(0);    \t\r\n             nrf_drv_gpiote_init();\r\n\tconst nrf_drv_gpiote_in_config_t GP_config = \r\n\t{\r\n\t\tNRF_GPIOTE_POLARITY_HITOLO,\r\n\t\tNRF_GPIO_PIN_PULLUP,\r\n\t\tfalse,\r\n\t\ttrue\t\r\n\t};\r\n\tnrf_drv_gpiote_in_init(PPM_pin, &GP_config, pin_event_handler);\r\n\tnrf_drv_gpiote_in_event_addr_get(PPM_pin);\r\n\t\r\n\tnrf_drv_gpiote_in_event_enable(PPM_pin, true);\r\n\tconst nrf_drv_timer_config_t TI_config = \r\n\t{\r\n\t\tNRF_TIMER_FREQ_1MHz,\r\n\t\tNRF_TIMER_MODE_TIMER,\r\n\t\tNRF_TIMER_BIT_WIDTH_32,\r\n\t\t0,\r\n\t\tNULL\r\n\t};\r\n  nrf_drv_timer_init(&TIMER_LED, &TI_config, timer_led_event_handler);\r\n\tnrf_drv_timer_enable(&TIMER_LED);\r\n\r\n    void pin_event_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)\r\n    {\r\n\tstatic uint32_t ftime=0,stime=0;\r\n\tstatic uint8_t ch_num = 0;\r\n\tif((pin == PPM_pin) && (action == NRF_GPIOTE_POLARITY_HITOLO))\r\n\t{\r\n\t\tftime = nrf_drv_timer_capture(&TIMER_LED,NRF_TIMER_CC_CHANNEL3);\r\n\t\t//printf(\"%d\\n\\r\",ftime);\r\n\t\tdtime = ftime - stime;\r\n\t\t//printf(\"%d\\n\\r\",dtime);\r\n\t\t//stime = ftime;\r\n\t\tif(dtime > 2550)\r\n\t\t{\r\n\t\t\tch_num = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\t\r\n\t\t\t\tChannel_data[ch_num] = dtime;\r\n\t\t\t\tch_num++;\r\n\t\t}\t\r\n\t\tnrf_gpio_pin_toggle(25);\r\n\t\tstime = nrf_drv_timer_capture(&TIMER_LED,NRF_TIMER_CC_CHANNEL3);\r\n\t}\r\n\t//NRF_GPIOTE->EVENTS_IN[0] = 0;\r\n}\r\n\r\n\r\nPS: the dtime is the value I want.\r\nPlease give me some suggestion.\r\nThank you!",
    "tag": "timer"
  },
  {
    "text": "Strange behaviour SPI_MASTER peripheral Dear Nordic developers,\r\n\r\nSPI_MASTER peripheral behaves in a way, that I cannot understand from manual is it normal or no.\r\n\r\nI have implemented something similar to loopback example.\r\nAfter initialization I'm writing first byte to the TXD register and immediately after the first one second byte. (as it has double buffer).\r\nAs I expect, I'm getting two READY events. In a first READY event I'm reading RXD register two times and I get expected two values already in a first READY event.\r\n\r\nI was thinking that I should get first byte in a first READY event and the second byte in a second READY event.\r\nMy simplified code is bellow.\r\n           \r\n    void SPI0_TWI0_IRQHandler(void)\r\n    {\r\n        if ((NRF_SPI0->EVENTS_READY == 1) && (NRF_SPI0->INTENSET & SPI_INTENSET_READY_Msk))\r\n        {\r\n            NRF_SPI0->EVENTS_READY = 0;\r\n            if (first_ready_event)\r\n            {\r\n               rx_data[0] = (uint8_t)spi_base->RXD;\r\n               rx_data[1] = (uint8_t)spi_base->RXD;\r\n            }\r\n         if (second_ready_event)\r\n         // do nothing\r\n        }\r\n    }\r\n\r\n\r\n     int main()\r\n     {\r\n        while(true)\r\n        {\r\n           master_spi->TXD =cnt;\r\n           master_spi->TXD =cnt + 1;\r\n           nrf_delay_us(100);\r\n        }\r\n      }\r\n\r\n\r\nI'd really appreciate if someone could help me and clarify all this.\r\n\r\nThanks and regards,\r\nHarut",
    "tag": "spi"
  },
  {
    "text": "What is extended compare mode in timer? I was going through the timer resources and I found a function nrf_drv_timer_extended_compare . Can someone please explain me what this function does?\r\n![image description](/attachment/5810f3d603cc64f3f2ffe11289a60731)\r\n",
    "tag": "timer"
  },
  {
    "text": "After calling sd_softdevice_enable then SystemReset. Why? I use the SDK v11.0 alpha, the S130 with my USB-dongle(NRF51422).\r\n\r\nI use the low_power_pwm to initialize 4 different PWMs. I used the Example low_power_pwm_s130_pca10031 and just added one PWM. It worked fine.\r\n\r\nThen i took the ble_app_hrs_c_s130_pca10031 Example added the 4 PWMs.\r\nNow i get a SystemReset when i call the sd_softdevice_enable function and get the err_code  \tNRF_ERROR_INVALID_STATE.\r\n\r\nWhy i can't enable the softdevice?\r\n\r\n    int main(void){\r\n    bool erase_bonds;\r\n\t\t\r\n    // Initialize.\r\n    SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, false);\t\t\t//ADDED by Pechi\r\n    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, NULL);\t\t//ADDED by Pechi\r\n    low_power_init();\t\t\t\t\t\t\t\t\t\t\t\t\t\t//ADDED by Pechi Init of 4 PWMs\r\n    \r\n    buttons_leds_init(&erase_bonds);\r\n    nrf_log_init();\r\n    ble_stack_init();\t\t\t\t\t//!Here! SystemReSet after calling sd_softdevice_enable\r\n    device_manager_init(erase_bonds);\r\n    db_discovery_init();\r\n    hrs_c_init();\r\n    bas_c_init();\r\n\t\t\r\n    // Start scanning for peripherals and initiate connection\r\n    // with devices that advertise Heart Rate UUID.\r\n    scan_start();\r\n\t\t\r\n    for (;; )\r\n    {\r\n        power_manage();\r\n    }\r\n",
    "tag": "pwm"
  },
  {
    "text": "Buzzer beep in Immediate Alert Service Hi.\r\nI am adding buzzer beeping in Immediate Alert Service of ble_app_proximity example. Event thought Immediate Alert signal is sent from nRF Master Control, there is no beeping. I would like to know the reason and how to solve it.\r\n\r\nThe code is as follows:\r\n(1) In alert_signal() function:\r\n\r\n        static void alert_signal(uint8_t alert_level) {\r\n        uint32_t err_code;\r\n        switch (alert_level) {\r\n            case BLE_CHAR_ALERT_LEVEL_NO_ALERT:\r\n                err_code = bsp_indication_set(BSP_INDICATE_ALERT_OFF);\r\n                APP_ERROR_CHECK(err_code);\r\n    \t    pwm_stop();\r\n                break;\r\n            case BLE_CHAR_ALERT_LEVEL_MILD_ALERT:\r\n                err_code = bsp_indication_set(BSP_INDICATE_ALERT_0);\r\n                APP_ERROR_CHECK(err_code);\r\n    \t    pwm_start();\r\n                break;\r\n            case BLE_CHAR_ALERT_LEVEL_HIGH_ALERT:\r\n                err_code = bsp_indication_set(BSP_INDICATE_ALERT_3);\r\n                APP_ERROR_CHECK(err_code);\r\n    \t    pwm_start();\r\n                break;\r\n            default:\r\n                // No implementation needed.\r\n                break;\r\n        }\r\n    }\r\n\r\n(2) In main() function, before calling advertising_start(), the following statement is added:\r\n\r\n    init_pwm(1000L, BUZZER);\r\n\r\n(3) The following C file is linked:\r\n\r\n    APP_PWM_INSTANCE(PWM1, 1);                   // Create the instance \"PWM1\" using TIMER1.\r\n    static volatile bool ready_flag;            // A flag indicating PWM status.\r\n    \r\n    void pwm_ready_callback(uint32_t pwm_id) {   // PWM callback function\r\n        ready_flag = true;\r\n    }\r\n    \r\n    uint32_t init_pwm(uint32_t perior, uint8_t pin) {   \r\n    \tuint32_t err_code = 0;\r\n    \r\n    \tnrf_gpio_pin_dir_set(pin, NRF_GPIO_PIN_DIR_OUTPUT);\r\n    \tnrf_gpio_pin_clear(pin);\r\n    \r\n    \t/* 2-channel PWM, 200Hz, output on DK LED pins. */\r\n    \tapp_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(perior, pin);\r\n    \r\n    \tpwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_LOW;\r\n    \r\n        /* Initialize and enable PWM. */\r\n        err_code = app_pwm_init(&PWM1, &pwm1_cfg, pwm_ready_callback);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t/* \r\n    \tapp_pwm_enable(&PWM1);\r\n    \twhile (app_pwm_channel_duty_set(&PWM1, 0, 50) == NRF_ERROR_BUSY);\r\n    \t*/\r\n    \r\n        return err_code;\r\n    }\r\n    \r\n    void pwm_start(void) {\r\n    \tnrf_drv_gpiote_out_task_enable(BUZZER);\r\n    \tapp_pwm_enable(&PWM1);\r\n    \twhile (app_pwm_channel_duty_set(&PWM1, 0, 50) == NRF_ERROR_BUSY);\r\n    }\r\n    \r\n    void pwm_stop(void) { \r\n    \t ret_code_t err_code;\r\n    \t\r\n    \tapp_pwm_disable(&PWM1);\r\n    \tnrf_drv_gpiote_out_task_disable(BUZZER);\r\n    \terr_code = app_pwm_uninit(&PWM1);\r\n    \tAPP_ERROR_CHECK(err_code);        \r\n    \tnrf_gpio_cfg_output(BUZZER);\r\n    \tnrf_gpio_pin_clear(BUZZER);\r\n    }\r\n\r\n\r\nAccording to Immediate Alert signal, LED is indicated. So, the Immediate Alert signal is received. Also, when the last comment in int_pwm() function is uncommented, by calling init_pwm() the buzzer is beeped. But after connection is established, the beeping is stopped. This seems to indicate that some configuration is incorrect. But I am not sure what kind of setting should be modified.\r\n\r\nI didn't modify ble_app_proximity except alert_signal() function. That is, ble_app_proximity itself works well. The program is compiled by Keil using SDK 9.0. It runs on SoftDevice S110 8.0. I tried to use SDK10.0, but the result was same.\r\n\r\nI would appreciate having your helps and suggestion. Best regards.",
    "tag": "pwm"
  },
  {
    "text": "High data rate SPI on Nrf52 using EasyDMA lists My application involves the Nrf52 using softdevice and a slave only SPI ADC running at approximately 26khz. The ADC has a pin interrupt to indicate data ready. There seems to be no way that i can guarantee the softdevice won't hang up the ISR for more than ~40us so I am looking for other solutions. \r\n\r\nThe one that comes to mind is to use PPI to trigger TASK_START on the SPIM. Combined with what little I can glean from the EasyDMA lists description, it would seem that this could result in my samples getting stored successively in memory. The trouble is that I see no way to read the contents of the buffer and then reset the dma list without the possibility of yielding to the soft device somewhere in the middle of this process. \r\n\r\nIs globally disabling interrupts the only solution here? Is there another way to read the ADC?\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Problem in understanding RTC Hi, can anyone explain to me about this example in this link with details : \r\nhttps://github.com/andenore/NordicSnippets/blob/master/examples/rtc/main.c \r\nI'm a newbie in nordic and i found it difficult to understand this example.\r\nKindly assist and reply asap. Thanks!",
    "tag": "timer"
  },
  {
    "text": "i2c communication problems Hi,\r\n\r\nI have been having a lot of problems communicating with an Atmel SAM D09 as a slave, and an nrf51422 as a master.\r\n\r\nI seem to have two problems, hopefully solving just one will get me where I need to be. but I can't seem to narrow it down. The first issue, I have been trying to use a slightly modified twi_sw_master.c to communicate with the slave, this has worked with plenty of other i2c devices out there, like EEPROMs Acelerometers, and PMICs however the Atmel won't ack. The reason I believe this to be a problem, is it doesn't run at exactly 100Khz (best i can get is 94Khz), this seems highly unlikely to me, but it is the only thing that is apparent as the Atmel is returning no error while polling the interrupt flags, and all the config is set as required. It is also pulling up both of its i2c pins, which would indicate that it is working. I have done plenty of debugging with uart, and all seems normal.\r\n\r\nTo get around this i have tried using twi_hw_master.c to work, and i do get 100Khz exactly, however the waveform i see on my scope looks wrong. To my understanding, there are 9 clock pulses on SCL, the last one being for an ack/nack, this was present on the sw version, but on the hw version it is not present and there also does not appear to be a valid stop condition, although no data is being transferred due to the lack of an ack.  My aim is to use the self programming function of the Atmel SAM to update it OTA via the BLE on the nrf. the code on the Atmel is from the ASF, so i can be quite sure it works. Also worth noting that the Atmel chip is configured to respond to any address between 0-127 regardless. Unfortunately for me i am very restricted on GPIOs on the nrf, so using something else is out of the question.\r\n![image description](http://s15.postimg.org/p3tk2l0x7/scope.png)",
    "tag": "i2c"
  },
  {
    "text": "i2c communication problems Hi,\r\n\r\nI have been having a lot of problems communicating with an Atmel SAM D09 as a slave, and an nrf51422 as a master.\r\n\r\nI seem to have two problems, hopefully solving just one will get me where I need to be. but I can't seem to narrow it down. The first issue, I have been trying to use a slightly modified twi_sw_master.c to communicate with the slave, this has worked with plenty of other i2c devices out there, like EEPROMs Acelerometers, and PMICs however the Atmel won't ack. The reason I believe this to be a problem, is it doesn't run at exactly 100Khz (best i can get is 94Khz), this seems highly unlikely to me, but it is the only thing that is apparent as the Atmel is returning no error while polling the interrupt flags, and all the config is set as required. It is also pulling up both of its i2c pins, which would indicate that it is working. I have done plenty of debugging with uart, and all seems normal.\r\n\r\nTo get around this i have tried using twi_hw_master.c to work, and i do get 100Khz exactly, however the waveform i see on my scope looks wrong. To my understanding, there are 9 clock pulses on SCL, the last one being for an ack/nack, this was present on the sw version, but on the hw version it is not present and there also does not appear to be a valid stop condition, although no data is being transferred due to the lack of an ack.  My aim is to use the self programming function of the Atmel SAM to update it OTA via the BLE on the nrf. the code on the Atmel is from the ASF, so i can be quite sure it works. Also worth noting that the Atmel chip is configured to respond to any address between 0-127 regardless. Unfortunately for me i am very restricted on GPIOs on the nrf, so using something else is out of the question.\r\n![image description](http://s15.postimg.org/p3tk2l0x7/scope.png)",
    "tag": "twi"
  },
  {
    "text": "How to use external interrupt to wake up sleep mode in nrf51822 [Interrupt_Sleep.txt](/attachment/af1cd8adff8c0df7fe7e91840aad08a3)\r\n\r\nCurrently, I'm trying to use external interrupt that generated by ADXL345 to wake up the nrf51822 after sleep but not working as i want. Kindly check on the attached code and give advise. \r\nPlease help!!! Thanks.",
    "tag": "interrupt"
  },
  {
    "text": "crc blocking Greetings from a Nordic newbie!\r\n\r\nI am currently merging an existing AD 433MHz transceiver with a nRF51422 so that I can read an ANT+ heartrate monitor to our existing functionality.\r\n\r\nMy big question is, can I loose my existing processor.\r\n\r\nRight now, I need to process incoming data 1 bit a time from a AD 433MHz radio, at a rate of 1200 baud. So on every cycle from the existing radio I do a CRC comparison of my incoming data (which I need to que) with my CRC block.\r\n\r\nThis poses two problems:\r\n\r\n1. Can I deterministically respond to the external radios 1200Hz interrupt while the S110 firmware is running? This seems to be in the order of 400uS so it seems I am ok. \r\n\r\nand\r\n\r\n2. How long will the nRF51422 block my access to the CRC module? I assume the firmware will lock me out and vice versa so that we do not stand on each others data (is it that easy?).\r\n\r\nThanks in advance\r\nSteve\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Best way to implement micros() function in nrf51822? I need to implement the micros() function of arduino on nrf51822. Can someone guide me on how it can be done?\r\n\r\nThis the function for Arduino:\r\n\r\n        unsigned long micros() {\r\n        unsigned long m;\r\n        uint8_t oldSREG = SREG, t;\r\n     \r\n        cli();\r\n        m = timer0_overflow_count;\r\n    #if defined(TCNT0)\r\n        t = TCNT0;\r\n    #elif defined(TCNT0L)\r\n        t = TCNT0L;\r\n    #else\r\n        #error TIMER 0 not defined\r\n    #endif\r\n \r\n   \r\n    #ifdef TIFR0\r\n        if ((TIFR0 & _BV(TOV0)) && (t & 255))\r\n            m++;\r\n    #else\r\n        if ((TIFR & _BV(TOV0)) && (t & 255))\r\n            m++;\r\n    #endif\r\n \r\n        SREG = oldSREG;\r\n     \r\n        return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());\r\n    }\r\n\r\nBasically the function returns the number of microseconds since the board started running.",
    "tag": "timer"
  },
  {
    "text": "ADC values in advertising data dynamically changing Hello,\r\n\r\nHow to put values changing over time into advertising data? \r\nWhat I want to acchieve is to send ADC values that are changing dynamically over advertising packet which I wish to change over time. \r\n\r\nI would like to know how to even send random dynamic numbers over advertising data packet.\r\nI am using nRF51822, SDK8.0.0., SoftDevice100,\r\n\r\n\r\nPS I've seen this: https://devzone.nordicsemi.com/question/33128/nrf51822-adc-and-s110/ but can't get the code working...",
    "tag": "adc"
  },
  {
    "text": "ADC Interrupt not starting I am programming with mbed, and i am trying to start the adc-task via ppi and timer cc events.\r\nanother ppi channel is used to toogle the LED.\r\n\r\nI am using the nRF51822 on the RedBearLabs BLE NANO.\r\n\r\nAfter 2 seconds (start of cc[1] event) thw while loops stops executing, bit led toggling via ppi continues.\r\n\r\nI took several examples form GitHub as a starting point.\r\n\r\nUSBRX and USBTX use Pin 9 & 11\r\n\r\nWhere is my mistake? \r\n\r\n    #include <nrf.h>\r\n    #include \"nrf_delay.c\"\r\n    #include \"mbed.h\"\r\n    \r\n    #define PIN_LED     19UL\r\n    \r\n    Serial pc(USBTX, USBRX);\r\n    \r\n    volatile int32_t adc_sample;\r\n    volatile uint8_t adc_flag = 0;\r\n    \r\n    void ADC_IRQHandler(void)\r\n    {\r\n        NRF_ADC->EVENTS_END = 0;\r\n        adc_sample = NRF_ADC -> RESULT;\r\n        adc_flag = 1;\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n        pc.printf(\"\\nSERIAL_INIT\\n\");\r\n    \r\n        // Configure PIN_GPIO as output\r\n        NRF_GPIO->DIRSET = (1UL << PIN_LED);\r\n        \r\n        // Configure GPIOTE Task\r\n        NRF_GPIOTE->CONFIG[0] =     (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos)|\r\n                                    (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos)|\r\n                                    (GPIOTE_CONFIG_OUTINIT_High << GPIOTE_CONFIG_OUTINIT_Pos)|\r\n                                    (PIN_LED << GPIOTE_CONFIG_PSEL_Pos);\r\n        pc.printf(\"GPIO_INIT\\n\"); \r\n        \r\n        // Configure ADC\r\n        // Enable interupt at END Event\r\n        NRF_ADC->INTENSET = ADC_INTENSET_END_Msk;\r\n        NVIC_EnableIRQ(ADC_IRQn); \r\n        \r\n        // no Prescaling  - ReferenceVoltage VBG - 8bit - Analog Input 4\r\n        NRF_ADC->CONFIG = (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos)                               /* Bits 17..16 : ADC external reference pin selection. */\r\n                                            | (ADC_CONFIG_PSEL_AnalogInput4 << ADC_CONFIG_PSEL_Pos)                                 /*!< Use analog input 6 as analog input (P0.05). */\r\n                                            | (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)                                          /*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n                                            | (ADC_CONFIG_INPSEL_AnalogInputNoPrescaling << ADC_CONFIG_INPSEL_Pos)  /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n                                            | (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);  \r\n        // enable ADV                                    \r\n        NRF_ADC->ENABLE =       ADC_ENABLE_ENABLE_Enabled;\r\n        \r\n        pc.printf(\"ADC_STARTED\\n\");                      \r\n        \r\n        // Configure Timer \r\n        NRF_TIMER0->BITMODE =    (TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos);\r\n        NRF_TIMER0->PRESCALER =  (4 << TIMER_PRESCALER_PRESCALER_Pos); // 1us periode\r\n        \r\n        // Configure Timer Events\r\n        NRF_TIMER0->CC[0] = 1000000; // 1s compare value\r\n        NRF_TIMER0->CC[1] = 2000000; // 2s compare value\r\n        \r\n        // Shortcut clear timer at compare1 event\r\n        NRF_TIMER0->SHORTS = (TIMER_SHORTS_COMPARE1_CLEAR_Enabled << TIMER_SHORTS_COMPARE1_CLEAR_Pos);\r\n        pc.printf(\"TIMER0_INIT\\n\");\r\n        \r\n        // Configure PPI Channel 0\r\n        NRF_PPI->CH[0].EEP = (uint32_t)&NRF_TIMER0->EVENTS_COMPARE[0];\r\n        NRF_PPI->CH[0].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n        \r\n        // Configure PPI Channel 1\r\n        NRF_PPI->CH[1].EEP = (uint32_t)&NRF_TIMER0->EVENTS_COMPARE[1];\r\n        NRF_PPI->CH[1].TEP = (uint32_t)&NRF_ADC->TASKS_START;\r\n        \r\n        // Configure PPI Channel 2\r\n        NRF_PPI->CH[2].EEP = (uint32_t)&NRF_TIMER0->EVENTS_COMPARE[1];\r\n        NRF_PPI->CH[2].TEP = (uint32_t)&NRF_GPIOTE->TASKS_OUT[0];\r\n        pc.printf(\"PPI_INIT\\n\");\r\n                                \r\n        // Enable PPI channels 0 and 1\r\n        NRF_PPI->CHENSET = (1UL << 0) | (1UL << 1) | (1UL << 2);\r\n        pc.printf(\"PPI_ENABLED\\n\");\r\n        \r\n        // Start timer0\r\n        NRF_TIMER0->TASKS_START = 1;\r\n        pc.printf(\"TIMER0_STARTED\\n\");\r\n        \r\n        while (1)\r\n            {\r\n                pc.printf(\"l\");\r\n                if (adc_flag == 1)\r\n                {\r\n                    pc.printf(\"%d/n\", (int)adc_sample);\r\n                    adc_flag = 0;\r\n                }\r\n            }\r\n    }",
    "tag": "timer"
  },
  {
    "text": "TWI/I2C with SDK 11 (long transfers) Hi, \r\n\r\nI would like to use my NRF51DK with SDK11 and SD130 to control my SSD1306 OLED screen over TWI/I2C.\r\n\r\nTo refresh the OLED screen, we have to send it the whole display buffer in one transfer. All was working great under SDK9 and SDK10 (SD110) in which we could send long buffers (length argument was uint32_t), however in SDK11, nrf_drv_twi_tx() takes an \"uint8_t length\". \r\n\r\nI then tried to slice buffers into 255bytes max transfers, but it does not work. I looked over the TWI bus with my logic analyzer, all signals are correctly generated but a start condition happens every time a transfer slice begins (I thought it might be the problem as it looks to be the only difference from the results I get with SDK10).\r\n\r\nThis is the code I use to slice sent data :\r\n    \r\n    bool I2C_Write(uint8_t address, uint8_t const  *data, uint16_t length, bool Stop )\r\n    {\r\n    \tuint32_t err_code;\r\n    \tfor (int i=0; i<length; i+=256) {\r\n    \t\terr_code = nrf_drv_twi_tx(&twi, address, &data[i], MIN(255, length-i), (i+256 >= length)? !Stop : true);\r\n    \t\tif (err_code != NRF_SUCCESS) return false;\r\n    \t}\r\n    \treturn (err_code == NRF_SUCCESS);\r\n    }\r\n\r\nand the following to initialize TWI:\r\n\r\n    nrf_drv_twi_t twi = NRF_DRV_TWI_INSTANCE(0);\r\n\r\n    bool I2C_master_init(uint32_t sda, uint32_t scl, nrf_twi_frequency_t frequency)\r\n    {\r\n    \tnrf_drv_twi_config_t config;\r\n    \tconfig.frequency = frequency;\r\n    \tconfig.interrupt_priority = APP_IRQ_PRIORITY_HIGH;\r\n    \tconfig.scl = scl;\r\n    \tconfig.sda = sda;\r\n    \t\r\n    \tuint32_t err_code = nrf_drv_twi_init(&twi, &config, NULL, NULL);\r\n    \tnrf_drv_twi_enable(&twi);\r\n    \r\n      return (err_code == NRF_SUCCESS);\r\n    }\r\n\r\nHow should I handle long packet transfers with the new SDK11?\r\n\r\nThank you\r\n\r\n\r\nArnaud",
    "tag": "twi"
  },
  {
    "text": "Headers to include for Timer SDK I'm trying to compile a program on mbed for a BLE Nano, which uses the nRF51822. I've included the nRF51822 library by Team Nordic that's listed on mbed's library wizard and have gotten GPIO working by including \"nrf_gpio.h\". I want to use the application timer library documented [here](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v11.0.0%2Fgroup__app__timer.html&cp=4_0_0_6_6_21). A section of my code:\r\n\r\n    uint32_t err_code = NRF_SUCCESS;\r\n    APP_TIMER_INIT(0, 1, NULL);\r\n    APP_TIMER_DEF(timer_handle);\r\n    err_code = app_timer_create(&timer_handle, APP_TIMER_MODE_REPEATED, timer_callback);\r\n    APP_ERROR_CHECK(err_code);\r\n    err_code = app_timer_start(&timer_handle, STATUS_CHECK_TIME, NULL);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\ngets flagged for undefined identifiers on everything timer related (APP_TIMER_INIT, app_timer_create, etc.) since I haven't included the header for the application timer library. Which header is this?\r\n\r\nI can't find any condensed reference of which headers are needed for each library in the documentation, so if one exists, a link to that would be appreciated as well.",
    "tag": "timer"
  },
  {
    "text": "SoftDevice interrupt Hi,\r\n\r\nI have problem with handling events originated by SoftDevice and getting new interrupts from SD.\r\nI have one event which handling is very time consuming - during that operation I get new Interrupts from SD that stop handling of previous event.\r\n \r\nI am aware of the fact that SD interrupts have the highest priority but maybe it is possible to move my event handling to another thread and handle it simultaneously with SD interrupt.\r\n\r\nThank you for your help",
    "tag": "interrupt"
  },
  {
    "text": "SoftDevice interrupt Hi,\r\n\r\nI have problem with handling events originated by SoftDevice and getting new interrupts from SD.\r\nI have one event which handling is very time consuming - during that operation I get new Interrupts from SD that stop handling of previous event.\r\n \r\nI am aware of the fact that SD interrupts have the highest priority but maybe it is possible to move my event handling to another thread and handle it simultaneously with SD interrupt.\r\n\r\nThank you for your help",
    "tag": "interrupt"
  },
  {
    "text": "Unable to perform UART transfer on every Timer Interrupt Hi All,\r\n\r\nI am using nRF51422DK with SDK 10 and trying to communicate with an external peripheral over UART at every timer interrupt. \r\n\r\nI have modified the ble_app_hrs example so that whenever application timer generates an event I send UART command, wait for response (approx 150 ms)  and then try to receive the bytes. \r\n\r\nTo check my UART communication works fine, I performed a set of UART communication before initializing the timer and ble stack. I am able to send and receive data as desired.  UART interrupt is enabled to notify completion of TX and RX data\r\n\r\nHowever, when I perform the same routine within the timer event handler,  the system resets and jumps back to the first function trying to reinitialize all from the start. \r\n\r\nCan anyone let me what could be the issue?\r\n\r\nThank you.\r\n\r\nBest \r\nRichard\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "Different IRQ priority levels Hi,\r\n\r\nsystem info:\r\n\r\n - SDK: v6.0.0.43681\r\n - S110 V7.0.0\r\n - nRF51822 Rev.2\r\n\r\n\r\nI\u2019m using a ~4ms one shot timer (using the timer library) which is being started in the RADIO_NOTIFICATION_IRQHandler(). In the timer_timeout_handler() I\u2019m starting an ADC measurement, now my question: The ADC IRQ priority is configured as sd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_HIGH);, could this combination cause a problem/error because the RTC1_IRQn in the app_timer.c is configured with APP_IRQ_PRIORITY_LOW?",
    "tag": "adc"
  },
  {
    "text": "Using SPI after disable SD Hello,\r\n\r\nI have got a problem with use SPI. I get hard fault after call spi_master_open(), exactly when sd_nvic_ClearPendingIRQ function is call. \r\nThis situation is so specific because i use SD at the begining and after that i disable it and try to use SPI.\r\nHow should i work with spi after disable SD?\r\n\r\nRegards Michal,",
    "tag": "spi"
  },
  {
    "text": "How can I clear TXDRDY interrupt in uart? Hi,\r\nI'm using nrf51822. After sending a data from TXD, I enable the TXDRDY interrupt by setting INTENSET register. Then I can get into TXDRDY interrupt handler function. But I don't know how to clear the pending interrupt, then the interrupt handler function will be triggered again and again. I know setting INTENCLR register can disable the interrupt. But I don't want to disable the interrupt and enable it after sending another data, I just want to clear current interrupt and can get another interrupt after I sent another data.\r\nHow can I deal with it?\r\n\r\nThanks,\r\nBinLei",
    "tag": "interrupt"
  },
  {
    "text": "Is there a way to send one PWM output to more than one pin? I am using the nRF51822 with the s130 softdevice, and I would like to control three RGB LED modules with three PWMs (R, G, and B). For various conditions, either one, two or all three of the LED modules would need to be on, but with the same PWM values. Therefore, I need only three PWMs, but I would need to be able to direct the PWMs to multiple pins simultaneously. Is there any way to achieve this? Thanks!\r\n",
    "tag": "pwm"
  },
  {
    "text": "Porting ble_app_uart into twi_master_with_slave Hi,\r\n\r\nI am using the nRF52 with code from SDK 9.2, as well as the S132 softdevice. I basically ported code from the ble_uart_app into the twi_example to send data over bluetooth.\r\n\r\nI tried to port the ble_uart functions from the main file, as well as the libraries it used. Once I finished porting the libraries, the code can build just fine, but the UART does not output any printfs. More importantly, the nordic does not begin advertisement.\r\n\r\nI included my main function code just in case:\r\n\r\n    int main(void)\r\n    {\r\n    \tuart_config();\r\n      \ttwi_init(); \r\n        printf(\"\\nTWI Sensor Example\\r\\n\");\r\n    \t//BT\r\n    \tuint32_t err_code;\r\n        bool erase_bonds;\r\n        uint8_t buffer[BLE_NUS_MAX_DATA_LEN] = {0};\r\n    \t\t\r\n        // Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        buttons_leds_init(&erase_bonds);\r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n    \terr_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t//BT end\r\n    }",
    "tag": "i2c"
  },
  {
    "text": "Porting ble_app_uart into twi_master_with_slave Hi,\r\n\r\nI am using the nRF52 with code from SDK 9.2, as well as the S132 softdevice. I basically ported code from the ble_uart_app into the twi_example to send data over bluetooth.\r\n\r\nI tried to port the ble_uart functions from the main file, as well as the libraries it used. Once I finished porting the libraries, the code can build just fine, but the UART does not output any printfs. More importantly, the nordic does not begin advertisement.\r\n\r\nI included my main function code just in case:\r\n\r\n    int main(void)\r\n    {\r\n    \tuart_config();\r\n      \ttwi_init(); \r\n        printf(\"\\nTWI Sensor Example\\r\\n\");\r\n    \t//BT\r\n    \tuint32_t err_code;\r\n        bool erase_bonds;\r\n        uint8_t buffer[BLE_NUS_MAX_DATA_LEN] = {0};\r\n    \t\t\r\n        // Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_MAX_TIMERS, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        buttons_leds_init(&erase_bonds);\r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n    \terr_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t//BT end\r\n    }",
    "tag": "twi"
  },
  {
    "text": "nrf51422 ANT interrupts and WS2812b I am having an issue implementing a WS2812b driver for the nrf51422 using the 210 softdevice. We currently have ANT enabled with a tx master only channel setup. The WS2812b driver uses bit-banging to transmit the bit pattern to a strand of LEDs. Due to the nature of the one wire WS2812b protocol, this bit banging has very sensitive timing tolerances. By adding this bit pattern transmission to the tx event handler (ran in main context off of ant_event_process), the bit stream is interrupted mid-transmission by an ISR exceeding 50us causing the bit stream to be corrupted.\r\n\r\nDoing some digging it seems that this issue only occurs with ant enabled and a channel opened. By disabling ANT and putting the LED code on a separate, periodic signal, the issue goes away. It appears that there is an ANT related interrupt that causes the bit transmission to be corrupted. If I add a delay in my driver code the LED pattern is not corrupted as the interrupt occurs during the delay. That being said, the delay is not ideal as it holds up all main context events.\r\n\r\nDoes anyone have an idea of what is causing this issue? What is it about ANT that I get this periodic interrupt  (following the tx event) that holds up the processor for more than 50 us? If anyone has suggestions on how to get around this issue I would greatly appreciate it.\r\n\r\nCheers,\r\n\r\nBraden",
    "tag": "interrupt"
  },
  {
    "text": "s110 v8.00 ,ADC for Detection of lithium battery\uff0cwho can offer a example? I use the s110 v8.00   and nrf51822QFAA,the ADC for Detection of lithium battery\uff0c\r\nwho can offer a example?",
    "tag": "adc"
  },
  {
    "text": "sleep function is not working when timer/RTC is running in nRF51822 [nrf51822_sleep_and_timer.txt](/attachment/d643d2a2db9afbf60c4350878429837c)\r\n\r\nHi... I having tough time to make the sleep function to work when timer/RTC is running in the background of nRF51822. The attached text file containing my code. After comment out the start_timer() & start_RTC() in the setup() then the sleep function is working fine as I will only can be woke up by the external internal. If either one of this function : start_timer() or start_RTC() is uncommented from the setup() then the system is not going to sleep as I got to know it by checking on the serial monitor as it's keep on printing \"Hello\". Kindly assist. Thanks.",
    "tag": "timer"
  },
  {
    "text": "Calling app_sched_event_put inside interrupt Hi,\r\nI'm debugging a small app that is using the LPCOMP to trigger an interrupt when the BLE device is turned off. We have a capacitor to maintain alive the nRF for a while after the power is turned off (the idea is to let the nRF store some data in flash before die).\r\n\r\nThis is the code I use to configure and use the LPCOMP:\r\n\r\n    void LPCOMP_init(void) {\r\n    /* Enable interrupt on LPCOMP CROSS event */\t\t\r\n\tNRF_LPCOMP->INTENSET = LPCOMP_INTENSET_DOWN_Msk;\r\n\tNVIC_EnableIRQ(LPCOMP_IRQn);\r\n\r\n    //  5 : 5V,  ref. 1/8 VDD\r\n    // 12 : 12V, ref. 3/8 VDD\r\n    // 24 : 24V, ref. 6/8 VDD\r\n\t\r\n\t/* Configure LPCOMP */\r\n    if (power == 5) \r\n    \tNRF_LPCOMP->REFSEL = (LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling << LPCOMP_REFSEL_REFSEL_Pos);\r\n    else if (power == 12)\r\n    \tNRF_LPCOMP->REFSEL = (LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling << LPCOMP_REFSEL_REFSEL_Pos);\r\n    else\r\n    \tNRF_LPCOMP->REFSEL = (LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling << LPCOMP_REFSEL_REFSEL_Pos);\r\n\r\n\t/* Configure LPCOMP - set reference input source to AIN2 */\r\n\tNRF_LPCOMP->PSEL |= (LPCOMP_PSEL_PSEL_AnalogInput2 << LPCOMP_PSEL_PSEL_Pos);\r\n\t\r\n\t/* Enable and start the low power comparator */\r\n\tNRF_LPCOMP->ENABLE = LPCOMP_ENABLE_ENABLE_Enabled;\t\r\n\tNRF_LPCOMP->TASKS_START = 1;\r\n    }\r\n\r\n    /* Interrupt handler for LPCOMP */\r\n    void LPCOMP_COMP_IRQHandler(void)\r\n    {\r\n    uint32_t err_code;\r\n\r\n\t// Clear event\r\n\tNRF_LPCOMP->EVENTS_DOWN = 0;\r\n    // Stop LPCOMP\r\n    NRF_LPCOMP->TASKS_STOP = 1;\r\n    NRF_LPCOMP->ENABLE = LPCOMP_ENABLE_ENABLE_Disabled;\r\n\r\n    // Debug\r\n    nrf_gpio_pin_set(GPIO_PIN);\r\n\r\n\t// Append store task in scheduler\r\n    err_code = app_sched_event_put(NULL, 0, config_store);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\n    // Debug\r\n    nrf_gpio_pin_clear(GPIO_PIN);\r\n    }\r\n\r\n    void config_store(void *p_data, uint16_t p_size)\r\n    {\r\n    // Stop Advertising\r\n    sd_ble_gap_adv_stop();\r\n\r\n\t// Store current configuration to flash\r\n\tps_config_store(&m_config);\r\n    }\r\n\r\n\r\n    int main(void)\r\n    {\r\n\r\n    ...\r\n\r\n    // Enter main loop.\r\n    for (;;) {\r\n        app_sched_execute();\r\n\t\tsd_app_evt_wait();\r\n    }\r\n    }\r\n\r\n\r\nThe problem I'm facing with this configuration is that when I call the app_sched_event_put() the code hangs and stops working.\r\nLooking inside at the  app_sched_event_put() I see that there are two calls to CRITICAL_REGION_ENTER() and CRITICAL_REGION_EXIT(), I tried to comment out those calls and now the code works as expected. \r\nSo my question is, why the CRITICAL_REGION_ENTER/EXIT macros are causing this problem?\r\n\r\nThe software is compiled with -DSOFTDEVICE_PRESENT and SoftDevice is enabled and inited.",
    "tag": "interrupt"
  },
  {
    "text": "More than 2 pwm channels per instance Hi,\r\n\r\nI am trying to fade out 5 LEDs over the course of 500ms simultaneously. I am using soft device s110  but am happy to pause everything for the half a second while the LEDs fade (ie make the pwm blocking).\r\n\r\nIs this possible to do? Each of the LEDs is connected to a separate GPIO. If so, how?\r\n\r\nThanks,",
    "tag": "pwm"
  },
  {
    "text": "Issues with using Timer1 in counter mode after SDK migration. Hi!\r\n\r\nI have inherited a large codebase that I'm trying to migrate to SDKv10 from SDKv6. \r\n\r\nThe project also uses an A4960 BLDC motor controller. To bring the motor up to speed, we count the number of rising edges on the TACHO pin of the controller, but for some reason this no longer works as it used to.\r\n\r\nThe following piece of code initializes the counter.\r\n\r\n    void freqcntr_init() {\r\n        uint8_t softdevice_enabled;\r\n        uint32_t err_code;\r\n\r\n        /* Stop and clear the timer */\r\n        NRF_TIMER1->TASKS_STOP = 1;\r\n        NRF_TIMER1->TASKS_CLEAR = 1;\r\n\r\n        /* Disable the TIMER1 interrupt vector */\r\n        NVIC_DisableIRQ(TIMER1_IRQn);\r\n\r\n        /* Disable interrupts on all compare channels */\r\n        NRF_TIMER1->INTENCLR = TIMER_INTENCLR_COMPARE0_Msk\r\n                | TIMER_INTENCLR_COMPARE1_Msk\r\n                | TIMER_INTENCLR_COMPARE2_Msk\r\n                | TIMER_INTENCLR_COMPARE3_Msk;\r\n\r\n        NVIC_ClearPendingIRQ(TIMER1_IRQn);\r\n\r\n        /* Select counter mode */\r\n        NRF_TIMER1->MODE = (TIMER_MODE_MODE_Counter << TIMER_MODE_MODE_Pos);\r\n\r\n        /* 32-bit width so that we minimize risk of overflowing counter. */\r\n        NRF_TIMER1->BITMODE = (TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos);\r\n\r\n        /* Make the BLDCTACHO pin an input will a pull-down resistor to keep it\r\n         * from floating unpredictably. */\r\n        nrf_gpio_cfg_input(BLDCTACHO_PIN_NO, NRF_GPIO_PIN_PULLDOWN);\r\n\r\n        /* Configure GPIO task/event block to generate an event for every low-to-\r\n         * high transition of the input signal. */\r\n        nrf_gpiote_event_configure(FREQCNTR_GPIOTE_CHANNEL, BLDCTACHO_PIN_NO, NRF_GPIOTE_POLARITY_LOTOHI);\r\n\r\n        /* Whether or not the soft device is enabled determines how we configure\r\n         * the PPI block. */\r\n        err_code = sd_softdevice_is_enabled(&softdevice_enabled);\r\n        APP_ERROR_CHECK(err_code);\r\n\r\n        /* Connect the rising-edge GPIOTE event to the counter's count task so that\r\n         * we count the number of rising edges and then enable the PPI channel. */\r\n        if (softdevice_enabled) {\r\n            err_code = sd_ppi_channel_assign(FREQCNTR_PPI_CHANNEL,\r\n                    &(NRF_GPIOTE->EVENTS_IN[FREQCNTR_GPIOTE_CHANNEL]),\r\n                    &(NRF_TIMER1->TASKS_COUNT));\r\n            APP_ERROR_CHECK(err_code);\r\n\r\n            err_code = sd_ppi_channel_enable_set(FREQCNTR_PPI_CHENSET_MASK);\r\n            APP_ERROR_CHECK(err_code);\r\n        } else {\r\n            NRF_PPI->CH[FREQCNTR_PPI_CHANNEL].EEP = (uint32_t)&(NRF_GPIOTE->EVENTS_IN[FREQCNTR_GPIOTE_CHANNEL]);\r\n            NRF_PPI->CH[FREQCNTR_PPI_CHANNEL].TEP = (uint32_t)&(NRF_TIMER1->TASKS_COUNT);\r\n            NRF_PPI->CHENSET = FREQCNTR_PPI_CHENSET_MASK;\r\n        }\r\n\r\n        /* Enable counting */\r\n        NRF_TIMER1->TASKS_START = 1;\r\n    }\r\n\r\nAnd this function is called every once in a while to get the count:\r\n\r\n    void freqcntr_updateFreq() {\r\n        /* Capture the count */\r\n        NRF_TIMER1->TASKS_CAPTURE[0] = 1;\r\n\r\n        SEGGER_RTT_printf(\"Count: %lu\\r\\n\", NRF_TIMER1->CC[0]);\r\n\r\n        /* Reset the count as soon as we have saved the old count */\r\n        NRF_TIMER1->TASKS_CLEAR = 1;\r\n    }\r\n\r\nUnfortunately, this always prints 0 for the counter value. I know that the problem can be from somewhere else, but wanted to check if there is anything glaringly wrong with the code above.\r\n\r\nThanks!\r\n",
    "tag": "timer"
  },
  {
    "text": "PWM Library SDK 9 with SoftDevice I am using SDK 9 on an nRF51 device with the S110 SoftDevice.  I am aware of issues using the the PWM library from SDK 9.  I need to use the PWM functionality but would like to understand the least painful way to do this.  I could migrate my entire application to SDK 10, or I could apply selective patches to the PSM libraries in SDK 9.  I prefer the 2nd option, but I want to make sure I understand what the correct patches are.  So far, I'm aware of the change referenced in https://devzone.nordicsemi.com/question/52275/unable-to-toggle-pwm-module-off-and-on/ which adds a call to pwm_irq_enable() to the app_pwm_enable() function.\r\nAre there other changes that need to be made to SDK 9 PWM to make it functional?\r\nThanks...",
    "tag": "pwm"
  },
  {
    "text": "Adding a timer to a BLE application I am working on adding a periodic timer to an existing and running application to add some new features.\r\n\r\nI mimic exactly what is done in the peripheral/timer_pca10028 example, except the following minor(?) changes:\r\n\r\n - Variable/function names and add some #define\r\n - Change `#define TIMER0_ENABLED` value from `0` to `1`\r\n - Change handler to print out an incrementing static uint8 instead of toggling LEDs\r\n\r\nThe app stopped working after those change, and was printing out UART rubbishes instead of what it had done before that. Since I remember reading somewhere here that TIMER0 canot be used, I made some more changes:\r\n\r\n - Change timer instance from `NRF_DRV_TIMER_INSTANCE(0)` to `NRF_DRV_TIMER_INSTANCE(1)`\r\n - Change `#define TIMER0_ENABLED` back to `0`\r\n - Change `#define TIMER1_ENABLED` value from `0` to `1`\r\n\r\nNow the timer works. However, the timer handler is called way too quickly. There must be tens of printf fired off every seconds. I could not figure out why.\r\n\r\nHere is my timer related code for referrence\r\n\r\n    #define INTERVAL    1000            /**< Number of mili seconds between interrupts */\r\n    const nrf_drv_timer_t TIMER = NRF_DRV_TIMER_INSTANCE(1);\r\n\r\n    static void ble_stack_init(void)\r\n    {\r\n      uint32_t err_code;\r\n\r\n      // Initialize the SoftDevice handler module.\r\n      SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_RC_250_PPM_4000MS_CALIBRATION, NULL);\r\n      // Other non-timer codes...\r\n    }\r\n    \r\n    void timer_event_handler(nrf_timer_event_t event_type, void* p_context)\r\n    {   \r\n      static uint8_t i;\r\n      i++;\r\n      printf(\"%x\\n\", i);\r\n    }\r\n    \r\n    // main()\r\n    uint32_t time_ms = INTERVAL; // I tried using 500 or 5000 here, but they also don't work\r\n    uint32_t time_ticks;\r\n    uint32_t err_code;\r\n    err_code = nrf_drv_timer_init(\r\n      &TIMER,\r\n      NULL,\r\n      timer_event_handler);\r\n    if (err_code == NRF_SUCCESS) {\r\n      printf(\"NRF_SUCCESS\\n\");\r\n    } else {\r\n      printf(\"%08x\\n\", err_code);\r\n    }\r\n    APP_ERROR_CHECK(err_code);\r\n    time_ticks = nrf_drv_timer_ms_to_ticks(&TIMER, time_ms);\r\n    nrf_drv_timer_extended_compare(&STIMER, \r\n      NRF_TIMER_CC_CHANNEL0, \r\n      time_ticks, \r\n      NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, \r\n      true); \r\n    nrf_drv_timer_enable(&TIMER);\r\n\r\nSo my question is:\r\n\r\n 1. Was the reason the app failed to run with `TIMER0` is that `TIMER0` is used for some core functionality of a BLE app?\r\n\r\n  1.1. If yes, is it the `APP_TIMER` or something else? \r\n\r\n  1.2. If no, what would the cause `TIMER0` not to work then?\r\n\r\n  1.3. Does this mean `TIMER0` cannot be used anywhere else?\r\n\r\n 2. Why is TIMER1 running so quickly? I suspect two places that could be the source of problem but do not understand them fully to work further on:\r\n\r\n 2.1. I understand that `nrf_drv_timer_ms_to_ticks()` would convert the ms time value passed to equivalent value in \"ticks\" for the timer parameter. Is this always dependable? The SDK documentation says that this function detects if overflow occurs, but I do not see any interruption in the application flow.\r\n\r\n 2.2. According to the [this SDK documentation](http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk51.v10.0.0/group__lib__driver__timer.html#ga02b2d6f6d83049b70faf31d41fa2627e) a \"default configuration\" is applied to the TIMER1 when `nrf_drv_timer_init()` was called with a second parameter of `NULL`. But what exactly is this \"default configuration\"?",
    "tag": "timer"
  },
  {
    "text": "Problems Implementing Workaround to get nrf52 to send an octet / one byte through SPI I'm having trouble implementing the workaround that was mentioned in the following previous post: [https://devzone.nordicsemi.com/question/55937/nrf52-sending-an-octet/](https://devzone.nordicsemi.com/question/55937/nrf52-sending-an-octet/)\r\n\r\nThus, I've attached the relevant code that I have so far. \r\n\r\nP.S. I'm a beginner so some things that may be obvious to you, might not be obvious to me. Thus I would greatly appreciate detailed answers! The more information, the better. \r\n\r\nIn my main.c file:    \r\n\r\n    /**\r\n     * @brief Work-around for transmitting 1 byte with SPIM.\r\n     *\r\n     * @param spim: The SPIM instance that is in use.\r\n     * @param ppi_channel: An unused PPI channel that will be used by the\r\n    \t\tworkaround.\r\n     * @param gpiote_channel: An unused GPIOTE channel that will be used by\r\n    \t\tthe workaround.\r\n     *\r\n     * @warning Must not be used when transmitting multiple bytes.\r\n     * @warning After this workaround is used, the user must reset the PPI\r\n    \t\tchannel and the GPIOTE channel before attempting to transmit multiple\r\n    \t\tbytes.\r\n     */\r\n    void setup_workaround_for_ftpan_58(NRF_SPIM_Type *spim, \r\n    \t\t\t\t\t\t\t       uint32_t ppi_channel, \r\n    \t\t\t\t\t\t\t       uint32_t gpiote_channel){\r\n    \t\r\n        // Create an event when SCK toggles.\r\n    \tNRF_GPIOTE->CONFIG[gpiote_channel] = \r\n    \t\t(GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos) | \r\n    \t\t(spim->PSEL.SCK << GPIOTE_CONFIG_PSEL_Pos) | \r\n    \t\t(GPIOTE_CONFIG_POLARITY_Toggle <<GPIOTE_CONFIG_POLARITY_Pos);\r\n    \r\n    \t// Stop the spim instance when SCK toggles.\r\n    \tNRF_PPI->CH[ppi_channel].EEP = (uint32_t)&NRF_GPIOTE->EVENTS_IN[gpiote_channel];\r\n    \tNRF_PPI->CH[ppi_channel].TEP = (uint32_t)&spim->TASKS_STOP;\r\n    \tNRF_PPI->CHENSET = 1U << ppi_channel;\r\n    }\r\n    \r\n    /**@brief Functions prepares buffers and starts data transfer to AS3911\r\n     *\r\n     * @param[in] p_tx_data     A pointer to a buffer TX.\r\n     * @param[in] p_rx_data     A pointer to a buffer RX.\r\n     * @param[in] len           A length of the data buffers.\r\n     */\r\n    static void spi_send_recv(uint8_t * const p_tx_data,\r\n                              uint8_t * const p_rx_data,\r\n                              const uint16_t  len)\r\n    {\r\n    \tSEGGER_RTT_WriteString(0, \"Send and Receive info \\n\");\r\n    \t\r\n        if (len == 1){\r\n    \t\tnrf_ppi_channel_t ppi_channel;\r\n    \t\tuint32_t gpiote_task_addr;\r\n    \t\tret_code_t err_code;\r\n    \t\t\t\r\n    \t\t//initializes the GPIOTE channel so that SCK toggles\r\n    \t\tnrf_drv_gpiote_out_config_t config = GPIOTE_CONFIG_OUT_TASK_TOGGLE(false);\r\n    \t\terr_code = nrf_drv_gpiote_out_init(SPIM0_SCK_PIN, &config);\r\n    \t\tAPP_ERROR_CHECK(err_code);\t\r\n    \t\r\n    \t\t//allocates the first unused PPI Channel\r\n    \t\terr_code = nrf_drv_ppi_channel_alloc(&ppi_channel);\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t\r\n    \t\t//get the address of the GPIOTE task \r\n    \t\t//(is this is a GPIOTE channel??????)\r\n    \t\tgpiote_task_addr = nrf_drv_gpiote_out_task_addr_get\t(SPIM0_SCK_PIN);\r\n    \t\r\n    \t\t//enable the PPI channel.\r\n    \t\terr_code = nrf_drv_ppi_channel_enable(ppi_channel);\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t\r\n    \t\t//enable the GPIOTE output pin task.\r\n    \t\tnrf_drv_gpiote_out_task_enable(SPIM0_SCK_PIN);\r\n    \t\t\t\r\n    \t\t//Start transfer of data\r\n    \t\terr_code = nrf_drv_spi_transfer(&m_spi_master, p_tx_data, len, p_rx_data, len);\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t\t\t\r\n    \t\t//interrupt transfer of data so that only one byte is sent\r\n    \t\tsetup_workaround_for_ftpan_58(NRF_SPIM_Type *spim, \r\n    \t\t\t\t\t\t\t\t\t       ppi_channel, \r\n    \t\t\t\t\t\t\t\t\t       gpiote_task_addr);\r\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    \t\t//disable the ppi channel\r\n    \t\terr_code = nrf_drv_ppi_channel_disable(ppi_channel);\r\n    \t\r\n    \t\t//disable a GPIOTE output pin task.\r\n    \t\tnrf_drv_gpiote_out_task_disable(SPIM0_SCK_PIN);\r\n    \t}\r\n    \telse{\r\n    \t\t// Start transfer.\r\n    \t\tuint32_t err_code = nrf_drv_spi_transfer(&m_spi_master, p_tx_data, len,         \r\n                                                                                p_rx_data, len);\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t}\r\n    \t\t\r\n        nrf_delay_ms(delay);\r\n    }\r\n    \r\n    /**@brief Function for sending 1 byte to AS3911\r\n    *\r\n    * @param[in] cmd is the register of the AS3911 that you want to write to\r\n    */\r\n    void as3911ExecuteCommand(uint8_t cmd){\r\n    \tuint8_t write_buffer[1];\r\n    \tSEGGER_RTT_WriteString(0, \"Entered Execute Command\\n\");\r\n    \twrite_buffer[0] = cmd | AS3911_CMD_MODE;\r\n    \tspi_send_recv(write_buffer, NULL, 1);\r\n    }\r\n    \r\n    int main(void){\r\n    \t//0 is the terminal number where the text is output on the J-link RTT\r\n    \t//These lines are meant for debugging purposes and are not necessary \r\n    \tSEGGER_RTT_WriteString(0, \"Program Begin\\n\");\t\t\t\r\n    \t\t\r\n    \t//INITIALIZING PERIPHERALS\r\n    \t//Initialize UART, and board support\r\n    \tuart_config();\r\n    \tbsp_configuration();\r\n    \t\t\r\n    \t//Configure SPI interface\r\n        nrf_drv_spi_config_t const config =\r\n        {\r\n            #if (SPI0_ENABLED == 1)\r\n                .sck_pin  = SPIM0_SCK_PIN, \r\n                .mosi_pin = SPIM0_MOSI_PIN,\r\n                .miso_pin = SPIM0_MISO_PIN,\r\n                .ss_pin   = SPIM0_SS_PIN,\r\n            \r\n            #endif\r\n            .irq_priority = APP_IRQ_PRIORITY_LOW, //tells computer what to prioritize over other things\r\n    \t\t\t\t.orc          = 0x00,\r\n            .frequency    = NRF_DRV_SPI_FREQ_1M,\r\n            .mode         = NRF_DRV_SPI_MODE_1,\r\n            .bit_order    = NRF_DRV_SPI_BIT_ORDER_MSB_FIRST,\t\r\n        };\r\n    \t\t\r\n    \t//Initialize SPI\r\n    \tret_code_t err_code = nrf_drv_spi_init(&m_spi_master, &config, spi_master_event_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \t\t\r\n    \t//initialize GPIOTE and PPI\r\n        err_code = nrf_drv_ppi_init();\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        err_code = nrf_drv_gpiote_init();\r\n        APP_ERROR_CHECK(err_code);\r\n    \t\t\r\n    \t//VARIABLES\r\n    \tuint8_t numBytesReg = 0x1D;\r\n    \t\t\r\n    \t//Infinite loop containing main functionality\r\n    \tfor(;;){\r\n    \t\tif (m_transfer_completed)\r\n    \t\t{\r\n    \t\t\tm_transfer_completed = false;\t\t\r\n    \t\t\tas3911WriteRegister(numBytesReg, 0x01);\r\n    \t\t\tas3911ExecuteCommand(0xC1);\t\t\t\t\r\n    \t\t}\t\t\t\r\n    \t}\r\n    }\t\r\n\r\nATTACHMENTS:\r\n[main.c](/attachment/f164ecbfe3e2d2fa9f539aa17c8072d1)\r\n[nrf_drv_spi.c](/attachment/99f98b131d7145e4c72c6f0cda30674e)\t\r\n[nrf_drv_config.h](/attachment/c4738618118c98fa139faabf0214dba2)\r\n[nrf_drv_gpiote.c](/attachment/c63f018fce425be1e03f15c13bdfccb6)\r\n[nrf_drv_ppi.c](/attachment/ce963639e1bfdac59e4abb647a7a4735)\r\n\r\n",
    "tag": "spi"
  },
  {
    "text": "nrf52 Preview DK SPI Master - No Slave Select Toggle Hi All,\r\n\r\nI'm working with the NRF52 Preview DK, with SDK V 0.92. \r\n\r\nI've been looking at and tweaking the SPI_Master tutorial found under /examples/peripheral/spi_master/ while following the documentation for the SPI Hardware Drivers found [here](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk52.v0.9.2%2Findex.html): \r\n\r\nSo far, I've been able to successfully write data out on the MOSI pin of the SPI1 peripheral, verified using a saleae logic analyzer. However, I've had to change the trigger settings because the slave select pin does not seem to be toggling low to initialize the transaction. (see attached screen capture).\r\n\r\n![image description](/attachment/a89baa09762e73d84d78fdfd672a2051)\r\n\r\nI've tried overriding the default NRF_DRV_SPI_DEFAULT_CONFIG() value for ss_pin with the SPIM1_SS_PIN found in the pca13006.h file like so, but still no luck. \r\n\r\n    \t// 2) Configure and Initialize the instance \r\n\tnrf_drv_spi_config_t config = NRF_DRV_SPI_DEFAULT_CONFIG(1);\r\n\tconfig.frequency \t\t\t\t\t\t= NRF_DRV_SPI_FREQ_1M;\t\t\t\t\t\t\r\n\tconfig.mode \t\t\t\t\t\t\t\t=\tNRF_DRV_SPI_MODE_3;\t\t\t\t\t\t\t\r\n\tconfig.bit_order\t\t\t\t\t\t= NRF_DRV_SPI_BIT_ORDER_LSB_FIRST; \r\n\tconfig.ss_pin\t\t\t\t\t\t\t\t= SPIM1_SS_PIN;\r\n\r\nAny other ideas on how I can \"enable\" the slave select of the SPI1 peripheral?\r\n\r\nI've attached my entire main code at the bottom of this post\r\n\r\nThanks!\r\n\r\n    int main(void){\r\n\r\n\tuint32_t err_code;\r\n\tconst uint8_t *tx_buf=\"Helloooo\";\r\n\tuint8_t tx_buf_len=9;\r\n\tuint8_t *rx_buf=\"World\";\r\n\tuint8_t rx_buf_len=6;\r\n\t\r\n\tSEGGER_RTT_printf(0, \"Hello World! Let's Initialize the SPI1 Peripheral as master\\n\");\r\n\t\r\n\t// 1) Create an SPI master driver instance to control SPI1 peripheral\r\n\tstatic const nrf_drv_spi_t m_spi_master_1 = NRF_DRV_SPI_INSTANCE(1);\r\n\t\r\n\t// 2) Configure and Initialize the instance \r\n\tnrf_drv_spi_config_t config = NRF_DRV_SPI_DEFAULT_CONFIG(1);\r\n\tconfig.frequency \t\t\t\t\t\t= NRF_DRV_SPI_FREQ_1M;\t\t\t\t\t\t\r\n\tconfig.mode \t\t\t\t\t\t\t\t=\tNRF_DRV_SPI_MODE_3;\t\t\t\t\t\t\t\r\n\tconfig.bit_order\t\t\t\t\t\t= NRF_DRV_SPI_BIT_ORDER_LSB_FIRST; \r\n\tconfig.ss_pin\t\t\t\t\t\t\t\t= SPIM1_SS_PIN;\r\n\t\t\r\n\terr_code = nrf_drv_spi_init(&m_spi_master_1, &config, NULL);\t// NULL event handler = blocking mode\r\n\r\n\tif (err_code != NRF_SUCCESS){\r\n\t\t\tSEGGER_RTT_printf(0, \"Could not properly run nrf_drv_spi_init() to initialize SPI Peripheral\\n\");\r\n\t\t\treturn -1;\r\n\t}\r\n\t\r\n\t// Send data continuously in infinite loop\r\n\tfor(;;){\r\n\t\terr_code = nrf_drv_spi_transfer(&m_spi_master_1, tx_buf, tx_buf_len, rx_buf, rx_buf_len);\r\n\t\tnrf_delay_ms(100);\r\n\t}\r\n\t\r\n\t// Uninitialize the SPI Master Driver instance\r\n\tnrf_drv_spi_uninit(&m_spi_master_1);\r\n\t\r\n\treturn 0;\r\n}",
    "tag": "spi"
  },
  {
    "text": "All LEDs light up upon ble error Hello, \r\n\r\nI am using the nRF52 along with SDK 9.0.2. I have used both the ble_app_uart code and the twi_master_slave code to send data from a sensor over bluetooth to the nRF Toolbox UART app on Android. I can flash the code, connect to the nRF52, and read data over bluetooth just fine, but only with using an nrf_delay_ms. \r\n\r\nIf I use a delay less than about 50ms, the app disconnects from the nRF52 bluetooth, and all the LEDs light up. This is important, because I can't use too big of a delay, or my sampling rate will be too low and the quality of the data suffers.\r\n\r\nIs it a common error for all LEDs to light up? Could the need for the delay be a hardware limitation on how quickly the nordic can send transmissions over bluetooth?\r\n\r\nThanks.",
    "tag": "i2c"
  },
  {
    "text": "NRF51822 measure input voltage Hi,\r\n\r\nI am trying to use an nrf51822 with a sensor that outputs value between 0-5V. What I am confused about is how to read input voltage on the beacon. I saw some people using ADC, but there was no clear instruction on how exactly to do it. Maybe you could provide clear instructions on how to configure a pin as an input pin correctly, set up the ADC and read the voltage, let's say, every 100ms? This would be very helpful.\r\n\r\nLooking forward to hearing from you. Thanks in advance.\r\n\r\nRegards,\r\nRobert \r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "SPI Master while sending/receiving BLE packets What I would like to do is run a basic SPI program that reads data from a register on a non Nordic transceiver chip. My nRF51 would have to act as the master because the transceiver can only act as a slave device. I would like to then take the data I received over SPI and send it via BLE.\r\n\r\nAfter going through the SDK for hours it seems as though a serialized application is not the route to take because the connectivity board (which is handling the BLE transfers) is the slave device. \r\n\r\nIs it possible to use one board and have an active BLE connection while being an SPI Master?",
    "tag": "spi"
  },
  {
    "text": "TWI Init/Uninit Driver Bug I have an application that uses many TWI buses, on many pins of the nRF51.  I handle this by initializing/uninitializing a single TWI bus for different transactions.  I ran into the issue where the TWI driver would get stuck in \"transfer_in_progress\" every once in awhile while using SDK v9.0.  When debugging I could see that the \"transfer_in_progress\" flag is only cleared in the interrupt, so it was impossible to recover from a stuck \"transfer_in_progress\" after a disable/uninit.  To resolve my issue I added:\r\n\r\n    m_cb[p_instance->instance_id].transfer.transfer_in_progress = false;\r\n\r\nto the \r\n\r\n    void nrf_drv_twi_disable(nrf_drv_twi_t const * const p_instance)\r\n\r\nfunction.  I am probably circumventing some terrible race condition that I have created, but with this change my tests have done thousands of successful TWI transactions.  The original author of the driver might have a better idea how to prevent the failure.  I dislike maintaining my own driver files because it prevents me from taking SDK updates wholesale, it would be nice to have a fix in the SDK.  Maybe this has been fixed in v10.0 or v11.0?",
    "tag": "twi"
  },
  {
    "text": "TWI Init/Uninit Driver Bug I have an application that uses many TWI buses, on many pins of the nRF51.  I handle this by initializing/uninitializing a single TWI bus for different transactions.  I ran into the issue where the TWI driver would get stuck in \"transfer_in_progress\" every once in awhile while using SDK v9.0.  When debugging I could see that the \"transfer_in_progress\" flag is only cleared in the interrupt, so it was impossible to recover from a stuck \"transfer_in_progress\" after a disable/uninit.  To resolve my issue I added:\r\n\r\n    m_cb[p_instance->instance_id].transfer.transfer_in_progress = false;\r\n\r\nto the \r\n\r\n    void nrf_drv_twi_disable(nrf_drv_twi_t const * const p_instance)\r\n\r\nfunction.  I am probably circumventing some terrible race condition that I have created, but with this change my tests have done thousands of successful TWI transactions.  The original author of the driver might have a better idea how to prevent the failure.  I dislike maintaining my own driver files because it prevents me from taking SDK updates wholesale, it would be nice to have a fix in the SDK.  Maybe this has been fixed in v10.0 or v11.0?",
    "tag": "i2c"
  },
  {
    "text": "no member named POWER in 'NRF_TWI_Type {aka struct <anonymous>}' Hello,\r\n\r\nI am attempting to implement the TWI drivers from the SDK for a nrf52832 chip for a pca10040 board. I am using the twi_hw_master files to drive my TWI and insofar I have been unable to implement it because I am having the following issue when building: \r\n \r\n\r\n    twi_hw_master.c:53:21: error: 'NRF_TWI_Type {aka struct <anonymous>}' has no member named 'POWER'\r\n\r\n\r\nThat particular Struct is defined in the nrf52.h file. As far as I can tell this is entirely true and there actually is no member called POWER in NRF_TWI_Type, only in :\r\n\r\n    typedef struct {\r\n      __IO uint32_t  POWER;                             /*!< Description cluster[0]: RAM0 power control register                   */\r\n      __O  uint32_t  POWERSET;                          /*!< Description cluster[0]: RAM0 power control set register               */\r\n      __O  uint32_t  POWERCLR;                          /*!< Description cluster[0]: RAM0 power control clear register             */\r\n      __I  uint32_t  RESERVED0;\r\n    } POWER_RAM_Type;\r\n\r\nAlso, I am getting the following popup when I try to open declaration:\r\n\r\n![image description](/attachment/0aafa634bdf3b1920d25395d86ea6bee)\r\n\r\n(the path covered in red is exactly the same in both instances)\r\n\r\nIs it possible I am including the file nrf52.h twice?\r\n\r\nCan anyone lend a hand?  \r\nThanks in advance!",
    "tag": "twi"
  },
  {
    "text": "SPI EasyDMA MAXCNT limitation Hi everyone,\r\n\r\nI've been testing SPIM with easyDMA, using nrf_drv_spi. I'd like to flush a 6-axis sensor FIFO in one SPI operation (31 samples * 12 bytes = 372 bytes) but as soon as the size of the buffer exceeds 256 bytes, it doesn't work and I only read 10 samples (120 bytes).\r\n\r\nI can't find anywhere that MAXCNT is limited to 256 bytes. Is it a bug or is it really limited?\r\n\r\n(I assume the sensor supports more than 256-byte read operation)",
    "tag": "spi"
  },
  {
    "text": "TWI read from multiple sensors return err 17 Hi,\r\n\r\nI'm reading temperature and humidity from 2 sensors in my system\r\n\r\nAt some point in time during a quick and dirt check the system has been proven working fine and I could read temp and humidity values (so no error in hw)\r\n\r\nThen I cleanup the code and nothing works anymore\r\n\r\nReading first sensor (temperature) is fine but 2nd read from humidity sensor return ERR 17 (should be NRF_ERROR_BUSY = driver not ready for new transfer)  \r\n\r\nIn my main code I have TWI TX calls to start transmission and then I'm waiting for TWI HANDLER to complete transfer\r\n\r\n\r\n    // Enter main loop.\r\n    for (;;)\r\n    {\r\n      switch (twi_case_main) {\r\n          case TWI_WAIT_MCP9808:\r\n            if (m_xfer_done == true) {\r\n              twi_case_main = TWI_MCP9808;\r\n            }\r\n          break;\r\n          case TWI_MCP9808:\r\n            twi_case_var = TWI_MCP9808;  // set case for twi_handler\r\n            reg[0] = MCP9808_RA_TEMP;\r\n            twi_err_code = nrf_drv_twi_tx(&m_twi_sensors, MCP9808_ADDR, reg, sizeof(reg), false);  \r\n            APP_ERROR_CHECK(twi_err_code);\r\n            twi_case_main = TWI_WAIT_HTDU21D_RH;\r\n          break;\r\n\r\n          case TWI_WAIT_HTDU21D_RH:\r\n            if (m_xfer_done == true) {\r\n              twi_case_main = TWI_HTDU21D_RH;\r\n            }\r\n          break;\r\n          \r\n          case TWI_HTDU21D_RH:\r\n            twi_case_var = TWI_HTDU21D_RH;  // set case for twi_handler\r\n            reg[0] = TRIGGER_HUMD_MEASURE_NOHOLD;\r\n            twi_err_code = nrf_drv_twi_tx(&m_twi_sensors, HTDU21D_ADDRESS, reg, sizeof(reg), false);  \r\n            APP_ERROR_CHECK(twi_err_code);\r\n            twi_case_main = TWI_IDLE;\r\n          break;\r\n\r\n          case TWI_IDLE:\r\n            if (m_xfer_done == true) {\r\n              twi_case_var = TWI_WAIT_MCP9808;\r\n            }\r\n          break;\r\n\r\n          default:\r\n            twi_case_var = TWI_MCP9808;\r\n          break;\r\n      }\r\n    }\r\n\r\n\r\nIn my twi handler\r\n\r\n/**\r\n * @brief TWI events handler.\r\n */\r\nvoid twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n{   \r\n// some variables here\r\n    \r\n    switch (twi_case_var) {\r\n      // TWI events sequence is initiated by main task with a nrf_drv_twi_tx() call and complete with the following sequence \r\n      case TWI_MCP9808:\r\n        switch(p_event->type)\r\n        {\r\n            case NRF_DRV_TWI_TX_DONE:\r\n                /* Read 2 bytes from the specified address. */\r\n                err_code = nrf_drv_twi_rx(&m_twi_sensors, MCP9808_ADDR, data, sizeof(uint8_t) * 2, false);\r\n                APP_ERROR_CHECK(err_code);\r\n            break;\r\n  \r\n            case NRF_DRV_TWI_RX_DONE:\r\n              // Mask out flags and clean up sign bit\r\n              temp = data[0] << 8 | data[1];\r\n              temperature = temp * some_k; // temperature\r\n\r\n              m_xfer_done = true;  // tell main app sensor read has been complete\r\n            break;\r\n\r\n          default:\r\n            break;        \r\n        }   \r\n      break;\r\n      \r\n      case TWI_HTDU21D_RH:\r\n        switch(p_event->type)\r\n        {\r\n            case NRF_DRV_TWI_TX_DONE:\r\n                /* Read 3 bytes from the specified address. */\r\n                err_code = nrf_drv_twi_rx(&m_twi_sensors, HTDU21D_ADDRESS, data, sizeof(uint8_t) * 3, false);\r\n                APP_ERROR_CHECK(err_code);\r\n            break;\r\n  \r\n            case NRF_DRV_TWI_RX_DONE:\r\n              // Mask out flags and clean up sign bit\r\n              temp = data[0] << 8 | data[1];\r\n              humidity1 = temp * some_k; // humidity\r\n\r\n              m_xfer_done = true;  // tell main app sensor read has been complete\r\n            break;\r\n\r\n            default:\r\n            break;        \r\n        }\r\n      break;\r\n    }\r\n}\r\n\r\nI'm getting err 17 when I try to read from humidity sensor\r\nWhat am I doing wrong?\r\n\r\nThanks",
    "tag": "twi"
  },
  {
    "text": "nRF51822 PWM reload causing reset Hi,\r\n\r\nI'm working on a second iteration of a board that uses the Raytac nRF51822 module. \r\n\r\nEverything's same as the first version except I've added some sensors and switches. \r\n\r\nI'm using the 4 channel PWM driver and I'm noticing that reloading the PWM registers causes the MCU to reset immediately.\r\n\r\n    nrf_radio_request_t radio_request;\r\n    radio_request.request_type = NRF_RADIO_REQ_TYPE_EARLIEST;\r\n    radio_request.params.earliest.hfclk = NRF_RADIO_HFCLK_CFG_DEFAULT;\r\n    radio_request.params.earliest.length_us = 250;\r\n    radio_request.params.earliest.priority = NRF_RADIO_PRIORITY_HIGH;\r\n    radio_request.params.earliest.timeout_us = 100000;\r\n    sd_radio_request(&radio_request);\r\n\r\nIs there something obvious I need to look into ? To clarify, exact same schematic worked fine on an older revision of my design.\r\n\r\nThanks",
    "tag": "pwm"
  },
  {
    "text": "nrf_drv_spi_transfer larger transfer size Hi,\r\n\r\nI'm working with an SPI FLASH chip that has a page size 256.  I noticed that when I call `nrf_drv_spi_transfer()`, the rx length of 256 rolls over the uint8_t container and is zero! \r\n\r\nDigging deeper, I found that the RX size is used for `nrf_spim_rx_buffer_set()`, also taking the argument as uint8_t.  This function sets `p_spim->RXD.MAXCNT = length;`\r\nMAXCNT is size uint32_t.  Is there a reason I shouldn't mess with these sizes?  \r\n\r\nI'm also thinking I'd need a tx buffer size at least 256 to write a page at a time.\r\n",
    "tag": "spi"
  },
  {
    "text": "nRF52 PWM frequency question Hi,\r\n\r\nBy using the PWM exampl in SDK 0.9.2, I can generate a 1MHz PWM signal without problem.\r\nHowever, it seems that the function provided by SDK can just set upto 1MHz PWM?\r\n\r\nI am using fillowing MACRO provided by SDK:\r\n\r\n    #define APP_PWM_DEFAULT_CONFIG_1CH(period_in_us, pin)                                  \\\r\n        {                                                                                  \\\r\n            .pins            = {pin, APP_PWM_NOPIN},                                       \\\r\n            .pin_polarity    = {APP_PWM_POLARITY_ACTIVE_LOW, APP_PWM_POLARITY_ACTIVE_LOW}, \\\r\n            .num_of_channels = 1,                                                          \\\r\n            .period_us       = period_in_us                                                \\\r\n        }\r\n\r\nI then set APP_PWM_DEFAULT_CONFIG_1CH(1L, 8)  and got 1MHz signal.\r\nIf I need more higher frequency, say 4MHz, I need 0.25us in period_in_us field which is not allowed since it is uint32 type.\r\n\r\nIs there any way to get more higher frequency than 1MHz?\r\n\r\nAlso, can this pwm library been use with SD? I can't get PWM out put if I \r\ntry to config it in beacon example (set before the SD is init)\r\n\r\nBy the way, nRF52 do have PWM peripheral, why the example still using timer and PPI for PWM function? Is there any example to show how to use the real PWM peripheral?\r\n\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "SPI Slave problem with buffers (nRF51, SDK v10) - Bug in nrf_drv_spis_event_t structure? Hello,\r\n\r\nI've been working with the SPI Slave on a nRF51-DK for several days. I am using the nRF51-DK (PCA10028), S130 v1.0.0 and SDK v10.0.0. First, I set up a RX and TX buffer of equal size (nrf_drv_spis_buffers_set() is called with same RX and TX buffer lengths). In this scenario, everything seemed to work fine.\r\n\r\nAfter I started to implement my SPI protocol, I wanted to change the TX buffer length so that it represents the actual amount of data to transmit. I expected the driver to send the \"overread\" character for any additional bytes. The RX buffer length was kept at the actual buffer size. In this scenario, I had a lot of trouble with receiving the expected data. I played arount with switching buffer length parameters in nrf_drv_spis_buffers_set() but in the end, I came to the following conclusion:\r\n\r\n**In the nrf_drv_spis_event_t structure which is reported to the event handler, rx_amount and tx_amount are switched.**\r\n\r\nCan anyone confirm this bug? If I use the tx_amount value as the number of received bytes, my current implementation seems to work fine.\r\n\r\n\r\n**Update:**\r\n\r\n[SPIS_Test.zip](/attachment/c6fe11b5d2f2b9a6864644e5c18c9cf8)\r\n\r\nHere is a sample code that demonstrates the bug. It is a makefile project with GCC toolchain. see hardware_config.h for SPI pins. You can observe the debug output with the Segger JLink RTT Client (see *driver/spis.c*, `spis_event_handler()` ).\r\n\r\nThe software configures a TX buffer of 2 bytes and a RX buffer of up to 200 bytes. Buffers are cleared to 0 before each transaction. Now, when you use a SPI Master to send for example 8 bytes (data bytes are not 0), you can see the that the correct data has been received (8 data bytes) but `rx_amount` countains 2. On the other hand, `tx_amount` contains 8 although we only configured a tx buffer length of 2 bytes. You may switch those values and the debug output shows the correct information.\r\n",
    "tag": "spi"
  },
  {
    "text": "nRF51 and MPU6050 TWI Issue Hi,\r\n\r\nI've looked at the example codes provided by Martin in these two topics for communicating to a MPU6050 through TWI:\r\n\r\n1- https://devzone.nordicsemi.com/question/48894/hardware-twii2c-example/  (uses SDK 9)\r\n2- https://devzone.nordicsemi.com/question/59309/mpu6050-on-nrf51822/        (uses SDK 10)\r\n\r\nJust for others to know: The first one is just a TWI example, and the second one has a set of functions added for MPU9150/MPU6050. I found the only difference between SDK 9 and 10 in the *nrf_drv_twi_init* function, which needs 3 parameters in SDK 9 and 4 parameters in SDK 10. Also, I paid attention to TWI instance used in *NRF_DRV_TWI_INSTANCE*, and enabled it in *nrf_drv_config*.\r\n\r\nI'm in process of trouble shooting this and any comments can help. Here are what I observed by using the codes above in my project on a PCA20006 with 3rd revision IC and SDK 9. Similar to 2, I only use *twi_init()*, *mpu_init()* and then just a couple of readings.\r\n\r\n1- Without connecting the MP board, I added a blinking LED code in *mpu9150_twi_event_handler* which is called by *twi_handler*. This is added under \"*case NRF_DRV_TWI_ERROR*\". As there is no device on TWI, program goes to this error case and LED blinks.\r\n\r\n2- When connecting the MPU board, the program doesn't go to the error case at all, and also exactly after using *mpu_init()*, the current of MPU board goes from 0 to 3~4 mA. So, I thought the TWI is working. BUT,\r\n\r\n3- I added an IO pin toggle for 10usec, under \"*case NRF_DRV_TWI_TX_DONE*\". Similar to the TWI example by Martin I expected that after a successful TX, it should go to that case and toggle the pin. But, this doesn't happen + when I monitor the SCL and SDA pins it seems that they are always \"HIGH\". \r\n\r\nFrom one hand, it seems that two boards are actually communicating as compared to \"no MPU case\", the code never goes to the error case. On the other hand it doesn't go to TX_DONE case either and it seems that the pins are not changing.\r\n\r\nAny comments?\r\n\r\nBTW, SDA and SCL lines are pulled up in MPU6050 board to its VLOGIC=3V by 2K resistors. \r\n\r\nUpdate 1 - Oscilloscope screen shot with **MPU9150_TWI_TIMEOUT = 5000** - See Comments for more information\r\n![image description](/attachment/920bb61259983c9d37819a52a9a1f8c4)\r\n\r\nUpdate 2 - Screen shot with **MPU9150_TWI_TIMEOUT = 1000** with an IO pin toggling after each NRF_DRV_TWI_RX_DONE event\r\n![image description](/attachment/472989fa045f929bc4e9c22e35c598a9)\r\n\r\nUpdate 3 - Screen shot with **MPU9150_TWI_TIMEOUT = 750** with an IO pin toggling after each NRF_DRV_TWI_RX_DONE event + IO pin toggle after the while loop + conditional toggle based on twi_tx_done\r\n![image description](/attachment/e667f16d75c5a74ef536405add86d106)\r\n\r\n[main.c](/attachment/c34b52a6a61737f4cffa0942560c3f3c)\r\n[mpu9150.c](/attachment/7c0559031d1fb2a20e640e1378542d7d)\r\n[mpu9150.h](/attachment/9b3c238e3b06b83c6d8df1fb346e1a14)",
    "tag": "twi"
  },
  {
    "text": "nRF52832 twi_master_transfer Hey guys,\r\nI have a little problem on a new board comunicating with a MPU9250 sensor. \r\n\r\n- Chip version is nrf52832-QFAA-BA\r\n- GPIO PINS Used P0.20 (SDA) and P0.21 (SCL)\r\n- I can read the sensor WHO_AM_I register correctly (it returns 0x71).\r\n- I can't write on register, function twi_master_transfer returns always false.\r\n\r\nHere my TWI macro functions to read and to write:\r\n       \r\n    bool readI2cData(unsigned char address, unsigned char reg, unsigned char len, unsigned char * data)\r\n    {\t\t\r\n\t\r\n        // Write: register address we want to start reading from\r\n\tif (twi_master_transfer(address<<1, &reg, 1, TWI_DONT_ISSUE_STOP))\r\n\t{\r\n\t\t  // Read: the number of bytes requested.\r\n\t\tif (twi_master_transfer(address<<1 | TWI_READ_BIT, data, len, TWI_ISSUE_STOP))\r\n\t\t{\t\t\t\r\n\t\t  // Read succeeded.\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// read or write failed.\r\n\treturn false;\r\n    }\r\n    uint8_t readI2cReg(uint8_t address, uint8_t reg){\r\n    unsigned char data;\r\n\t\r\n\tif (readI2cData(address, reg,1, &data)) \r\n\t{\r\n\t\treturn data;\r\n\t}\r\n\treturn 0; \r\n    }\r\n\r\n\r\n    \r\n\r\n    bool writeI2cReg(unsigned char address, unsigned char reg, unsigned char len, const unsigned char   value)\r\n\r\n    {\r\n\tuint8_t data[2];\r\n\tdata[0] = reg;\r\n\tdata[1] = value;\r\n\t\r\n    // Write: register protocol\r\n\tif (twi_master_transfer(address << 1 , data, len,1))\r\n\t{\r\n\t\treturn true;    \r\n\t}\r\n\t\r\n\t// read or write failed.\r\n\treturn false;\r\n     }\r\n\r\nAnd here is what I try to write:\r\n\r\n    unsigned char data[6];\r\n\r\n    /* Reset device. */\r\n    data[0] = BIT_RESET; //equal to 0x80\r\n    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))\r\n        return -1;\r\n    delay_ms(100);\r\n\r\n    /* Wake up chip. */\r\n    data[0] = 0x00;\r\n    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))\r\n        return -1;\r\n\r\nWhere am I wrong? Probably missing something?\r\n\r\nThanks.",
    "tag": "twi"
  },
  {
    "text": "nRF52832 twi_master_transfer Hey guys,\r\nI have a little problem on a new board comunicating with a MPU9250 sensor. \r\n\r\n- Chip version is nrf52832-QFAA-BA\r\n- GPIO PINS Used P0.20 (SDA) and P0.21 (SCL)\r\n- I can read the sensor WHO_AM_I register correctly (it returns 0x71).\r\n- I can't write on register, function twi_master_transfer returns always false.\r\n\r\nHere my TWI macro functions to read and to write:\r\n       \r\n    bool readI2cData(unsigned char address, unsigned char reg, unsigned char len, unsigned char * data)\r\n    {\t\t\r\n\t\r\n        // Write: register address we want to start reading from\r\n\tif (twi_master_transfer(address<<1, &reg, 1, TWI_DONT_ISSUE_STOP))\r\n\t{\r\n\t\t  // Read: the number of bytes requested.\r\n\t\tif (twi_master_transfer(address<<1 | TWI_READ_BIT, data, len, TWI_ISSUE_STOP))\r\n\t\t{\t\t\t\r\n\t\t  // Read succeeded.\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// read or write failed.\r\n\treturn false;\r\n    }\r\n    uint8_t readI2cReg(uint8_t address, uint8_t reg){\r\n    unsigned char data;\r\n\t\r\n\tif (readI2cData(address, reg,1, &data)) \r\n\t{\r\n\t\treturn data;\r\n\t}\r\n\treturn 0; \r\n    }\r\n\r\n\r\n    \r\n\r\n    bool writeI2cReg(unsigned char address, unsigned char reg, unsigned char len, const unsigned char   value)\r\n\r\n    {\r\n\tuint8_t data[2];\r\n\tdata[0] = reg;\r\n\tdata[1] = value;\r\n\t\r\n    // Write: register protocol\r\n\tif (twi_master_transfer(address << 1 , data, len,1))\r\n\t{\r\n\t\treturn true;    \r\n\t}\r\n\t\r\n\t// read or write failed.\r\n\treturn false;\r\n     }\r\n\r\nAnd here is what I try to write:\r\n\r\n    unsigned char data[6];\r\n\r\n    /* Reset device. */\r\n    data[0] = BIT_RESET; //equal to 0x80\r\n    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))\r\n        return -1;\r\n    delay_ms(100);\r\n\r\n    /* Wake up chip. */\r\n    data[0] = 0x00;\r\n    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))\r\n        return -1;\r\n\r\nWhere am I wrong? Probably missing something?\r\n\r\nThanks.",
    "tag": "i2c"
  },
  {
    "text": "nrf_drv_twi and read register Hi,\r\nhow is the new nrf_drv_twi supposed to be used for reading registers?\r\nThe sequence for that is pretty much industry standard:\r\n\r\n    > Device address\r\n    < Ack \r\n    > 0x00 (register)\r\n    < Ack\r\n    < Data\r\n    > Ack\r\n\r\nthis code will write the address twice (one w and one r) rather then doing a write and then expecting data to be clocked from the peripheral:\r\n\r\n     nrf_drv_twi_tx(&twi, MAX7315_ADDRESS, (uint8_t*)&buf, 1, true);\r\n     nrf_drv_twi_rx(&twi, MAX7315_ADDRESS, (uint8_t*)&buf, 1, false);\r\n\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "TWI0 + TWI1 + SPIx Hey Guys,\r\n\r\nIn my custom board I need to use two different I2C bus and one SPI.\r\n\r\nAt the moment i'm using twi_master to comunicate with one of the TWI bus,\r\nbut to switch TWI the only option I've seen is to change:\r\n\r\nTWI_MASTER_CONFIG_CLOCK_PIN_NUMBER (13U)\r\n\r\nTWI_MASTER_CONFIG_DATA_PIN_NUMBER (14U)\r\n\r\nhow can i configure two istances of the twi_master?\r\n\r\nFurthermore I need to use an SPI beside these the TWI, what SPI should I be using?\r\nIs it the SPI2 due to the concurrent use of TWI0 and TWI1?\r\n\r\nI'm alittle bit confused.\r\n\r\nThanks.",
    "tag": "twi"
  },
  {
    "text": "TWI0 + TWI1 + SPIx Hey Guys,\r\n\r\nIn my custom board I need to use two different I2C bus and one SPI.\r\n\r\nAt the moment i'm using twi_master to comunicate with one of the TWI bus,\r\nbut to switch TWI the only option I've seen is to change:\r\n\r\nTWI_MASTER_CONFIG_CLOCK_PIN_NUMBER (13U)\r\n\r\nTWI_MASTER_CONFIG_DATA_PIN_NUMBER (14U)\r\n\r\nhow can i configure two istances of the twi_master?\r\n\r\nFurthermore I need to use an SPI beside these the TWI, what SPI should I be using?\r\nIs it the SPI2 due to the concurrent use of TWI0 and TWI1?\r\n\r\nI'm alittle bit confused.\r\n\r\nThanks.",
    "tag": "i2c"
  },
  {
    "text": "NRF51 ADC max input resistance Hello,\r\nI red a Reference manual v3.0 for NRF51, chapter 31.1.3 (Input impedance).\r\nAnd I did not understand information about impedance.\r\nWhat maximal input resistance can be for correct ADC measurement data?",
    "tag": "adc"
  },
  {
    "text": "soft device threading - when and what are calls safe? I would like to learn more about when it is safe to invoke soft device methods and when it is not.  For example, are the following 'allowed' to make soft device calls to update a characteristic?  If not, what is the suggested workaround?  For example, can I initiate a TX characteristic notification to the peer from any of these contexts?\r\n\r\n 1. From within a button interrupt handler\r\n 2. From within a timer interrupt\r\n 3. From a callback when an RX characteristic notification is received\r\n 4. From an on_ble event handler",
    "tag": "interrupt"
  },
  {
    "text": "I2C PN532 Problem (Clock Stretching?) Hi,\r\n\r\nI am trying to connect a PN532 (RFID Tag Reader module) to BLE Nano (nrf58122) using I2C.\r\nThis doesn't work, and I'm trying to figure out why.\r\n\r\nI am generating the code via Arduino IDE. The sketch compiles and works beautifully with an Arduino. However, when tested with the BLE Nano, it fails to send a command over I2C.\r\n\r\nI think this might be related to clock stretching, however, I am not an expert in I2C communication. I tried modifying the code directly by setting the frequency to 400kHz, but that did not seem to change anything.\r\n\r\nI am attaching the code below. Basically, success returns false on the BLE nano, but not with Arduino.\r\n\r\nThe device is connected via SDA=>P0_10, SCL=>P0_8, and has two 1.5k pull up resistors to VDD.\r\n\r\n-----------\r\n  Wire.begin();\r\n\r\n  Wire.beginTransmission(PN532_I2C_ADDRESS); \r\n\r\n  delay(20);\r\n\r\n  Wire.endTransmission();                    \r\n\r\n  \r\n  Wire.beginTransmission(PN532_I2C_ADDRESS);\r\n\r\n  bool success = Wire.write(PN532_PREAMBLE));\r\n\r\n--------------------------------\r\n",
    "tag": "i2c"
  },
  {
    "text": "nRF51: is it possible to read the timer counter register? Is it possible to directly read the timer module counter register in the nRF51?",
    "tag": "timer"
  },
  {
    "text": "nRF51822  s110 + TWI Crashes I'm testing out TWI on pins 24/25 and I get a crash when I attempt to do a TWI transfer and I find myself in: WDT_IRQHandler ()\r\n\r\nI'm using much of the example code:\r\n\r\nAPP_TWI_INIT(&m_app_twi, &config, MAX_PENDING_TRANSACTIONS, err_code);\r\n\r\napp_twi_transfer_t const lm75b_init_transfers[LM75B_INIT_TRANSFER_COUNT] =\r\n    {\r\n        APP_TWI_WRITE(LM75B_ADDR, default_config, sizeof(default_config), 0)\r\n    };\r\n\r\napp_twi_perform(&m_app_twi, lm75b_init_transfers, LM75B_INIT_TRANSFER_COUNT, NULL);\r\n\r\nMore precisely, the function \r\n\r\nret_code_t result = app_twi_schedule(p_app_twi, &internal_transaction);\r\n\r\ndoesn't return...\r\n\r\nAlso, all this happens *before* any ble stuff happens.\r\n\r\n\r\nthanks!",
    "tag": "twi"
  },
  {
    "text": "NRF_ERROR_NO_MEM plus scheduler I'm getting the NRF_ERROR_NO_MEM when I try to put my ADC interrupt routine into the scheduler. The code runs without error if I run from the ADC interrupt handler directly but hits the NVIC_system_reset if I try to put the code into the scheduler. I'm using the scheduler else where in my code without issue. This is with NRF51822 and SD 8. This works fine:\r\n\r\n\r\n----------\r\n\r\n\r\nvoid ADC_IRQHandler(void){\r\n\r\n    nrf_adc_conversion_event_clean();\r\n  \tif (measure_bat == true)\r\n\t{\r\n\t\t batt_voltage = nrf_adc_result_get();\r\n\t}\r\n \telse if (measure_hwid == true)\r\n \t{\r\n \t\thwid = nrf_adc_result_get();\r\n\t}\r\n\t\r\n\tdebug_uart_test();\r\n\t\r\n\tmeasure_bat = false;\r\n\tmeasure_hwid = false;\r\n\t\r\n\tnrf_adc_input_select(NRF_ADC_CONFIG_INPUT_DISABLED);\r\n\tNVIC_DisableIRQ(ADC_IRQn);\r\n}\r\n\r\n\r\n----------\r\n\r\n\r\nBut if I try to do this, it resets with NRF_ERROR_NO_MEM\r\n\r\n\r\n----------\r\n\r\n\r\nvoid ADC_IRQHandler(void)\r\n{\r\n\r\n   ret_code_t err_code;\r\n   err_code = app_sched_event_put(NULL, 0, adc_scheduler_handler);\r\n   APP_ERROR_CHECK(err_code);\r\n\r\n}\r\n\t\r\nvoid adc_scheduler_handler(void *data, uint16_t size)\r\n{\r\n\r\n    nrf_adc_conversion_event_clean();\r\n\tif (measure_bat == true)\r\n\t{\r\n\t\tbatt_voltage = nrf_adc_result_get();\r\n\t}\r\n\telse if (measure_hwid == true)\r\n\t{\r\n\t\thwid = nrf_adc_result_get();\r\n\t}\r\n\t\r\n\tdebug_uart_test();\r\n\t\r\n\tmeasure_bat = false;\r\n\tmeasure_hwid = false;\r\n\t\r\n\tnrf_adc_input_select(NRF_ADC_CONFIG_INPUT_DISABLED);\r\n\tNVIC_DisableIRQ(ADC_IRQn);\r\n}\r\n\r\n\r\n----------\r\nPS Any tips on how to format my code on this forum? The auto format doesn't seem to recognize chunks of my code...",
    "tag": "adc"
  },
  {
    "text": "IO expander control with TWI Hello, \r\n\r\nI've been trying to control MCP23017 IO expander with TWI using nRF52832. When I execute the code it stops at nrf_drv_twi_tx. The address pins A(0:2) are 0. \r\n\r\nAny idea on what may not work here?\r\n\r\nCode:\r\n\r\n    #define I2C_SCL_PIN \t\t\t(21)\r\n    #define I2C_SDA_PIN \t\t\t(20)\r\n    #define I2C_EXPANDER_ADD \t        (0x40)\r\n    \r\n    const int resetPin = 19;\r\n    const int ledPin = 26;\r\n    \t\r\n    static const nrf_drv_twi_t twi = NRF_DRV_TWI_INSTANCE(0);\r\n    \r\n    static ret_code_t i2cSend(size_t target_register, uint8_t data_to_write) {\r\n    \t\tuint8_t buffer[2];\r\n    \t\tbuffer[0] = target_register;\r\n    \t\tbuffer[1] = data_to_write;\r\n    \t\r\n    \t\treturn nrf_drv_twi_tx(&twi, I2C_EXPANDER_ADD, buffer, 0x02, false);\t\t\r\n    }\r\n    \r\n    int main(){\t\r\n    \tret_code_t err_code;\r\n    \tuint8_t data;\r\n    \tsize_t addr;\r\n    \t\r\n    \tnrf_gpio_cfg_output(resetPin);\t//Expander reset pin\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    \tnrf_gpio_cfg_output(ledPin);\r\n    \tnrf_gpio_pin_set(resetPin);\t\r\n    \tnrf_gpio_pin_set(ledPin);          //Expander inactive state\r\n    \t\r\n      const nrf_drv_twi_config_t twi_config = {\r\n        .scl                       = I2C_SCL_PIN,\r\n        .sda                      = I2C_SDA_PIN,\r\n        .frequency            = NRF_TWI_FREQ_400K,\r\n        .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n      };\r\n    \t\r\n    \terr_code = nrf_drv_twi_init(&twi, &twi_config, NULL, NULL);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \t\r\n    \tnrf_drv_twi_enable(&twi);\r\n    \t\r\n      i2cSend(0x01, 0x00);                     //Access direction register of PortB\r\n    \t\r\n    \twhile(1){\r\n    \t\tnrf_delay_ms(500);\r\n    \t\t\r\n    \t\ti2cSend(0x13, 0x02);\t           //Access PortB, Turn LED2 ON\r\n    \t\tnrf_gpio_pin_set(ledPin);     //Turn LED1 OFF\r\n    \t\t\r\n    \t\tnrf_delay_ms(500);\r\n    \t\t\r\n    \t\ti2cSend(0x13, 0x00);            //Access PortB, Turn LED2 OFF\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    \t\tnrf_gpio_pin_clear(ledPin);  //Turn LED1 ON\r\n    \t}\r\n    }",
    "tag": "twi"
  },
  {
    "text": "IO expander control with TWI Hello, \r\n\r\nI've been trying to control MCP23017 IO expander with TWI using nRF52832. When I execute the code it stops at nrf_drv_twi_tx. The address pins A(0:2) are 0. \r\n\r\nAny idea on what may not work here?\r\n\r\nCode:\r\n\r\n    #define I2C_SCL_PIN \t\t\t(21)\r\n    #define I2C_SDA_PIN \t\t\t(20)\r\n    #define I2C_EXPANDER_ADD \t        (0x40)\r\n    \r\n    const int resetPin = 19;\r\n    const int ledPin = 26;\r\n    \t\r\n    static const nrf_drv_twi_t twi = NRF_DRV_TWI_INSTANCE(0);\r\n    \r\n    static ret_code_t i2cSend(size_t target_register, uint8_t data_to_write) {\r\n    \t\tuint8_t buffer[2];\r\n    \t\tbuffer[0] = target_register;\r\n    \t\tbuffer[1] = data_to_write;\r\n    \t\r\n    \t\treturn nrf_drv_twi_tx(&twi, I2C_EXPANDER_ADD, buffer, 0x02, false);\t\t\r\n    }\r\n    \r\n    int main(){\t\r\n    \tret_code_t err_code;\r\n    \tuint8_t data;\r\n    \tsize_t addr;\r\n    \t\r\n    \tnrf_gpio_cfg_output(resetPin);\t//Expander reset pin\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    \tnrf_gpio_cfg_output(ledPin);\r\n    \tnrf_gpio_pin_set(resetPin);\t\r\n    \tnrf_gpio_pin_set(ledPin);          //Expander inactive state\r\n    \t\r\n      const nrf_drv_twi_config_t twi_config = {\r\n        .scl                       = I2C_SCL_PIN,\r\n        .sda                      = I2C_SDA_PIN,\r\n        .frequency            = NRF_TWI_FREQ_400K,\r\n        .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n      };\r\n    \t\r\n    \terr_code = nrf_drv_twi_init(&twi, &twi_config, NULL, NULL);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \t\r\n    \tnrf_drv_twi_enable(&twi);\r\n    \t\r\n      i2cSend(0x01, 0x00);                     //Access direction register of PortB\r\n    \t\r\n    \twhile(1){\r\n    \t\tnrf_delay_ms(500);\r\n    \t\t\r\n    \t\ti2cSend(0x13, 0x02);\t           //Access PortB, Turn LED2 ON\r\n    \t\tnrf_gpio_pin_set(ledPin);     //Turn LED1 OFF\r\n    \t\t\r\n    \t\tnrf_delay_ms(500);\r\n    \t\t\r\n    \t\ti2cSend(0x13, 0x00);            //Access PortB, Turn LED2 OFF\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    \t\tnrf_gpio_pin_clear(ledPin);  //Turn LED1 ON\r\n    \t}\r\n    }",
    "tag": "i2c"
  },
  {
    "text": "Not Exiting \"while loop\" after a TWI event Hi,\r\n\r\nI'm facing a weird problem resulting from the following code:\r\n\r\n    while((!twi_tx_done) && timeout--); \r\nThe main file and the MPU9150.c which includes this command are attached [main-2016-02-16.c](/attachment/b724f6e887cd0ebe0b30495b30a75f6b) [mpu9150.c](/attachment/c85834e698942c66f3f6ab04ae7c0f0d). Normally the program should exit this loop whenever a TWI transmit is complete and the handler sets *twi_tx_done = true*. Timeout is just setting a limit on the wait time for TWI to get completed. \r\n\r\nI'll explain below how I tested the program, but the result is that: when the loop is empty, it ALWAYS exits with the timeout = 0 (which is much longer than what a normal twi_tx is). Checking inside the handler and after the while loop show that *twi_tx_done* is SET TO TRUE by the handler, but the while loop can not detect it!\r\n\r\nI tried to add a toggling pin inside the while loop to see when it exits and re-enter the loop. Interestingly, with this single command added, it started working and now it exits at the same time the handler sets the *twi_tx_done = true* !\r\n\r\nAs toggling an IO consumes power, I though that maybe adding any command inside the loop can make it work. But, when changed the command to *nrf_gpio_pin_clear(x)* it again exits at the timeout!\r\n\r\n**Test setup:**\r\nHere is the path to the functions including the while loop:\r\n\r\nmpu_init->mpu9150_init (main.c) -> mpu9150_write_single (mpu9150.c)\r\n\r\nmpu_init->mpu9150_config (main.c) -> mpu9150_write_burst (mpu9150.c)\r\n\r\nIn the figures below:\r\n\r\n**CH1-Yellow:** SCL = TWI Clock\r\n\r\n**CH3-Purple:** PIN0 = Toggles whenever the handler sets *twi_tx_done = true* + whenever the while loop exits with a timeout\r\n\r\n**CH2-Green:** PIN3 = Toggles if(twi_tx_done) after the while loop\r\n\r\n**CH4-Pink:** PIN 20 = Toggles whenever program enters write_single & write_burst function + exactly before the while loop\r\n\r\nFor toggling inside the while loop, PIN20 is used.\r\n\r\n**CASE 1:** When an IO toggle is used inside the loop, the program works as expected\r\n![image description](/attachment/06aa504c7562df8f2f2e03b34774e00f)\r\n\r\n**Enlarged trace**, showing that no timeout occurred\r\n![image description](/attachment/2eb108f0abbac1404df494d2dd3aaa58)\r\n\r\n**CASE 2:** The toggle command is NOT used in the write_single function (left half) and the program exits at timeout (vs) Right half, which toggling is used\r\n![image description](/attachment/3b7009e1e68893ff238b52dc4beaa7e5)",
    "tag": "twi"
  },
  {
    "text": "Recording time for which the button is pressed Hi,\r\n\r\nI want to count the time in seconds for which I press the button and stop the counter when the button is released. How should I detect the long press of button and determine the time for which it was pressed ?\r\nI have a nrf 51 development board. Any suggestions would be appreciated.",
    "tag": "timer"
  },
  {
    "text": "Lowest power mode for an external interrupt with nRF51822? Our system will awake from an external accelerometer interrupt, so I would need a code fragment which shuts down S110 soft device (and radio of course) and also all the nRF51822 peripherals, as well as RAM retention. Even the real time clock is not needed. The CPU only needs to awake by the external interrupt. My related questions are:\r\n\r\n1. What is the needed code to do that, can I still use sd_app_evt_wait()?\r\n2. What should I expect as the current consumption in that state?\r\n3. Further, what is the code to get the system up and running again?\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Bluetooth Alarm Clock Hi,\r\n\r\nI want to use nrf51 development board as a bluetooth alarm clock using internal RTC . How can I generate timestamps to determine current date and time. Can the timer library be used for this purpose?\r\n\r\n ",
    "tag": "timer"
  },
  {
    "text": "Could I use nrf6350.c on nrf52? Hi all:\r\n\r\nI use SDK0.9.2 of nrf52,and I try to add nrf6350.c on nrf52 project.\r\nbut the TWI does not work,\r\nCould I use nrf6350.c on nrf52?",
    "tag": "twi"
  },
  {
    "text": "Adding TWI communication with accelerometer to BLE Hello,\r\n\r\nI have a nRF51DK.\r\nI am trying to use the TWI driver to communicate via I2C with an accelerometer MMA8452Q.\r\nI already have a working code based on several SDK examples : basically it is based on the \"experimental : multiactivity\" example with a custom BLE service. Softdevice S130.\r\nAs I said I try to add TWI support to get the data from the accelerometer and transfer the data over BLE.\r\nOn the hardware side, I have a separate 3.3V to supply the accelerometer and I connect directly the SCL pin to the P0.07 pin of the nRF51DK and the SDA pin to the P0.30 pin of the nRF51DK.\r\nOn the software side, I have added to my working code :\r\n\r\n- a call to twi_init() in the main function\r\n\r\n- the function twi_init() itself, based on the SDK TWI sensor example\r\n\r\n- after the call of twi_init in the main function, a first call to nrf_drv_twi_tx is performed in order to set the accelerometer in active mode. I then expect a call to the TWI event handler to say \"NRF_DRV_TWI_TX_DONE\", but the handler is never called.\r\n- the TWI event handler function twi_evt_handler itself\r\n\r\n- I added a timer event every 2000 ticks to initiate a read action on the I2C bus; the handler is named accelerometer_sample_read_timeout_handler\r\n\r\nAs written above, the TWI event handler is not called after the first write action (set the sensor in active mode). However, if I disconnect the wires between the nRF51DK and the sensor the handler is immediately called with the \"NRF_DRV_TWI_ERROR\" event (NRF_TWI_ERROR_ADDRESS_NACK).\r\n\r\nI guess I must be doing something wrong but I can't figure out what. Could you please help me?\r\nAttached is the main.c and the MMA8452Q.h (containing the registers defines).\r\n\r\nThanks a lot in advance for your help.\r\n[main.c](/attachment/94b8b9eddc82a00459c36aa6e55b746f)\r\n[MMA8452Q.h](/attachment/2d72775641dad1cfd83be8bc253ca896)",
    "tag": "twi"
  },
  {
    "text": "pwm can not work with softdevice, when i use s110(v7.1) , sdk 6.1 Hi  Nordics,\r\n\r\nI copy pwm sample code into my proximity project, to drive a buzzer .\r\n\r\nI init pwm before softdevice. but, once \"SOFTDEVICE_HANDLER_INIT\" is excuted, the buzzer pin no longer toggle.\r\n\r\nMy question is , softdevice use TIMER0, my pwm use TIMER2, it seems that they are independent two modules.  why pwm not working ?\r\n\r\nMany thanks !\r\n\r\nBob\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Data from callback initialiser to callback? I have a bluetooth service which I want to have to initialise a TWI transaction (using app_twi). I want to get the data back from the TWI transaction, but I can't figure quite the best way to do that. I have the ble service and TWI working separately, it's just bringing them together neatly that is awkward it seems.\r\n\r\nI was previously trying to figure out out to get data back from a callback function, but I thought it might be easier to instead move the TWi transaction instantiation to the service file itself, that way the callback can occur in the same file as the data is required.\r\n\r\nWhere I am struggling now is in having the callback function send the data to the characteristic update function. The update function as always been located in service.c, but was previously called from main.c by a timeout interrupt where the data also originated. This was fine since the data structure (`ble_os_t m_our_service;\\) for the service is instantiated in main.c and it could be passed through to update function.\r\n\r\nNow however, the updated data is coming from within the service.c.\r\n\r\nThe `rh_read()` function is called in the timer timout interrupt as before, but this generates a callback when the TWI transfer is complete. But since it's a callback, it doens't have access to the `m_our_service` data structure which is required by the update characteristic function, `our_humidity_characteristic_update(&m_our_service, &rh_conv);` \r\n\r\nI can't pass it as `p_user_data` in the transaction data since it's 'not a compile time constant'.\r\n\r\nHow can I safely pass the required data structure through when there is this disconnection between transfer initiator and callback function?\r\n\r\n\r\n    static void rh_read_callback(ret_code_t result, void * p_data)\r\n    {\r\n    \tnrf_gpio_pin_toggle(LED);\r\n    \r\n    \t\r\n    \tif(result != NRF_SUCCESS)\r\n    \t{\r\n    \t\tprintf(\"Transfer failure - twi_read_callback - Error: %d\\r\\n\", (int)result); \r\n    \t}else{\r\n    \t\t\r\n    \t\tuint16_t rh_raw = (m_sht21_buffer[0]<<8) | (m_sht21_buffer[1]&0xFC) ; // 8 bit\t\r\n    \t\tuint16_t rh_conv   = -6 + ((125 * rh_raw)>>16); \t// RH= -6 + 125 * SRH/2^16 // 34us as floats, 2us as ints\r\n    \t\t\r\n    \t\tprintf(\"\\033[2J\\033[1;1H\");\r\n    \t\tprintf(\"RH real: %d%%\\n\\r\\n\", rh_conv);\r\n    \t\t\r\n    \t\tour_humidity_characteristic_update(&m_our_service, &rh_conv);     //////////////// PROBLEM\r\n    \t\t\r\n    \t}\r\n    }\r\n    \r\n    \r\n    void rh_read(void)\r\n    {\r\n    \t\r\n    \t\r\n    \tstatic app_twi_transfer_t transfers[] = \r\n    \t{\r\n    \t\tSHT21_RH_READ(&m_sht21_buffer[0])\r\n    \t};\r\n    \tstatic app_twi_transaction_t const transaction =\r\n    \t{\r\n    \t.callback            = rh_read_callback,\r\n    \t.p_user_data         = NULL,\r\n    \t.p_transfers         = transfers,\r\n    \t.number_of_transfers = sizeof(transfers) / sizeof(transfers[0])\r\n    \t};\r\n    \t\r\n    \tAPP_ERROR_CHECK(app_twi_schedule(&m_app_twi, &transaction));\r\n    }\r\n\r\n\r\nLater on I will have a few services accessing the TWI at potentially conflicting intervals. Will use of the app_twi_schedule() like I have here prevent any issues with that?",
    "tag": "twi"
  },
  {
    "text": "the keyboard(use GPIOE interrupt) has no response Hi,\r\n\r\n   I have a strange problem\uff0c\r\n  I use NUS service connect with phone , send or receive data\uff0cafter some process\uff0cmay happen\r\n  the keyboard(use GPIOE interrupt) has no response, but the system can run normal\r\n\uff08include timer interrupt\uff0c WDT\uff09\uff0c sometimes the ble also can't work\uff0csometimes can work normal.\r\n    it's very trouble me\uff0c why it is happend\uff1f \r\n    maybe the system stack\uff1f\r\n",
    "tag": "interrupt"
  },
  {
    "text": "UART INTERRUPT Hello:\r\nIm using SDK 10 with softdevice V130.\r\nIm opening UART:\r\n\r\n    uint32_t err_code; \r\n\r\n    const app_uart_comm_params_t comm_params =\r\n       {\r\n           RX_PIN_NUMBER,\r\n           TX_PIN_NUMBER,\r\n           RTS_PIN_NUMBER,\r\n           CTS_PIN_NUMBER,\r\n           APP_UART_FLOW_CONTROL_DISABLED,\r\n           false,\r\n           UART_BAUDRATE_BAUDRATE_Baud38400\r\n       };\r\n\r\n    APP_UART_FIFO_INIT(&comm_params,\r\n                          UART_RX_BUF_SIZE,\r\n                          UART_TX_BUF_SIZE,\r\n                          NULL,\r\n                          APP_IRQ_PRIORITY_LOW,\r\n                          err_code);\r\n\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nTo communicate with another microcontroller. NRF has the control to switch on and off the second microcontroller, and I have the following problem:\r\nIf the slave microcontroller is switched off, the RX pin of the NRF has low state and NRF go to loop while (1).\r\nI have solved it with the following instruction after the uart init:\r\nnrf_gpio_cfg_input(RX_PIN_NUMBER, NRF_GPIO_PIN_PULLUP);\r\nBut I guess that it is not the best way to solve it.\r\nshould I disable uart interrupt? (I don't need uart interrupt on my program)\r\nhow must I do it?\r\n\r\nI can't put an external pull up.\r\n\r\nThank you. ",
    "tag": "interrupt"
  },
  {
    "text": "Porting example about twi and HID keyboard Hi, all.\r\n\r\nI want data read from gyro sensor through i2c, and then send it through bluetooth equipment.(PC or iPhone and so on)\r\nMy development environment is like below.\r\n\r\n - chip : nRf51822\r\n - example version : nRF_Example 10.0.0\r\n - pack version : check the attached file([pack_list.PNG](/attachment/493e21ddda79408ff11dd7f111578c7f))\r\n - Applied \"RTT source\" for debugging. have no uart port on the board.\r\n   : https://devzone.nordicsemi.com/tutorials/6/\r\n\r\nAt first, i did test like below.\r\n\r\n - [ble_app_hids_keyboard] : operation check completed.\r\n - [twi_sensor] : operation check completed\r\n - [twi_master_using_app_twi] operation check completed\r\n - [ble_app_hids_keyboard + twi_sensor] : operation check completed\r\n - [ble_app_hids_keyboard + twi_master_using_app_twi] : Error occured\r\n   => I want this feature.\r\n\r\nSource build is ok. But when excute the program, it does not working.\r\nI guess the problem is for \"rtc_config()\" function, but it is not sure.\r\n\r\nmain function is consist of like below:\r\n![image description](/attachment/9092370f9695a37626baa31f835bdded)\r\n\r\nPlseas kindly comment for resolving this issue. ",
    "tag": "twi"
  },
  {
    "text": "adc wrong values Hi\r\nI have nrf51822 CEAA which is powered with 1.9 volt on vdd (low power chip). I'm using ADC to measure battery level but the conversion gave me 5.4 volt wich is wrong for the battery\r\n\r\nhere my adc configuration\r\n\r\n    NRF_ADC->INTENSET = (ADC_INTENSET_END_Disabled << ADC_INTENSET_END_Pos);\t\t/*!< Interrupt disabled. */                                                                                // config ADC\r\n    \tswitch (channel) {\r\n    \tcase CH_BATT:                                                                                                                          /* Battery voltage */\r\n    \t\tNRF_ADC->CONFIG = (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos)   /* Bits 17..16 : ADC external reference pin selection (no ref). */\r\n    \t\t\t| (AIN_BAT << ADC_CONFIG_PSEL_Pos)                                          /*!< Use analog input \"AIN_BAT\" as analog input. */\r\n    \t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)                      /*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n    \t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */\r\n    \t\t\t| (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos);                         /*!< 10bit ADC resolution. */ \r\n\r\nI joined [here](/attachment/a75fc8b23b9df0fac0905dad8e97bf71) the schematic. the input is IMG_BAT P0.01\r\n\r\nthe second answer of this [question](https://devzone.nordicsemi.com/question/102/what-voltage-range-can-be-measured-with-the-adc/)\r\n\r\n> VDD 1.8, prescaling 1/3: AIN max 2.1V\r\n> (rule 2 limitation). is that mean that\r\n> the input should not exceed 2.1 volt\r\n> (battery can go to 4.2 volt)\r\n\r\nshould I put resistors to reduce battery voltage, so that the max input be 2.1 (at 4.2 battery voltage, ADC input is 2.1)???",
    "tag": "adc"
  },
  {
    "text": "How to Program NRF51422 w/S130 to read input pin into ADC I'm trying to replicate an Arduino Uno application where we connect a M3Q alcohol sensor into an analog pin and feed the data into the ADC. The specific board I have is made by [Taiyo Yuden](http://www.yuden.co.jp/wireless_module/document/EVBManual/TY_BLE_JN_EVBManual_V1.00_20150914.pdf). I've gone through various code samples in Nordic Semiconductor's Github page ([including this one]( https://github.com/NordicSemiconductor/nrf51-ADC-examples/tree/master/adc_example_with_softdevice_and_UART/adc_example_with_softdevice_and_UART)) and I'm still unsure on how to setup the board to read the analog signal.  If I understood correctly the code sample linked above they are trying to read data from BLE and send it to the ADC.  In my application I want to read analog data from the sensor and then transmit it over bluetooth with the BLE module.  Any help/tips on how to setup the ADC and read events after conversion will be greatly appreciated.",
    "tag": "adc"
  },
  {
    "text": "app_twi_schedule with Soft Device returning error I'm hoping this is just something silly that I've overlooked, but I'm running into an issue: Whenever I try to prompt the scheduling of a TWI transaction an error occurs\r\n\r\nWhat I'm trying to do is initialise the transaction when a certain value is sent to the characteristic. What I'm seeing in the debugger though is an NRF_ERROR_BUSY being generated when doing the `app_twi_schedule` in the function below (called when the write is made), located within my service file:\r\n\r\n    void rh_read(void)\r\n    {\r\n    \t//printf(\"rh read...  \");\r\n    \t\r\n    \tstatic app_twi_transfer_t transfers[] = \r\n    \t{\r\n    \t\tSHT21_RH_READ(&m_sht21_buffer[0])\r\n    \t};\r\n    \tstatic app_twi_transaction_t const transaction =\r\n    \t{\r\n    \t.callback            = rh_read_callback,\r\n    \t.p_user_data         = NULL,\r\n    \t.p_transfers         = transfers,\r\n    \t.number_of_transfers = sizeof(transfers) / sizeof(transfers[0])\r\n    \t};\r\n    \t\r\n    \tAPP_ERROR_CHECK(app_twi_schedule(&m_app_twi, &transaction));\r\n\r\n}\r\n\r\nThe [documentation](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v11.0.0%2Fgroup__nrf__drv__twi.html) says that this error is thrown when the queue is full, but no other twi transactions would have been scheduled at this point. When the slave device is set up it's set up with `app_twi_perform`, and I see them complete on with my scope.\r\n\r\nHere's my TWI setup function:\r\n\r\n    static void twi_init(void)\r\n    {\r\n    \tret_code_t err_code;\r\n    \t\r\n    \tnrf_drv_twi_config_t const config = {\r\n    \t\t.scl\t\t\t\t\t\t= I2C_SCL,\r\n    \t\t.sda\t\t\t\t\t\t= I2C_SDA,\r\n    \t\t.frequency\t\t\t\t\t= NRF_TWI_FREQ_100K,\r\n    \t\t.interrupt_priority\t\t\t= APP_IRQ_PRIORITY_HIGH\r\n    \t};\r\n    \t\r\n    \tAPP_TWI_INIT(&m_app_twi, &config, MAX_PENDING_TRANSACTIONS, err_code);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    }\r\n\r\nAny idea what's happening here?\r\n",
    "tag": "twi"
  },
  {
    "text": "nRF52 TWI easyDMA feature Hi,\r\n\r\nI want to know that if the TWI easyDMA in nRF52 can help in achieving this task:\r\n\r\n- we want to read from TWI each 10msec based on a timer interrupt and write the values in an array, e.g., A\r\n\r\n- meanwhile we want to transfer an array, e.g., B. Assume we can choose between non-connectable advertising or being in a connection.\r\n\r\nIs this possible? Normally we should wait for the reading to finish, and then transmit in the 10msec window. Can DMA help in eliminating this sequence?\r\n\r\nThanks!",
    "tag": "twi"
  },
  {
    "text": "App_twi_schedule() returning error with S110 I'm hoping this is just something silly that I've overlooked, but I'm running into an issue: Whenever I try to prompt the scheduling of a TWI transaction an error occurs\r\n\r\nWhat I'm trying to do is initialise the transaction when a certain value is sent to the characteristic. What I'm seeing in the debugger though is an NRF_ERROR_BUSY being generated when doing the `app_twi_schedule` in the function below (called when the write is made), located within my service file:\r\n\r\n    void rh_read(void)\r\n    {\r\n    \t//printf(\"rh read...  \");\r\n    \t\r\n    \tstatic app_twi_transfer_t transfers[] = \r\n    \t{\r\n    \t\tSHT21_RH_READ(&m_sht21_buffer[0])\r\n    \t};\r\n    \tstatic app_twi_transaction_t const transaction =\r\n    \t{\r\n    \t.callback            = rh_read_callback,\r\n    \t.p_user_data         = NULL,\r\n    \t.p_transfers         = transfers,\r\n    \t.number_of_transfers = sizeof(transfers) / sizeof(transfers[0])\r\n    \t};\r\n    \t\r\n    \tAPP_ERROR_CHECK(app_twi_schedule(&m_app_twi, &transaction));\r\n\r\n}\r\n\r\nThe [documentation](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v11.0.0%2Fgroup__nrf__drv__twi.html) says that this error is thrown when the queue is full, but no other twi transactions would have been scheduled at this point. When the slave device is set up it's set up with `app_twi_perform`, and I see them complete on with my scope.\r\n\r\nHere's my TWI setup function:\r\n\r\n    static void twi_init(void)\r\n    {\r\n    \tret_code_t err_code;\r\n    \t\r\n    \tnrf_drv_twi_config_t const config = {\r\n    \t\t.scl\t\t\t\t\t\t= I2C_SCL,\r\n    \t\t.sda\t\t\t\t\t\t= I2C_SDA,\r\n    \t\t.frequency\t\t\t\t\t= NRF_TWI_FREQ_100K,\r\n    \t\t.interrupt_priority\t\t\t= APP_IRQ_PRIORITY_HIGH\r\n    \t};\r\n    \t\r\n    \tAPP_TWI_INIT(&m_app_twi, &config, MAX_PENDING_TRANSACTIONS, err_code);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    }\r\n\r\nAny idea what's happening here?",
    "tag": "twi"
  },
  {
    "text": "[mbed] What exactly does the return value of AnalogIn::read_u16() means? According to [this post](https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/analogin_api.c), and [this GitHub source file](https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/analogin_api.c), in the nRF51 chip's mbed implementation:\r\n\r\n * The ADC reference voltage is 1/3 power supply\r\n * read_u16() seems to return `NRF_ADC->RESULT`\r\n * `NRF_ADC->RESULT` maximum possible value would be 0x3FF, when ADC input equals to ADC reference voltage.\r\n\r\nFrom an experiment I just ran, I observed the following\r\n\r\n * At ADC input of ~897mV, `read_u16()` returns ~0x011a, or 282 decimal.\r\n * At ADC input of ~520mV, `read_u16()` returns ~0x00b9, or 185 decimal.\r\n * Leaving the ADC input pin floating, `read_u16()` returns ~0x00af, or 175 decimal.\r\n\r\nUsing linear approximation with the first two data points, at `read_u16()` value of 0x03FF, the ADC input should be >4V. \r\n\r\nIf using only one of those data points with the assumption that at 0V input, `read_u16()` returns 0, then 0x03FF still means a voltage >3V. \r\n\r\nThese numbers certainly cannot be 1/3 power supply! What could be going on here? Am I misunderstanding something?\r\n\r\n----------\r\n\r\nJust in case this fact is the reason to the problem: To conduct my experiment, I use a (1M - 220k) voltage divider to supply 1/6 of VDD or 5V to the analog input. \r\n\r\n----------\r\n\r\nOn another note, according to [mbed's `Analog In` reference](https://developer.mbed.org/users/mbed_official/code/mbed/docs/87f2f5183dfb/classmbed_1_1AnalogIn.html#a475e3e9fa76c6ea79ad235829926d0a3) and the [AnalogIn.h](https://developer.mbed.org/users/mbed_official/code/mbed/docs/87f2f5183dfb/AnalogIn_8h_source.html) header file, `read_u16()` returns \"input voltage, represented as an unsigned short in the range [0x0, 0xFFFF]\". This description sucks. But at the same time it doesn't seem to be what nRF51's implementation of the function is returning. Is there any comment on this?",
    "tag": "adc"
  },
  {
    "text": "nrf51822 radio interrupt ??? I have two device , one is Tx-Device the other is Rx-Device.\r\n\r\nTx-Device : Auto continued Send 4 bytes data to Rx-Device by Radio.\r\n\r\nRx-Device : Using Radio Interrupt receive data from Tx-Device Radio,if receive data then Led is action , And main loop continued print string to Uart.\r\n\r\n**But Rx-Device not still print string to Uart. only print one time.**\r\n\r\nHave somebody can tech me why ??How to sloved this question ?\r\n\r\n**[Tx-Device Source Code]**\r\n\r\n    void init(void)\r\n    {   \r\n        NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n        NRF_CLOCK->TASKS_HFCLKSTART    = 1\r\n        while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0)\r\n        {\r\n        }\r\n    \r\n        radio_configure();\r\n        NRF_RADIO->PACKETPTR = (uint32_t)packet;\r\n        nrf_gpio_range_cfg_input(BUTTON_START, BUTTON_STOP, BUTTON_PULL);\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n        init();  \r\n        while (true)\r\n        {\r\n            if(nrf_gpio_pin_read(BUTTON_START)==0x00)\r\n            {\r\n                    packet[0] = 0x00;\r\n                    packet[1] = 0x01;\r\n                    packet[2] = 0x02;\r\n                    packet[3] = 0x03;\r\n                    NRF_RADIO->EVENTS_READY = 0U;\r\n                    NRF_RADIO->TASKS_TXEN   = 1;\r\n                    while (NRF_RADIO->EVENTS_READY == 0U)\r\n                    {\r\n                    }\r\n                    NRF_RADIO->TASKS_START = 1U;\r\n                    NRF_RADIO->EVENTS_END  = 0U;  \r\n                    while (NRF_RADIO->EVENTS_END == 0U)\r\n                    {\r\n                    }\r\n                    NRF_RADIO->EVENTS_DISABLED = 0U;\r\n                    NRF_RADIO->TASKS_DISABLE = 1U;\r\n                    while (NRF_RADIO->EVENTS_DISABLED == 0U)\r\n                    {\r\n                    }\r\n                    nrf_delay_ms(10);\r\n            }\r\n        }\r\n    }\r\n\r\n**[Rx-Device Source Code]**\r\n\r\n    void Radio_init(void)\r\n    {    \r\n        NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n        NRF_CLOCK->TASKS_HFCLKSTART = 1;\r\n        while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0)\r\n        {\r\n        }\r\n    \r\n        radio_configure();\r\n        NRF_RADIO->PACKETPTR = (uint32_t)packet;                     \r\n        NRF_RADIO->INTENSET = RADIO_INTENSET_READY_Enabled << RADIO_INTENSET_READY_Pos | \r\n        RADIO_INTENSET_ADDRESS_Enabled << RADIO_INTENSET_ADDRESS_Pos;\r\n        NVIC_SetPriority(RADIO_IRQn, 1);\r\n        NVIC_ClearPendingIRQ(RADIO_IRQn);\r\n        NVIC_EnableIRQ(RADIO_IRQn);                     \r\n    }\r\n    \r\n    void RADIO_IRQHandler(void)\r\n    {\r\n            NRF_RADIO->EVENTS_END = 0U;\r\n            NRF_RADIO->TASKS_START = 1U;\r\n    \r\n            while(NRF_RADIO->EVENTS_END == 0U)\r\n            {\r\n            }\r\n            if (NRF_RADIO->CRCSTATUS == 1U)\r\n            {\r\n                    if (LED_IRQFlag == 0){\r\n                            nrf_gpio_pin_clear(LED_0);\r\n                            LED_IRQFlag ++;\r\n                    }else if (LED_IRQFlag == 1){\r\n                            nrf_gpio_pin_set(LED_0);\r\n                            LED_IRQFlag = 0;\r\n                    }\r\n            }\r\n            NRF_RADIO->EVENTS_DISABLED = 0U;\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n        Radio_init();\r\n        Port_Init();\r\n        NRF_RADIO->EVENTS_READY = 0U;\r\n        NRF_RADIO->TASKS_RXEN = 1U;\r\n        while(1)\r\n        {\r\n            simple_uart_putstring((const uint8_t *)\"Start: \\n\\r\");\r\n        }\r\n    }",
    "tag": "interrupt"
  },
  {
    "text": "How to send gyro sensor data through bluetooth(ble)? Hi, all.\r\n\r\nI want data read from gyro sensor through i2c, and then send it through bluetooth equipment.(PC or iPhone and so on)\r\nBut i don'k know how to send gyro sensor data through bluetooth.\r\n\r\nI tried to send gyro sensor data transmitted through \"on_hids_evt()\" and \"on_hids_evt()\" and \"bsp_event_handler()\" functions. But it did not fit.\r\n\r\nI would like to transmit the gyro sensor data via the BLE **continuously**.\r\nIn other words, I would like to express the mouse cursor through the sensor value.\r\n(Not use button triggering like \"ble_app_hids_mouse\" original example.)\r\n\r\nMy development environment is like below.\r\n\r\n - chip : nRf51822\r\n - example : ble_app_hids_mouse(s130) in nRF_Example 10.0.0\r\n \r\nPlease kindly comment guide or relevant Q&A issue.\r\n(I can't found relevant this issue in \"Questions\" tab, yet.)",
    "tag": "twi"
  },
  {
    "text": "Not answered question (nRF52 TWI easyDMA feature) Hi,\r\n\r\nCan anybody comment on the following question please?\r\n\r\nhttps://devzone.nordicsemi.com/question/69636/nrf52-twi-easydma-feature/\r\n\r\nThanks!",
    "tag": "twi"
  },
  {
    "text": "How do i Create Nested Timer HI,\r\ni want to have a application in which a timer timeout say 5 second. and during this timeout there is another timer say 1 second. whenever the 1sec timer timeouts then it executes some function. and whenever the 5 second timer timeouts then it restarts it again.\r\n\r\nhow do i do this.\r\n\r\ni tried something below is my code:\r\n\r\n\r\n    // Timeout handler for the repeated timer\r\n    static void timer_handler(void * p_context)\r\n    {\r\n    \t\t\r\n        SEGGER_RTT_WriteString (0, \"--> in timeout handler\\n\");\r\n    \t\r\n    \t\tSEGGER_RTT_printf(0, \"Time Out. \\n\"); \r\n    }\r\n    \r\n    static void wait_timer_handler(void * p_context)\r\n    {\r\n    \t\t\r\n      \t\tSEGGER_RTT_printf(0, \"wait Time Out. \\n\"); \r\n    }\r\n    \r\n    \r\n    // Create timers\r\n    static void init_timers()\r\n    {\r\n        uint32_t err_code;\r\n    \t\r\n    \t\t// Initialize the Application timer Library.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n    \t\tSEGGER_RTT_printf(0, \"APP_TIMER_INTI initialised. \\n\");\r\n    \r\n        // Create timers\r\n        err_code = app_timer_create(&m_led_a_timer_id,\r\n                                    APP_TIMER_MODE_REPEATED,\r\n                                    timer_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    static void init_waiting_timers()\r\n    {\r\n        uint32_t err_code;\r\n    \t\r\n    \t\t// Initialize the Application timer Library.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n    \t\tSEGGER_RTT_printf(0, \"APP_TIMER_INTI initialised. \\n\");\r\n    \r\n        // Create timers\r\n        err_code = app_timer_create(&wait_timer_id,\r\n                                    APP_TIMER_MODE_REPEATED,\r\n                                    wait_timer_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    static void start_timer()\r\n    {\r\n    \tuint32_t err_code;\r\n      // Start application timers.\r\n      err_code = app_timer_start(m_led_a_timer_id, APP_TIMER_TICKS(2000, APP_TIMER_PRESCALER), NULL);\r\n      APP_ERROR_CHECK(err_code);\r\n    \tSEGGER_RTT_printf(0, \"Timer Started \\n\"); \r\n    \t\r\n    \terr_code = app_timer_start(wait_timer_id, APP_TIMER_TICKS(100, APP_TIMER_PRESCALER), NULL);\r\n      APP_ERROR_CHECK(err_code);\r\n    \tSEGGER_RTT_printf(0, \"Wait Timer Started \\n\"); \r\n    }\r\n\r\n\r\n\r\nmy main function :\r\n\r\n    // Main function.\r\n    int main(void)\r\n    {\r\n    \t\tSEGGER_RTT_printf(0, \"Hello World \\n\"); \r\n    \t\r\n        // Request LF clock.\r\n        lfclk_request();\r\n    \t\tSEGGER_RTT_printf(0, \"LF Clock Requested!! \\n\"); \r\n    \r\n        // Configure GPIO's.\r\n        //gpio_config();\r\n    \t\t//SEGGER_RTT_printf(0, \"GPIO Configured! \\n\"); \r\n    \r\n         \r\n    \r\n        // Create application timer instances.\r\n        init_timers();\r\n    \t\tSEGGER_RTT_printf(0, \"Application Timer Created. \\n\");\r\n    \t\r\n    \t\tstart_timer();\r\n    \t\t\r\n        // Main loop.\r\n        while (true)\r\n        {\r\n    \t\t\t\r\n    \t\t\t\r\n    \t\t\t//SEGGER_RTT_printf(0, \"Blinking.. %d times\\n\",count);\r\n    \t\t\t\r\n    \t\t\t// Wait for interrupt.\r\n            __WFI();\r\n    \t\t\t\r\n            \t\t\t\r\n        }\r\n    \t\t\r\n    }\r\n\r\n ",
    "tag": "timer"
  },
  {
    "text": "Regarding nRF51 Timer Hi.\r\nI'm using PCA10028 and SDK10.0.0, S130 v1.0.0.\r\nAnd \"ble_app_hrs_c\" example is my reference code.\r\n\r\nIt works well before i add code for timer as below.\r\n\r\n\r\n\r\nvoid start_timer(void) \r\n{\t\t \r\n\r\n\tNRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;  // Set the timer in Counter Mode \r\n\tNRF_TIMER2->TASKS_CLEAR = 1;               // clear the task first to be usable for later \r\n\tNRF_TIMER2->PRESCALER = 0;                             //Set prescaler. Higher number gives slower timer. Prescaler = 0 gives 16MHz timer \r\n\tNRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\t\t //Set counter to 16 bit resolution \r\n\tNRF_TIMER2->CC[0] = 32768;\t\t\t\t\t\t\t   //Set value for TIMER2 compare register 0 \r\n\tNRF_TIMER2->CC[1] = 1;                                 //Set value for TIMER2 compare register 1 \r\n\t\t \r\n\t// Enable interrupt on Timer 2, both for CC[0] and CC[1] compare match events \r\n\tNRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos) | (TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos); \r\n\tNVIC_EnableIRQ(TIMER2_IRQn); \r\n\t\t \r\n\tNRF_TIMER2->TASKS_START = 1;               // Start TIMER2 \r\n} \r\n\r\nvoid TIMER2_IRQHandler(void) \r\n{ \r\n\r\n\tnrf_gpio_pin_toggle(GPIO_TOGGLE_PIN_1);\r\n\r\n\r\n} \r\n\r\nint main(void)\r\n{\r\n    bool erase_bonds;\r\n\r\n    // Initialize.\r\n    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, NULL);\r\n    buttons_leds_init(&erase_bonds);\r\n    uart_init();\r\n\r\n#if 1 // timer test\r\n\tnrf_gpio_cfg_output(GPIO_TOGGLE_PIN);\r\n\tstart_timer();\r\n#endif\r\n\t\r\n.......\r\n}\r\n\r\n\r\n\r\nIt does'nt work well after i add \"start_timer()\" function.\r\nI don't understand.\r\nCan you tell me why?\r\nI hope your reply.\r\n",
    "tag": "timer"
  },
  {
    "text": "unable to reset timer hi,\r\ni have a timer which is being called each second. when i give timeout less then 1 second then the code executes properly and goes to event handler. but when the timeout is more than 1 second then code stops and goes to main function.\r\n\r\nhow can i make my code such that each time when the timer timeout is more than 1 second then it restarts itself and goes to handler. \r\n\r\nthanks!!",
    "tag": "timer"
  },
  {
    "text": "restart timer before it expires hi,\r\ni want to restart my timer before it expires.\r\nsuppose my timeout is 2 second and i want to restart it in between 0-2 second based on signal when i receive before expires.\r\n\r\nthanks!!",
    "tag": "timer"
  },
  {
    "text": "Tell if timer is running Is there a way to tell if the timer is running? There's a start task, and a stop task, but I'm not sure how to tell if a timer is currently running. The best thing I can think of is to capture the value, wait a little while, capture the value again, and see if it's changed. This seems both unreliable and time-consuming. Is there a better way?\r\n\r\nThanks!",
    "tag": "timer"
  },
  {
    "text": "How do I control servo simultaneosly in the interrupt_hadler? Hi,\r\n\r\nI'm using SD110, SDK 10.0.0, nRF51822\r\n\r\nIn my own application, I control 4 servo by pwm with Timer1 and Timer2,\r\n\r\nand I have 2 buttons, each button is a flag for moving servo1,2 and servo3,4.\r\n\r\nWhen button1 occur button_interrupt, a flag which I declared refer move_servo1_or_servo2.\r\n\r\n\r\nThis is example code :\r\n\r\n    button_handler()\r\n    {\r\n      switch(pin)\r\n      {\r\n        case button1:\r\n         flag = move_servo1_or_servo2;\r\n         break;\r\n        case button2:\r\n         flag = move_servo3_or_servo4;\r\n         break;\r\n      }\r\n    }\r\n    \r\n    int main()\r\n    {\r\n      while()\r\n      {\r\n        if(flag != null)\r\n        {\r\n          move_servo(flag);\r\n        }\r\n      }\r\n    }\r\n\r\nUntil now, This is not a problem, but I need to control servo within interrupt.\r\n\r\nFor example :\r\n\r\n    button_handler()\r\n    {\r\n      switch(pin)\r\n      {\r\n        case button1:\r\n          move_servo1();\r\n          break;\r\n        case button2:\r\n          move_servo2();\r\n          break;\r\n      }\r\n    }\r\n\r\nLike above,\r\n\r\nThe problem is when I deal with controling servo in interrupt,\r\napplication is stopped every activity, or something unpredictable result.\r\n\r\nHow do I solve it?\r\n\r\nThaks,",
    "tag": "pwm"
  },
  {
    "text": "How do I control servo simultaneosly in the interrupt_hadler? Hi,\r\n\r\nI'm using SD110, SDK 10.0.0, nRF51822\r\n\r\nIn my own application, I control 4 servo by pwm with Timer1 and Timer2,\r\n\r\nand I have 2 buttons, each button is a flag for moving servo1,2 and servo3,4.\r\n\r\nWhen button1 occur button_interrupt, a flag which I declared refer move_servo1_or_servo2.\r\n\r\n\r\nThis is example code :\r\n\r\n    button_handler()\r\n    {\r\n      switch(pin)\r\n      {\r\n        case button1:\r\n         flag = move_servo1_or_servo2;\r\n         break;\r\n        case button2:\r\n         flag = move_servo3_or_servo4;\r\n         break;\r\n      }\r\n    }\r\n    \r\n    int main()\r\n    {\r\n      while()\r\n      {\r\n        if(flag != null)\r\n        {\r\n          move_servo(flag);\r\n        }\r\n      }\r\n    }\r\n\r\nUntil now, This is not a problem, but I need to control servo within interrupt.\r\n\r\nFor example :\r\n\r\n    button_handler()\r\n    {\r\n      switch(pin)\r\n      {\r\n        case button1:\r\n          move_servo1();\r\n          break;\r\n        case button2:\r\n          move_servo2();\r\n          break;\r\n      }\r\n    }\r\n\r\nLike above,\r\n\r\nThe problem is when I deal with controling servo in interrupt,\r\napplication is stopped every activity, or something unpredictable result.\r\n\r\nHow do I solve it?\r\n\r\nThaks,",
    "tag": "interrupt"
  },
  {
    "text": "Timer scheduler Hello:\r\nI have detected a problem with a timer on my program.\r\nI can solve it, but I would like to understand what is happening exactly.\r\n\r\nMy program starts to scan BLE signal, and, if it find a known advertising signal, it starts a timer inside the ble_event_handler function.\r\nIf the nrf detects again the signal, it stops the timer, and starts it again (reset the timer to initial value).\r\nIf the nrf doesn't detect a new known advertising signal, the timer expires, and go to interruption.\r\n\r\nI have init the timer:\r\n\r\n     uint32_t err_code;\r\n    // Initialize timer module\r\n    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n\r\n    //Create a general timer\r\n    err_code = app_timer_create(&general_timer_id, APP_TIMER_MODE_SINGLE_SHOT,  general_timer_handler);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nAnd inside the ble_event_handler function I have the following code:\r\n\r\n    static void on_ble_evt(ble_evt_t * p_ble_evt)\r\n    {\r\n    ....\r\n\t\t\t\terr_code = app_timer_stop(general_timer_id);\r\n\t\t\t\tAPP_ERROR_CHECK (err_code);\r\n\r\n\t\t\t\terr_code = app_timer_start(general_timer_id, APP_TIMER_SCAN ,NULL);\r\n\t\t\t\tAPP_ERROR_CHECK (err_code);\r\n    ....\r\n    }\r\nMy problem is that sometimes, it gives me an error of full queue (error 04), and it is because Im acumulating more instructions than APP_TIMER_OP_QUEUE_SIZE (2, on my code).\r\n\r\nIf I make APP_TIMER_OP_QUEUE_SIZE great than 2, it solves the problem, but I have some questions:\r\n- Can I restart the timer, or have I to stop and start it?\r\n\r\nIf the APP_TIMER_OP_QUEUE_SIZE is 1, when I stop timer (first instruction), it goes ok, but when I start timer (second instruction), I get the error 04. \r\nIf I stop the timer, the queue must be 0 when the instruction has been done, why get I the error 04 on the next instruction?\r\nIs it because it is executing inside the ble_event_handler?\r\nIs a problem of priorities?\r\n\r\nI don't know if you have enough information to answer this question, but...\r\nwhy, despite config APP_TIMER_OP_QUEUE_SIZE to 2, I get the error 04 sometimes?\r\n\r\nHow can I know how many tasks are on the queue of the timer?\r\n\r\nThank you.\r\n\r\n",
    "tag": "timer"
  },
  {
    "text": "TIMER + PWM + SAADC + PPI I'd like to control a DC motor using PWM (PWM0, pretty straight forward).\r\nTo determine motor speed I disable the PWM every 5ms (TIMER1, pretty straight forward) and measure Back-EMF via SAADC.\r\nTo synchronise this I'd like to use PPI\r\n\r\nIn order to implement a stable solution I'd like to clarify a few things with you:\r\n\r\n**1. Start SAADC**\r\n\r\n    err = nrf_drv_ppi_channel_assign (ppiCh, (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[1], (uint32_t)&NRF_SAADC->TASKS_START);\r\n    \r\n    NRF_PPI->FORK[ppiCh].TEP = (uint32_t)&NRF_SAADC->TASKS_SAMPLE;\r\n\r\nDo I need the FORK instruction?\r\nWhat is the difference between START and SAMPLE? I find the manual is not very clear on this.\r\n\r\n**2. SAADC multi-channel**\r\nEvery 5ms (i.e. when PWM disabled) I'd like to sample 2 channels. Here is my code\r\n\r\n    nrf_saadc_channel_config_t  adcChannel0 = NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE (AIN0);\r\n    adcChannel0.gain      = NRF_SAADC_GAIN1_4;\r\n    adcChannel0.reference = NRF_SAADC_REFERENCE_VDD4;\r\n    err = nrf_drv_saadc_channel_init (0, &adcChannel0);\r\n    \r\n    nrf_saadc_channel_config_t  adcChannel1 = NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE (AIN1);\r\n    adcChannel1.gain      = NRF_SAADC_GAIN1_4;\r\n    adcChannel1.reference = NRF_SAADC_REFERENCE_VDD4;\r\n    err = nrf_drv_saadc_channel_init (1, &adcChannel1);\r\n\r\nIn case that one channel is configured (AIN0 only) my code works as expected\r\nIn case that two channels are configured (AIN0/1, as per example above) the 5ms time slots are lost. Why? \r\nWe're working with Rev1 samples. Can we use Scan Mode? There are numerous references about it being buggy...\r\n\r\n\r\n**3. SAADC results**\r\n\r\nI believe I understand the concept behind this:\r\n\r\n    NRF_SAADC->RESULT.PTR    = (uint32_t)mAdcResult;\r\n    NRF_SAADC->RESULT.MAXCNT = 1;\r\n\r\nWhen running my code I doubt that values in `mAdcResult` are correct. They are updated but the value doesn't change even though the actual analog voltage does.\r\n\r\n**4. Other stuff**\r\nHere is some more you might need to know:\r\n\r\n    nrf_drv_saadc_init (NULL, onAdcEvent);\r\n    \r\n    static void  onAdcEvent (nrf_drv_saadc_evt_t const *event)\r\n    {\r\n        if (event->type == NRF_DRV_SAADC_EVT_DONE)\r\n        {\r\n            NRF_SAADC->TASKS_STOP = 1;  <-- Do I need this ?\r\n            NRF_SAADC->EVENTS_END = 0;  <-- Do I need this ?\r\n    \r\n            nrf_gpio_pin_toggle (PIN_DEBUG);\r\n        }\r\n    }\r\n\r\nSAADC resolution: set to 10bit\r\nSAADC oversamling: set to disabled\r\n\r\nThanky for your help\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "app_timer_cnt_get() gives 0 after connecting to peripheral hi,\r\nafter connecting to peripheral device. app_timer_cnt_get() function always gives 0. why it is so. i am not able to understand it.\r\ncan anyone help me to get the current timer.\r\n\r\nthanks!!",
    "tag": "timer"
  },
  {
    "text": "TWI issue ? Hello,\r\n\r\nI have a capricious component on my TWI bus, and sometimes my nRF52 do an infinite loop in file nrf_drv_twi.c\r\n\r\nin this loop\r\nwhile (!nrf_twim_event_check(p_twim, evt_to_wait))\r\n{\r\n...\r\n}\r\n\r\nWhy I have no done and no error ? Could it be possible to add a timeout as protection. \r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "One sample, interrupt driven SAADC I only want one sample from the SAADC at a time, and from interrupt process every sample. I tried using the SDK but there is way to much overhead going on if I am to use two buffers of size 1 each. \r\n\r\nI then found the Nordic snippet github repo, which showed me how to do one sample only, but not with interrupt.\r\n\r\n\r\nSo, I do a ADC enable and start, and setup interrupt on END event. The ADC sample task is triggered with a timer (using the SDK since I know that is working) but the interrupt is only fired once. \r\nIn the ISR I reset the END event and do another START, waiting for the sample task. The timer is triggered again after this but apparently the result is not transferred to my buffer and the END event is not set. \r\n\r\nWhat do I need to do on the ADC in my ISR to let it trigger tagain except for letting the timer do another sample task?",
    "tag": "interrupt"
  },
  {
    "text": "TWI recover from timeout I am using the TWI module in master mode, with sdk 10. I purposely create an error situation, in which the TWI gets stuck and keeps returning `NRF_ERROR_BUSY` every time I try to initiate a transfer. How may the device recover from this block? I have tried `uninit`/`init` the TWI module, with no success.",
    "tag": "twi"
  },
  {
    "text": "Add Multiple Timers in sdk 11 (S130) I am developing an code which requires use of multiple Timers.\r\nI am using Sdk 11 here when i try to initialize timer there is no field for **APP_TIMER_MAX_TIMERS** in APP_TIMER_INIT function.\r\nBefore this i was using Sdk 6.1.0 and in that there was provision for choosing number of timers.\r\n\r\nEven i need to use SCHEDULER but there is no field for enabling scheduler instead of that there is SCHEDULER_FUNC argument. \r\nCan anybody help me out with this since i am new to this sdk.\r\n\r\n**For reference i am attaching routine from both SDKs** \r\n\r\nSdk 11 = APP_TIMER_INIT(PRESCALER, OP_QUEUES_SIZE, SCHEDULER_FUNC)  \r\nSdk 6  =  APP_TIMER_INIT(PRESCALER, MAX_TIMERS, OP_QUEUES_SIZE, USE_SCHEDULER)",
    "tag": "timer"
  },
  {
    "text": "TWI initialization Hello guys\r\nI tried to start TWI bus and got a lot of questions. (NRF51 1422 AC)\r\n\r\nI added necessary libraries, could You tell me what more i need to include in my code :\r\n<pre>\r\n#define TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER (0U)\r\n#define TWI_MASTER_CONFIG_DATA_PIN_NUMBER (2U)\r\n//\r\nstatic const nrf_drv_twi_t m_twi = NRF_DRV_TWI_INSTANCE(0);\r\nstatic nrf_drv_twi_config_t nrf_drv_twi_config =\r\n{\t.scl = TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER,\r\n\t.sda = TWI_MASTER_CONFIG_DATA_PIN_NUMBER,\r\n\t.frequency = NRF_TWI_FREQ_100K,\r\n\t.interrupt_priority = 0};\r\n\r\n void nrf_drv_twi_initialize(void){\r\n\t \r\n nrf_drv_twi_init(&m_twi, &nrf_drv_twi_config, 0, NULL);\r\n\tnrf_drv_twi_enable(&m_twi);\r\n\t \r\n }\r\n \r\n void nrf_drv_twi_uninitialize(void){\r\n\t \r\n\tnrf_drv_twi_uninit(&m_twi);\r\n\tnrf_drv_twi_disable(&m_twi);\r\n\t \r\n } \r\n</pre>\r\nand\r\n\r\n    nrf_drv_twi_tx(&m_twi,(0x49<<1),&read_adress,1,true);\r\n\t\r\n    nrf_drv_twi_rx(&m_twi,(0x49<<1),&value1, 1);\r\n\r\nBut is not working for me. Could u answer me too, operation (0x49<<1) with sensor adress is necessary with our example ?",
    "tag": "twi"
  },
  {
    "text": "nRF51 external interrupt with low power Hi. I'm using PCA10028, SDK10.0.0, S130.\r\n\r\nI'm testing External interrupt.\r\n\r\nCurrent concumption was just 50uA around(low speed advertising mode).\r\n\r\nBut It goes 1mA around after i put \"gpio_init()\" as below.\r\nI'm sure i don't use DEBUG mode when i check current consumption.\r\n\r\n\r\n    static void gpio_init(void)\r\n    {\r\n    \r\n        ret_code_t err_code;\r\n    \r\n        err_code = nrf_drv_gpiote_init();\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_out_config_t out_config = GPIOTE_CONFIG_OUT_SIMPLE(false);\r\n    \r\n        err_code = nrf_drv_gpiote_out_init(BSP_LED_3, &out_config);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n        in_config.pull = NRF_GPIO_PIN_PULLUP;\r\n    \r\n        err_code = nrf_drv_gpiote_in_init(BUTTON_3, &in_config, in_pin_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_in_event_enable(BUTTON_3, true);\r\n    }\r\n    \r\n    static void ble_peripheral_operation(bool erase_bonds)\r\n    {\r\n        uint32_t err_code;\r\n        ble_gap_addr_t   addr;\r\n        ble_gap_addr_t * p_addr = &addr;\r\n    \r\n        gap_params_init();\r\n    \tservices_init();\r\n        advertising_init();\r\n    \tconn_params_init();\r\n    \r\n    \terr_code = sd_ble_gap_address_get(p_addr);\r\n    \t\r\n       err_code = ble_advertising_start(BLE_ADV_MODE_SLOW);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n     \r\n    int main(void)\r\n    {\r\n    \r\n        bool erase_bonds;\r\n    \r\n        // Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, NULL);\r\n    \r\n    gpio_init();\t\t// External interrupt test\r\n    \r\n        ble_stack_init();\r\n    \r\n    \tble_peripheral_operation(erase_bonds);\r\n    \r\n    \tfor (;; )\r\n    \t{\r\n    \t\tpower_manage();\r\n    \r\n    \t}\r\n    }\r\n\r\n\r\nI want to get External interrupt while nRF51 is advertising.\r\nI need your help.\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Get battery level when BLE is connected Hi,\r\n\r\nI have to check every 10 minutes the battery level when **BLE is connected**.\r\n\r\nI have found in this forum this source : https://github.com/NordicSemiconductor/nrf51-ADC-examples/blob/master/adc-example-with-softdevice/main.c\r\n\r\nAs the source date is 2014-07-25, can you confirm that it is still the right way to check battery level with nRF51822 softdevice 8 and SDK10 when the chip has a active (potential data transfert) connection with a central?\r\n\r\n    //ADC initialization\r\n    static void adc_init(void)\r\n    {\t\r\n    \t/* Enable interrupt on ADC sample ready event*/\t\t\r\n    \tNRF_ADC->INTENSET = ADC_INTENSET_END_Msk;   \r\n    \tsd_nvic_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_LOW);  \r\n    \tsd_nvic_EnableIRQ(ADC_IRQn);\r\n    \t\r\n    \tNRF_ADC->CONFIG\t= (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos) /* Bits 17..16 : ADC external reference pin selection. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_PSEL_AnalogInput2 << ADC_CONFIG_PSEL_Pos)\t\t\t\t\t/*!< Use analog input 2 as analog input. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)\t\t\t\t\t\t\t/*!< Use internal 1.2V bandgap voltage as reference for conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */\r\n    \t\t\t\t\t\t\t\t\t| (ADC_CONFIG_RES_8bit << ADC_CONFIG_RES_Pos);\t\t\t\t\t\t\t\t\t/*!< 8bit ADC resolution. */ \r\n    \t\r\n    \t/* Enable ADC*/\r\n    \tNRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\r\n    }\r\n\r\n    // ADC timer handler to start ADC sampling\r\n    static void adc_sampling_timeout_handler(void * p_context)\r\n    {\r\n    \tuint32_t p_is_running = 0;\r\n    \t\t\r\n    \tsd_clock_hfclk_request();\r\n    \twhile(! p_is_running) {  \t\t\t\t\t\t\t//wait for the hfclk to be available\r\n    \t\tsd_clock_hfclk_is_running((&p_is_running));\r\n    \t}               \r\n    \tnrf_gpio_pin_toggle(LED_2);\t\t//Toggle LED2 to indicate start of sampling\r\n    \tNRF_ADC->TASKS_START = 1;\t\t\t\t\t\t\t//Start ADC sampling\r\n    }\r\n\r\n    /* Interrupt handler for ADC data ready event */\r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n    \r\n      /* Write ADC result to port 2 */\r\n     \tnrf_gpio_port_write(NRF_GPIO_PORT_SELECT_PORT2, NRF_ADC->RESULT); \r\n    \tnrf_gpio_pin_toggle(LED_3);\r\n    \t\r\n    \t//Use the STOP task to save current. Workaround for PAN_028 rev1.5 anomaly 1.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n    \t\r\n    \t//Release the external crystal\r\n    \tsd_clock_hfclk_release();\r\n    }\r\n\r\nThanks",
    "tag": "adc"
  },
  {
    "text": "pcb design Hi Guys,\r\n\r\nWe have schematic of future NRF 51822 project, who can help us with PCB design? Or who can suggest me where i can do it? \r\n\r\n[PCB.DXF](/attachment/9dd72c911a044b69ec69788bc24f3536)\r\n\r\n[schematic.pdf](/attachment/e3886348b27099f9bd16f72037a1a639)\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Need help convert string(char) to hex for ADC Hello!\r\n\r\nI'm trying to use the nRF51422 internal ADC to send the value over BLE then monitoring the value received on the nRF Master control panel on Android phone but I see that the received value is \"(0x) 3D,\"=\"  for ADC value, which the second string value \"=\" is equivalent to 0x3D as shown on [asciitable.com](http://asciitable.com). I want to let it shows as (0x) 3D3D\r\n\r\nBelow is my code for  ADC_IRQHandler :\r\n\r\n\r\n     void ADC_IRQHandler(void)\r\n    {\r\n    \twhile(!NRF_ADC->EVENTS_END&&NRF_ADC->BUSY){};\r\n    \t\r\n    \t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n    \t\r\n    //  adc_result = nrf_adc_result_get();\r\n    \t\t\r\n    \t\r\n    \t\tuint8_t adc_result[2];\r\n    \t\tadc_result[0] = NRF_ADC->RESULT;\r\n    \t\tadc_result[1] = NRF_ADC->RESULT >> 8;\r\n    \t\t\r\n    \t\tble_adc(&m_adc, adc_result);\r\n    \t\t\r\n    \t\t\r\n    \t//Use the STOP task to save current.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n    \t\r\n    \t//Release the external crystal\r\n    \t\tsd_clock_hfclk_release();\r\n    }\t\r\n\r\nI use the ble_adc command to send the data over BLE as 8 bit unsign integer which from ADC as uint8_t.\r\n\r\n\r\nAnd this is the ble_adc function code:\r\n\r\n    uint32_t ble_adc(ble_adc_t * p_adc, uint8_t *adc_level)\r\n    {\r\n        uint32_t err_code = NRF_SUCCESS;\r\n        ble_gatts_value_t gatts_value;\r\n    \r\n            // Initialize value struct.\r\n            memset(&gatts_value, 0, sizeof(gatts_value));\r\n    \r\n            gatts_value.len     = sizeof(uint8_t);\r\n            gatts_value.offset  = 0;\r\n            gatts_value.p_value = adc_level;\r\n    \r\n            // Save new battery value.\r\n            p_adc->adc_level_last = *adc_level;\r\n    \r\n            // Update database.\r\n            err_code = sd_ble_gatts_value_set(p_adc->conn_handle,\r\n                                              p_adc->adc_level_handles.value_handle,\r\n                                              &gatts_value);\r\n            if (err_code != NRF_SUCCESS)\r\n            {\r\n                return err_code;\r\n            }\r\n    \r\n            // Send value if connected and notifying.\r\n            if ((p_adc->conn_handle != BLE_CONN_HANDLE_INVALID) && p_adc->is_notification_supported)\r\n            {\r\n                ble_gatts_hvx_params_t hvx_params;\r\n    \r\n                memset(&hvx_params, 0, sizeof(hvx_params));\r\n    \r\n                hvx_params.handle = p_adc->adc_level_handles.value_handle;\r\n                hvx_params.p_data = gatts_value.p_value;\r\n    \t\t\thvx_params.p_len  = &gatts_value.len;\r\n    \t\t\thvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\r\n      \r\n                err_code = sd_ble_gatts_hvx(p_adc->conn_handle, &hvx_params);\r\n            }\r\n            else\r\n            {\r\n                err_code = NRF_ERROR_INVALID_STATE;\r\n            }\r\n        return err_code;\r\n    }\r\n\r\n\r\nHowever, what I received from the nRF Master control panel is \"(0X) 3D,\"=\"  which the \u201csecond\u201d received \"adc_result\" value is \"=\"  in Hex value it should be \"0x3D\". I've tried a lot methods to solve the problem, but not of them is working. This is the screenshot of what I'm getting on the Phone.\r\n\r\n\r\n![How to convert string to HEX?](/attachment/312ce28a6b9c64e296e138b2957ec771)\r\n\r\n\r\nIf anyone know the solution for how to convert this string as the HEX value, Please help me out.\r\n\r\nThank you!\r\n\r\n\r\n\r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Need help for Converting string to Hex on ADC Hello!\r\n\r\nI'm trying to use the nRF51422 internal ADC to send the value over BLE then monitoring the value received on the nRF Master control panel on Android phone but I see that the received value is \"(0x) 3D,\"=\"  for ADC value, which the second string value \"=\" is equivalent to 0x3D as shown on [asciitable.com](http://asciitable.com). I want to let it shows as (0x) 3D3D\r\n\r\nBelow is my code for  ADC_IRQHandler :\r\n\r\n\r\n     void ADC_IRQHandler(void)\r\n    {\r\n    \twhile(!NRF_ADC->EVENTS_END&&NRF_ADC->BUSY){};\r\n    \t\r\n    \t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n    \t\r\n    //  adc_result = nrf_adc_result_get();\r\n    \t\t\r\n    \t\r\n    \t\tuint8_t adc_result[2];\r\n    \t\tadc_result[0] = NRF_ADC->RESULT;\r\n    \t\tadc_result[1] = NRF_ADC->RESULT >> 8;\r\n    \t\t\r\n    \t\tble_adc(&m_adc, adc_result);\r\n    \t\t\r\n    \t\t\r\n    \t//Use the STOP task to save current.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n    \t\r\n    \t//Release the external crystal\r\n    \t\tsd_clock_hfclk_release();\r\n    }\t\r\n\r\nI use the ble_adc command to send the data over BLE as 8 bit unsign integer which from ADC as uint8_t.\r\n\r\n\r\nAnd this is the ble_adc function code:\r\n\r\n    uint32_t ble_adc(ble_adc_t * p_adc, uint8_t *adc_level)\r\n    {\r\n        uint32_t err_code = NRF_SUCCESS;\r\n        ble_gatts_value_t gatts_value;\r\n    \r\n            // Initialize value struct.\r\n            memset(&gatts_value, 0, sizeof(gatts_value));\r\n    \r\n            gatts_value.len     = sizeof(uint8_t);\r\n            gatts_value.offset  = 0;\r\n            gatts_value.p_value = adc_level;\r\n    \r\n            // Save new battery value.\r\n            p_adc->adc_level_last = *adc_level;\r\n    \r\n            // Update database.\r\n            err_code = sd_ble_gatts_value_set(p_adc->conn_handle,\r\n                                              p_adc->adc_level_handles.value_handle,\r\n                                              &gatts_value);\r\n            if (err_code != NRF_SUCCESS)\r\n            {\r\n                return err_code;\r\n            }\r\n    \r\n            // Send value if connected and notifying.\r\n            if ((p_adc->conn_handle != BLE_CONN_HANDLE_INVALID) && p_adc->is_notification_supported)\r\n            {\r\n                ble_gatts_hvx_params_t hvx_params;\r\n    \r\n                memset(&hvx_params, 0, sizeof(hvx_params));\r\n    \r\n                hvx_params.handle = p_adc->adc_level_handles.value_handle;\r\n                hvx_params.p_data = gatts_value.p_value;\r\n    \t\t\thvx_params.p_len  = &gatts_value.len;\r\n    \t\t\thvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\r\n      \r\n                err_code = sd_ble_gatts_hvx(p_adc->conn_handle, &hvx_params);\r\n            }\r\n            else\r\n            {\r\n                err_code = NRF_ERROR_INVALID_STATE;\r\n            }\r\n        return err_code;\r\n    }\r\n\r\n\r\nHowever, what I received from the nRF Master control panel is \"(0X) 3D,\"=\"  which the \u201csecond\u201d received \"adc_result\" value is \"=\"  in Hex value it should be \"0x3D\". I've tried a lot methods to solve the problem, but not of them is working. This is the screenshot of what I'm getting on the Phone.\r\n\r\n\r\n![How to convert string to HEX?](/attachment/93650a2571d0317ab02cacd491a89374)\r\n\r\n\r\nIf anyone know the solution for how to convert this string as the HEX value, Please help me out.\r\n\r\nThank you!\r\n\r\n\r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "TWI nrf_drv_twi_uninit (nRF52, S132) Hello.\r\nI'm trying to stop TWI. (NRF52, S132)\r\n\r\nSDK_11.0.0-2.alpha_bc3f6a0\r\ns132_nrf52_2.0.0-7.alpha_softdevice\r\n\r\nabout 450uA current keep stop (disable) TWI.\r\n(default 2Hz advertising : about 60uA)\r\n\r\nnrf_drv_twi_init (...) -> nrf_drv_twi_tx(...) -> nrf_drv_twi_uninit (..)\r\nThe sequence of operation as the above.\r\n\r\nBut there are still some current consumption (450uA) after nrf_drv_twi_uninit (..).\r\nThe symptoms must be completed after the normal communication.\r\n\r\nOther sequences\r\n=> Without communication(nrf_drv_twi_tx)\r\n    nrf_drv_twi_init (...) -> nrf_drv_twi_uninit (..)\r\n    => keep about 60uA !!! normal!!!\r\n\r\nTWI, TWIM  same.\r\n\r\nnRF52 internal keep TWI????\r\n\r\nPlease tell us how to completely stop twi ...\r\n\r\nPS.\r\nnrf_drv_twi_uninit();\r\nnrf_drv_twi_disable();\r\nsame result.\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "How to Read 16 bit ADC Value on nRF Master app? not 8 bit! Hello!\r\n\r\nI'm trying to read 16 bit ADC Value on nRF Master app instead of only 8 bit, and I know that there is the example code on [github](https://github.com/NordicSemiconductor/nrf51-ADC-examples/blob/master/adc_example_with_softdevice_and_UART/adc_example_with_softdevice_and_UART/main.c) which is only send me the 8 bit \"uint8_t adc_result\" data to nRF mater app\r\n\r\n    /* Interrupt handler for ADC data ready event */\r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \tuint8_t adc_result;\r\n    \t\r\n    \t/* Clear dataready event */\r\n      NRF_ADC->EVENTS_END = 0;\t\r\n    \r\n      /* Write ADC result both to the UART and over BLE */\r\n    \tadc_result = NRF_ADC->RESULT;\r\n    \tapp_uart_put(adc_result);\r\n    \tble_nus_send_string(&m_nus, &adc_result, 1);\r\n    \tnrf_gpio_pin_toggle(LED_3);        //indicate on LED that the ADC interrupt handler is executing\r\n    \t\r\n    \t//Use the STOP task to save current. Workaround for PAN_028 rev1.5 anomaly 1.\r\n      NRF_ADC->TASKS_STOP = 1;\r\n    \t\r\n    \t//Release the external crystal\r\n    \tsd_clock_hfclk_release();\r\n    }\t\r\n\r\n\r\nwhere it sends the ADC value over Bluetooth by the \"ble_nus_send_string()\" command:\r\n\r\n    uint32_t ble_nus_send_string(ble_nus_t * p_nus, uint8_t * string, uint16_t length)\r\n    {\r\n        ble_gatts_hvx_params_t hvx_params;\r\n    \r\n        if (p_nus == NULL)\r\n        {\r\n            return NRF_ERROR_NULL;\r\n        }\r\n        \r\n        if ((p_nus->conn_handle == BLE_CONN_HANDLE_INVALID) || (!p_nus->is_notification_enabled))\r\n        {\r\n            return NRF_ERROR_INVALID_STATE;\r\n        }\r\n        \r\n        if (length > BLE_NUS_MAX_DATA_LEN)\r\n        {\r\n            return NRF_ERROR_INVALID_PARAM;\r\n        }\r\n        \r\n        memset(&hvx_params, 0, sizeof(hvx_params));\r\n    \r\n        hvx_params.handle = p_nus->rx_handles.value_handle;\r\n        hvx_params.p_data = string;\r\n        hvx_params.p_len  = &length;\r\n        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\r\n        \r\n        return sd_ble_gatts_hvx(p_nus->conn_handle, &hvx_params);\r\n    }\r\n\r\n\r\nif I just similarly change the 'uint8_t adc_result' to 'uint16_t adc_result' it will show me endless ERROR. \r\n\r\nDoes anyone have any solutions for reading the ADC value on the nRF Mater Control panel app 16 bits instead of only 8 bits?\r\n\r\nAny help is appreciated! \r\n\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "Is there have any tutorial for how to create GATT service? Hello!\r\n\r\nIs there have any tutorial for how to create GATT service on the MCP(master control panel app) and what coding do we need to add to the project?\r\n\r\n",
    "tag": "adc"
  },
  {
    "text": "nrf_drv_twi_tx twi softdevice s110 problem hi~\r\ni am working with nrf 51822 with custom board and softdevice s110.\r\ni am using is7020-a20 temperature / humidity sensor via twi (i2c)\r\n\r\ni tried 2 versions of twi example in sdk ver.10 using nrf_drv_twi and app_twi.\r\ntwi_init() looks working fine on both.\r\n\r\naddress of pin scl is 15 and sda is 16 and address of sensor is (0x80 >> 1). i checked it several times.\r\n\r\nwhen i execute nrf_drv_twi_tx() or nrf_drv_twi_rx(), device stops and doesn't work neither app_twi_perform(). \r\n\r\ni know that app_twi_xxx functions uses nrf_drv_twi_xxx functions. \r\n\r\ni read some questions about twi communication with softdevice s110.\r\nso i tried to assign ppi channel to twi and it didn't work too.\r\n\r\nplease check my code and tell me what is wrong with my code\r\n\r\ni commented out what i've tried before, so check the commented code too. thanx.\r\n[main.c](/attachment/795c1f52c4255c6a68b7bafa2cc82975)\r\n",
    "tag": "twi"
  },
  {
    "text": "nRF52 DK does not run GPIOTE interrupt handler after some time with SoftDevice 132 present Hi All,\r\n\r\nI'm having a problem with my application which involves regularly sampling I2C slave data and sending it over Bluetooth. The I2C slave generates an active high interrupt when new data is available, which signals my application to read the data as well as write to some registers to clear the interrupt to prepare it for the next sampling interval. This active high interrupt is mapped to a GPIOTE interrupt which looks for the low to high transition and calls the event handler I just described\r\n\r\nThis seems to work well at least initially, but after some time (which varies anywhere from 30 seconds - 10 mins) my NRF52 stops servicing the interrupt. In other words, the slave fires an interrupt, but afterwards the NRF52 does not issue the I2C start condition to begin reading the new data and writing to the required registers to clear the new data interrupt. \r\n\r\nThe part that is puzzling to me, is that the time which elapses before the \"timeout\" happens is not very consistent. At times, the application will run for 10+ minutes with no problems, while at others this condition will occur in under a minute. \r\n\r\nI've attached a trace of my I2C data lines, as well the interrupt on Channel 2 (not SCL as noted in the screen) to better illustrate my problem. \r\n\r\nI'm using the nrf52 DK PC10036, with SD 1.0.0.3 alpha, with Software Packs nrf_drivers version 3.1.0 and nrf_libraries version 4.0.0.2. \r\n\r\nAny thoughts or recommendations would be appreciated! \r\n\r\nThanks \r\n\r\n![image description](/attachment/84b8f7dca8bfc581786b4bf5ff28c581)",
    "tag": "twi"
  },
  {
    "text": "nRF52 DK does not run GPIOTE interrupt handler after some time with SoftDevice 132 present Hi All,\r\n\r\nI'm having a problem with my application which involves regularly sampling I2C slave data and sending it over Bluetooth. The I2C slave generates an active high interrupt when new data is available, which signals my application to read the data as well as write to some registers to clear the interrupt to prepare it for the next sampling interval. This active high interrupt is mapped to a GPIOTE interrupt which looks for the low to high transition and calls the event handler I just described\r\n\r\nThis seems to work well at least initially, but after some time (which varies anywhere from 30 seconds - 10 mins) my NRF52 stops servicing the interrupt. In other words, the slave fires an interrupt, but afterwards the NRF52 does not issue the I2C start condition to begin reading the new data and writing to the required registers to clear the new data interrupt. \r\n\r\nThe part that is puzzling to me, is that the time which elapses before the \"timeout\" happens is not very consistent. At times, the application will run for 10+ minutes with no problems, while at others this condition will occur in under a minute. \r\n\r\nI've attached a trace of my I2C data lines, as well the interrupt on Channel 2 (not SCL as noted in the screen) to better illustrate my problem. \r\n\r\nI'm using the nrf52 DK PC10036, with SD 1.0.0.3 alpha, with Software Packs nrf_drivers version 3.1.0 and nrf_libraries version 4.0.0.2. \r\n\r\nAny thoughts or recommendations would be appreciated! \r\n\r\nThanks \r\n\r\n![image description](/attachment/84b8f7dca8bfc581786b4bf5ff28c581)",
    "tag": "interrupt"
  },
  {
    "text": "Clocks, timers, RTC, why? I am developing software for the nRF52.  As recommended by many recent posts here in the Developer Zone, I have upgraded to SDK 11.  I am working on an application for a battery-powered device which will repeat the following cycle:\r\n\r\n1. Sleep, for one to 10 minutes.\r\n\r\n2. On waking, conduct six well-timed operations, about 0.1 seconds apart.  These operations will include sampling the SAADC and acting as an I2C master to communicate with a peripheral.\r\n\r\n3. Communicate the results of the operations in step 2.  At first I will send this information to the UART, but eventually I want to transmit over BLE.\r\n\r\nObviously, I don't want to use a busy-wait when the CPU will be idle for 10 minutes.  But there seem to be three different ways to implement hardware timers.  If I look at  an nrf_config_drv.h file, I see flags for CLOCK_ENABLED, TIMER0_ENABLED through TIMER4_ENABLED, and finally, RTC0_ENABLED through RTC3_ENABLED.\r\n\r\nThe tutorials (which only cover SDK 10) and example code are not helping me to understand the different types of timers, or how to choose between them.  Can someone please summarize the reasons for the existence of these various approaches to timing?  Thanks.\r\n",
    "tag": "timer"
  },
  {
    "text": "How do I run a long operation without disrupting a BLE link? I am developing a BLE peripheral with SDK9 and SD110. The PPCP are 80-400ms, 5 slave latency and 5s supervision timeout.\r\n\r\nI am currently running some blocking code in response to an alert level update (from IAS). The blocking code is manually driving a piezo element. I am placing that function on the scheduler queue in the hopes it would be pre-empted by the softdevice as needed. Unfortunately I am getting link loss as a result of updating the alert level.\r\n\r\nIs there a way to make this work with my current setup? Or, do I need to use a different method? (At this time it seems like a timer would be an acceptable alternative, but I'm pressed for time and have not worked with 16MHz timers on this device yet)\r\n\r\n---\r\nEDIT\r\n\r\nThanks all -- I ended up using TIMER1 and some clever code. Things now work acceptably. Previously I am fairly certain my code was executing in too high of an interrupt context. Now I don't care what the context is because the code returns nearly immediately.",
    "tag": "timer"
  },
  {
    "text": "timer that pwm opens can not be closed Hi,all~\r\n\r\nI got a question about pwm's timer. Here is my working environment: SDK 10.0, SD8.0, IC VERSION: qfabc0.\r\n\r\nI use timer1 as clock of pwm.    `APP_PWM_INSTANCE(PWM1,1);`  \r\nWhen I run `app_pwm_enable()`,the current goes to 3.6 mA. And then I run `app_pwm_disable()`, but the current still remains 3.6 mA.\r\n\r\nThen I try to figure out where the current comes from, so I comment the code: `nrf_drv_timer_enable(p_instance->p_timer);` in `app_pwm_enable()`, then the current can be colsed normally.\r\n\r\nSo it seems like the timer cannot be closed after pwm open it. But I also have tried timer2 to generate a gpiote task to toggle a port, and its current is only 500uA and can be closed normally, so why not here?  \r\n\r\nThanks a lot!",
    "tag": "pwm"
  },
  {
    "text": "Not enough timers My application uses the Softdevice, app_timer and app_pwm.\r\nSo all timers are in use, but I have to measure two more pwm signals on two input pins.\r\n(Those come from HC-SR04 sonar sensors)\r\n\r\nI have set up interrupt handlers on raising and falling edges but now I need a time source which is precise enough. When I just use the RTC1 counter which is used by app_timer I get wrong results most of the time. I guess app_timer resets the counter sometimes.\r\n\r\nMaybe it would be possible to modify app_timer so I can get a free running timer?(app_timer would have to save the counter value to some variable before reset or something)\r\n\r\nSo all I need is another time source that just counts up and is at least as precise as the RTC.",
    "tag": "timer"
  },
  {
    "text": "Redbear BLE nano / CR2450 / Battery level Hello,\r\n\r\nI'm powering a Readbear BLE nano using a CR2450 coin cell battery.  The firmware application is written using mbed.  How can I measure the battery level of the CR2450 over time using the Nordic mbed API and libraries?\r\n\r\nThanks,\r\nChris",
    "tag": "adc"
  },
  {
    "text": "Reading GPIO Analog Input on NRF52 I am trying to read an analog value on the GPIO port into my application.  Looking through the examples, there aren't any that help solve this problem as the ADC example is only for the NRF51.\r\n\r\nI am trying to read a sensor value connected to the board and I am utilizing the schematic shown here for my initial learning process: https://www.sparkfun.com/tutorials/389\r\n\r\nThe 5V and GND are corrected accordingly and the analog input is connected to P0.03 (A0) on my board.  I modified the \"/examples/peripheral/bsp/\" code to include GPIO functionality.  First I added:\r\n\r\n    #include \"nrf_gpio.h\"\r\n    #include <inttypes.h>\r\n    #define PORT_NUM 3\r\n\r\nThen I added:\r\n\r\n    static void gpio_init(void)\r\n    {\r\n    \t\tnrf_gpio_cfg_input(PORT_NUM, NRF_GPIO_PIN_NOPULL);\r\n    }\r\n\r\nIn the \"bsp_evt_handler\" I added this to the bottom:\r\n\r\n\t\tuint32_t pin_value = 0;\r\n\t\tuint8_t port_value = 0;\r\n\t\tpin_value = nrf_gpio_pin_read(PORT_NUM);\r\n\t\tport_value = nrf_gpio_port_read(PORT_NUM);\r\n\t\tprintf(\"pin value: %zu\\n\\r\", pin_value);\r\n\t\tprintf(\"port value: %zu\\n\\r\", port_value);\r\n\t\tprintf(\"port value: %\" PRIu8 \" \\n\\r\", port_value);\r\n\r\nAnd in the main function above uart_init(); I added:\r\n\r\n    gpio_init();\r\n\r\nA full source code is at this pastebin: http://pastebin.com/zZXR0EU6\r\n\r\nWhenever I am reading the UART, the value is always 0.  No matter if I am pressing the sensor down or not.  What could be the issue here?",
    "tag": "adc"
  },
  {
    "text": "APP_TIMER_MAX_TIMERS I see in multiple examples of NRF51 SDK:\r\n\r\n    #define APP_TIMER_MAX_TIMERS        (2+BSP_APP_TIMERS_NUMBER)          /**< Maximum number of timers used by the application. */\r\n\r\nbut it is never used. Is it still needed or is it a relict of former SDK versions?",
    "tag": "timer"
  },
  {
    "text": "TIMER+PPI+ADC on nrf52 Hi,\r\n\r\nI am looking for some assistance to choose the best way using the nrf52832 processor in a correct way.\r\n\r\nThe main task is to generate a 1KHz PWM Signal with changeable Duty-Ciclye during the runtime. On every cycle (Signal change high/low - low/high), or better after the signal changed, i need to measure with the integrated saadc. I also need control about the Signal to set the PWM pin to low, or to high.\r\n\r\nWhat is the best way to use the nrf52 chip? Should i use the integrated hardware PWM module and can i trigger the saadc on a signal cycle? Or should i use a Timer to generate the PWM Signal, reload the CC registers with different values for Duty-Cycle and trigger saadc measurements on every timeout? \r\n\r\nI am thankful for every help,\r\nbest regards,\r\nNils :)",
    "tag": "timer"
  },
  {
    "text": "TIMER+PPI+ADC on nrf52 Hi,\r\n\r\nI am looking for some assistance to choose the best way using the nrf52832 processor in a correct way.\r\n\r\nThe main task is to generate a 1KHz PWM Signal with changeable Duty-Ciclye during the runtime. On every cycle (Signal change high/low - low/high), or better after the signal changed, i need to measure with the integrated saadc. I also need control about the Signal to set the PWM pin to low, or to high.\r\n\r\nWhat is the best way to use the nrf52 chip? Should i use the integrated hardware PWM module and can i trigger the saadc on a signal cycle? Or should i use a Timer to generate the PWM Signal, reload the CC registers with different values for Duty-Cycle and trigger saadc measurements on every timeout? \r\n\r\nI am thankful for every help,\r\nbest regards,\r\nNils :)",
    "tag": "pwm"
  },
  {
    "text": "App timer resets When Advertising starts Hi,\r\n\r\nI am measuring real time using the app_timer library and when i start the advertising mode using ble_advertising_start(), the timer resets to 0 rather than continuing from the previous counter value. What is the reason for that? Should i store the counter value in memory before advertising starts ? I am using SDK11",
    "tag": "timer"
  },
  {
    "text": "ADC multiple Sampling Hello Everybody,\r\n\r\nI have read these articles on the site : [article_1](https://devzone.nordicsemi.com/question/1771/high-sample-rate-with-adc-and-softdevice/) & \r\n[article_2](https://devzone.nordicsemi.com/blogs/481/using-the-adc-with-the-s110-softdevice/)\r\n\r\nI need to do something like that, read around 8000 sample  with sampling rate equals to 100khz\r\nI mean get the readout from the adc, send it to the mobile to do some statistics but I found that there is a limitation on the sampling rate.\r\n\r\nwould you  mind helping me or if there is something I did is not correct, check the attached code:\r\n\r\n\r\n\t\t\t//ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling\r\n\t\t\t\t// Configure ADC\r\n\t\t\t\tNRF_ADC->CONFIG     = (ADC_CONFIG_RES_8bit                             << ADC_CONFIG_RES_Pos)     |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)  |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(ADC_CONFIG_REFSEL_VBG\t\t\t\t\t\t\t\t\t\t       << ADC_CONFIG_REFSEL_Pos)  |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(ADC_CONFIG_PSEL_AnalogInput4                    << ADC_CONFIG_PSEL_Pos)    |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(ADC_CONFIG_EXTREFSEL_None                       << ADC_CONFIG_EXTREFSEL_Pos);\r\n\t\t\t\tNRF_ADC->EVENTS_END = 0;\r\n\t\t\t\tNRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Enabled;\r\n\r\n\t\t\t\tNRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.\r\n\t\t\t\tNRF_ADC->TASKS_START = 1;\r\n\t\t\t\t\r\n\t\t\t\twhile (!NRF_ADC->EVENTS_END)\r\n\t\t\t\t{\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\r\n\t\t\t\t\r\n\t\t\t\tNRF_ADC->EVENTS_END     = 0;\r\n\t\t\t\tNRF_ADC->TASKS_STOP     = 1;\r\n\t\t\t\t\r\n\t\t\t\treturn NRF_ADC->RESULT;\r\n\t\t}\r\n\r\n\t\t\t#define num_bit\t\t\t\t\t\t8\r\n\t\t\t#define number_samples    10\r\n\t\t\t#define threshold \t\t\t\t500\r\n\t\r\n\t\t\t\t\t\r\n\t\t\tstatic void level_meas_timeout_handler(void * p_context)\r\n\t\t\t{\r\n\t\t\t\t\tUNUSED_PARAMETER(p_context);\r\n\t\t\t\t\tuint32_t err_code ;\r\n\r\n\t\t\t\t\tfor (j = 0; j < num_bit ; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (k=0; k < number_samples ; k++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t//get the adc reading\r\n\t\t\t\t\t\t\t\tsample_I_temp[j][k] = temp_level_get();\r\n\t\t\t\t\t\t\t\tnrf_delay_ms(1);\r\n\t\t\t\t\t\t\t\t//nrf_delay_us(20);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\r\n\t\t\t\tfor (j = 0; j < num_bit ; j++)\r\n\t\t\t\t\t{ \r\n\t\t\t\t\t\tfor (k=0; k < number_samples ; k++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\terr_code = ble_level_update(&m_temp,sample_I_temp[j][k]);\r\n\t\t\t\t\t\t\tif ((err_code != NRF_SUCCESS) &&\r\n\t\t\t\t\t\t\t\t(err_code != NRF_ERROR_INVALID_STATE) &&\r\n\t\t\t\t\t\t\t\t(err_code != BLE_ERROR_NO_TX_BUFFERS) &&\r\n\t\t\t\t\t\t\t\t(err_code != BLE_ERROR_GATTS_SYS_ATTR_MISSING)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tAPP_ERROR_HANDLER(err_code);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tnrf_delay_ms(10);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} \r\n\t\t\t}\r\n\r\n\r\n\r\nble level update function will send the value of the adc as a notification for the mobile.",
    "tag": "adc"
  },
  {
    "text": "Different battery level readings on same voltage I am trying to read CR2032 (button cell) battery level with ADC read. I always supply the same voltage to nRF51 but level readings are different each time (71% - 100%) on 3.0V (which should be 100%). Besides that, I get warning for using `ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling` - `main.c(784): warning:  #188-D: enumerated type mixed with another type` while I've seen in multiple examples that this is the proper way to initialize. Can I ignore the warning? Without this enum I get completely wrong results.\r\n\r\nBack to different readings. So, I initialize ADC:\r\n\r\n    void ADC_init(void)\r\n    {\t\r\n    \tnrf_adc_config_t nrf_adc_config;\r\n    \tnrf_adc_config.reference = NRF_ADC_CONFIG_REF_VBG;\r\n    \tnrf_adc_config.resolution = NRF_ADC_CONFIG_RES_8BIT;\r\n    \tnrf_adc_config.scaling=  NRF_ADC_CONFIG_SCALING_SUPPLY_ONE_THIRD;\r\n    \r\n        // Initialize and configure ADC\r\n        nrf_adc_configure( (nrf_adc_config_t *)&nrf_adc_config);\r\n        nrf_adc_input_select(ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling); // ignore warning\r\n        nrf_adc_int_enable(ADC_INTENSET_END_Enabled << ADC_INTENSET_END_Pos);\r\n        NVIC_SetPriority(ADC_IRQn, NRF_APP_PRIORITY_HIGH);\r\n        NVIC_EnableIRQ(ADC_IRQn);\r\n    }\r\n\r\nand then start the ADC conversion on BLE_GAP_EVT_CONNECTED with `nrf_adc_start()` which triggers ADC_IRQHandler when done:\r\n\r\n    void ADC_IRQHandler(void)\r\n    {\r\n    \tnrf_adc_conversion_event_clean();\r\n    \tint32_t adc_sample = nrf_adc_result_get();\r\n    \t\r\n            // adc_sample => battery level\r\n            // send level using battery service\r\n    \r\n    \tnrf_adc_stop();\r\n    }\r\n\r\nWhat could cause different readings? Is my ADC initialization wrong? ",
    "tag": "adc"
  },
  {
    "text": "Status of I2C pins and GPIOs in System OFF mode What is the status of I2C pins and GPIO pins in the System OFF mode? Do they float once the SOC enters SYSTEM OFF mode? Here the accelerometer we are using consumes high current when its I2C pins are floating. So it is critical to keep it not floating even in the SYSTEM OFF mode. \r\n\r\nWe are using softdevice 110 v8 and nRF1822 soc.",
    "tag": "i2c"
  },
  {
    "text": "How much power does a timer use? I am simulating button presses on a peripheral nRF51 device to determine average battery life. I send \"button state\" to central in a timer every 10s, with which I simulate 8640 button presses per day which is equal to a few months of usage in normal use-case. I use app_timer library.\r\n\r\nHow much power would this additional timer use on average? Could the power consumption be reflected in dramatically shorter battery life? ",
    "tag": "timer"
  },
  {
    "text": "Is any example for access ST LIS3DH in NRF52 Hi all:\r\nI am developing the driver of ST LIS3DH and its mcu is NRF52.\r\nIf I want to read the value of whoami.\r\nI am not sure if I need call the function of\r\n\r\n    nrf_drv_twi_tx\t(\r\n    \tnrf_drv_twi_t const *\tp_instance,\r\n    \tuint8_t \t\t\t\taddress,\r\n    \tuint8_t const *\t\t\tp_data,\r\n    \tuint8_t \t\t\t\tlength,\r\n    \tbool \t\t\t\t\tno_stop \r\n    )\r\n\r\nwhere \r\n`address` is the I2C Address of LIS3DH,\r\n`p_data` is the adree of the register of whoami,\r\n`length` = 1, and\r\n`no_stop` is true.\r\n\r\nAnd then call the function function of\r\n\r\n    nrf_drv_twi_rx\t(\r\n    \tnrf_drv_twi_t const *\tp_instance,\r\n    \tuint8_t \t\t\t\taddress,\r\n    \tuint8_t * \t\t\t\tp_data,\r\n    \tuint8_t \t\t\t\tlength \r\n    )\r\n\r\nwhere\r\n`address` is the I2C Address of LIS3DH,\r\n`p_data` is the buffer for receive data, and\r\n`length` = 1.\r\n\r\nBecause my program is always not return from the function of nrf_drv_twi_rx.\r\nIs any mistake I made.\r\n\r\nBTW, I am using the example code of \"app_twi\" and just change the configure of SDA/SDA pins and I2C Address..\r\n\r\nThanks...\r\n",
    "tag": "twi"
  },
  {
    "text": "App Timer tutorial, nrf_drv_clock_lfclk_request I am debugging a small program for the nRF52, which uses the App Timer and communicates over UART.  I am trying to keep up with bug fixes, and so I'm using SDK 11.0.\r\n\r\nThe UART works fine, my program prints a greeting in the first few lines of main().  But I don't seem to be setting up timer interrupts correctly, since the printing that is supposed to occur at each timer tick (every 5 seconds), in my timer handler function, is not taking place.\r\n\r\nIn order to get my program to compile at all, I had to write the LFCLK request in my timer configuration function as follows:\r\n\r\nnrf_drv_clock_lfclk_request(false);\r\n\r\nI copied that from an example somewhere, I'm not sure exactly where.\r\n\r\nHowever, the App Timer tutorial shows that nrf_drv_clock_lfclk_request takes NO arguments.  The function definition that I'm seeing wants a pointer to a nrf_drv_clock_handler_item_t.\r\n\r\nI have to wonder why this discrepancy exists.  It might be because the tutorial isn't written for SDK 11.0, but I don't know for sure.  I also wonder whether my code in fact fails to start the LFCLK.\r\n\r\nI will post my complete program if it helps.  I thought that I would start with the first discrepancy I found before dumping 100 lines of code to the forums.  Thanks for your help.",
    "tag": "timer"
  },
  {
    "text": "Is there any other way to get GPIO interrupt without GPIOTE \r\nGPIOTE only allow 4 GPIO pin interrupt.\r\nbut I need to use 7 GPIO pin interrupt. is there any other way but GPIOTE?\r\n\r\nThanks in advance.",
    "tag": "interrupt"
  },
  {
    "text": "nRF52 0.6V Reference Accuracy Hi,\r\n\r\nCan someone from Nordic point me to documentation which specifies the accuracy of the 0.6V internal reference used by the ADC?  \r\n\r\nThank you!",
    "tag": "adc"
  },
  {
    "text": "Using TWI with BLE in SDK 10.0.0 Hello, everyone. I used to use TWI with BLE in SDK 6.1.0 to operate ext sensor. Now I want to update my program in SDK 10.0.0. But there are too many differerance between 6.1.0 and 10.0.0. Is there an example in SDK 10.0.0 that I can refer to or is there another thirdpart example?\r\nThanks.",
    "tag": "twi"
  },
  {
    "text": "Sample multiple inputs with fixed rate using ADC hal Hi\r\n\r\nI have been searching the forums, but were not able to find an answer to my question.\r\n\r\nI'm trying to sample 4 analog inputs on the nRF51-DK using the ADC hal. (SDK10)\r\nFrom the example i managed to sample one input. How do i sample from more inputs with a fixed sample rate? I was not able to find any examples that uses the ADC driver.\r\n\r\nThanks in advance",
    "tag": "adc"
  },
  {
    "text": "nRF52832's pin function limit I want to use ADC / PWM / I2S / UART / SPI / I2C / \u200eat a time. \r\nSo, Can I use all GPIO pin  assign any function?\r\nIf I can't use some function at a time,  I want to know the limit.\r\nFor example I2S and SPI.",
    "tag": "i2c"
  },
  {
    "text": "nRF52 SAADC gain error a function of Vcc? Hi \r\n\r\nI'm attempting to read a PT-100 sensor value that is part of a voltage divider using a nRF52.\r\n\r\nBoth the reference resistor and the PT-100 is sampled while the voltage divider isn't connected to Vcc and while it is (using a PMOS transistor).\r\n\r\nThe Off value is subtraced from the ON value (an attempt to null out the offset).\r\nThe difference between the two resulting signals is then used to compute the resistance of the unknown PT-100 (should reduce gain errors).\r\n\r\nBasically this setup works and I'm capable of reading the PT-100, I have however discovered a small but noticeable drift in the readings if I modulate the supply voltage.\r\n\r\nThe error looks like a change in the gain that is slightly different for the two pairs of MUX combinations used in the measurements.\r\n\r\nAs part of debugging the issue I have tried to measure the internal Vcc/2 with respect to Vcc using the following ADC configuration:\r\n\r\n    nrf_saadc_channel_config_t channel0Config_ = {\r\n      .resistor_p = NRF_SAADC_RESISTOR_DISABLED,\r\n      .resistor_n = SAADC_CH_CONFIG_RESP_VDD1_2,\r\n      .gain = NRF_SAADC_GAIN1_4,\r\n      .reference = NRF_SAADC_REFERENCE_VDD4,\r\n      .acq_time = NRF_SAADC_ACQTIME_40US,\r\n      .mode = NRF_SAADC_MODE_DIFFERENTIAL,\r\n      .pin_p = SAADC_CH_PSELP_PSELP_VDD,\r\n      .pin_n = NRF_SAADC_INPUT_DISABLED\r\n    };\r\n\r\nIf I run the nRF52 @ 2V then increase the voltage to 3V I get the following values from the ADC:\r\n![image description](/attachment/c78135b409ecea9742d89dd888e1caf5)\r\n\r\nAs it can be seen the values does drop a number of LSBs.\r\n\r\nI should be noted that I haven't observed any significant change in the offset values.\r\n\r\n**My questions are:**\r\n\r\n**A) Is the ADC gain error a function of the supply voltage?**\r\n\r\n**B) Should I expect that the gain error is the same for different MUX selections or does the MUX selection potentially introduce gain errors as well?**\r\n\r\nMy own guess would be:\r\n\r\nA) Maybe the leak current variations as function of the voltage across the sample and hold capacitor may explain the drop in the values returned by the ADC\r\n\r\nKind Regards Visti Andresen",
    "tag": "adc"
  },
  {
    "text": "Help: why is the output is different than input? Hello!\r\n\r\nI'm trying to get the 16 bit ADC value as 2 of 8 bit array from nRF51 development kit over bluetooth to MCP, but when it displays on the MCP the value is \"swap\" for example is input value is 0X1020 then, in the MCP it shows \"(0x) 20-10\r\n\r\nHere is the code:\r\n\r\n        uint32_t adc_update(ble_adc_t * p_bms, uint16_t adc)\r\n    {\r\n    \tuint32_t err_code = NRF_SUCCESS;\r\n    \tble_gatts_value_t gatts_value;\r\n    \t\r\n    \t// Initialize value struct.\r\n      memset(&gatts_value, 0, sizeof(gatts_value));\r\n    \t\r\n    \tgatts_value.len     = sizeof(uint16_t);\r\n    \tgatts_value.offset  = 0;\r\n    \tgatts_value.p_value = (uint8_t *)&adc;\r\n    \t\r\n    \tif(p_bms->bvm_count== BLE_ADC_MAX_BUFFERED_MEASUREMENTS)\r\n    \t{\r\n    \t\t// The voltage measurement buffer is full, delete the oldest value\r\n            memmove(&p_bms->adc_buffer[0],\r\n                    &p_bms->adc_buffer[1],\r\n                    (BLE_ADC_MAX_BUFFERED_MEASUREMENTS - 1) * sizeof(uint16_t));\r\n            p_bms->bvm_count--;\r\n    \t}\r\n\r\n    \t// Add new value\r\n    \tuint16_t ab = 0x1020;\r\n    \tp_bms->adc_buffer[p_bms->bvm_count++] = ab;\r\n    \t\r\n    \t\t\r\n    \t// Update database.\r\n    \terr_code = sd_ble_gatts_value_set(p_bms->conn_handle,\r\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tp_bms->sample_level_handles.value_handle,\r\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&gatts_value);\r\n        \t    \t\r\n    \t// Send value if connected and notifying.\r\n            if ((p_bms->conn_handle != BLE_CONN_HANDLE_INVALID) && p_bms->is_notification_supported)\r\n            {\r\n    \t\t\t\t\tuint8_t initial_sample_level[MAX_ADC_LEN];\r\n    \t\t\t\t\tuint16_t len;\r\n    \t\t\t\t\tuint16_t hvx_len;\r\n    \t\t\t\t\t\r\n              ble_gatts_hvx_params_t hvx_params;\r\n    \t\t\t\t\tlen = adc_encode(p_bms,initial_sample_level);\r\n    \t\t\t\t\thvx_len = len;\r\n    \r\n                memset(&hvx_params, 0, sizeof(hvx_params));\r\n                hvx_params.handle = p_bms->sample_level_handles.value_handle;\r\n                hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\r\n    \t\t\t\t\t\thvx_params.offset = 0;\r\n    \t\t\t\t\t  hvx_params.p_len  = &hvx_len;\r\n    \t\t\t\t\t\thvx_params.p_data = initial_sample_level;\r\n    \r\n                err_code = sd_ble_gatts_hvx(p_bms->conn_handle, &hvx_params);\r\n    \t\t\t\t\t\tif ((err_code == NRF_SUCCESS) && (hvx_len != len))\r\n    \t\t\t\t\t\t{\r\n    \t\t\t\t\t\t\t\terr_code = NRF_ERROR_DATA_SIZE;\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t}\r\n            else\r\n            {\r\n                err_code = NRF_ERROR_INVALID_STATE;\r\n            }\r\n    \r\n        return err_code;\r\n    }\r\n\r\nPlease look closer to this piece of code:\r\n\r\n    // Add new value\r\n    \tuint16_t ab = 0x1020;\r\n    \tp_bms->adc_buffer[p_bms->bvm_count++] = ab;\r\n\r\nIf the value of ab = 0x1020 the MCP will display (0x) 20 - 10\r\n\r\nHere is the screen shot of what it display on MCP.\r\n\r\n![image description](/attachment/4c1b9c968dcaee569b5627ca886a8b11)\r\n\r\nI've tried to fixed this all day today, but still can't fix it.\r\n\r\nAny help is greatly appreciative! ",
    "tag": "adc"
  },
  {
    "text": "Is nRF51 development kit big endian or little endian? Hello! \r\n\r\nAnyone know the nRF51 development kit transfer and store data value on memory address as big endian or little endian?",
    "tag": "adc"
  },
  {
    "text": "timer can not trigger by right ticks Hi all,\r\n\r\nI create 4 timer in APP, and there seem only one timer (work in single shot mode) can not trigger by right ticks.\r\n\r\nI add some log and find that:\r\n\r\n 1. First I start this timer, timeout_ticks is 229376 (7s), then I get the current time     by app_timer_cnt_get, it show the current time is 4 .\r\n 2. When time out of this timer get the current time is 229382, it seem right.\r\n 3. Then I start this timer against, timeout_ticks is 16384 (0.5s), the current time is 229386.\r\n 4. But something wrong, I wait almost 7s, then it get timeout handler. And I also print the current time, it is 229393, it seems wrong, 229393 -229382 = 11,it is not 16384, but I wait almost 7s.  \r\n 5. Finally I start this timer against, timeout_ticks is 196608(6s),current time is 229398. \r\n 6. But also get wrong current time of 229405 when the time out, but I think I wait about 6s to get this time out which seem right.\r\n\r\nWhat's wrong?  Please help me, thank you very much.\r\n\r\nWhat I use is NRF52, and the SDK is nRF5_SDK_11.0.0, softdevice is s132.",
    "tag": "timer"
  },
  {
    "text": "Send data on an notification event hello everybody,\r\n\r\nI need to send some data on the value attached with the notification:\r\n\r\n    \r\n     /**@brief Function for adding the notify Level characteristic.\r\n       *\r\n       * @param[in]   p_notify        notify Service structure.\r\n       * @param[in]   p_notify_init   Information needed to initialize the service.\r\n       *\r\n       * @return      NRF_SUCCESS on success, otherwise an error code.\r\n       */\r\n\r\n\r\n       static uint32_t notification_char_add(ble_notify_t * p_notify, const ble_notify_init_t *  p_notify_init)\r\n     {\r\n    uint32_t            err_code;\r\n    ble_gatts_char_md_t char_md;\r\n    ble_gatts_attr_md_t cccd_md;\r\n    ble_gatts_attr_t    attr_char_value;\r\n    ble_uuid_t          ble_uuid;\r\n    ble_gatts_attr_md_t attr_md;\r\n    uint8_t             initial_notification;\r\n    uint8_t             encoded_report_ref[BLE_SRV_ENCODED_REPORT_REF_LEN];\r\n    uint8_t             init_len; \r\n\r\n    // Add notify Level characteristic\r\n    if (p_notify->is_notification_supported)\r\n    {\r\n        memset(&cccd_md, 0, sizeof(cccd_md));\r\n\r\n        // According to notify_SPEC_V10, the read operation on cccd should be possible without\r\n        // authentication.\r\n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);\r\n        cccd_md.write_perm = p_notify_init->notification_char_attr_md.cccd_write_perm;\r\n        cccd_md.vloc       = BLE_GATTS_VLOC_STACK;\r\n    }\r\n\r\n    memset(&char_md, 0, sizeof(char_md));\r\n\r\n    char_md.char_props.read   = 1;\r\n    char_md.char_props.notify = (p_notify->is_notification_supported) ? 1 : 0;\r\n    char_md.p_char_user_desc  = NULL;\r\n    char_md.p_char_pf         = NULL;\r\n    char_md.p_user_desc_md    = NULL;\r\n    char_md.p_cccd_md         = (p_notify->is_notification_supported) ? &cccd_md : NULL;\r\n    char_md.p_sccd_md         = NULL;\r\n\r\n    ble_uuid.type = p_notify->uuid_type;\r\n    ble_uuid.uuid = UUID_notify_CHAR;\r\n\t\t\r\n    memset(&attr_md, 0, sizeof(attr_md));\r\n\r\n    attr_md.read_perm  = p_notify_init->notification_char_attr_md.read_perm;\r\n    attr_md.write_perm = p_notify_init->notification_char_attr_md.write_perm;\r\n    attr_md.vloc       = BLE_GATTS_VLOC_STACK;\r\n    attr_md.rd_auth    = 0;\r\n    attr_md.wr_auth    = 0;\r\n    attr_md.vlen       = 0;\r\n\r\n    initial_notification = p_notify_init->initial_notification;\r\n\r\n    memset(&attr_char_value, 0, sizeof(attr_char_value));\r\n\r\n    attr_char_value.p_uuid    = &ble_uuid;\r\n    attr_char_value.p_attr_md = &attr_md;\r\n    attr_char_value.init_len  = sizeof(uint8_t *);\r\n    attr_char_value.init_offs = 0 ;\r\n    attr_char_value.max_len   = 26 ;\r\n    attr_char_value.p_value   = &initial_notification;\r\n\r\n    err_code = sd_ble_gatts_characteristic_add(p_notify->service_handle, &char_md,\r\n                                               &attr_char_value,\r\n                                               &p_notify->notification_handles);\r\n    if (err_code != NRF_SUCCESS)\r\n    {\r\n        return err_code;\r\n    }\r\n\r\n    if (p_notify_init->p_report_ref != NULL)\r\n    {\r\n        // Add Report Reference descriptor\r\n        BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_REPORT_REF_DESCR);\r\n\r\n        memset(&attr_md, 0, sizeof(attr_md));\r\n\r\n        attr_md.read_perm = p_notify_init->notification_report_read_perm;\r\n        BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.write_perm);\r\n\r\n        attr_md.vloc    = BLE_GATTS_VLOC_STACK;\r\n        attr_md.rd_auth = 0;\r\n        attr_md.wr_auth = 0;\r\n        attr_md.vlen    = 0;\r\n        \r\n        init_len = ble_srv_report_ref_encode(encoded_report_ref, p_notify_init->p_report_ref);\r\n        \r\n        memset(&attr_char_value, 0, sizeof(attr_char_value));\r\n\r\n        attr_char_value.p_uuid    = &ble_uuid;\r\n        attr_char_value.p_attr_md = &attr_md;\r\n        attr_char_value.init_len  = init_len;\r\n        attr_char_value.init_offs = 0;\r\n        attr_char_value.max_len   = attr_char_value.init_len;\r\n        attr_char_value.p_value   = encoded_report_ref;\r\n\r\n        err_code = sd_ble_gatts_descriptor_add(p_notify->notification_handles.value_handle,\r\n                                               &attr_char_value,\r\n                                               &p_notify->report_ref_handle);\r\n        if (err_code != NRF_SUCCESS)\r\n        {\r\n            return err_code;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        p_notify->report_ref_handle = BLE_GATT_HANDLE_INVALID;\r\n    }\r\n\r\n    return NRF_SUCCESS;\r\n}\r\n\r\nit works with me, but I have a problem the data size is variable, I need to change the maximum value of attribute : attr_char_value.max_len   = 26 ;\r\n\r\nto be able to send data without the garbage, otherwise I need a way not to send this garbage data  :) :) ",
    "tag": "adc"
  },
  {
    "text": "simple timer question hi, i am going to make a simple timer with SDK 6.0.0, nrf51822 and softdevice.\r\n\r\nfirst, i use ble_app_uart example as a base code, because i need to BLE communication with high frequency.\r\n\r\nhere is my simple code \r\n\r\nint main(void)\r\n{\r\n\r\n    // Initialize\r\n    leds_init();\r\n    timers_init();\r\n    buttons_init();\r\n//    uart_init();\r\n    ble_stack_init();\r\n    gap_params_init();\r\n    services_init();\r\n    advertising_init();\r\n    conn_params_init();\r\n    sec_params_init();\r\n\t\tnrf_gpio_cfg_output(22);\r\n\t\r\n\t//NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n\t\tNRF_CLOCK->TASKS_HFCLKSTART;\r\n\t\r\n\t\t//Wait for external oscillator to start up\r\n\t\r\n\t\tNRF_TIMER2->PRESCALER = 4;\r\n\t\tNRF_TIMER2->TASKS_CLEAR;\r\n\t\tNRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;\r\n\t\tNRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;\r\n\t\tNRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n\t\tNRF_TIMER2->CC[0] = 400;\r\n\r\n\t\tNRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);\r\n\t\tNVIC_EnableIRQ(TIMER2_IRQn);\r\n\t\tNRF_POWER->TASKS_CONSTLAT;\r\n\t\tNRF_TIMER2->TASKS_START;\r\n    \r\n//    simple_uart_putstring(START_STRING);\r\n    \r\n    advertising_start();\r\n    \r\n    // Enter main loop\r\n    for (;;)\r\n    {\r\n\r\n        //power_manage();\r\n    }\r\n}\r\n\r\nvoid TIMER2_IRQHandler(void)\r\n{\r\n\tNRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n\t NRF_TIMER2->TASKS_CLEAR;\r\n\t\tnrf_gpio_pin_toggle(22);\r\n\t\tnrf_gpio_pin_toggle(21);\r\n\t\tnrf_gpio_pin_toggle(20);\r\n}\r\n\r\nthe BLE connection is operated well with BLE toolbox. But the timer2 compare interrupt is never called. \r\n\r\nand i cannot use the RTS timer with app_timer function because i need more 1/32767 Hz\r\n\r\nThere is anything that i missed???",
    "tag": "timer"
  },
  {
    "text": "app_gpiote_user_register doesn't work with nRF52 SDK My code is as follows:\r\n\r\nAPP_GPIOTE_INIT(4);\r\nretcode = app_gpiote_user_register(&gpioID, 0, (1 << INT_PIN_MAXIM), interrupt);\r\n\r\nThe latter function call seems to fail with retcode == NRF_ERROR_NO_MEM. When I look at the documentation, it says:\r\n\r\n\"NRF_ERROR_NO_MEM\u2002\u2002Returned if the application tries to register more users than defined when the GPIOTE module was initialized in app_gpiote_init.\"\r\n\r\nWhat could be wrong with this? Similar code seems to work with nRF51. I am using nRF5_SDK_11.0.0-2.alpha_bc3f6a0. There's also s132 soft device running (alpha version).\r\n\r\nEDIT: I am using freeRTOS and it looks like xCreateTask() has something to do with this. Somehow creating a task allocates gpiote channels and that is why the call fails. I debugged a bit and the code fails here:\r\n\r\n    ret_code_t nrf_drv_gpiote_in_init(nrf_drv_gpiote_pin_t pin,\r\n                                      nrf_drv_gpiote_in_config_t const * p_config,\r\n                                      nrf_drv_gpiote_evt_handler_t evt_handler)\r\n    {\r\n        ASSERT(pin < NUMBER_OF_PINS);\r\n        ret_code_t result = NRF_SUCCESS;\r\n        /* Only one GPIOTE channel can be assigned to one physical pin. */\r\n        if (pin_in_use_by_gpiote(pin))\r\n        {\r\n            result = NRF_ERROR_INVALID_STATE;\r\n        }\r\n        else\r\n        {\r\n            int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);\r\n            if (channel != NO_CHANNELS)\r\n            {\r\n                if (p_config->is_watcher)\r\n                {\r\n                    nrf_gpio_cfg_watcher(pin);\r\n                }\r\n                else\r\n                {\r\n                    nrf_gpio_cfg_input(pin,p_config->pull);\r\n                }\r\n    \r\n                if (p_config->hi_accuracy)\r\n                {\r\n                    nrf_gpiote_event_configure(channel, pin,p_config->sense);\r\n                }\r\n                else\r\n                {\r\n                    m_cb.port_handlers_pins[channel-NUMBER_OF_GPIO_TE] |= (p_config->sense)<< SENSE_FIELD_POS;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                result = NRF_ERROR_NO_MEM; // THIS IS FROM WHERE THE ERROR COMES\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Are All Interrupts diabled during a BLE event? I have implement the systick with the idea to use it for delay functions.\r\nThe systick is running normal if no BLE Events occur, but during a BLE event it seems to be stopped.\r\nAre all interrupts disabled during a BLE event from the softdevice?\r\nWhat is the best method to implement mS delays during a BLE event?",
    "tag": "interrupt"
  },
  {
    "text": "Disabling advertising Hello everyone\r\n\r\nI'm trying to disable advertising but it doesn't work in some cases, I don't really know why. Here is my pretty simple piece of code:\r\n\r\n    /* Disconnect and then disable advertising */ \r\n    if (m_conn_handle != BLE_CONN_HANDLE_INVALID)\r\n    {\r\n        sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);\r\n    }\r\n    uint32_t err_code = sd_ble_gap_adv_stop();\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nThe issue I'm having is that I got the `BLE_ADV_EVT_SLOW` after a few seconds, when the fast advertising interval expires. I guess the timer is not stopped...\r\n\r\nAlso, I have seen sometimes that the timer is not stopped instantly when `app_timer_stop` is called. The handler is called one last time before being stopped.\r\n\r\nI use SDK v11 with S132 v2.0.0 (nRF52)",
    "tag": "timer"
  },
  {
    "text": "asynchronous pulse counting in low power mode Hello,\r\n\r\nI have an NRF51822 (redbealab ble nano) that I would like to use to count pulses in very low power mode.\r\n\r\n* Pulses are asynchronous\r\n* The rate of pulses can vary from a few Hz to ~100 kHz\r\n* I want to sleep, or go in low power mode while counting\r\n* Once in a while, the cpu wakes up and checks the count\r\n\r\nMy initial idea is to use one of the timer in counter mode and lower the clock frequency. My questions:\r\n\r\n* Is it possible to count asynchronous pulses this way ?\r\n* Is the counter tied to the system clock ?\r\n* If yes, what is the maximum separation between to pulses that I can detect ? (or maximum rate)\r\n\r\nI'd be glad for any pointer to the documentation or example pieces of code.",
    "tag": "timer"
  },
  {
    "text": "How to resolve NRF_ERROR_INTERNAL error in TWI communication? Hi,\r\n\r\nI'm using PCA10040 board, There i connected the fuel gauge IC via TWI communication.\r\nThere pca10040 will acts as master and fuel gauge IC will acts as slave.\r\n\r\nWhile Read and write we are getting \"NRF_ERROR_INTERNAL\" error and hangs there itself.\r\nIf i give some delay (like 100ms) for each read and write its working fine.\r\n\r\nThat same fuel gauge setup i connected to some other controller (Master), There also i'm accessing via TWI communication.\r\nThere without delay i can able to read and write the values.\r\n\r\nAfter that i probed both the setups (PFA),\r\n\r\nsetup 1 : PCA10040 (Master) - Fuel Gauge IC (slave)\r\n\r\n[NORDIC.tar.bz2](/attachment/68e5bb8d58935513e572b39c7ce65e84)\r\n\r\nsetup 2 : Other Controller (Master) - Fuel Gauge IC (slave)\r\n\r\n[OTHER_CONTROLLER.tar.bz2](/attachment/25786b1dfc7f8a7e5e1bb36276f23509)\r\n\r\nWhile comparing that,\r\nIn Nordic setup, End of the each byte (after 9 clock cycles) SDA pulse goes high for some time. But in other controller not like that wherever data presents that time only it goes high.\r\n\r\nIs that extra SDA pulse cause any issue ?\r\n\r\nMay i know why that SDA pulse goes high for some time in Nordic controller?\r\n\r\nThanks in advance,\r\n\r\n",
    "tag": "twi"
  },
  {
    "text": "Thoughts on why TWI line will work on DK but not on beacon? Hello,\r\n\r\nI am utilizing an accelerometer sensor and communicating with it using TWI (I2C). I have both a development kit (NRF51-DK) and the Beacon (nRF51822-Beacon).  I can properly use the sensor on the DK and get proper data transfer. However, when I connect the sensor to the Beacon, the data transfer becomes corrupted.  I do realize that my chips are different (51422 on DK and 51822 for beacon), but have made the changes accordingly in my IDE.  Any thoughts would be useful.  As a note I use CrossWorks as my IDE, and use the TWI header and source files given by Nordic SDK.\r\n\r\nAs an example, when I program a read of the sensor, the DK receives the proper data.  However, when I read any register on the sensor using the Beacon, I receive a 0xD4. The sensor address is 0xD6.\r\n\r\nThank you for any input.",
    "tag": "twi"
  },
  {
    "text": "how to start/stop the same timer very fast? My question : when the person  want to use the same timer1 repeatly in 16ms app timer, so i set timer1_state flag for timer1 busy or free. in another period of 16ms app timer, he will first check the state busy or free when he use timer1.\r\n\r\n16ms-------use timer1(3.9ms and close/free it)---------||--16ms ------use timer1(check free)--\r\n\r\nand repeat the case n times. but i found that  some timer1 is busy,not free.\r\n\r\n\r\nmy detail code like the following:\r\n\r\nstart_16ms();\r\n\r\nstart timer1\r\n \r\nNRF_TIMER1->TASKS_START = 1;\r\n\r\ntimer1_status = BUSY;  //set the Busy Flag.\r\n// timer1 last 3.9ms, it will close it itself in timer1 handler.\r\n\r\ntimer1_handler():\r\n//stop timer task.\r\n\r\nNRF_TIMER1->TASKS_CLEAR = 1;\r\n\r\nNRF_TIMER1->TASKS_STOP = 1;\r\n\r\n  //clear the status.\r\n\r\n   timer1_status = FREE;\r\n\r\nin the 16ms handler, i will start the timer1 again..\r\n\r\nif(timer1_status ==BUSY)\r\n\r\n{\r\n\r\n       printf(\"busy\");\r\n   \r\n}\r\n\r\nelse\r\n\r\n{//FREE\r\n        \r\n      NRF_TIMER1->TASKS_START = 1;     //start the timer1 again.\r\n        timer1_status = BUSY;\r\n}\r\n\r\n\r\nand this case happens n times repeatedly. we can stop the 16ms app timer.\r\n\r\nand we can also start 16ms app timer  for another m times.\r\n\r\nwe tested and found that sometime it print busy.\r\n\r\n----------\r\ntypedef enum\r\n{\r\n\r\n    FREE = 0,                 /**< free */\r\n    BUSY = 1,                  /**< busy */\r\n\r\n} timer_status_type;\r\n\r\ntimer_status_type timer1_status = FREE;",
    "tag": "timer"
  },
  {
    "text": "Timer handler mess up application flow I have a working application with TIMER1 setup to fire handler every 10us. I would like to add a 560us periodic event to enable/disable a PWM, so I add a little more code to my timer handler:\r\n\r\n    static uint16_t                         m_10us_cntr2= 0;\r\n    void timer_event_handler(nrf_timer_event_t event_type, void* p_context)\r\n    {\r\n        // TROUBLESOME_CODE  -----------------------------------------\r\n        m_10us_cntr2++;\r\n        if (m_10us_cntr2>= 56)\r\n        {\r\n    //        NOT EVEN DOING ANYTHING HERE YET\r\n            m_10us_cntr2= 0;\r\n        }\r\n        // /TROUBLESOME_CODE  ----------------------------------\r\n        \r\n        m_10us_cntr++;\r\n        if (m_10us_cntr>= 100000)\r\n        {\r\n            m_second_counter++;\r\n            m_10us_cntr= 0;\r\n        }\r\n        //m_second_counter++;\r\n        if (m_second_counter == PERIODIC_TASKS_PERIOD)\r\n        {\r\n            m_periodic_flag = true;\r\n            m_second_counter = 0;\r\n        }\r\n    }\r\n\r\nTo my surprise, just the presence of the if block make the app crash completely during TIMER1 initialization. The debug printf() statement \"end of timer_init\\n\" I had after my TIMER1 initialization function calls could only push out \"end\" or \"end o\" before the app crashes.\r\n\r\nWhat is causing this? Is there a way to fix it?\r\n\r\nUpdate: for reference, here is my timer_init() code:\r\n\r\n    void timer_init()\r\n    {\r\n        DEBUG_PRINT((\"timer_init\\n\"));\r\n        \r\n        uint32_t                err_code = NRF_SUCCESS;\r\n        uint32_t                time_us = 10; //Time (in microseconds) between consecutive compare events.\r\n        uint32_t                time_ticks;    \r\n\r\n        nrf_drv_timer_config_t  timer_config = NRF_DRV_TIMER_DEFAULT_CONFIG(1);\r\n        timer_config.frequency  = NRF_TIMER_FREQ_16MHz;\r\n\r\n\r\n        err_code = nrf_drv_timer_init(&m_timer, &timer_config, timer_event_handler);\r\n        if (err_code != NRF_SUCCESS)\r\n        {\r\n           // The only error possible for this function is NRF_ERROR_INVALID_PARAM\taccording to SDK v10 documentation\r\n           // TODO: handling error\r\n        }\r\n\r\n        time_ticks = nrf_drv_timer_us_to_ticks(&m_timer, time_us);\r\n        DEBUG_PRINT((\"time_ticks = %d\\n\", time_ticks));\r\n\r\n        nrf_drv_timer_extended_compare(\r\n            &m_timer, NRF_TIMER_CC_CHANNEL0, time_ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, true);\r\n\r\n        nrf_drv_timer_enable(&m_timer);\r\n        DEBUG_PRINT((\"end of timer_init()\\n\"));\r\n        \r\n    }\r\n\r\nThe app always failed while printing out the last debug print (\"end of timer_init()\"). \r\n\r\nUpdate Apr 20 2016: \r\nSo I run a few more experiments, and the details bizarre me even more, so please bare with me.\r\n\r\n 1. I first tried to use uVision debug to look at what cause the app flow to hang. When I hit stop, I found the current-line-of-execution pointer sometimes points at `nrf_timer_event_check()`, sometimes at my `timer_event_handler()`, sometimes at `nrf_timer_event_clear()`. It feels like this is a case of interrupt handling taking too long and block the code flow.\r\n\r\n    I also observed that the \"end of timer_init()\\n\" print not only fails midway, but also sometimes have characters print out of order.\r\n 2. I tried to move the `timer_init()` call to the bottom of all of my initialization function calls. This moves the following two functions to be called before `timer_init()`:\r\n\r\n    a- `i2c_slave_drv_init()`: A function I used to read confirmation values and initialization values to an I2C slave peripheral. In case it matters, my I2C read and write implementation uses the following *blocking wait* to wait for TWI Driver events\r\n\r\n            watchdog_counter = 0;\r\n            while(!twi_drv_evt_received && watchdog_counter < 60000)\r\n            {\r\n                nrf_delay(1);\r\n                watchdog_counter++;\r\n            }\r\n\r\n    b- `ble_advertising_start()`\r\n\r\n    The app can now run without major issue after this change. The only minor issue is my 1s flag now takes a lot more than a second to fire. I assume this is due to `timer_event_handler()` processing delay\r\n 3. Now here comes the bizarre part: I tried to reproduce the issue by moving `timer_init()` back where it was. And the issue stop happening. However, that is only as long as I don't add another `if` block to `timer_event_handler`. If I change the `TROUBLESOME_CODE` into the following, I can then reproduce the issue:\r\n\r\n        if (m_10us_cntr2 > 56)\r\n        {\r\n            if (m_pwm_toggle) {\r\n                // TODO\r\n            } else {\r\n                // TODO\r\n            }\r\n            m_pwm_toggle = !m_pwm_toggle;\r\n            m_10us_cntr2 = 0;\r\n        }\r\n 5. At this point, I found out that the app did not actually got stuck entirely. Returning to the console after writing the above, I found that the issue is:\r\n\r\n    a- While running initialization code, it just takes almost half a minute to print out a single characters. You can see in this screen record: [uart_rate_init.avi](/attachment/1fad78a38a5be95ae49f6d6204435010) (Please excuse the low quality. I need to do so due to the long duration of the process)\r\n\r\n    b- While running `main()`'s super loop code, the app could only print 3-5 characters a second. You could see in this screen record: [uart_rate_loop.avi](/attachment/3c269d7ef04400212e791abbbd8b7c21)\r\n\r\nAnd that is the last of my observations. I hope somebody have an idea what is going on. This is really too strange for me to have any idea.",
    "tag": "timer"
  },
  {
    "text": "ADC softdevice sd_nvic_SetPriority Hi\r\n\r\nI'm having issues implementing ADC sampling to my ble project.\r\nI'm using the nRF51-DK with SDK11 and S130. I used the example from github (https://github.com/NordicSemiconductor/nrf51-ADC-examples/tree/master/adc-example-with-softdevice), but i am unable to build the project.\r\n\r\nGetting following errors:\r\n\r\n    error: 'NRF_APP_PRIORITY_LOW' undeclared (first use in this function)\r\n    error: implicit declaration of function 'sd_nvic_EnableIRQ' [-Werror=implicit-function-declaration]\r\n\r\nThis is weired since softdevice_handler.h is included in the project. \r\nAlso i would like to ask if it is a good idea to use the ADC hal driver instead?\r\n\r\nWould appriciate some help.\r\n\r\n[main.c](/attachment/fce0967c48f4c1bad184a249fcf00f50)",
    "tag": "adc"
  },
  {
    "text": "problem with SAADC Scan mode on 4 anolog channels Hello I am currently using the NRF52 DK2 PCA10040 with S132 soft device (nRF52 SDK v0.9.2) . I have setup my code to sample 4 analog pins periodically. I configured double buffering non-blocking mode through the driver and have a callback function sending all 4 results over BLE through the UART BLE service. I am using the nRF UART console android application to view my send data. I have set the ADC resolution to 12 bit.\r\n\r\nI am only able to receive data for the first two channels when taking values from p_event->data.done.p_buffer\r\n\r\nI assume the results should be stored in order from p_buffer[0] - p_buffer[3]. However i recieve results for:\r\n\r\n - ADC channel 0: on p_buffer[0] \r\n - ADC channel 1: on p_buffer[2] \r\n - ADC channel 2: can not be seen \r\n - ADC channel 3: seen on p_buffer[1] and p_buffer[3] (they both read high values when shorted to  VDD but are different each time i receive)\r\n\r\nI tested this by shorting all ANALOG pins to VDD individually and viewing the Console output.I am unsure if i am reading the pointer in the wrong order or if there is a bug somewhere else.\r\n\r\nlink to dl my project folder : http://www.filedropper.com/bleappuart \r\n\r\n    #define SAMPLES_IN_BUFFER 4\r\n    static nrf_saadc_value_t       m_buffer_pool[2][SAMPLES_IN_BUFFER];\r\n    \r\n    void saadc_sampling_event_init(void)\r\n    {\r\n        ret_code_t err_code;\r\n        err_code = nrf_drv_ppi_init();\r\n        APP_ERROR_CHECK(err_code);\r\n        err_code = nrf_drv_timer_init(&m_timer, NULL, timer_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        /* setup m_timer for compare event every 100ms */\r\n        uint32_t ticks = nrf_drv_timer_ms_to_ticks(&m_timer, 1000);\r\n        nrf_drv_timer_extended_compare(&m_timer, NRF_TIMER_CC_CHANNEL0, ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, false);\r\n        nrf_drv_timer_enable(&m_timer);\r\n    \r\n        uint32_t timer_compare_event_addr = nrf_drv_timer_compare_event_address_get(&m_timer, NRF_TIMER_CC_CHANNEL0);\r\n        uint32_t saadc_sample_event_addr = nrf_drv_saadc_task_address_get(NRF_SAADC_TASK_SAMPLE);\r\n    \r\n        /* setup ppi channel so that timer compare event is triggering sample task in SAADC */\r\n        err_code = nrf_drv_ppi_channel_alloc(&m_ppi_channel);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        err_code = nrf_drv_ppi_channel_assign(m_ppi_channel, timer_compare_event_addr, saadc_sample_event_addr);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    // Enable ADC sampling event\r\n    void saadc_sampling_event_enable(void)\r\n    {\r\n        ret_code_t err_code = nrf_drv_ppi_channel_enable(m_ppi_channel);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    void saadc_callback(nrf_drv_saadc_evt_t const * p_event)\r\n    {\r\n        // Done Event\r\n        if (p_event->type == NRF_DRV_SAADC_EVT_DONE)\r\n        {\r\n            ret_code_t err_code;\r\n         \r\n            err_code = nrf_drv_saadc_buffer_convert(p_event->data.done.p_buffer, SAMPLES_IN_BUFFER);\r\n            APP_ERROR_CHECK(err_code);\r\n            \r\n            \r\n            //printf(\"ADC event number: %d\\r\\n\",(int)m_adc_evt_counter);\r\n            char buffer[256];\r\n            unsigned int message_length;\r\n            message_length = sprintf(buffer, \"%d %d %d %d\", p_event->data.done.p_buffer[0], p_event->data.done.p_buffer[1], p_event->data.done.p_buffer[2], p_event->data.done.p_buffer[3]);\r\n            ble_nus_string_send(&m_nus,(uint8_t *)&buffer,message_length); \r\n            m_adc_evt_counter++;\r\n        }\r\n    }\r\n    \r\n    void saadc_init(void)\r\n    {\r\n        ret_code_t err_code;\r\n        \r\n        // Setup All SAADC Channels\r\n        nrf_saadc_channel_config_t channel_1_config =\r\n            NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE(NRF_SAADC_INPUT_AIN4);\r\n        channel_1_config.acq_time = NRF_SAADC_ACQTIME_10US;\r\n        channel_1_config.gain = NRF_SAADC_GAIN1_4;\r\n        channel_1_config.reference = NRF_SAADC_REFERENCE_VDD4;\r\n        \r\n        nrf_saadc_channel_config_t channel_2_config =\r\n            NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE(NRF_SAADC_INPUT_AIN5);\r\n        channel_2_config.acq_time = NRF_SAADC_ACQTIME_10US;\r\n        channel_2_config.gain = NRF_SAADC_GAIN1_4;\r\n        channel_2_config.reference = NRF_SAADC_REFERENCE_VDD4;\r\n        \r\n        nrf_saadc_channel_config_t channel_3_config =\r\n            NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE(NRF_SAADC_INPUT_AIN6);\r\n        channel_3_config.acq_time = NRF_SAADC_ACQTIME_10US;\r\n        channel_3_config.gain = NRF_SAADC_GAIN1_4;\r\n        channel_3_config.reference = NRF_SAADC_REFERENCE_VDD4;\r\n        \r\n        nrf_saadc_channel_config_t channel_4_config =\r\n            NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE(NRF_SAADC_INPUT_AIN7);\r\n        channel_4_config.acq_time = NRF_SAADC_ACQTIME_10US;\r\n        channel_4_config.gain = NRF_SAADC_GAIN1_4;\r\n        channel_4_config.reference = NRF_SAADC_REFERENCE_VDD4;\r\n        \r\n        err_code = nrf_drv_saadc_init(NULL, saadc_callback);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        // Initialize Channels\r\n        err_code = nrf_drv_saadc_channel_init(0, &channel_1_config);\r\n        APP_ERROR_CHECK(err_code);\r\n        err_code = nrf_drv_saadc_channel_init(1, &channel_2_config);\r\n        APP_ERROR_CHECK(err_code);\r\n        err_code = nrf_drv_saadc_channel_init(2, &channel_3_config);\r\n        APP_ERROR_CHECK(err_code);\r\n        err_code = nrf_drv_saadc_channel_init(3, &channel_4_config);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        err_code = nrf_drv_saadc_buffer_convert(m_buffer_pool[0],SAMPLES_IN_BUFFER);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        err_code = nrf_drv_saadc_buffer_convert(m_buffer_pool[1],SAMPLES_IN_BUFFER);\r\n        APP_ERROR_CHECK(err_code);\r\n    }",
    "tag": "adc"
  },
  {
    "text": "UART interrupt troubles migrating from rev2 to rev3 of nrf51822 HW Hi,\r\n\r\nI have an existing solid BLE S110 (v7.3.0) application running on a rev2 nrf51822 custom board, based on the SDK version 6.1.0. I need to port this to a rev3 board for another project and I'm having issues. I'm running a custom serial driver which has been tested extensively on my existing application, however when running on the rev3 nrf51822 I'm running into an issue where the UART TX interrupt arbitrarily decides no to fire. ie,\r\n\r\n    NRF_UART0->TXD.AsWord32 = byte;\r\n\r\nDoes not always result in a tx interrupt. 99% of the time it will, though sometime it decides not to. My driver can't recover from this, and thus, the app crashes. It's almost as if the UARTs tx interrupt enable bit (UART_INTENSET_TXDRDY) is being toggled for a short time, or the interrupt is being cleared in a higher priority interrupt before it can fire. I'm very stuck! \r\n\r\nWhen I test this without initialising the BLE SD the problem does **NOT** occur. I am using \"sd_nvic_SetPriority\" at a priority of 5. I tested priority 1 and 3 with the same result. \r\n\r\nI've gone back to the v6.1.0 SDK, running the ble_hrs app with the addition of my serial driver. Running the app on the PCA10001 (rev1) board and by custom board with rev2 HW, and the problem does **NOT** occur. With the rev3 HW also on my custom board, the issue remains. \r\n\r\nAny ideas?\r\n\r\nCheers,\r\nSam",
    "tag": "interrupt"
  },
  {
    "text": "unexpected system reset when triggerring pwm with ble connected Hi Experts\uff0c\r\n\r\nI use TIMER_1 and PPI to driver a 'H' style bridge for our motor. Unexpected system reset will happen if I trigger the 'H' bridge PWM with ble connected. It works fine if ble is not connected. Seems there is something conflicted between ble and pwm (ppi, or timer)?\r\nBlow is my motor driver code:\r\n\r\n motor_conf m_conf[3] = { \r\n  { 50, 100,  159, 200},  // 15: 8\r\n  { 75, 100,  175, 200},  // 15: 8\r\n  { 25, 100,  125, 200},  // 15: 8\r\n};\r\n\r\nstatic motor_mode m_mode = IDLE;\r\n\r\n__STATIC_INLINE void mode_set(int level) {\r\n  NRF_TIMER1->CC[0] = m_conf[level].l_en;\r\n  NRF_TIMER1->CC[1] = m_conf[level].l_dis;\r\n  NRF_TIMER1->CC[2] = m_conf[level].r_en;\r\n  NRF_TIMER1->CC[3] = m_conf[level].r_dis;\r\n}\r\n\r\nstatic void timer1_cc01_init(void) {\r\n\t\r\n    uint32_t crystal_is_running = 0;\r\n\t  sd_clock_hfclk_request();\r\n\r\n    while(!crystal_is_running){\r\n        sd_clock_hfclk_is_running(&crystal_is_running);\r\n    } \r\n    \r\n  NRF_TIMER1->MODE =TIMER_MODE_MODE_Timer;\r\n  NRF_TIMER1->BITMODE = TIMER_BITMODE_BITMODE_16Bit<<TIMER_BITMODE_BITMODE_Pos;\r\n  NRF_TIMER1->PRESCALER   = 8; \r\n  NRF_TIMER1->TASKS_CLEAR = 1;\r\n  mode_set(MOTOR_LOW);\r\n  NRF_TIMER1->SHORTS=(TIMER_SHORTS_COMPARE3_CLEAR_Enabled<<TIMER_SHORTS_COMPARE3_CLEAR_Pos);\r\n  \r\n}\r\n\r\n\r\nstatic void ppi_init(void) {\r\n  nrf_ppi_channel_t ppi_ch[8];\r\n  ret_code_t err_code;\r\n\t\r\n  nrf_drv_ppi_init();\r\n\t\t\r\n  /* PPI setup: */\r\n  for (uint8_t i = 0; i < 8; ++i) {\r\n    err_code = nrf_drv_ppi_channel_alloc(&ppi_ch[i]);\r\n    if (err_code != NRF_SUCCESS) {\r\n      goto error; // Resource deallocation is done by callee.\r\n    }\r\n    nrf_drv_ppi_channel_disable(ppi_ch[i]);\r\n  }\r\n     \r\n  nrf_drv_ppi_channel_assign(ppi_ch[0],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[0],\r\n                             nrf_drv_gpiote_out_task_addr_get(M1));\r\n  nrf_drv_ppi_channel_assign(ppi_ch[1],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[0],\r\n                             nrf_drv_gpiote_out_task_addr_get(M4));\r\n  nrf_drv_ppi_channel_assign(ppi_ch[2],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[1],\r\n                             nrf_drv_gpiote_out_task_addr_get(M1)); \r\n  nrf_drv_ppi_channel_assign(ppi_ch[3],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[1],\r\n                             nrf_drv_gpiote_out_task_addr_get(M4));  \r\n   \r\n  nrf_drv_ppi_channel_assign(ppi_ch[4],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[2],\r\n                             nrf_drv_gpiote_out_task_addr_get(M3));\r\n  nrf_drv_ppi_channel_assign(ppi_ch[5],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[2],\r\n                             nrf_drv_gpiote_out_task_addr_get(M2));   \r\n  nrf_drv_ppi_channel_assign(ppi_ch[6],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[3],\r\n                             nrf_drv_gpiote_out_task_addr_get(M3));\r\n  nrf_drv_ppi_channel_assign(ppi_ch[7],\r\n                             (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[3],\r\n                             nrf_drv_gpiote_out_task_addr_get(M2));   \r\n\r\n  for (uint8_t i = 0; i < 8; ++i) {\r\n    nrf_drv_ppi_channel_enable(ppi_ch[i]);\r\n  }\r\n\r\n error:\r\n  APP_ERROR_CHECK(err_code);\r\n}\r\n\r\nstatic void gpiote_init(void) {\r\n  ret_code_t err_code;\r\n  nrf_drv_gpiote_out_config_t out_config = GPIOTE_CONFIG_OUT_TASK_TOGGLE(NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n  \r\n  err_code = nrf_drv_gpiote_out_init(M1, &out_config);\r\n  APP_ERROR_CHECK(err_code);\r\n  err_code = nrf_drv_gpiote_out_init(M3, &out_config);\r\n  APP_ERROR_CHECK(err_code);\r\n\r\n  nrf_drv_gpiote_out_config_t low_config = GPIOTE_CONFIG_OUT_TASK_TOGGLE(NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n\r\n  err_code = nrf_drv_gpiote_out_init(M2, &low_config);\r\n  APP_ERROR_CHECK(err_code);\r\n  err_code = nrf_drv_gpiote_out_init(M4, &low_config);\r\n  APP_ERROR_CHECK(err_code); \r\n}\r\n\r\nvoid motor_stop(void) {\r\n  NRF_TIMER1->TASKS_CLEAR = 1;\r\n  *(uint32_t *)0x40009C0C = 0;\r\n  NRF_TIMER1->TASKS_STOP = 1;\r\n\r\n  nrf_drv_gpiote_out_task_force(M1, NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n  nrf_drv_gpiote_out_task_force(M3, NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n  nrf_drv_gpiote_out_task_force(M2, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n  nrf_drv_gpiote_out_task_force(M4, NRF_GPIOTE_INITIAL_VALUE_LOW);  \r\n  nrf_drv_gpiote_out_task_disable(M1);\r\n  nrf_drv_gpiote_out_task_disable(M3);\r\n  nrf_drv_gpiote_out_task_disable(M2);\r\n  nrf_drv_gpiote_out_task_disable(M4);\r\n\r\n  m_motor_left = true;\r\n  m_mode = IDLE;\r\n}\r\n\r\nvoid motor_tune(motor_mode level) {\r\n  m_motor_left = true;\r\n  *(uint32_t *)0x40009C0C = 0;\r\n \r\n  nrf_drv_gpiote_out_task_force(M1, NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n  nrf_drv_gpiote_out_task_force(M3, NRF_GPIOTE_INITIAL_VALUE_HIGH);\r\n  nrf_drv_gpiote_out_task_force(M2, NRF_GPIOTE_INITIAL_VALUE_LOW);\r\n  nrf_drv_gpiote_out_task_force(M4, NRF_GPIOTE_INITIAL_VALUE_LOW);    \r\n  nrf_drv_gpiote_out_task_enable(M1);\r\n  nrf_drv_gpiote_out_task_enable(M4); \r\n  nrf_drv_gpiote_out_task_enable(M3);\r\n  nrf_drv_gpiote_out_task_enable(M2);\t\r\n  \r\n  mode_set(level);\r\n\r\n  NRF_TIMER1->TASKS_CLEAR = 1;\r\n  *(uint32_t *)0x40009C0C = 1;\r\n  NRF_TIMER1->TASKS_START = 1;\r\n\r\n  m_mode = level;\r\n}\r\n\r\nI defined SOFTDEVICE_PRESENT and modified SD_PPI_RESTRICTED as 1, so the nrf_drv_ppi.c will call functions with sd_ prefix.\r\n\r\nThe chip is nrf51822 and my sdk is v9.0 and softdevice is s110-v8.0.\r\nPlease help have a look.",
    "tag": "pwm"
  },
  {
    "text": "using TWI while using GCC for 'ble_app_hrs' on NRF51 pca10028 S110 Hello,\r\n\r\nI use GCC as IDE because I must(though I debug perfectly via Keil v5). I migrated to eclipse GCC by the [tutorial](https://devzone.nordicsemi.com/tutorials/7/) published here on 'Devzone'. I added some C codes and drivers for NRF 51. 'spi_drv_master' works fine but not 'twi_drv_twi'.\r\n\r\nI'm trying to use the TWI(I2C) service, but I cannot continue through the 'nrf_drv_twi_tx' function to end it through 'twi_transfer' because:\r\n `p_cb->transfer_in_progress = true`\r\nthus, I always return `NRF_ERROR_BUSY` and fail.  here is the snippet from 'twi_transfer':\r\n\r\n    static ret_code_t twi_transfer(nrf_drv_twi_t const * const p_instance,\r\n                                   uint8_t                     address,\r\n                                   uint8_t const             * p_data,\r\n                                   uint32_t                    length,\r\n                                   bool                        xfer_pending,\r\n                                   bool                        is_tx)\r\n    {\r\n        ASSERT(m_cb[p_instance->instance_id].state == NRF_DRV_STATE_POWERED_ON);\r\n        ASSERT(length > 0);\r\n    \r\n        control_block_t * p_cb = &m_cb[p_instance->instance_id];\r\n    \r\n        bool is_busy = false;\r\n        CRITICAL_REGION_ENTER();\r\n        if (p_cb->transfer_in_progress)\r\n        {\r\n            is_busy = true;\r\n        }\r\n        else\r\n        {\r\n            p_cb->transfer_in_progress = true;\r\n        }\r\n        CRITICAL_REGION_EXIT();\r\n        if (is_busy)\r\n        {\r\n            return NRF_ERROR_BUSY;\r\n        }\r\n    ***\r\n    }\r\n\r\n'ASSERT' function does not seem to work either since:\r\n `p_cb->state = NRF_DRV_STATE_UNINTIALIZED` \r\nand that occurs when I hit the `control_block_t * p_cb = &m_cb[p_instance->instance_id];`\r\nbreakpoint.\r\n\r\nwhen I hit the `bool is_busy = false` breakpoint, only then when I get:\r\n `p_cb->state = NRF_DRV_STATE_POWERED_ON`\r\n\r\nas mentioned above, `is_busy = true;` and I return and fail.\r\n\r\nhere is how I initalized the TWI:\r\n\r\n    void twi_i2c_init (void)\r\n    {\r\n        ret_code_t err_code;\r\n      \r\n    //\t  nrf_gpio_cfg_input(MAX_GPIO_INT_PIN,NRF_GPIO_PIN_PULLUP);\r\n     \t\r\n        const nrf_drv_twi_config_t twi_i2c_MAX30101_config = {\r\n           .scl                = I2C_SCL_PIN,\r\n           .sda                = I2C_SDA_PIN,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n        };\r\n        \r\n        err_code = nrf_drv_twi_init(&twi_i2c_MAX30101, &twi_i2c_MAX30101_config, (nrf_drv_twi_evt_handler_t)twi_i2c_handler, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_twi_enable(&twi_i2c_MAX30101);\r\n    }\r\n\r\nand here is how I read from TWI:\r\n\r\n    void twi_i2c_MAX30101_read(uint8_t reg_addr, uint8_t* rxBuff, int size)\r\n    {\r\n        ret_code_t err_code;\r\n    \t\tm_tx_done = true;\r\n    \r\n    \t\ttwi_i2c_init();\r\n    \r\n    \t\tif((0 < size) && (size < I2C_RXBUFFER_SIZE))\r\n    \t\t{\r\n    \t\t\t/* Writing to MAX30101 */\r\n    \t\t\ti2cTransfer[0] = reg_addr;\r\n    \t\t\trxBuffer.size = size;\r\n    //\t\t\tif(MAX30101_FIFO_read_flag)\r\n    //\t\t\t{\r\n    //\t\t\t\twhile(nrf_gpio_pin_read(MAX_GPIO_INT_PIN) == 1);\r\n    //\t\t\t\tMAX30101_FIFO_read_flag = 0;\r\n    //\t\t\t}\r\n    \t\t\terr_code = nrf_drv_twi_tx(&twi_i2c_MAX30101, MAX30101_ADDRESS>>1, i2cTransfer, 1, true);\r\n    \t\t}\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n    \t\tdo{\r\n    \t\t\t\t// Make sure any pending events are cleared\r\n    \t\t\t\t__SEV();\r\n    \t\t\t\t__WFE();\r\n    \t\t\t\t// Enter System ON sleep mode\r\n    \t\t\t\t__WFE();\r\n          }while(m_rx_done == false);\r\n    \t\t\r\n    \t\t\tm_rx_done = false;\r\n    \t\t\r\n    //\t\ti2cTransfer = {0};\r\n    \t\t\r\n    \t\tfor(int i=0; i < size; i++)\r\n    \t\t{\r\n    \t\t\trxBuff[i] = rxBuffer.rx_Buffer[i];\r\n    \t\t}\r\n    \t\t\r\n    //\t\trxBuff_t rxBuffer = {0};\r\n    }\r\n\r\n\r\nI tried earlier to impose:\r\n`m_cb[p_instance->instance_id].transfer_in_progress = false;`\r\nbut that did not help me to transfer data. I transfer nonesence.\r\n\r\nWhat should I do? Via Keil it works fine.\r\n\r\nIdan",
    "tag": "twi"
  },
  {
    "text": "How to synchronize PWM with external event As for dimmer applications neccessary, a pwm signal with variable duty-cycle must be generated to drive a triac. But to be synchronized with the mains' zero crossing, the pwm cycle must be started by a GPIO event from a zero-crossing sensor (optocoupler). What would be the best approach to solve this problem? Has anybody done a similar thing before?",
    "tag": "pwm"
  },
  {
    "text": "packet loss issue with nus service I am sending IMU data as 20 byte packets through nus service at the rate of 50 such packets per second.   The device is a nrf51 DK configured as ble peripheral (S110).  The application contains twi to read data from sensor, nus to send data, and uart to print error messages.  The packets are labelled with a continuous sequence number.\r\n\r\nWhen using Master Control panel ( windows 7 and Android 5.0 ) to receive data from the nrf51 DK, the sequence numbers are continuous with no missing packets. However, when I use another nrf51 / 52 DK configured as central (S130 / S132) to receive data (ble_app_uart_c), I observe missing sequence numbers showing loss of about more than 50%. The error code being logged is 0x3004, which means buffer overflow in the stack.\r\n\r\nWhat could the problem possibly be?\r\n\r\nI was using Keil IDE initially and recently started working with IAR too.\r\n\r\n**P.S:**  I've tested those nrf51 / 52 central devices with other ARM based ble SoCs from other vendors implementing the same nus profiles. They seem to work fine without any packet loss in the reception.",
    "tag": "twi"
  },
  {
    "text": "Frequency of GPIOTE_IRQHandler calls? i've written this program to toggle a led on a button click\r\n\r\nif the time between two button pushs is less than 3 seconds it doesn't work the handler isn't called , i've to wait a few more seconds between two clicks!!!\r\n\r\nwhy is that, what's the problem\r\nthank you!\r\n\r\n    int main(void)\r\n    {\r\n       nrf_gpio_cfg_sense_input(BUTTON_1, NRF_GPIO_PIN_NOPULL, NRF_GPIO_PIN_SENSE_LOW);\r\n       nrf_gpio_range_cfg_output(BSP_LED_0, BSP_LED_2);\r\n       NRF_GPIOTE->INTENSET = GPIOTE_INTENSET_PORT_Msk;\r\n       NVIC_EnableIRQ(GPIOTE_IRQn);\t\t\r\n       while(1)\r\n       {     \r\n            __WFE();\r\n            __SEV();\r\n            __WFE();       \r\n       }\r\n    }\r\n    void GPIOTE_IRQHandler(void) \r\n    {\r\n        if(NRF_GPIOTE->EVENTS_PORT)\r\n        {\r\n            NRF_GPIOTE->EVENTS_PORT = 0;\r\n            nrf_gpio_pin_toggle(BSP_LED_1);\t\t\r\n        }\r\n    }\r\n",
    "tag": "interrupt"
  },
  {
    "text": "PWM frequency accuracy hello,\r\n    I want to generate a square wave; examples of your company use PWM official offer;Square wave frequency lower accuracy, configuration 10KHz frequency, there will be error \u00b1 16Hz.How do I need to configure the frequency accuracy can reach \u00b1 1Hz?\r\nHere is the code:\r\n\r\n    void demo1(void)\r\n    {\r\n        printf(\"Demo 1\\r\\n\");\r\n    \r\n        /*\r\n         * This demo plays back a sequence with different values for individual\r\n         * channels (LED 1 - LED 4). Only four values are used (one per channel).\r\n         * Every time the values are loaded into the compare registers, they are\r\n         * updated in the provided event handler. The values are updated in such\r\n         * a way that increase and decrease of the light intensity can be observed\r\n         * continuously on succeeding channels (one second per channel).\r\n         */\r\n    \r\n        uint32_t err_code;\r\n        nrf_drv_pwm_config_t const config0 =\r\n        {\r\n            .output_pins =\r\n            {\r\n                BSP_LED_0 | NRF_DRV_PWM_PIN_INVERTED, // channel 0\r\n                BSP_LED_1 | NRF_DRV_PWM_PIN_NOT_USED, // channel 1\r\n                BSP_LED_3 | NRF_DRV_PWM_PIN_NOT_USED, // channel 2\r\n                BSP_LED_2 | NRF_DRV_PWM_PIN_NOT_USED  // channel 3\r\n            },\r\n            .irq_priority = _PRIO_APP_HIGH,\r\n            .base_clock   = PWM_PRESCALER_PRESCALER_DIV_1,\r\n            .count_mode   = NRF_PWM_MODE_UP,\r\n            .top_value    = 100,\r\n            .load_mode    = NRF_PWM_LOAD_INDIVIDUAL,\r\n            .step_mode    = NRF_PWM_STEP_AUTO\r\n        };\r\n        err_code = nrf_drv_pwm_init(&m_pwm0, &config0, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        m_used |= USED_PWM(0);\r\n    \r\n        m_demo1_seq_values.channel_0 = 33;\r\n        m_demo1_seq_values.channel_1 = 40;\r\n        m_demo1_seq_values.channel_2 = 50;\r\n        m_demo1_seq_values.channel_3 = 60;\r\n        m_demo1_phase = 0;\r\n    \r\n        nrf_drv_pwm_simple_playback(&m_pwm0, &m_demo1_seq, 1,\r\n            NRF_DRV_PWM_FLAG_LOOP);\r\n    }",
    "tag": "pwm"
  },
  {
    "text": "pwm frequency accuracy I use nRF5_SDK_11.0.0 PWM demo generating 10KHz square wave;\r\nTest results: precision \u00b1 16Hz frequency error;\r\nHow do I need to configure to however accuracy of \u00b1 1Hz?\r\n\r\n\r\nCode:\r\nvoid demo1(void)\r\n{\r\n    printf(\"Demo 1\\r\\n\");\r\n\r\n    /*\r\n     * This demo plays back a sequence with different values for individual\r\n     * channels (LED 1 - LED 4). Only four values are used (one per channel).\r\n     * Every time the values are loaded into the compare registers, they are\r\n     * updated in the provided event handler. The values are updated in such\r\n     * a way that increase and decrease of the light intensity can be observed\r\n     * continuously on succeeding channels (one second per channel).\r\n     */\r\n\r\n    uint32_t err_code;\r\n    nrf_drv_pwm_config_t const config0 =\r\n    {\r\n        .output_pins =\r\n        {\r\n            BSP_LED_0 | NRF_DRV_PWM_PIN_INVERTED, // channel 0\r\n            BSP_LED_1 | NRF_DRV_PWM_PIN_NOT_USED, // channel 1\r\n            BSP_LED_3 | NRF_DRV_PWM_PIN_NOT_USED, // channel 2\r\n            BSP_LED_2 | NRF_DRV_PWM_PIN_NOT_USED  // channel 3\r\n        },\r\n        .irq_priority = _PRIO_APP_HIGH,\r\n        .base_clock   = PWM_PRESCALER_PRESCALER_DIV_1,\r\n        .count_mode   = NRF_PWM_MODE_UP,\r\n        .top_value    = 100,\r\n        .load_mode    = NRF_PWM_LOAD_INDIVIDUAL,\r\n        .step_mode    = NRF_PWM_STEP_AUTO\r\n    };\r\n    err_code = nrf_drv_pwm_init(&m_pwm0, &config0, NULL);\r\n    APP_ERROR_CHECK(err_code);\r\n    m_used |= USED_PWM(0);\r\n\r\n    m_demo1_seq_values.channel_0 = 33;\r\n    m_demo1_seq_values.channel_1 = 40;\r\n    m_demo1_seq_values.channel_2 = 50;\r\n    m_demo1_seq_values.channel_3 = 60;\r\n    m_demo1_phase = 0;\r\n\r\n    nrf_drv_pwm_simple_playback(&m_pwm0, &m_demo1_seq, 1,\r\n        NRF_DRV_PWM_FLAG_LOOP);\r\n}",
    "tag": "pwm"
  },
  {
    "text": "Missing interrupt sometimes Hello all,\r\n\r\nI am using the nrf51822 chip as well as an accelerometer LIS3DH. The device does advertising and turns on a LED when it is active.\r\n\r\n The accelerometer is configured to detect when the device has not been moved for 2 minutes. When this happens, the nRF51822 stops advertising and switches off the LED until the accelerometer detectes movement again. This works with an interruption (same interruption for putting to sleep as well as to awake).\r\n\r\nI have found that sometimes the interrupt handler does not trigger (I checked with an oscylloscope that the accelerometer does trigger the interrupt, so the problem is in the processor).\r\nWhen this happens, I have to wait a couple of minutes and then the processor awakes normally.\r\n\r\nI attach here the relevant part of the code:\r\n\r\n    static void accel_interrupt_handler1(uint8_t pin_no, uint8_t button_action)\r\n    {\r\n\tstopped_person=button_action;\r\n    }\r\n\r\nThe stopped_person variable is dealt with in another part of the code.\r\n\r\nThe initialization of the interrupt is:\r\n\r\n    static void interrupts_init(void)\r\n    {\t\r\n    \t//Interrupts\r\n    \tstatic app_button_cfg_t buttons[] =\r\n        {\r\n    \t\t\t\t{ACCEL_INT1, APP_BUTTON_ACTIVE_HIGH, NRF_GPIO_PIN_NOPULL, accel_interrupt_handler1},\t\t\t\r\n        };\t\r\n    \t\t\r\n        APP_BUTTON_INIT(buttons, sizeof(buttons) / sizeof(buttons[0]), BUTTON_DETECTION_DELAY, true); \t\t\t\r\n    }\r\n\r\nIt is important to note that this works most of times.\r\nCould anyone tell me why I am missing some interrupts?\r\n\r\nThank you very much!",
    "tag": "interrupt"
  },
  {
    "text": "NRF51422 TWI not functioning properly Hello, i have a strange situation here with TWI module and i have no idea what is happening. I have read a lot of posts here on devzone and the code i am using is also found somewhere on this forum, however in none of the post i found the same behaviour which i am seeing. I have a temperature sensor which is driven via i2c, so for this i am trying to use TWI. Piece of code which i am using is atached in the picture below.![image description](/attachment/694d43fbc8d52bc250330a868b87b966)\r\n\r\nIf i am letting the code to run, then i hit a break-point at line 283. After i let the code to run again, i hit a break-point at line 286. At line 285 i am sending data to sensor with `ret_code = nrf_drv_twi_tx(&p_twi_instance, 0x40, &dummy_data, 1, false);` In this case, this is what i am seeing with oscilloscope on SCL and SDA lines:\r\n![image description](/attachment/3ee32c901308b701d03186c884f9d744)\r\n\r\nIf i remove a break-point at line 283 and allowing the code to run, i hit a break-point at line 286 and this is what i am seeing with oscilloscope in this case:\r\n![image description](/attachment/aa30135d09ac1b4d94e5a1305ba78a67)\r\n\r\nAlso, this time i see in TWI1 events, that EVENTS_ERROR is set. Also, in TWI1_ERRORSRC register i have ANACK bit set. After this i have tried to do my own version of twi communication with sensor by modifying TWI1 module registers directly. However, that gives exactly the same results. Putting the break-point between sending data, and then running the code again - communication is seen. If allowing the code to run without any breakpoints, device gives NACK and communication fails.I don't understand what is causing this behaviour. Any help is appreciated. By the way, i am using SoftDevice S110_V8.\r\n\r\n@ EDIT: After adding delay after TWI module initialization, and sending data. I don't understand however what is causing small voltage drop just few ms before starting communication?:\r\n[delay.png](/attachment/a864efedea2e96f721d4c73606bb1d39)\r\n",
    "tag": "twi"
  },
  {
    "text": "How to use _WFI and WFE to enter idle mode Hi all:\r\nTo saving power I implement the function to read data after interrupt is triggered..\r\n\r\nbelow are my codes..\r\nMy expectation is..\r\n\r\nLet CPU enter idle mode to wait interrupt by call _WFI()\r\nAfter interrupt is triggered start to read data and call _WFE() to save power.\r\nAfter read out 100 datas, CPU enter idle mode to wait interrupt triggered again...\r\n\r\nHowever, the function of LIS3DH_ReadOutZYX(XYZ_Data) is always called even there is no any interrupt is triggered.\r\nHow can I revise my code to meet my requirements?\r\nThanks..\r\n\r\n    int main(void)\r\n    {\r\n      BSP_Init();\r\n    \r\n      static bool bPoweSaving = true;\r\n    \r\n    \r\n        int16_t         XYZ_Data[3]={0};\r\n    \r\n        uint8_t reg = 0;\r\n        ret_code_t err_code;\r\n        static int i = 0;\r\n    \r\n         \r\n        while(true)\r\n        {\r\n         \r\n            /* Start transaction with a slave with the specified address. */\r\n         if( bPoweSaving)\r\n         {\r\n           __WFI();\r\n           \r\n         }\r\n         else\r\n         {\r\n         \r\n           __WFE();\r\n         }\r\n         bPoweSaving = false;\r\n         err_code = LIS3DH_ReadOutZYX(XYZ_Data);  \r\n        }\r\n         i ++; \r\n         if (i > 100)\r\n           bPoweSaving = true;\r\n     \r\n    }",
    "tag": "interrupt"
  },
  {
    "text": "makefile error when using soft device with twi hello,\r\n\r\nmy makefile use to work before i add the twi nrf_drv_twi.c file and included the directory \r\nINC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/**nrf_soc_nosd**)\r\n\r\ni get the error below when building at  app_util_platform.c:\r\n\r\n   \r\n\r\n     app_util_platform.c: In function 'app_util_critical_region_enter':\r\n    /Users/brookgebremedhin/nordicSDK11/components/libraries/util/app_util_platform.c:36:3: error: implicit declaration of function 'sd_nvic_critical_region_enter' [-Werror=implicit-function-declaration]\r\n       (void)sd_nvic_critical_region_enter(p_nested);\r\n       ^\r\n    /Users/brookgebremedhin/nordicSDK11/components/libraries/util/app_util_platform.c: In function 'app_util_critical_region_exit':\r\n    /Users/brookgebremedhin/nordicSDK11/components/libraries/util/app_util_platform.c:49:3: error: implicit declaration of function 'sd_nvic_critical_region_exit' [-Werror=implicit-function-declaration]\r\n\r\nif i tell the makefile that i am not using the soft device then it can build.\r\ncam anyone show me a working makefile that uses twi and soft device together ?\r\n\r\nmy makefile is attached below\r\n\r\nthanks\r\n\r\n[Makefile](/attachment/80bb6de5c5508f27d6c6ddf9f7133783)",
    "tag": "twi"
  },
  {
    "text": "using i2c to send 3 command per 10ms, ppi available? just like \r\nhttps://github.com/Martinsbl/nrf5-mpu-examples/tree/master/nrf52-mpu-easydma-using-timers-and-drivers\r\nwe add a sensor, and try to read 2 sensors by 3 command in i2c.\r\nis it possible to still using ppi?",
    "tag": "i2c"
  },
  {
    "text": "I2C communication Is there any tutorial or good example for I2C communication using TWI? I already saw the examples for TWI, but I don't find them very intuitive to change for I2C. \r\n\r\nI'm trying to code from scratch, but if anyone has something to help thank you in advance.\r\n\r\n(using nrf51 - SDK11 - S130 v2.0)",
    "tag": "i2c"
  },
  {
    "text": "Can ble_nus_string_send() be called from a TWI callback? Calling `ble_nus_string_send()` from within a TWI callback (case NRF_DRV_TWI_EVT_DONE) is performing a reset on my PCA10028 (nRF51422). It works fine from the main loop. \r\n\r\nAm I right in assuming that BLE operations cannot be issued from such callbacks? But on the other hand, the `ble_app_uart` example issues the same call within the uart handler (APP_UART_DATA_READY).\r\n\r\nI'd appreciate any clarification on the above.\r\n\r\nThanks",
    "tag": "interrupt"
  },
  {
    "text": "How to obtain current PWM value? Hi,\r\n\r\nis there any simple way to obtain current PWM value if nrf52 PWM module is used to produce complex waveform from RAM array? The task is to get currently settled value of duty-cycle and to perform some modification of residual data according that value. I didn't find any register containing either pointer to or currently locked value.",
    "tag": "pwm"
  },
  {
    "text": "'TWI0_INSTANCE_INDEX' undeclared Hello, \r\nmy setup is nrf51822, with SDK 10.\r\n\r\nI try to create application to drive I2C components and I get compilations errors:\r\nIn function 'Hal_I2cInit':\r\n../../../nrf5-sdk/components/drivers_nrf/twi_master/nrf_drv_twi.h:73:29: error: 'TWI0_INSTANCE_INDEX' undeclared (first use in this function)\r\n     .instance_id = CONCAT_3(TWI, id, _INSTANCE_INDEX) \\\r\n\r\nthat I don't understand.\r\n\r\nthe nrf_drv_config.h file has been modified to change \"#define TWI0_ENABLED 0\" to \"#define TWI0_ENABLED 1\"\r\n\r\nIf someone can explain please the issue, it would be nice\r\nthanks \r\nBR",
    "tag": "i2c"
  },
  {
    "text": "Issue with 2 Instance x 2 Channel PWMs and TWI RX Hi everyone,\r\n\r\nI'm seeing a weird issue with one of my two instances of 2ch PWMs where if I receive data from TWI, my PWM1 stops functioning and TWI stops functioning as well. However, transmitting data using TWI does not show the same issue and issues are only seen after receiving data from TWI. If I only use PWM2 instead of using both PWM1 and PWM2, TWI issue is no longer seen and I can use TWI to transmit and receive data without issues.\r\n\r\nHere is how I initialize my TWI and PWM:\r\n\r\n    twi_master_init();\r\n    \r\n    ... // initialize S210 and other stuff...\r\n     \r\n    PWM1.p_cb->channels_cb[0].gpio_pin = 25;\r\n    PWM1.p_cb->channels_cb[0].pulsewidth = 0x00000000;\r\n    PWM1.p_cb->channels_cb[0].ppi_channels[0] = NRF_PPI_CHANNEL1;\r\n    PWM1.p_cb->channels_cb[0].ppi_channels[1] = NRF_PPI_CHANNEL2;\r\n    PWM1.p_cb->channels_cb[0].polarity = APP_PWM_POLARITY_ACTIVE_HIGH ;\r\n    PWM1.p_cb->channels_cb[0].initialized = 0;\r\n\r\n    PWM1.p_cb->channels_cb[1].gpio_pin = 26;\r\n    PWM1.p_cb->channels_cb[1].pulsewidth = 0x00000000;\r\n    PWM1.p_cb->channels_cb[1].ppi_channels[0] = NRF_PPI_CHANNEL3;\r\n    PWM1.p_cb->channels_cb[1].ppi_channels[1] = NRF_PPI_CHANNEL4;\r\n    PWM1.p_cb->channels_cb[1].polarity = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n    PWM1.p_cb->channels_cb[1].initialized = 0;\r\n\r\n    PWM1.p_cb->period = 0xFFFFFFFF;\r\n    PWM1.p_cb->p_ready_callback = pwm_ready_callback;\r\n    PWM1.p_cb->ppi_channels[0] = NRF_PPI_CHANNEL5;\r\n    PWM1.p_cb->ppi_channels[1] = NRF_PPI_CHANNEL6;\r\n    PWM1.p_cb->ppi_group = NRF_PPI_CHANNEL_GROUP0;\r\n    PWM1.p_cb->state = NRF_DRV_STATE_UNINITIALIZED;\t\r\n\r\n    PWM2.p_cb->channels_cb[0].gpio_pin = 28;\r\n    PWM2.p_cb->channels_cb[0].pulsewidth = 0x00000000;\r\n    PWM2.p_cb->channels_cb[0].ppi_channels[0] = NRF_PPI_CHANNEL7;\r\n    PWM2.p_cb->channels_cb[0].ppi_channels[1] = NRF_PPI_CHANNEL8;\r\n    PWM2.p_cb->channels_cb[0].polarity = APP_PWM_POLARITY_ACTIVE_HIGH ;\r\n    PWM2.p_cb->channels_cb[0].initialized = 0;\r\n\r\n    PWM2.p_cb->channels_cb[1].gpio_pin = 29;\r\n    PWM2.p_cb->channels_cb[1].pulsewidth = 0x00000000;\r\n    PWM2.p_cb->channels_cb[1].ppi_channels[0] = NRF_PPI_CHANNEL9;\r\n    PWM2.p_cb->channels_cb[1].ppi_channels[1] = NRF_PPI_CHANNEL10;\r\n    PWM2.p_cb->channels_cb[1].polarity = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n    PWM2.p_cb->channels_cb[1].initialized = 0;\r\n\r\n    PWM2.p_cb->period = 0xFFFFFFFF;\r\n    PWM2.p_cb->p_ready_callback = pwm_ready_callback;\r\n    PWM2.p_cb->ppi_channels[0] = NRF_PPI_CHANNEL11;\r\n    PWM2.p_cb->ppi_channels[1] = NRF_PPI_CHANNEL12;\r\n    PWM2.p_cb->ppi_group = NRF_PPI_CHANNEL_GROUP1;\r\n    PWM2.p_cb->state = NRF_DRV_STATE_UNINITIALIZED;\r\n     \r\n    // begin initialization of PWM channels\r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(4096L, 25, 26);\r\n    app_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_2CH(4096L, 28, 29);\r\n    // initialize and enable PWM\r\n    pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\tpwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n    err_code = app_pwm_init(&PWM1, &pwm1_cfg, pwm_ready_callback);\r\n    APP_ERROR_CHECK(err_code);\r\n\tpwm2_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\tpwm2_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n    err_code = app_pwm_init(&PWM2, &pwm2_cfg, pwm_ready_callback);\r\n    APP_ERROR_CHECK(err_code);\r\n    // enable PWMs\r\n    app_pwm_enable(&PWM1);\r\n    app_pwm_enable(&PWM2);\r\n\t// set all PWMs to 0%\r\n    while (app_pwm_channel_duty_set(&PWM1, 1, 0) == NRF_ERROR_BUSY);\t// left backward\r\n    while (app_pwm_channel_duty_set(&PWM1, 0, 0) == NRF_ERROR_BUSY);\t// left forward\r\n    while (app_pwm_channel_duty_set(&PWM2, 1, 0) == NRF_ERROR_BUSY);\t// right forward\r\n    while (app_pwm_channel_duty_set(&PWM2, 0, 0) == NRF_ERROR_BUSY);\t// right backward\r\n\r\nI tried changing the above PPI channels for PWM around from 1-12 to 20 to 21 and PPI channel group from 0 and 1 to 2 to 3 but still the same issue is seen. Does TWI receiver use one of the PPI essential to the PWM functionality or vise versa?\r\n\r\nThank you for your help.",
    "tag": "pwm"
  },
  {
    "text": "How do I recover from a failed I2C write? By design, the TI LP55231 LED driver IC will fail the TWI write of the reset register (0x3D). It's necessary to reset the IC in an edge use case. I'm using the nRF51822 HW TWI driver and cannot recover from this. The first write returns without error (NRF_SUCCESS). Successive TWI writes return with an internal error (NRF_ERROR_INTERNAL). Manually clearing the bus does not seem to work. Re-initializing the driver seems an extreme workaround. Is there a trick to this?\r\n\r\nsnip:\r\n\r\n     data[0]=LP55231_RESET_REGISTER;\r\n     data[1]=LP55231_RESET_VALUE;\r\n     retcode = nrf_drv_twi_tx( &TWI_DRIVER, IC_ADDRESS, data, 2, false );\r\n     APP_ERROR_CHECK( retcode );\r\n\r\n*nRF51822_xxAC/256/32/S130*\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "setting up pwm for LED SDK 11 Hi,\r\nim trying to set up 3 PWMs for simulating a RGB LED with the 3 leds on the nrf52-dk.\r\nI need the following behavior:\r\n\r\npushing on a button increases the width of the period -> led gets brighter.\r\n\r\nHow do i set up a simple pwm where i can set the pulse width. I should work with S132 and SDK 11.\r\nThis one would be perfect:\r\nhttps://github.com/NordicSemiconductor/nrf51-pwm-library\r\n\r\n but i cant get it up and running with SDK11.",
    "tag": "pwm"
  },
  {
    "text": "I want to use PWM on only one output pin I want to use PWM on only one output pin. I'm using a nrf51422 and softdevice s130.\r\n\r\nI want to be able to set the PWM and then change it again (a sequence). This is to be able to generate sounds through a buzzer.\r\n\r\nIs there a simple example I can look at.\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "nrf_drv_timer with TIMER2 and s310 on nRF5144 I wrote this code found in an example and it works fine:\r\n\r\n    #include \"nrf_drv_config.h\"\r\n    #include \"nrf_drv_timer.h\"\r\n\r\n    //Before I activated TIMER0, TIMER1 and TIMER2 in nrf_drv_config.h\r\n    const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(0);\r\n\r\n    /**\r\n    * @brief Handler for timer events.\r\n    */\r\n    void timer_led_event_handler(nrf_timer_event_t event_type, void* p_context)\r\n    {\r\n        switch(event_type)\r\n        {\r\n            case NRF_TIMER_EVENT_COMPARE0:\r\n                LED_redLed_toggle();\r\n                break;        \r\n            default:\r\n                //Do nothing.\r\n                break;\r\n        }    \r\n    }\r\n  \r\n    int main(void)\r\n    {\r\n    \tLED_init();\t\r\n\r\n    \tuint32_t time_ms = 3000;  //Time(in miliseconds) between consecutive compare events.\r\n        uint32_t time_ticks;\r\n        uint32_t err_code = NRF_SUCCESS;\r\n    \t\r\n    \terr_code = nrf_drv_timer_init(&TIMER_LED, NULL, timer_led_event_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n  \r\n    \ttime_ticks = nrf_drv_timer_ms_to_ticks(&TIMER_LED, time_ms);\r\n    \t\r\n        nrf_drv_timer_extended_compare( &TIMER_LED,\r\n                                                              NRF_TIMER_CC_CHANNEL0,\r\n                                                              time_ticks,\r\n                                                              NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK,\r\n                                                              true);\r\n        \r\n        nrf_drv_timer_enable(&TIMER_LED);\r\n\r\n    \t//ANT_init();\r\n    \t\r\n    \t//BLE_init();\r\n    \t\r\n    \t// Main Loop\r\n    \twhile(1)\r\n    \t{\t\r\n            PWR_sleep();\r\n    \t}\r\n    }\r\n\r\nWhen I active the softdevice, removing comments at these lines:\r\n\r\n    \t//ANT_init();\r\n    \t\r\n    \t//BLE_init();\r\n\r\nThe code doesn't run. I found that TIMER0 is used by softdevice, so I tried to use TIMER1 or TIMER2 changing this line:\r\n\r\n    const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(0);\r\n\r\ninto:\r\n\r\n    const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(1);\r\n\r\nand then also into:\r\n\r\n    const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(2);\r\n\r\n\r\nIn both cases the interrupt will be continuous, and not after the setted time.\r\n\r\nWhat does could be the issue?\r\n\r\n\r\nI found on this forum a similar question, but I tried to reduce the timer frequency and I get that I can set the timer untill 2s, but over 2s the timer restart to interrupt continuously. The settings I modified are:\r\n\r\n    #define TIMER2_ENABLED 1\r\n    \r\n    #if (TIMER2_ENABLED == 1)\r\n    #define TIMER2_CONFIG_FREQUENCY    NRF_TIMER_FREQ_31250Hz\r\n    #define TIMER2_CONFIG_MODE         TIMER_MODE_MODE_Timer\r\n    #define TIMER2_CONFIG_BIT_WIDTH    TIMER_BITMODE_BITMODE_32Bit\r\n    #define TIMER2_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n    \r\n    #define TIMER2_INSTANCE_INDEX      (TIMER1_ENABLED+TIMER0_ENABLED)\r\n\r\n\r\nHow can I use the timer to have interrupts every 5 minuts ?\r\n\r\nIt seems like the TIMER_BITMODE_BITMODE_32Bit doens't set correclty the register behaviour as a 32bit register, but remains at 16bit so, setting timer times bigger than 2seconds make the interrupts arriving continuously.\r\n\r\nI need a timer which can interrupt every 5 minuts or more to wakup the application which I put in sleep with sd_app_wait(); (PWR_sleep(); in my code).\r\n\r\nHow can I reach this?\r\n\r\n\r\n\r\nThanks.\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "PWM with a piezo buzzer,How can I change the PWM frequency? I use the nrf51822qfaa,s110 v8.00,SDK V10.0.\r\nI use PWM module with a piezo buzzer.\r\nNow I need change the buzzer frequency,\r\nHow can I change the PWM frequency?\r\n\r\nfor example:\r\n\r\n    /* 2-channel PWM, 200Hz, output on DK LED pins. */\r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(5000L, BSP_LED_0, BSP_LED_1);",
    "tag": "pwm"
  },
  {
    "text": "nRF52832 DK clk/interrupt is un-deterministic I am trying to trigger some functions based on some pre-determined timings. I tried to do that using nrf_delay_us and also using timer0 interrupts, but both are giving me un-deterministic timings. So for a delay of 1 second using the delay or the timer methods both give more like ~999,980 us. I tried to force CONSTLAT but for some reason in the debugger I can see that the command has no effect on the TASKS_CONSTLAT bit.",
    "tag": "interrupt"
  },
  {
    "text": "nRF52 PWM Glitch Error I have an implementation that is using a PWM output to drive a LED.  It has been observed that when the LED is on in a constant drive state, fixed PWM output train, the LED will \"flash\".  i.e. change intensity for a short period, and then return to the correct output level.  This happens at a very sporadic and infrequent rate.  I had a capture of the PWM output on scope, and did not properly save it, so I am working on getting one to post with this question.\r\n\r\nWhat is observed in the trace that I did have, is a singular event in the pulse train, which looks like the PWM module misses the \"off\" trigger, and carries the output in the \"on\" state until the point in time that the next \"off\" trigger would occur.  The PWM module then shuts off the output and continues operating correctly from that point, until some random point in the future.\r\nThe output is running a fairly show 150 Hz PWM period, which we have cut into 255 DC elements.  There is not change in the observed period frequency during this event.  The PWM is running a simple playback, single PWM value task.  I have instrumented all of the change vectors, and nothing from the software side is directing a change during this operation.  \r\n\r\nThe system is running SD132 and using SDK 11 release.  We are running the radio in advertising and also connected modes. It is not clear yet if this has any effect on the problem.  \r\n\r\nThe question in this would be, is there some hardware path that could allow the system to miss a counter crossing event?  It seems that the PPI and task system should handle this without interference from other hardware elements, but maybe there is something not apparent.\r\n\r\nUpdate: Ok, I got my scope image.  Took awhile.  The trace shows the 100us pulses running at 6.660ms period.  The single outlier is 6.76ms in width, or as described above, it looks like the hardware missed the shutoff for a single period, then picked back up running.\r\n\r\n![image description](/attachment/0e5810454f4d422718e42ffefa1c4561)\r\n\r\nUpdate for Code:  Adding a snippet of code for Ole.  Configuration of the SD Clock and then the setup for the PWM control.  \r\n\r\n    #define NRF_CLOCK_LFCLKSRC      {.source        = NRF_CLOCK_LF_SRC_XTAL,            \\\r\n                                 .rc_ctiv       = 0,                                \\\r\n                                 .rc_temp_ctiv  = 0,                                \\\r\n                                 .xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM}\r\n\r\n\r\nSetup for PWM\r\n\r\n    #define HL_NUM_LED_PWM_STEPS (255)\r\n    \r\n            static nrf_drv_pwm_t m_LED_pwm     = NRF_DRV_PWM_INSTANCE(0); \r\n            static nrf_drv_pwm_config_t const m_LED_config =\r\n            {\r\n                .output_pins =\r\n                {\r\n                    OUTPUT_LED_ENABLE_PWM_PIN, // channel 0\r\n                    NRF_DRV_PWM_PIN_NOT_USED, // channel 1\r\n                    NRF_DRV_PWM_PIN_NOT_USED, // channel 2\r\n                    NRF_DRV_PWM_PIN_NOT_USED  // channel 3\r\n                },\r\n                .base_clock = NRF_PWM_CLK_250kHz,\r\n                .count_mode = NRF_PWM_MODE_UP,\r\n                .top_value  = 1667,\r\n                .load_mode  = NRF_PWM_LOAD_INDIVIDUAL,\r\n                .step_mode  = NRF_PWM_STEP_AUTO\r\n            };\r\n            static nrf_pwm_values_individual_t m_LED_seq_values =\r\n            {\r\n                .channel_0 = 0,\r\n                .channel_1 = 0,\r\n                .channel_2 = 0,\r\n                .channel_3 = 0\r\n            };\r\n            static nrf_pwm_sequence_t const m_LED_channel_seq =\r\n            {\r\n                .values.p_individual = &m_LED_seq_values,\r\n                .length              = NRF_PWM_VALUES_LENGTH(m_LED_seq_values),\r\n                .repeats             = 0,\r\n                .end_delay           = 0\r\n            };\r\n        static nrf_pwm_edge_t m_LED_polarity = NRF_PWM_EDGE_FALL;\r\n\r\nInit and call to start the action\r\n\r\n    err_code = nrf_drv_pwm_init(&m_LED_pwm, &m_LED_config, NULL);\r\n    APP_ERROR_CHECK(err_code);\r\n    \r\n    ledDriverSequenceCounts = (uint16_t)((uint32_t)ledDriverPwmCounts * m_LED_config.top_value / (uint32_t)HL_NUM_LED_PWM_STEPS);\r\n    ledDriverSequenceCounts |= m_LED_polarity;\r\n    m_LED_seq_values.channel_0 = ledDriverSequenceCounts;\r\n    nrf_drv_pwm_simple_playback(&m_LED_pwm, &m_LED_channel_seq, 1, NRF_DRV_PWM_FLAG_LOOP);\r\n\r\nFor the testing, I am just manually setting the PWM input to a value that make the glitch artifact visible, and then it is never changed again.  I also tried longer PWM DC settings, thinking there might be something in the short 140us duration, but I also see it glitch out to over a 1ms DC within the 6.66ms period.  As you said, mostly very infrequently, but sometimes \"quickly\" in succession. \r\n\r\nRegards,\r\nMichael\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Issues with PWM and S210 Hi everyone,\r\n\r\nWhen I run 4 instances (i.e., x2 PWM channels) of PWM with S210 (same example as the ant_background_scanning from SDK 10), after few seconds of constantly changing PWM duty cycle of 2 out of 4 PWM instances, the chip restarts by itself. Issue was not seen with PWM when softdevice and ANT were not enabled. Initialization of the softdevice and ANT is the same as the abovementioned example and the PWM is initialized as shown below:\r\n\r\n    APP_PWM_INSTANCE(PWM1,1);\t\t\t// Create the instance \"PWM1\" using TIMER1.\r\n    APP_PWM_INSTANCE(PWM2,2);\t\t\t// Create the instance \"PWM2\" using TIMER2.\r\n\r\n    void pwm_ready_callback(uint32_t pwm_id)\r\n    {\r\n        ready_flag = true;\r\n    }\r\n\r\n    ...\r\n\r\n    int main(void) {\r\n    ...\r\n         setup softdevice and ANT here\r\n    ...\r\n\r\n         // begin initialization of PWM channels\r\n         app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(4096L, 25, 26);\r\n         app_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_2CH(4096L, 28, 29);\r\n         //app_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_2CH(4096L, 26, 28);\r\n         // initialize and enable PWM\r\n         pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n         pwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n         err_code = app_pwm_init(&PWM1, &pwm1_cfg, pwm_ready_callback);\r\n         APP_ERROR_CHECK(err_code);\r\n         pwm2_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n         pwm2_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n         err_code = app_pwm_init(&PWM2, &pwm2_cfg, pwm_ready_callback);\r\n         APP_ERROR_CHECK(err_code);\r\n         // enable PWMs\r\n         app_pwm_enable(&PWM1);\r\n         app_pwm_enable(&PWM2);\r\n\r\n         ...\r\n\r\n         while(1) {\r\n                  while (app_pwm_channel_duty_set(&PWM1, 1, 16) == NRF_ERROR_BUSY);\t// left forward\r\n                  while (app_pwm_channel_duty_set(&PWM2, 1, 16) == NRF_ERROR_BUSY);\t// right backward\r\n                  nrf_delay_ms(1000);\r\n                  while (app_pwm_channel_duty_set(&PWM1, 1, 0) == NRF_ERROR_BUSY);\t// left forward\r\n                  while (app_pwm_channel_duty_set(&PWM2, 1, 0) == NRF_ERROR_BUSY);\t// right backward\r\n                  nrf_delay_ms(1000);\r\n         }\r\n\r\nOne observation that I made was that the PWM gets stuck at the first bit of the while loop when both instances are set to '16' percent before restarting. That is, instead of stopping all PWM after 1 second, the PWM continues at 16% duty cycle for several seconds and then restarts.\r\n\r\nThank you for your help.",
    "tag": "pwm"
  },
  {
    "text": "GPS with nRF52 on i2c Hi,\r\n\r\nI am struggling with the Ublox EVA7M with nRF52 on i2c and wonder if anyone can share a sample code of connecting a GPS to the nRF52.\r\nI am unable to make the twi work. I am using the twi_sensor example with the GPS address of 0x42U. My goal is to read the GPS messages and print them on USB UART. \r\nCan someone check the code below as well, please ?\r\n\r\nThanks !\r\n\r\n    /*Common addresses definition for GPS. */\r\n    \r\n    #define GPS_ADDR        (0x42U)\r\n    #define NUMBER_OF_SAMPLES 256\r\n    \r\n    static volatile bool m_xfer_done = true;\r\n    static volatile bool m_set_mode_done = false;\r\n    static const nrf_drv_twi_t m_twi_GPS = NRF_DRV_TWI_INSTANCE(0);\r\n    \r\n    static void uart_events_handler(app_uart_evt_t * p_event)\r\n    {\r\n        switch (p_event->evt_type)\r\n        {\r\n            case APP_UART_COMMUNICATION_ERROR:\r\n                APP_ERROR_HANDLER(p_event->data.error_communication);\r\n                break;\r\n    \r\n            case APP_UART_FIFO_ERROR:\r\n                APP_ERROR_HANDLER(p_event->data.error_code);\r\n                break;\r\n    \r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    \r\n    void read_data(int * p_new_sample)\r\n    {\r\n        printf(\"%c\", *p_new_sample);\r\n    }\r\n    \r\n    static void uart_config(void)\r\n    {\r\n    \r\n        uint32_t                     err_code;\r\n        const app_uart_comm_params_t comm_params =\r\n        {\r\n    \r\n            RX_PIN_NUMBER,\r\n            TX_PIN_NUMBER,\r\n            RTS_PIN_NUMBER,\r\n            CTS_PIN_NUMBER,\r\n            APP_UART_FLOW_CONTROL_DISABLED,\r\n            false,\r\n            UART_BAUDRATE_BAUDRATE_Baud115200\r\n        };\r\n    \r\n        APP_UART_FIFO_INIT(&comm_params,\r\n                           UART_RX_BUF_SIZE,\r\n                           UART_TX_BUF_SIZE,\r\n                           uart_events_handler,\r\n                           APP_IRQ_PRIORITY_LOW,\r\n                           err_code);\r\n    \r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n    {\r\n       \r\n        ret_code_t err_code;\r\n        static int m_sample;\r\n        printf(\"2\\n\");\r\n        switch(p_event->type)\r\n        {\r\n            case NRF_DRV_TWI_EVT_DONE:\r\n                if ((p_event->type == NRF_DRV_TWI_EVT_DONE) &&\r\n                    (p_event->xfer_desc.type == NRF_DRV_TWI_XFER_TX))\r\n                {\r\n                     printf(\"3\\n\");\r\n                    if(m_set_mode_done != true)\r\n                    {\r\n                        m_set_mode_done  = true;\r\n                        return;\r\n                    }\r\n                    m_xfer_done = false;\r\n                    /* Read 4 bytes from the specified address. */\r\n                    err_code = nrf_drv_twi_rx(&m_twi_GPS, GPS_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));\r\n                    APP_ERROR_CHECK(err_code);\r\n                    \r\n                }\r\n                else\r\n                {\r\n                     printf(\"4\\n\");\r\n                    read_data(&m_sample);\r\n                    m_xfer_done = true;\r\n                    \r\n                }\r\n                break;\r\n            default:\r\n                break;        \r\n        }   \r\n    }\r\n    \r\n    \r\n    void twi_init (void)\r\n    {\r\n    \r\n        ret_code_t err_code;\r\n        printf(\"1\\n\");\r\n        const nrf_drv_twi_config_t twi_GPS_config = {\r\n           .scl                = 26,\r\n           .sda                = 27,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n        };\r\n        \r\n        err_code = nrf_drv_twi_init(&m_twi_GPS, &twi_GPS_config, twi_handler, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_twi_enable(&m_twi_GPS);\r\n    }\r\n    \r\n    int main(void)\r\n    {\r\n        uart_config();\r\n        printf(\"\\n\\rTWI sensor example\\r\\n\");\r\n        twi_init();\r\n        uint8_t reg = 0;\r\n        ret_code_t err_code;\r\n        \r\n        while(true)\r\n        {\r\n            nrf_delay_ms(100);\r\n            /* Start transaction with a slave with the specified address. */\r\n            do\r\n            {\r\n                __WFE();\r\n            }while(m_xfer_done == false);\r\n            err_code = nrf_drv_twi_tx(&m_twi_GPS, GPS_ADDR, &reg, sizeof(reg), true);\r\n            //err_code = nrf_drv_twi_rx(&m_twi_GPS, GPS_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));\r\n            printf(\"%c\",reg);\r\n            APP_ERROR_CHECK(err_code);\r\n            m_xfer_done = false;\r\n        }\r\n    }\r\n    \r\n    /** @} */",
    "tag": "i2c"
  },
  {
    "text": "nrf_pwm.h requesting includes for wrong device Hello! I'm trying to use the PWM on a board containing an nRF51822 device. However, simply including the `nrf_pwm.h` file multiple errors are trigered, such as the following (among other):\r\n\r\n - sdk_11/components/drivers_nrf/hal/nrf_pwm.h:68:43: error: unknown type name 'NRF_PWM_Type'\r\n - sdk_11/components/drivers_nrf/hal/nrf_pwm.h:80:37: error: 'PWM_INTENSET_STOPPED_Msk' undeclared here (not in a function)\r\n - sdk_11/components/drivers_nrf/hal/nrf_pwm.h:312:45: error: unknown type name 'NRF_PWM_Type'\r\n\r\n\r\nAfter seraching the SDK I noticed that these defines are available on the iles relative to the nRF52 devices. Since I'm using an nRF51 device, how should I procede?\r\n",
    "tag": "pwm"
  },
  {
    "text": "interrupt entry time and interrupt disable ( nRF52 DK + image sensor ) Hi,\r\n\r\nI am testing that nRF52832 transfer QVGA still image from image sensor to phone as follows.\r\n\r\n1.\tnRF52832(nRF52 DK) is connected with image sensor through some signals(8bit data bus, MCLK, PCLK, HSYNC and VSYNC..)\r\n\r\n2.\tInitialize pin change interrupt by VSYNC signal.\r\n\r\n3.\tWhen user push button, nRF52 DK read QVGA still image from image sensor in VSYNC interrupt service routine.\r\n\r\n4.\tnRF52 DK transfer image to phone by Bluetooth.\r\n\r\n\r\nThen, I have two problems so I ask some questions to you.\r\n\r\nFirst, for pin change interrupt,\r\n\r\nInterval between H/W external interrupt(VSYNC interrupt) generation time and interrupt service routine(pin change interrupt) entry time is about 7.6us(B), but it should be under 0.4us in our project.  \r\nAlso, I had test it in GPIOTE_IRQHandler() but the interval is 2.4us(A). \r\n\r\nIf you have any solution that can decrease interval to under 0.4us, please let me know it.\r\n\r\n![image description](/attachment/c9563e9befffb03675da7a5079ac4b5a)\r\n\r\nHSYNC_IN => HSYNC interrupt signal from image sensor\r\n\r\nDBG_PORT0 => Debug signal which I add in GPIOTE_IRQHandler() start position\r\n\r\nDBG_PORT1 => Debug signal which I add in HSYNC interrupt service routine(pin change int)\r\n\r\nSecond, VSYNC interrupt service routine should not be disturbed by any other interrupt for about 200ms because image sensor output image data by only VSYNC, HSYNC and PCLK timing irrespective of nRF52832.\r\n\r\nThen it seems that other interrupt (RF interrupt?) is disturbing VSYNC interrupt. \r\n\r\nI had changed interrupt priority to Low - High, but read image have noise lines.\r\n\r\nAlso I had changed it to Highest but nRF52832 is not working.\r\n\r\nDo you have any solution that other interrupt does not disturb VSYNC interrupt?\r\n(ex. : RF off => read image data from interrupt => RF on => tx data to phone..)\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "interrupt entry time and interrupt disable ( nRF52 DK + image sensor ) Hi,\r\n\r\nI am testing that nRF52832 transfer QVGA still image from image sensor to phone as follows.\r\n\r\n1.\tnRF52832(nRF52 DK) is connected with image sensor through some signals(8bit data bus, MCLK, PCLK, HSYNC and VSYNC..)\r\n\r\n2.\tInitialize pin change interrupt by VSYNC signal.\r\n\r\n3.\tWhen user push button, nRF52 DK read QVGA still image from image sensor in VSYNC interrupt service routine.\r\n\r\n4.\tnRF52 DK transfer image to phone by Bluetooth.\r\n\r\n\r\nThen, I have two problems so I ask some questions to you.\r\n\r\nFirst, for pin change interrupt,\r\n\r\nInterval between H/W external interrupt(VSYNC interrupt) generation time and interrupt service routine(pin change interrupt) entry time is about 7.6us(B), but it should be under 0.4us in our project.  \r\nAlso, I had test it in GPIOTE_IRQHandler() but the interval is 2.4us(A). \r\n\r\nIf you have any solution that can decrease interval to under 0.4us, please let me know it.\r\n\r\n![image description](/attachment/c9563e9befffb03675da7a5079ac4b5a)\r\n\r\nHSYNC_IN => HSYNC interrupt signal from image sensor\r\n\r\nDBG_PORT0 => Debug signal which I add in GPIOTE_IRQHandler() start position\r\n\r\nDBG_PORT1 => Debug signal which I add in HSYNC interrupt service routine(pin change int)\r\n\r\nSecond, VSYNC interrupt service routine should not be disturbed by any other interrupt for about 200ms because image sensor output image data by only VSYNC, HSYNC and PCLK timing irrespective of nRF52832.\r\n\r\nThen it seems that other interrupt (RF interrupt?) is disturbing VSYNC interrupt. \r\n\r\nI had changed interrupt priority to Low - High, but read image have noise lines.\r\n\r\nAlso I had changed it to Highest but nRF52832 is not working.\r\n\r\nDo you have any solution that other interrupt does not disturb VSYNC interrupt?\r\n(ex. : RF off => read image data from interrupt => RF on => tx data to phone..)\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "No NAK reported with TWI driver? Using nRF5 SDK v11.0.0, I am working on bringing up new hardware based on the nRF52.  I started with code that works on the PCA10040 development board in which we connected an FTDI USB-to-I2C chip.  When switching to our new hardware board, we found that the slave chip was NAKing memory reads/writes; however, the TWI driver did not return any error indication.  I have verified that the data on the SDA line is such that the slave device is sending a NAK (i.e., leaving A = 1) for the data byte.\r\n\r\nSo, although we have a problem with our device, I don't understand why the TWI driver is not reporting back an error indication.  This is very important since the slave chip often uses NAKs to indicate if any bytes are sitting in its queues waiting to be read by the master.\r\n\r\nWe are using nrf_drv_twi.c in blocking mode.  Below is a block of code -- the last line should have some kind of error indication but it does not.\r\n\r\n    static uint8_t twi_usb_mtp_read_byte(uint16_t address)\r\n    {\r\n        uint32_t err_code;\r\n        uint8_t buffer[2];\r\n        uint8_t byte;\r\n    \r\n        buffer[0] = TWI_USB_MTP_ADDR_CMD;\r\n        err_code = nrf_drv_twi_tx(&m_twi_handle, TWI_USB_GENERAL_CALL_ADDR, buffer, 1, true);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        buffer[0] = (uint8_t)((address >> 8) & 0x00FF);\r\n        buffer[1] = (uint8_t)(address & 0x00FF);\r\n        err_code = nrf_drv_twi_tx(&m_twi_handle, TWI_USB_SLAVE_ADDR, buffer, 2, false);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        buffer[0] = TWI_USB_MTP_READ_CMD;\r\n        err_code = nrf_drv_twi_tx(&m_twi_handle, TWI_USB_GENERAL_CALL_ADDR, buffer, 1, true);\r\n        APP_ERROR_CHECK(err_code);\r\n\r\n        /* This call SHOULD return an error based on the physical SDA waveform. */\r\n        err_code = nrf_drv_twi_rx(&m_twi_handle, TWI_USB_SLAVE_ADDR, &byte, 1);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        return byte;\r\n    }\r\n\r\n    void twi_usb_init(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n        const nrf_drv_twi_config_t nrf_drv_twi_config = {\r\n            .scl                = TWI_SCL_PIN,\r\n            .sda                = TWI_SDA_PIN,\r\n            .frequency          = NRF_TWI_FREQ_100K,\r\n            .interrupt_priority = APP_IRQ_PRIORITY_LOW\r\n        };\r\n    \r\n        err_code = nrf_drv_twi_init(&m_twi_handle, &nrf_drv_twi_config, NULL, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_twi_enable(&m_twi_handle);\r\n    \r\n        /* Example that should read a byte from the slave. */\r\n        uint8_t dump = twi_usb_mtp_read_byte(0);\r\n    }\r\n\r\nIs this a known problem in the SDK?  Is there a patch or workaround available?\r\n",
    "tag": "i2c"
  },
  {
    "text": "nrf_gpio_cfg documentation leaves much unclear I guess we need some help with definitions.  Basically, we'd like to read data from an I2C line. Should be as simple as \"set to input\" and \"read the pin\".  However...\r\n\r\nIn the documentation, the nrf_gpio_cfg call has several parameters. Some are obvious; others appear to lack definitions.\r\n\r\n__STATIC_INLINE void nrf_gpio_cfg \t(\tuint32_t \tpin_number, \r\n\t\tnrf_gpio_pin_dir_t  dir, \r\n\t\tnrf_gpio_pin_input_t  input, \r\n\t\tnrf_gpio_pin_pull_t  pull, \r\n\t\tnrf_gpio_pin_drive_t  drive, \r\n\t\tnrf_gpio_pin_sense_t   sense \r\n\t)\t\t\r\n\r\nI\u2019m looking at what the settings should be for reading an I2C line while enabling the internal pullup.\r\n\r\n1)\tPresumably \u201cpin direction\u201d should be NRF_GPIO_PIN_DIR_INPUT.  This seems clear enough.\r\n2)\tInput buffer: what is this? Do I need NRF_GPIO_PIN_INPUT_CONNECT to be able to read a pin? Or is input buffering an additional optional feature?\r\n3)\tFor pullup we presumably set NRF_GPIO_PIN_PULLUP\r\n4)\tFor drive, we set NRF_GPIO_PIN_SOD1 to correspond to I2C standards\r\n5)\tSense mode: what is this? What does \u201csense\u201d mean? Does this correspond to generating an interrupt on an edge? For a binary value, what\u2019s the difference between sensing high and sensing low or not sensing at all? How does this affect the ability to just read the value of the pin using the nrf_gpio_pin_read() call?\r\n\r\nThanks!\r\n",
    "tag": "i2c"
  },
  {
    "text": "Radio Notifications become inverted If I have a high-priority interrupt (or a series of them) that runs long enough to completely mask a radio notification, then all further radio notifications appear inverted. Program architecture aside, **is there any way I can definitely tell whether a notification is an `ACTIVE` or a `nACTIVE`?** It's very troublesome when I get it wrong.\r\n\r\nAs an aside, is there any reason I can't have the radio notification run at priority 0? By definition it will never run at the same time as the lower stack, so it seems like I should be able to make it high priority. And by the same token, is there a reason I can't use priority 2? I can use priority 1, meaning I'm allowed to interrupt the upper stack\u2014any reason I can't just use priority 2 as well?\r\n\r\nAlternatively, is there any way I can make SWI1 take priority over ADC if both interrupts want to run?\r\n\r\nThanks!",
    "tag": "interrupt"
  },
  {
    "text": "PWM Frequency Measurement on nRF52 with SDK 11 Hi,\r\n\r\nI need to measure the frequency of a PWM signal with 50% duty cycle through one of the GPIO pins. The frequency of input PWM signal ranges between 100Hz to 1000Hz.\r\n\r\nI am hoping to measure the PWM frequency in the following way:\r\nI'll wait for the signal to go HIGH, start timing, then wait for the signal to go LOW and stop timing. Then I'll repeat the same process but this time from LOW to HIGH, and then find the average of the two half periods measured.\r\n\r\nI know the above process gives me half of a full period, but since the duty cycle of my PWM signal is 50% I can calculate the PWM frequency based on the averaged value.\r\n\r\nHow can I implement the above process?\r\n\r\nIs there a better way for measuring PWM signals?\r\n\r\nThanks",
    "tag": "pwm"
  },
  {
    "text": "Use restricted interrupt priority levels Is there any reason I can't have the radio notification run at priority 0? By definition it will never run at the same time as the lower stack, so it seems like I should be able to make it high priority.\r\n\r\nBy the same token, is there a reason I can't use priority 2? I can use priority 1, meaning I'm allowed to interrupt the upper stack\u2014any reason I can't just use priority 2 as well?\r\n\r\nAlternatively, is there any way I can make one interrupt (e.g. SWI1) take priority over another (e.g. ADC) if both interrupts want to run?",
    "tag": "interrupt"
  },
  {
    "text": "Changing connection interval cause issue with PWM Edit 2: Files need to reproduce the issue described in this questions:\r\n\r\n[pwm_conn_itvl_bug_files.zip](/attachment/734fb1c7db68d3e977aeb2636cd11018)\r\n\r\nTo reproduce the issue please just replace the main.c and nrf_drv_config.h into a ble_app_uart example in SDK v10.0.0, and put the project files into /s110/arm5_no_packs.\r\n\r\n---\r\n\r\nFurther inspection shows that `sd_ble_gap_ppcp_set()` (at line 127 of attachment's main.c) returns error code 7, which should be `NRF_ERROR_INVALID_PARAM`? This is strange because I believe that 2000ms is still well below the 4s limit.\r\n\r\n---\r\n\r\nEdit 1:\r\n\r\nI am using the PWM library to generate a PWM of period about 27us. After I tried changing the connection interval a little bit, I have noticed that any `max_conn_interval` greater than or equal to `MSEC_TO_UNITS(1999, UNIT_1_25_MS)` cause the PWM signal to become completely wrong. \r\n\r\nFor example, \r\n\r\n- With `MSEC_TO_UNITS(2000, UNIT_1_25_MS)` I am looking at a PWM signal with 3700ms period with 2600ms high. \r\n- Meanwhile, with `MSEC_TO_UNITS(1999, UNIT_1_25_MS)`, I got a PWM signal with 26.80~27.20us period with 13.60us high, very close to my intended 27us period with 50% duty cycle.\r\n\r\nIs there any reason for this? I don't think I see anything mentioned in the PWM library documentation.\r\n\r\nFor reference, I am using SDK v10.0.0, with SoftDevice S110 v8.0.0 on nRF51 DK. I started with ble_app_uart example, strip off all NUS code, add a Device Information Service in with just Serial Number field and now just started working with PWM.\r\n\r\nBelow is all of my code that I think is relevant.\r\n\r\n    #define MIN_CONN_INTERVAL               MSEC_TO_UNITS(1999, UNIT_1_25_MS)             /**< Minimum acceptable connection interval (20 ms), Connection interval uses 1.25 ms units. */\r\n    #define MAX_CONN_INTERVAL               MSEC_TO_UNITS(1999, UNIT_1_25_MS)             /**< Maximum acceptable connection interval (75 ms), Connection interval uses 1.25 ms units. */\r\n\r\n    ...\r\n\r\n    APP_PWM_INSTANCE(PWM, 2);\r\n\r\n    ...\r\n\r\n    /**@brief Function for initializing the Connection Parameters module.\r\n     */\r\n    static void conn_params_init(void)\r\n    {\r\n        uint32_t               err_code;\r\n        ble_conn_params_init_t cp_init;\r\n        \r\n        memset(&cp_init, 0, sizeof(cp_init));\r\n\r\n        cp_init.p_conn_params                  = NULL;\r\n        cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;\r\n        cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;\r\n        cp_init.max_conn_params_update_count   = MAX_CONN_PARAMS_UPDATE_COUNT;\r\n        cp_init.start_on_notify_cccd_handle    = BLE_GATT_HANDLE_INVALID;\r\n        cp_init.disconnect_on_fail             = false;\r\n        cp_init.evt_handler                    = on_conn_params_evt;\r\n        cp_init.error_handler                  = conn_params_error_handler;\r\n        \r\n        err_code = ble_conn_params_init(&cp_init);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\n    ...\r\n\r\n    /** @brief  Initialize PWM signal\r\n      */\r\n    static void pwm_init(void)\r\n    {\r\n        uint32_t err_code;\r\n        app_pwm_config_t pwm_config = APP_PWM_DEFAULT_CONFIG_1CH(27, 29);\r\n        err_code = app_pwm_init(&PWM, &pwm_config, NULL);\r\n        DEBUG_MAIN_PRINTF((\"app_pwm_init returns %d\\n\", err_code));\r\n        DEBUG_MAIN_PRINTF((\"period = %d\\n\", app_pwm_cycle_ticks_get(&PWM)));\r\n        APP_ERROR_CHECK(err_code);\r\n        app_pwm_enable(&PWM);\r\n        \r\n        while (app_pwm_channel_duty_set(&PWM, 0, 100) == NRF_ERROR_BUSY);\r\n    }\r\n\r\n\r\n    /**@brief Application main function.\r\n     */\r\n    int main(void)\r\n    {\r\n        uint32_t err_code;\r\n        bool erase_bonds;\r\n        uint8_t  start_string[] = START_STRING;\r\n        \r\n        // Initialization starts -----------------------------------------------------------------------\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        uart_init();\r\n        buttons_leds_init(&erase_bonds);\r\n        \r\n        pwm_init();\r\n        \r\n        ble_stack_init();\r\n        gap_params_init();\r\n        services_init();\r\n        advertising_init();\r\n        conn_params_init();\r\n        // Initialization ends -------------------------------------------------------------------------\r\n        \r\n        printf(\"%s\",start_string);\r\n        \r\n      \r\n        while (app_pwm_channel_duty_set(&PWM, 0, 50) == NRF_ERROR_BUSY);\r\n\r\n        err_code = ble_advertising_start(BLE_ADV_MODE_FAST);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        \r\n        \r\n        // Enter main loop.\r\n        for (;;)\r\n        {\r\n            power_manage();\r\n        }\r\n    }\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Detect High to Low and Low to High EDGE using GPIO PORT Event Hi,\r\n\r\nI am using the pin change interrupt example provided in the SDK examples. By setting the input sense to NRF_GPIOTE_POLARITY_LOTOHI, the interrupt handler is called and in that i again set the input sense to NRF_GPIOTE_POLARITY_HITOLO so that next time it senses the high to low edge. But it never senses HITOLO. I am not able to find the reason for why this is happening. \r\n\r\nHere is a example of the code\r\n\r\n    nrf_drv_gpiote_init();\r\n    nrf_drv_gpiote_out_init = GPIOTE_CONFIG_OUT_SIMPLE(false);\r\n    nrf_drv_gpiote_in_config_t in_config;\r\n    in_config.sense = NRF_GPIOTE_POLARITY_LOTOHI;\r\n    nrf_drv_gpiote_in_init(PIN_IN, &in_config, gpiote_event_handler);\r\n\r\nNow in the event handler gpiote_event_handler\r\ncase GPIOTE_CONFIG_POLARITY_LoToHi gets called in which i perform LED toggling and set the \r\n\r\n    in_config.sense = NRF_GPIOTE_POLARITY_HITOLO\r\n\r\nNow the next time it should sense High to Low Edge but it never goes into the case GPIOTE_CONFIG_POLARITY_HiToLo\r\n\r\nWhat could be the reason for this? I am using S110 and SDK10.\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Clarification on S110 SDS \"Processor availability and interrupt latency\" I am currently using MBR, and know the general interrupt latency due to MBR + SD from Table 26.  But I cannot understand how you arrived at those numbers.  IF this table was referring to JUST the MBR caused latency, I think it makes sense--assuming that MBR acts deterministically for EVERY interrupt.  But once SD is involved, I do not understand: wouldn't the SD caused interrupt latency change depending on whether there is an outstanding BLE activity?  So are numbers in Table 26 just an average?  If so, what is the maximum and minimum (therefore the jitter)?\r\n\r\nConversely, I understand that high priority app interrupt will interfere with the BLE upper stack performance.  Is there existing doc explaining how long I can take in the high priority app interrupt before I cause a problem?\r\n\r\nThank you very much for reading.",
    "tag": "interrupt"
  },
  {
    "text": "Sending I2C commands via BLE Hello,\r\n\r\nI will explain my setup:\r\n\r\nI have 2 nRF51-DK each one of them connected via I2C and SPI to two different custom boards. One being the central(nrfA) and the other being the peripheral(nrfB), regarding BLE.\r\n\r\nI want to send from **1st board----I2C----> nRFA -----BLE----> nRFB ---I2C--->2nd board**  and the other way around at the same time if needed. I am already using the NUS service to send the data received by SPI so wanted to use a different one for I2C.\r\n\r\nWhat I wanted to know is what is the easiest service or profile to send the I2C commands via BLE? Or is it easier to send SPI and I2C via NUS?\r\n\r\nI thought using the Immediate Alert Service (IAS) to send the I2C commands, but from what I discovered it can only be used on the peripheral side, is this correct?\r\n\r\nI'm using SDK11 and SD130 v2.\r\n\r\nThank you for the help,\r\n\r\nJorge Costa",
    "tag": "i2c"
  },
  {
    "text": "RTC interrupt does not wake up nRF52 I am having issues waking up nRF52 with s132 using the RTC interrupt. The same code is used on nRF51 with s130 and does not show this behavior.\r\n\r\nThe RTC is configured and the interrupts are fired and handled as expected every 10ms. The Softdefice is running but no advertising is enabled. The RTC configuration looks like:\r\n\r\n    NRF_RTC1->PRESCALER = 0;\r\n    NRF_RTC1->CC[0] = 32768 / 100;\r\n    NRF_RTC1->INTENCLR = 0xffffffffUL;\r\n    NRF_RTC1->INTENSET = (RTC_INTENSET_COMPARE0_Set << RTC_INTENSET_COMPARE0_Pos);\r\n    NRF_RTC1->TASKS_START = 1;\r\n    \r\n    result = sd_nvic_ClearPendingIRQ (RTC1_IRQn);\r\n    ASSERT (result == NRF_SUCCESS);\r\n    result = sd_nvic_SetPriority (RTC1_IRQn,NRF_APP_PRIORITY_LOW);\r\n    ASSERT (result == NRF_SUCCESS);\r\n    result = sd_nvic_EnableIRQ (RTC1_IRQn);\r\n    ASSERT (result == NRF_SUCCESS);\r\n\r\n\r\nThe problem occures when sending the nRF52 into sleep mode with:\r\n\r\n    result = sd_app_evt_wait();\r\n\r\nCompared to the nRF51 the nRF52 is not woken up by the RTC interrupt. Setting the Send Event on Pending bit in the System Control Register fixes the problem but it should not be necessary to set it: \r\n\r\n    SCB->SCR |= SCB_SCR_SEVONPEND_Msk;\r\n\r\nWhy is it necessary to set the the bit on nRF52? The interrupt for RTC is enabled and fired when the CPU is not sleeping. Did I miss a configuration on nRF52 which is not needed on nRF51?",
    "tag": "interrupt"
  },
  {
    "text": "nrf pwm library increases current consumption Hi, \r\nI am using nrf pwm library from here: https://github.com/NordicSemiconductor/nrf51-pwm-library.  I am driving two gpios for a piezo buzzer.\r\n\r\nI call pwm_init(), then use the call set_frequency_and_duty_cycle() to start pwm.\r\nTo stop, I call nrf_pwm_set_enabled(false)\r\n\r\nThe buzzer starts and stops fine. However, after calling nrf_pwm_set_enabled(false), the current consumption is now increased by 300 micro amps.\r\n\r\nHow do I decrease the current consumption?\r\n",
    "tag": "pwm"
  },
  {
    "text": "Getting started with PWM on nRF52 I am quite new to embedded firmware development and definitely just two days old into Nordic nRF52 development.\r\n\r\nI want to just setup a 25% duty cycle clock output on GPIO pin 5 for nRF52 with 100 KHz frequency. How can I do this with using just the drivers_nrf header files? I believe that I don't need to setup any IRQ handler for this, correct?\r\n\r\nI do not plan to use any SoftDevice and right now want something very simple so that that I can experiment and learn. Just just the static inline functions from components\\drivers_nrf\\hal\\ folder if possible.\r\n\r\nI see some sample code online that seems to use NRF_TIMER along with PWM_IRQHandler. But I thought that I could use PWM without any CPU interaction. Can't I use the NRF_PWM resources? I was hoping to find sample code that uses nrf_pwm_pins_set() and nrf_pwm_configure() etc. to just get a simple clock.\r\n\r\nI was hoping to have code similar to below but all examples I see use the TIMER2 instead. It feels like I am missing something major...\r\n\r\n    uint32_t out_pins[] = {5, NRF_PWM_PIN_NOT_CONNECTED, NRF_PWM_PIN_NOT_CONNECTED, NRF_PWM_PIN_NOT_CONNECTED};\r\n    static uint16_t pwm_seq[2] = {0x8800, 0x0800};\r\n    nrf_pwm_sequence_t const seq = \r\n    {\r\n        .values.p_common = pwm_seq,\r\n        .length          = sizeof(pwm_seq)/sizeof(uint16_t),\r\n        .repeats         = 0,\r\n        .end_delay       = 0\r\n    };\r\n\r\n    nrf_gpio_cfg_output(5);\r\n    nrf_pwm_pins_set(NRF_PWM0, out_pins);\r\n    nrf_pwm_enable(NRF_PWM0);\r\n    nrf_pwm_configure(NRF_PWM0, NRF_PWM_CLK_16MHz, NRF_PWM_MODE_UP, 1600);\r\n    nrf_pwm_loop_set(NRF_PWM0, 0);\r\n    nrf_pwm_decoder_set(NRF_PWM0, NRF_PWM_LOAD_COMMON, NRF_PWM_STEP_AUTO);\r\n\r\n    nrf_pwm_sequence_set(NRF_PWM0, 0, &seq);\r\n    \r\n    NRF_PWM0->TASKS_SEQSTART[0] = 1;\r\n\r\nBTW - this is on my custom board and not on dev-kit but that should really matter much. Any pointers appreciated. Thanks!",
    "tag": "pwm"
  },
  {
    "text": "Reading from HMC5883L using I2C Hi,\r\n\r\nI am currently in the process of interfacing the HMC5883L magnetometer with my nrf52 development board. I have verified the connection to be working using a logic analyzer. Furthermore, I have configured the sensor according to another post made here on this forum:\r\n\r\n    #define HMC5883L_ADDR (0x3CU>>1)\r\n    #define HMC5883L_REG_CONF_A (0x00) \r\n    #define HMC5883L_REG_CONF_B (0x01) \r\n    #define HMC5883L_REG_MODE (0x02) \r\n    #define HMC5883L_REG_X_MSB (0x03) \r\n    #define HMC5883L_REG_X_LSB (0x04)\r\n    uint8_t reg[3] = {0x3C, HMC5883L_REG_CONF_A, 0x70};\r\n    uint8_t reg1[3] = {0x3C, HMC5883L_REG_CONF_B, 0xA0};\r\n    uint8_t reg2[3] = {0x3C, HMC5883L_REG_MODE, 0x00};\t\r\n    \r\n    err_code = nrf_drv_twi_tx(&m_twi_master, HMC5883L_ADDR, reg, sizeof(reg), false);  \r\n    APP_ERROR_CHECK(err_code);\r\n    nrf_delay_ms(100);\r\n    err_code = nrf_drv_twi_tx(&m_twi_master, HMC5883L_ADDR, reg1, sizeof(reg), false);  \r\n    APP_ERROR_CHECK(err_code);\r\n    nrf_delay_ms(100);\r\n    err_code = nrf_drv_twi_tx(&m_twi_master, HMC5883L_ADDR, reg2, sizeof(reg), false);  \r\n    APP_ERROR_CHECK(err_code);\r\n\r\nCurrently I am trying to read the data into a buffer according to the following code\r\n\r\n    uint8_t reg3[2] = {0x3D, 0x03};\r\n    uint8_t reg4[2] = {0x3C, 0x03};\r\n\r\n    uint8_t buff_t[6];\r\n    short combined_x;\r\n    short combined_y;\r\n    short combined_z;\r\n    \r\n    while(1)\r\n    {\r\n        nrf_delay_ms(10);\r\n\r\n        nrf_drv_twi_tx(&m_twi_master, HMC5883L_ADDR, reg3, sizeof(reg3),false); // Point to register\t\t\t\r\n        nrf_drv_twi_rx(&m_twi_master, HMC5883L_ADDR, buff_t, 6); // Read register and fill buffer\t\t\r\n        nrf_drv_twi_tx(&m_twi_master, HMC5883L_ADDR, reg4, sizeof(reg4),false); // Reset register\t\t\t\r\n\t\t\t\r\n        combined_x = (buff_t[0] << 8 ) | (buff_t[1] & 0xff);\r\n        combined_y = (buff_t[2] << 8 ) | (buff_t[3] & 0xff);\r\n        combined_z = (buff_t[4] << 8 ) | (buff_t[5] & 0xff);\r\n    }\r\n\r\nwhich gives me this logic:![image description](/attachment/ab29da1eb7138f266f9c2d760fb70959)\r\n\r\nThere is no data visible in the buffer and according to the logic analyzer, there is also no data received over the data pin.\r\n\r\nCan someone help me out here?",
    "tag": "i2c"
  },
  {
    "text": "PWM clock on nRF52 does not lock on oscilloscope I have a very simple program that generates a 50% duty cycle clock using the NRF_PWM0 on the new nRF52 device. Unfortunately, my Tektronix 1GHz oscilloscope doesn't lock to the signal. If I used a Timer and GPIOTE with PPI then the clock was perfect.\r\n\r\nI am wondering if the PWM_CLK input to the PWM hardware resource is not correct. The reference manual just uses the PWM_CLK in description but doesn't describe what it is or how do I configure or start/lock it. Any ideas?\r\n\r\nNote that I am not using any SoftDevice and this is on a custom board with just the nRF52 part and nothing else.\r\n\r\n    int main (void)\r\n    {\r\n        // Start 16 MHz crystal oscillator .\r\n        NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;\r\n        NRF_CLOCK->TASKS_HFCLKSTART    = 1;\r\n\r\n        // Wait for the external oscillator to start up.\r\n        while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0) {\r\n        }\r\n \r\n        NRF_PWM0->ENABLE = (PWM_ENABLE_ENABLE_Enabled << PWM_ENABLE_ENABLE_Pos);\r\n        NRF_PWM0->PRESCALER = NRF_PWM_CLK_1MHz;\r\n        NRF_PWM0->MODE = NRF_PWM_MODE_UP;\r\n        NRF_PWM0->COUNTERTOP = 20;\r\n        NRF_PWM0->PSEL.OUT[0] = 6;\r\n        NRF_PWM0->PSEL.OUT[1] = NRF_PWM_PIN_NOT_CONNECTED;\r\n        NRF_PWM0->PSEL.OUT[2] = NRF_PWM_PIN_NOT_CONNECTED;\r\n        NRF_PWM0->PSEL.OUT[3] = NRF_PWM_PIN_NOT_CONNECTED;\r\n        NRF_PWM0->DECODER = ((uint32_t)NRF_PWM_LOAD_INDIVIDUAL << PWM_DECODER_LOAD_Pos) |\r\n                            ((uint32_t)NRF_PWM_STEP_AUTO << PWM_DECODER_MODE_Pos);\r\n        NRF_PWM0->SHORTS = 0;\r\n        NRF_PWM0->INTEN = 0;\r\n        static nrf_pwm_values_individual_t duty = \r\n        {\r\n            .channel_0 = 10,\r\n            .channel_1 = 10,\r\n            .channel_2 = 10,\r\n            .channel_3 = 10,\r\n        };\r\n\r\n        NRF_PWM0->SEQ[0].PTR = (uint32_t)&duty;\r\n        NRF_PWM0->SEQ[0].CNT = NRF_PWM_VALUES_LENGTH(duty);\r\n        NRF_PWM0->SEQ[0].REFRESH = 0;\r\n        NRF_PWM0->SEQ[0].ENDDELAY = 0;\r\n        NRF_PWM0->TASKS_SEQSTART[0] = 1;\r\n\r\n        while (1) {\r\n        }\r\n    }\r\n\r\nThanks a lot!",
    "tag": "pwm"
  },
  {
    "text": "Is there a possible clash of RTC1 usage? I have an mBed application that uses the S130 SoftDevice and polls data from a couple of other connected peripherals via I2C & SPI.\r\n\r\nI use a Ticker object, which seems to basically be a wrapper around the Nordic app_timer implementation and exposes RTC1 ticks to my application. This single Ticker is used to control polling & other timings across the application.\r\n\r\nEvery now and then the application-level stuff becomes unresponsive (and a hard reset is needed to make it work again) but the Softdevice is definitely running underneath & the hardware remains connected to whatever app I'm using.\r\n\r\nI suspect some sort of collision or missed RTC1 interrupt from the Ticker implementation which then leaves the all hardware & timer interrupts to never get reset.\r\n\r\nMy question is to anyone more familiar with RTC1 usage (and ideally mbed). Does my interrupt miss/collision theory sound plausible? Where should I look for other uses of RTC1 and things that could interrupt it?\r\n\r\nWould an SPI device triggered via a hardware IRQ line possible collide with a timer interrupt & cause it not to set?",
    "tag": "interrupt"
  },
  {
    "text": "Issues with PWM on nRF52 I have encountered two issues while using the NRF PWM driver on the nRF52 DK, with or without SoftDevice S132, along with SDK v11.0.0\r\n\r\nThe first one is the use of the NRF_DRV_PWM_PIN_INVERTED flag. Looking at the oscilloscope, I don't see the waveform's polarity changed, whether I `OR` the pin output number with the flag or not.\r\n\r\nThe second is stepping through a looped sequence. I never see the last duty value of my sequence being applied.\r\n\r\nWhat could be going wrong, or what could I be missing here?\r\n\r\nBelow is the main.c I used to produce the issues without SoftDevice. It should run by just replacing main.c in peripheral\\pwm_driver example.\r\n[main.c](/attachment/2fd543e6e069b60aaa3ac3416efe6932)",
    "tag": "pwm"
  },
  {
    "text": "Issues with PWM on nRF52 I have encountered two issues while using the NRF PWM driver on the nRF52 DK, with or without SoftDevice S132, along with SDK v11.0.0\r\n\r\nThe first one is the use of the NRF_DRV_PWM_PIN_INVERTED flag. Looking at the oscilloscope, I don't see the waveform's polarity changed, whether I `OR` the pin output number with the flag or not.\r\n\r\nThe second is stepping through a looped sequence. I never see the last duty value of my sequence being applied.\r\n\r\nWhat could be going wrong, or what could I be missing here?\r\n\r\nBelow is the main.c I used to produce the issues without SoftDevice. It should run by just replacing main.c in peripheral\\pwm_driver example.\r\n[main.c](/attachment/2fd543e6e069b60aaa3ac3416efe6932)",
    "tag": "pwm"
  },
  {
    "text": "GPIOTE PWM config question Hi, in the (not great) mBed PWM driver, when setting up GPIOTE to toggle the output pin they do this:\r\n\r\n\r\n    /** @brief Function for initializing the GPIO Tasks/Events peripheral.\r\n     */\r\n    void gpiote_init(PinName pin, uint8_t channel_number)\r\n    {\r\n        // Connect GPIO input buffers and configure PWM_OUTPUT_PIN_NUMBER as an output.\r\n        NRF_GPIO->PIN_CNF[pin] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)\r\n                                | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)\r\n                                | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)\r\n                                | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)\r\n                                | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);\r\n        NRF_GPIO->OUTCLR = (1UL << pin);\r\n        // Configure GPIOTE channel 0 to toggle the PWM pin state\r\n        // @note Only one GPIOTE task can be connected to an output pin.\r\n        /* Configure channel to Pin31, not connected to the pin, and configure as a tasks that will set it to proper level */\r\n        NRF_GPIOTE->CONFIG[channel_number] = (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos) |\r\n                                             (31UL << GPIOTE_CONFIG_PSEL_Pos) |\r\n                                             (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos);\r\n        /* Three NOPs are required to make sure configuration is written before setting tasks or getting events */\r\n        __NOP();\r\n        __NOP();\r\n        __NOP();\r\n        /* Launch the task to take the GPIOTE channel output to the desired level */\r\n        NRF_GPIOTE->TASKS_OUT[channel_number] = 1;\r\n    \r\n        /* Finally configure the channel as the caller expects. If OUTINIT works, the channel is configured properly.\r\n           If it does not, the channel output inheritance sets the proper level. */\r\n        NRF_GPIOTE->CONFIG[channel_number] = (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos) |\r\n                                             ((uint32_t)pin << GPIOTE_CONFIG_PSEL_Pos) |\r\n                                             ((uint32_t)GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos) |\r\n                                             ((uint32_t)GPIOTE_CONFIG_OUTINIT_Low << GPIOTE_CONFIG_OUTINIT_Pos); // ((uint32_t)GPIOTE_CONFIG_OUTINIT_High <<\r\n                                                                                                                 // GPIOTE_CONFIG_OUTINIT_Pos);//\r\n    \r\n        /* Three NOPs are required to make sure configuration is written before setting tasks or getting events */\r\n        __NOP();\r\n        __NOP();\r\n        __NOP();\r\n    }\r\n\r\n\r\nCan someone explain why they set pin 31 (which doesn't exist) to low using GPIOTE? What won't work if you only do the final `CONFIG`? Also what do the mean by `If OUTINIT works`? Does it not always work?",
    "tag": "pwm"
  },
  {
    "text": "Example code for nrf52 with 128x32 OLED? Hi I am trying to get my 128x32 oled device working with my nrf52 development kit board. Using PCA10040. Does anyone have or know of any example code that can get it up and running? Also I plan on using it with I2C connections. Thanks",
    "tag": "i2c"
  },
  {
    "text": "Different endpoint pairs can share the same PWM at the same time? we have the function using Timer1 to generate the PWM by ourself, not using pwm lib.\r\nit just like the following:\r\n\r\n    void function1(int endpoint1, int endpoint2)   // generate pwm at endpint1 and endpint2\r\n\r\nin this function, we control to set 1/0 and last time  at endpoint1 and endpoint2. \r\n\r\nat different time, we can invoke this function by different endpoint pair..for example, ep1,ep2;\r\n\r\nand ep3,ep4, and ep5,ep6;  everything looks fine.    my question is that we need ep1-ep2, and ep3-ep4  these two endpoint pair  invoke this function at the same time.   Is it ok ? or  have some risk for long time running.",
    "tag": "pwm"
  },
  {
    "text": "\"CLOCK_CONFIG_XTAL_FREQ\" is undefined Hello,\r\n\r\nI am trying to configure my NRF52 dev kit (PCA 10040) to work with pwm using the build-in timer. I used some code from the low_power_pwm example but when I am using it in my code with the libraries included I get these 3 errors:\r\n\r\nidentifier \"CLOCK_CONFIG_XTAL_FREQ\" is undefined\r\n      nrf_clock_xtalfreq_set(CLOCK_CONFIG_XTAL_FREQ);\r\nidentifier \"CLOCK_CONFIG_LF_SRC\" is undefined\r\n      nrf_clock_lf_src_set((nrf_clock_lf_src_t)CLOCK_CONFIG_LF_SRC);\r\nidentifier \"CLOCK_CONFIG_IRQ_PRIORITY\" is undefined\r\n\r\nI have included the same libraries and drivers from the example into my code (except for nrf_nvic.c) but it still gives me these errors. Also I am using the debug out pins if that helps. Any advice? Thanks.",
    "tag": "pwm"
  },
  {
    "text": "Is that possible to generate three PWM with softdevice? Hi,\r\n\r\nIn my application, I need 3 PWM to drive LED. Each PWM will have the same frequency but not the same duty cycle. \r\nIs that possible to do that? \r\nI know that Timer0 is used by softdevice so I can only use 2 timer.\r\n\r\nFurthermore, I will use current time sevice + 1 RTC to use as clock (need to light up the LED to some given time slot). \r\n\r\nThanks in advance for your help.  ",
    "tag": "pwm"
  },
  {
    "text": "Control BLE GPIO Hi,\r\nCan anyone suggest me a program that can control GPIO pins in nRF51822 from mobile?",
    "tag": "pwm"
  },
  {
    "text": "Can all GPIO pins be mapped as a external interupt pin? Hello ,\r\n\r\nEasy question, I am using the nRF52832 and am trying to find out if all gpio pins have gpiote functionality? And if so can all gpios be configured as an external interrupt to wake MCU from deep sleep mode?\r\n\r\nThanks",
    "tag": "interrupt"
  },
  {
    "text": "UART and I2C conflict on nrf51 with S130 I am working on application where the nrf51 will read information from several sensors and send the data to a smartphone app via BLE.  Among the sensors are one that sends a 23 byte message via UART at 9600 Baud about once a second and an Si7021 temp/humidity sensor over I2C.  I am using the S130 Softdevice, and currently am prototyping using the nrf51 DK board.  \r\n\r\nI have a timer setup to trigger once a second, in order to prepare the sensor data and send it over BLE.  This timeout handler routine seems like the natural place to put my blocking I2C code, but if I leave it here, then the application resets about every minute or so.  If I dump a bunch of data into the UART, it resets immediately.  If I comment out the I2C routine, then I can send the UART as much data as I want with no resets.  I am currently circumventing the problem by running the I2C code from the UART handler routine only after having received a complete message, so I know more UART data won't be received while the I2C is running.\r\n\r\nI don't like this workaround, and can not explain why I2C and UART read are not coexisting.  I have tried to include the most relevant code snippets below; let me know if you need to see more.  Thanks!\r\n\r\nAddendum 1: I had to set the TWI to \".interrupt_priority = APP_IRQ_PRIORITY_HIGH\" to call it from inside the timeout, or else it resets immediately.  With APP_IRQ_PRIORITY_HIGH, it takes about a minute to reset with normal sensor input.\r\n\r\nAddendum 2: I've spent some time with the debugger now, and determined that reset is triggered from inside the uart handler routine, and appears to be an over run of the 6 byte hardware UART receive buffer.  It's ok in my application to miss a message from the sensor occasionally, so I've tried to implement error handling for this case:\r\n\r\n \r\n\r\n   \r\n\r\n    case APP_UART_COMMUNICATION_ERROR:\r\n            if (p_event->data.error_communication == UART_ERRORSRC_OVERRUN_Msk)\r\n            {\r\n                // do I need more in here?\r\n                app_uart_flush();\r\n                index = 0;\r\n                uart_receive_state = WAIT_FOR_MSG;\r\n                printf(\"overrun!\\r\\n\");\r\n            } else {\r\n                APP_ERROR_HANDLER(p_event->data.error_communication);\r\n            }\r\n            break;\r\n\r\nThis seems to work, but I wonder- \r\n1. Should I add anything to this to clear the error, the hardware buffer, or anything else?\r\n2. Seems strange to me that the nrf51 can't keep up with this at 9600 Baud with BLE and some other peripherals- is that surprising?  This is a Commercial-Off-The-Shelf sensor with a UART interface, that like very many others, does NOT support hardware flow control.\r\n\r\nOriginal code below:\r\n\r\n        static void uart_init(void)\r\n    {\r\n        uint32_t                     err_code;\r\n        const app_uart_comm_params_t comm_params =\r\n        {\r\n            //RX_PIN_NUMBER, \r\n            12,\r\n            TX_PIN_NUMBER,\r\n            RTS_PIN_NUMBER,\r\n            CTS_PIN_NUMBER,\r\n            APP_UART_FLOW_CONTROL_DISABLED,\r\n            false,\r\n            UART_BAUDRATE_BAUDRATE_Baud9600\r\n        };\r\n    \r\n        APP_UART_FIFO_INIT( &comm_params,\r\n                           UART_RX_BUF_SIZE,\r\n                           UART_TX_BUF_SIZE,\r\n                           uart_event_handle,\r\n                           APP_IRQ_PRIORITY_LOW,  // should this be high?\r\n                           err_code);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    void uart_event_handle(app_uart_evt_t * p_event)\r\n    {\r\n    \r\n        switch (p_event->evt_type)\r\n        {\r\n            case APP_UART_DATA_READY:\r\n                UNUSED_VARIABLE(app_uart_get(&this_uart_char));\r\n                            \r\n                switch (uart_receive_state)\r\n                {\t\t\r\n    \t\t\t\t// parse uart output here and do this upon completion of message\r\n                    Si7021_read();                               \r\n                } \r\n                break;\r\n    \r\n            case APP_UART_COMMUNICATION_ERROR:\r\n                APP_ERROR_HANDLER(p_event->data.error_communication);\r\n                break;\r\n    \r\n            case APP_UART_FIFO_ERROR:\r\n                APP_ERROR_HANDLER(p_event->data.error_code);\r\n                break;\r\n    \r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    \r\n    void twi_init (void)\r\n    {\r\n        ret_code_t err_code;\r\n        \r\n        const nrf_drv_twi_config_t twi_si_7021_config = {\r\n           .scl                = SI7021_I2C_SCL_PIN,\r\n           .sda                = SI7021_I2C_SDA_PIN,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_LOW // was high\r\n        };\r\n        \r\n        err_code = nrf_drv_twi_init(&m_twi_si_7021, &twi_si_7021_config, NULL, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_twi_enable(&m_twi_si_7021);\r\n    }\r\n    \r\n    void Si7021_read( void )\r\n    {\r\n        ret_code_t err_code;\r\n        static uint16_t m_sample;\r\n    \tuint8_t reg;\r\n        uint16_t this_sample;\r\n    \t\r\n    \treg = SI7021_HUMD_MEASURE_HOLD;\r\n        err_code = nrf_drv_twi_tx(&m_twi_si_7021, SI7021_ADDR, &reg, sizeof(reg), true);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        /* Read 2 bytes from the specified address. */\r\n        err_code = nrf_drv_twi_rx(&m_twi_si_7021, SI7021_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        this_sample = (m_sample>>8) | (m_sample<<8);\r\n        \r\n    \thumidity = (float)this_sample * 125 / 65536.0 - 6;\r\n    \t\t\r\n    \treg = SI7021_TEMP_PREV;\r\n        err_code = nrf_drv_twi_tx(&m_twi_si_7021, SI7021_ADDR, &reg, sizeof(reg), true);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        /* Read 2 bytes from the specified address. */\r\n        err_code = nrf_drv_twi_rx(&m_twi_si_7021, SI7021_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        this_sample = (m_sample>>8) | (m_sample<<8);\r\n    \r\n        temperature = (float)this_sample * 175.72 / 65536.0 - 46.85;    \r\n        \r\n    }\r\n    \r\n    static void timers_init(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n        // Initialize timer module.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n    \r\n        // Create timers.\r\n    \r\n        err_code = app_timer_create(&m_sensor_timer_id,\r\n                                    APP_TIMER_MODE_REPEATED,\r\n                                    sensor_timeout_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    static void sensor_timeout_handler(void * p_context)\r\n    {\r\n        // if I do this here, the firmware resets if the UART is receiving much data\r\n        //Si7021_read();\r\n    \r\n        // at this point, get data together from sensors and send over BLE ( S130 softdevice ) \t\r\n    }",
    "tag": "i2c"
  },
  {
    "text": "Synchronizing DMA SAADC with PWM using nRF52 We have an optical measurement system where we need to pulse LED and sample a phototransistor precisely during the LED pulse. The rate of sampling is 1 kHz and we plan to use 1:10 pulse ratio for the LED.\r\n\r\nThis far, I have written a working system than samples at 1 kHz using SAADC and DMA (using four channels, actually). The LED is not pulsed yet, but is on all the time.\r\n\r\nI guess it is relatively simple to use pulse width modulation (PWM) to pulse the LED. However, I need to sychronize ADC with the PWM pulse. In another words, analog-to-digital conversion must happen about 100 us after the LED is put on.\r\n\r\nMy question is how to get this done? It would be best to stay in DMA based ADC, but is the synchronization with PWM possible? Or do I need to switch to interrupt based ADC (hopefully not)?\r\n",
    "tag": "pwm"
  },
  {
    "text": "nrf51822 tempeture based on interrupt I can read temp value by pulling flag but I Want to do that by interrupt\r\nI added this code to my Keil but interrupt on temp didn't work. \r\nI use Adc interrupt like this definition.\r\n\r\n\r\n    static void temp_init(void){\t\r\n\t\r\n\tNRF_TEMP->INTENSET |= TEMP_INTENSET_DATARDY_Enabled;   \r\n\tsd_nvic_SetPriority(TEMP_IRQn, NRF_APP_PRIORITY_LOW);  \r\n\tsd_nvic_EnableIRQ(TEMP_IRQn);\r\n\t\r\n\tNRF_TEMP->POWER = 1 ; \r\n    }/* Interrupt handler for TEMP data ready event */\r\n    void TEMP_IRQHandler(void){\r\n\tint32_t volatile temp;\r\n        NRF_TEMP->EVENTS_DATARDY = 0;\r\n\r\n        /**@note Workaround for PAN_028 rev2.0A anomaly 29 - TEMP: Stop task clears the TEMP register. */\r\n        temp = (nrf_temp_read() / 4);\r\n\r\n        /**@note Workaround for PAN_028 rev2.0A anomaly 30 - TEMP: Temp module analog front end does not power down when DATARDY event occurs. */\r\n        NRF_TEMP->TASKS_STOP = 1; /** Stop the temperature measurement. */\r\n\r\n        printf(\" temperature: %d\\n\\r\", (int)temp);\r\n    }\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "\"Peripherals overlap. SPI0, SPIS0, TWI0, TWIS0 - only one of these can be enabled.\" I'm trying a project (nrf52) where I use both twi and spi to communicate with a set of sensors (each with a different protocol (twi, spi). after enablling TWI0 and SPI0 I got directive error :\r\n\r\n    \"Peripherals overlap. SPI0, SPIS0, TWI0, TWIS0 - only one of these can be enabled.\"\r\n\r\ndoes that means that I cant use both I2C and SPI in same time?",
    "tag": "i2c"
  },
  {
    "text": "How to modify the PWM value with easydma   for NRF52??? now\uff0cI  want to use a serial port to transmit data, to change the duty and cycle  of PWM .",
    "tag": "pwm"
  },
  {
    "text": "connect temperature sensor with nrf52 Hello Everyone,\r\n\r\nI want to connect an MCP9808T-E/MC (temperature sensor) with the nrf52. Therefor I want to use I2C. \r\n\r\nI use the following example:\r\n\r\n    <nRF5_SDK_v11_0_0 folder>\\examples\\ble_peripheral\\experimental_ble_app_eddystone\\\r\n\r\nAre there any prefabricated functions/code witch I could use for this (besides TWI Sensor Example)?\r\n\r\n\r\nThanks!\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "example for i2c and s132 Hello everyone,\r\n\r\nthere is so much i2c code in the nrf52_bitfields.h (s132). \r\n\r\nIs there any example for i2c and s132?\r\n\r\nThanks!\r\n",
    "tag": "i2c"
  },
  {
    "text": "Softdevice and pwm Hi. I used softdevice 9.0 and s110 8.0.0.\r\n\r\nI want to make 38khz pulse.\r\n\r\nso i tried to use nrf_drv_timer. and i used timer1.\r\n\r\nWhen i used softdevice and nrf_drv_timer, timer was working.\r\n\r\nbut after a few mintes system was stop.\r\n\r\nIn order to make 38khz with softdeivce, what can i do ?\r\n\r\nplease help me .. \r\n\r\n ",
    "tag": "pwm"
  },
  {
    "text": "Problem with the NRF_DRV_TWI_INSTANCE(0) (twi/i2c) Hello!\r\n\r\nI want to connect the MCP9808 with the nrf52832. Therefor I use i2C. \r\n\r\nMy example on the nrf52832 is the: \r\n\r\n    <nRF5_SDK_v11_0_0 folder>\\examples\\ble_peripheral\\experimental_ble_app_eddystone\\\r\n\r\nNow, I have written the code of the twi_sensor example in the eddystone example. \r\n\r\nBut, there is an error on:\r\n\r\n    static const nrf_drv_twi_t m_twi_mcp9808 = NRF_DRV_TWI_INSTANCE(0);\r\n\r\nerror: use undeclared identifier \u2018TWI0_USE_EASY_DMA\u2019\r\n\r\nerror: use undeclared identifier \u2018TWI0_INSTANCE_INDEX\u2019\r\n\r\nerror: use undeclared identifier \u2018TWI0_USE_EASY_DMA\u2019\r\n\r\n\r\nWhat is wrong? \r\n\r\nI have include the \"nrf_drv_twi.h\" with the identification. \r\n\r\n\r\n----------\r\n\r\n\r\nMy main Code:\r\n\r\n        #include <stdbool.h>\r\n        #include <stdint.h>\r\n        #include \"ble_advdata.h\"\r\n        #include \"nordic_common.h\"\r\n        #include \"softdevice_handler.h\"\r\n        #include \"bsp.h\"\r\n        #include \"app_timer.h\"\r\n        #include \"nrf_temp.h\" \r\n        #include \"boards.h\"\r\n        #include \"app_util_platform.h\"\r\n        #include \"app_error.h\"\r\n        #include \"nrf_drv_twi.h\"\r\n        #include \"nrf_delay.h\"\r\n        \r\n        /*Pins to connect shield. */\r\n        #define DEVICE_SCL_PIN 0\r\n        #define DEVICE_SDA_PIN 1\r\n        \r\n        /*Common addresses definition for accelereomter. */\r\n        #define TEMP_ADDR        (0x18U)\r\n        \r\n        #define TEMP_REG_RFU   \t 0x00U\r\n        #define TEMP_REG_CONFIG  0x01U\r\n        #define TEMP_REG_TUPPER  0x02U\r\n        #define TEMP_REG_TLOWER  0x03U\r\n        #define TEMP_REG_TCRIT   0x04U\r\n        #define TEMP_REG_TEMP\t   0x05U\r\n        #define TEMP_REG_MID\t   0x06U\r\n        #define TEMP_REG_DID\t   0x07U\r\n        #define TEMP_REG_RESR    0x08U\r\n        \r\n        \r\n        // [max 255, otherwise \"int16_t\" won't be sufficient to hold the sum\r\n        //  of accelerometer samples]\r\n        #define NUMBER_OF_SAMPLES 20\r\n        \r\n    \r\n        \r\n        #define IS_SRVC_CHANGED_CHARACT_PRESENT 0                                 /**< Include the service changed characteristic. If not enabled, the server's database cannot be changed for the lifetime of the device. */\r\n        \r\n        #define CENTRAL_LINK_COUNT              0                                 /**< Number of central links used by the application. When changing this number remember to adjust the RAM settings*/\r\n        #define PERIPHERAL_LINK_COUNT           0                                 /**< Number of peripheral links used by the application. When changing this number remember to adjust the RAM settings*/\r\n        \r\n        #define APP_CFG_NON_CONN_ADV_TIMEOUT    0                                 /**< Time for which the device must be advertising in non-connectable mode (in seconds). 0 disables the time-out. */\r\n        #define NON_CONNECTABLE_ADV_INTERVAL    MSEC_TO_UNITS(1000, UNIT_0_625_MS) /**< The advertising interval for non-connectable advertisement (100 ms). This value can vary between 100 ms and 10.24 s). */\r\n        \r\n        // Eddystone common data\r\n        #define APP_EDDYSTONE_UUID              0xFEAA                            /**< UUID for Eddystone beacons according to specification. */\r\n        #define APP_EDDYSTONE_RSSI              0xEE                              /**< 0xEE = -18 dB is the approximate signal strength at 0 m. */\r\n        \r\n        // Eddystone UID data\r\n        #define APP_EDDYSTONE_UID_FRAME_TYPE    0x00                              /**< UID frame type is fixed at 0x00. */\r\n        #define APP_EDDYSTONE_UID_RFU           0x00, 0x00                        /**< Reserved for future use according to specification. */\r\n        #define APP_EDDYSTONE_UID_ID            0x01, 0x02, 0x03, 0x04, \\\r\n                                                0x05, 0x06                        /**< Mock values for 6-byte Eddystone UID ID instance.  */\r\n        #define APP_EDDYSTONE_UID_NAMESPACE     0xAA, 0xAA, 0xBB, 0xBB, \\\r\n                                                0xCC, 0xCC, 0xDD, 0xDD, \\\r\n                                                0xEE, 0xEE                        /**< Mock values for 10-byte Eddystone UID ID namespace. */\r\n        \r\n        // Eddystone URL data\r\n        #define APP_EDDYSTONE_URL_FRAME_TYPE    0x10                              /**< URL Frame type is fixed at 0x10. */\r\n        #define APP_EDDYSTONE_URL_SCHEME        0x00                              /**< 0x00 = \"http://www\" URL prefix scheme according to specification. */\r\n        #define APP_EDDYSTONE_URL_URL           0x6e, 0x6f, 0x72, 0x64, \\\r\n                                                0x69, 0x63, 0x73, 0x65, \\\r\n                                                0x6d,0x69, 0x00                   /**< \"nordicsemi.com\". Last byte suffix 0x00 = \".com\" according to specification. */\r\n        // Eddystone TLM data\r\n        #define APP_EDDYSTONE_TLM_FRAME_TYPE    0x20                              /**< TLM frame type is fixed at 0x20. */\r\n        #define APP_EDDYSTONE_TLM_VERSION       0x00                              /**< TLM version might change in the future to accommodate other data according to specification. */\r\n        #define APP_EDDYSTONE_TLM_BATTERY       0x00, 0xF0                        /**< Mock value. Battery voltage in 1 mV per bit. */\r\n        #define APP_EDDYSTONE_TLM_TEMPERATURE   0x0F, 0x00                        /**< Mock value. Temperature [C]. Signed 8.8 fixed-point notation. */\r\n        #define APP_EDDYSTONE_TLM_ADV_COUNT     0x00, 0x00, 0x00, 0x00            /**< Running count of advertisements of all types since power-up or reboot. */\r\n        #define APP_EDDYSTONE_TLM_SEC_COUNT     0x00, 0x00, 0x00, 0x00            /**< Running count in 0.1 s resolution since power-up or reboot. */\r\n        \r\n        #define DEAD_BEEF                       0xDEADBEEF                        /**< Value used as error code on stack dump, can be used to identify stack location on stack unwind. */\r\n        \r\n        #define APP_TIMER_PRESCALER             0                                 /**< Value of the RTC1 PRESCALER register. */\r\n        #define APP_TIMER_OP_QUEUE_SIZE         4                                 /**< Size of timer operation queues. */\r\n        \r\n        static ble_gap_adv_params_t m_adv_params;                                 /**< Parameters to be passed to the stack when starting advertising. */\r\n        \r\n        \r\n        //static uint8_t eddystone_url_data[] =   /**< Information advertised by the Eddystone URL frame type. */\r\n        //{\r\n        //    APP_EDDYSTONE_URL_FRAME_TYPE,   // Eddystone URL frame type.\r\n        //    APP_EDDYSTONE_RSSI,             // RSSI value at 0 m.\r\n        //    APP_EDDYSTONE_URL_SCHEME,       // Scheme or prefix for URL (\"http\", \"http://www\", etc.)\r\n        //    APP_EDDYSTONE_URL_URL           // URL with a maximum length of 17 bytes. Last byte is suffix (\".com\", \".org\", etc.)\r\n        //};\r\n        \r\n        /** @snippet [Eddystone UID data] */\r\n        //static uint8_t eddystone_uid_data[] =   /**< Information advertised by the Eddystone UID frame type. */\r\n        //{\r\n        //    APP_EDDYSTONE_UID_FRAME_TYPE,   // Eddystone UID frame type.\r\n        //    APP_EDDYSTONE_RSSI,             // RSSI value at 0 m.\r\n        //    APP_EDDYSTONE_UID_NAMESPACE,    // 10-byte namespace value. Similar to Beacon Major.\r\n        //    APP_EDDYSTONE_UID_ID,           // 6-byte ID value. Similar to Beacon Minor.\r\n        //    APP_EDDYSTONE_UID_RFU           // Reserved for future use.\r\n        //};\r\n        /** @snippet [Eddystone UID data] */\r\n        \r\n    \r\n        \r\n        static uint8_t eddystone_tlm_data[] =   /**< Information advertised by the Eddystone TLM frame type. */\r\n        {\r\n            APP_EDDYSTONE_TLM_FRAME_TYPE,   // Eddystone TLM frame type.\r\n            APP_EDDYSTONE_TLM_VERSION,      // Eddystone TLM version.\r\n            APP_EDDYSTONE_TLM_BATTERY,      // Battery voltage in mV/bit.\r\n            APP_EDDYSTONE_TLM_TEMPERATURE,  // Temperature [C].\r\n            APP_EDDYSTONE_TLM_ADV_COUNT,    // Number of advertisements since power-up or reboot.\r\n            APP_EDDYSTONE_TLM_SEC_COUNT     // Time since power-up or reboot. 0.1 s increments.\r\n        };\r\n        \r\n    \r\n        \r\n        \r\n        typedef struct\r\n        {\r\n        \t\tuint8_t MSB_Data;\r\n        \t\tuint8_t LSB_Data;\r\n        \t\r\n        } sample_t;\r\n        \r\n        sample_t Temp_Sensor;\r\n        \r\n        /* Buffer for samples. */\r\n        static sample_t m_sample_buffer[NUMBER_OF_SAMPLES] = {0};\r\n        \r\n        /* Indicates if reading operation from accelerometer has ended. */\r\n        static volatile bool m_xfer_done = true;\r\n        /* Indicates if setting mode operation has ended. */\r\n        static volatile bool m_set_mode_done = false;\r\n        /* TWI instance. */\r\n        static const nrf_drv_twi_t m_twi_mcp9808 = NRF_DRV_TWI_INSTANCE(0);\r\n    \r\n    \r\n        \r\n        \r\n        /**@brief Callback function for asserts in the SoftDevice.\r\n         *\r\n         * @details This function will be called in case of an assert in the SoftDevice.\r\n         *\r\n         * @warning This handler is an example only and does not fit a final product. You need to analyze\r\n         *          how your product is supposed to react in case of Assert.\r\n         * @warning On assert from the SoftDevice, the system can only recover on reset.\r\n         *\r\n         * @param[in]   line_num   Line number of the failing ASSERT call.\r\n         * @param[in]   file_name  File name of the failing ASSERT call.\r\n         */\r\n        void assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name)\r\n        {\r\n            app_error_handler(DEAD_BEEF, line_num, p_file_name);\r\n        }\r\n        \r\n        /**@brief Function for initializing the advertising functionality.\r\n         *\r\n         * @details Encodes the required advertising data and passes it to the stack.\r\n         *          Also builds a structure to be passed to the stack when starting advertising.\r\n         */\r\n        static void advertising_init(void)\r\n        {\r\n            uint32_t      err_code;\r\n        \t\tint32_t\t\t\t\ttemp;\r\n        \t\tuint8_t \t\t\ttemp_a;\r\n        \t\tuint8_t \t\t\ttemp_b;\r\n            ble_advdata_t advdata;\r\n            uint8_t       flags = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;\r\n            ble_uuid_t    adv_uuids[] = {{APP_EDDYSTONE_UUID, BLE_UUID_TYPE_BLE}};\r\n        \r\n            uint8_array_t eddystone_data_array;                             // Array for Service Data structure.\r\n        /** @snippet [Eddystone data array] */\r\n        \t\t \t\r\n    \r\n        \t\tsd_temp_get(&temp);\r\n        \t\t\r\n        \t\ttemp_a = temp; \r\n        \t\ttemp_b = temp;\r\n        \t\ttemp_a >>= 2;\r\n        \t\ttemp_b <<= 6;\r\n        \r\n        \r\n        \t\t\r\n        \t\teddystone_tlm_data [4] = temp_a;\r\n        \t\teddystone_tlm_data [5] = temp_b; \r\n        \t\t\r\n            eddystone_data_array.p_data = (uint8_t *) eddystone_tlm_data;   // Pointer to the data to advertise.\r\n            eddystone_data_array.size = sizeof(eddystone_tlm_data);         // Size of the data to advertise.\r\n        /** @snippet [Eddystone data array] */\r\n        \r\n            ble_advdata_service_data_t service_data;                        // Structure to hold Service Data.\r\n            service_data.service_uuid = APP_EDDYSTONE_UUID;                 // Eddystone UUID to allow discoverability on iOS devices.\r\n            service_data.data = eddystone_data_array;                       // Array for service advertisement data.\r\n        \r\n            // Build and set advertising data.\r\n            memset(&advdata, 0, sizeof(advdata));\r\n        \r\n            advdata.name_type               = BLE_ADVDATA_NO_NAME;\r\n            advdata.flags                   = flags;\r\n            advdata.uuids_complete.uuid_cnt = sizeof(adv_uuids) / sizeof(adv_uuids[0]);\r\n            advdata.uuids_complete.p_uuids  = adv_uuids;\r\n            advdata.p_service_data_array    = &service_data;                // Pointer to Service Data structure.\r\n            advdata.service_data_count      = 1;\r\n        \r\n            err_code = ble_advdata_set(&advdata, NULL);\r\n            APP_ERROR_CHECK(err_code);\r\n        \r\n            // Initialize advertising parameters (used when starting advertising).\r\n            memset(&m_adv_params, 0, sizeof(m_adv_params));\r\n        \r\n            m_adv_params.type        = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;\r\n            m_adv_params.p_peer_addr = NULL;                                // Undirected advertisement.\r\n            m_adv_params.fp          = BLE_GAP_ADV_FP_ANY;\r\n            m_adv_params.interval    = NON_CONNECTABLE_ADV_INTERVAL;\r\n            m_adv_params.timeout     = APP_CFG_NON_CONN_ADV_TIMEOUT;\r\n        }\r\n        \r\n        \r\n        /**@brief Function for starting advertising.\r\n         */\r\n        static void advertising_start(void)\r\n        {\r\n            uint32_t err_code;\r\n        \r\n            err_code = sd_ble_gap_adv_start(&m_adv_params);\r\n            APP_ERROR_CHECK(err_code);\r\n        \r\n            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING);\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n        \r\n        \r\n        /**@brief Function for initializing the BLE stack.\r\n         *\r\n         * @details Initializes the SoftDevice and the BLE event interrupt.\r\n         */\r\n        static void ble_stack_init(void)\r\n        {\r\n            uint32_t err_code;\r\n            \r\n        // see nrf_sdm.h for more details\r\n        nrf_clock_lf_cfg_t clock_lf_cfg = \r\n        {\r\n            .source = NRF_CLOCK_LF_SRC_RC,\r\n            .rc_ctiv = 16, // Interval in 0.25 s, 16 * 0.25 = 4 sec\r\n            .rc_temp_ctiv = 2, // Check temperature every .rc_ctiv, but calibrate every .rc_temp_ctiv \r\n            .xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_250_PPM,\r\n        };\r\n            \r\n            // Initialize the SoftDevice handler module.\r\n            SOFTDEVICE_HANDLER_INIT(&clock_lf_cfg, NULL);\r\n            \r\n            ble_enable_params_t ble_enable_params;\r\n            err_code = softdevice_enable_get_default_config(CENTRAL_LINK_COUNT,\r\n                                                            PERIPHERAL_LINK_COUNT,\r\n                                                            &ble_enable_params);\r\n            APP_ERROR_CHECK(err_code);\r\n            \r\n            //Check the ram settings against the used number of links\r\n            CHECK_RAM_START_ADDR(CENTRAL_LINK_COUNT,PERIPHERAL_LINK_COUNT);\r\n            \r\n            // Enable BLE stack.\r\n            err_code = softdevice_enable(&ble_enable_params);\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n        \r\n        \r\n        /**@brief Function for doing power management.\r\n         */\r\n        static void power_manage(void)\r\n        {\r\n            uint32_t err_code = sd_app_evt_wait();\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n        \r\n      \r\n    \r\n        /**\r\n         * @brief Function for setting active mode on mcp9808.\r\n         */\r\n        void mcp9808_set_mode(void)\r\n        {\r\n            ret_code_t err_code;\r\n            uint8_t reg[1] = {TEMP_REG_TEMP};\r\n        \r\n            err_code = nrf_drv_twi_tx(&m_twi_mcp9808, TEMP_ADDR, reg, sizeof(reg), false);  \r\n            APP_ERROR_CHECK(err_code);\r\n            \r\n            while(m_set_mode_done == false);\r\n        }\r\n        \r\n        \r\n        /**\r\n         * @brief TWI events handler.\r\n         */\r\n        void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n        {   \r\n            ret_code_t err_code;\r\n            static sample_t m_sample;\r\n            \r\n            switch(p_event->type)\r\n            {\r\n                case NRF_DRV_TWI_EVT_DONE:\r\n                    if ((p_event->type == NRF_DRV_TWI_EVT_DONE) &&\r\n                        (p_event->xfer_desc.type == NRF_DRV_TWI_XFER_TX))\r\n                    {\r\n                        if(m_set_mode_done != true)\r\n                        {\r\n                            m_set_mode_done  = true;\r\n                            return;\r\n                        }\r\n                        m_xfer_done = false;\r\n                        /* Read 4 bytes from the specified address. */\r\n                        err_code = nrf_drv_twi_rx(&m_twi_mcp9808, TEMP_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));\r\n                        APP_ERROR_CHECK(err_code);\r\n                    }\r\n                    else\r\n                    {\r\n                        Temp_Sensor = m_sample;\r\n                        m_xfer_done = true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;        \r\n            }   \r\n        }\r\n        \r\n        \r\n     void twi_init (void)\r\n    {\r\n        ret_code_t err_code;\r\n        \r\n        const nrf_drv_twi_config_t twi_mcp9808_config = {\r\n    \t\t\t.scl                = DEVICE_SCL_PIN,\r\n           .sda                = DEVICE_SDA_PIN,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n        };\r\n        \r\n        err_code = nrf_drv_twi_init(&m_twi_mcp9808, &twi_mcp9808_config, twi_handler, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_twi_enable(&m_twi_mcp9808);\r\n    }\r\n        \r\n    \r\n      \r\n        \r\n        /**\r\n         * @brief Function for application main entry.\r\n         */\r\n        int main(void)\r\n        {\r\n            uint32_t err_code;\r\n            // Initialize.\r\n            APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n            err_code = bsp_init(BSP_INIT_LED, APP_TIMER_TICKS(100, APP_TIMER_PRESCALER), NULL);\r\n         //  \terr_code = 0x0; \r\n        \t\tAPP_ERROR_CHECK(err_code);\r\n            ble_stack_init();\r\n            advertising_init();\r\n            twi_init();\t\r\n        //    LEDS_ON(LEDS_MASK);\r\n            // Start execution.\r\n            advertising_start();\r\n        \t\tnrf_gpio_pin_set(2);\r\n        \t  mcp9808_set_mode(); \r\n        \r\n        \t  uint8_t reg = TEMP_REG_TEMP;\r\n            ret_code_t err_code_sens;\r\n        \t\r\n            // Enter main loop.\r\n            for (;; )\r\n            {\r\n        \t\t\tdo\r\n                {\r\n                    __WFE();\r\n                }while(m_xfer_done == false);\r\n                err_code_sens = nrf_drv_twi_tx(&m_twi_mcp9808, TEMP_ADDR, &reg, sizeof(reg), true);\r\n                APP_ERROR_CHECK(err_code_sens);\r\n                m_xfer_done = false;\r\n        \t\t\t\t\r\n                power_manage();\r\n        \t    advertising_init();\t\r\n            }\r\n        }\r\n\r\n----------\r\n\r\nThanks for answer!\r\n\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Pwm Driver not work at board PCA10036 I want use pwm driver to generate 8 channel pwm wave with nrf52832\uff0c My board is PCA10036.  I  use example \u201cnRF5_SDK_11.0.0_89a8197\\examples\\peripheral\\pwm_driver\\pca10040\\arm5_no_packs\u201dand change board to PCA10036 in options for target.  After download, It can't work at all. Can you explain why?",
    "tag": "pwm"
  },
  {
    "text": "i2c and nrf52832 Hello!\r\n\r\nI want to connect the MCP9808 with the nrf52832. Therefor I use i2C. \r\nMy example on the nrf52832 is the: \r\n\r\n    <nRF5_SDK_v11_0_0 folder>\\examples\\ble_peripheral\\experimental_ble_app_eddystone\\\r\n\r\nNow, I have written the code of the twi_sensor example in the eddystone example. \r\n\r\nWhen I debug the program, the function `err_code = nrf_drv_twi_rx(&m_twi_mcp9808, TEMP_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));` in the `void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)` writes C1 in the MSB_Data and FF in the LSB_Data of the m_sample irrespective of the temperature. \r\n\r\n\r\nHave I forgotten something in the program code. \r\n\r\nMy whole code:\r\n\r\n    /* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.\r\n     *\r\n     * The information contained herein is property of Nordic Semiconductor ASA.\r\n     * Terms and conditions of usage are described in detail in NORDIC\r\n     * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.\r\n     *\r\n     * Licensees are granted free, non-transferable use of the information. NO\r\n     * WARRANTY of ANY KIND is provided. This heading must NOT be removed from\r\n     * the file.\r\n     *\r\n     */\r\n    \r\n    /** @file\r\n     *\r\n     * @defgroup experimental_ble_sdk_app_eddystone_main main.c\r\n     * @{\r\n     * @ingroup experimental_ble_sdk_app_eddystone\r\n     * @brief Eddystone Beacon UID Transmitter sample application main file.\r\n     *\r\n     * This file contains the source code for an Eddystone beacon transmitter sample application.\r\n     */\r\n    \r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    #include \"ble_advdata.h\"\r\n    #include \"nordic_common.h\"\r\n    #include \"softdevice_handler.h\"\r\n    #include \"bsp.h\"\r\n    #include \"app_timer.h\"\r\n    #include \"nrf_temp.h\" //XXX Neu\r\n    \r\n    \r\n    // XXX YYY Neu\r\n    #include \"boards.h\"\r\n    #include \"app_util_platform.h\"\r\n    #include \"app_error.h\"\r\n    #include \"nrf_drv_twi.h\"\r\n    #include \"nrf_delay.h\"\r\n    \r\n    /*Pins to connect shield. */\r\n    #define DEVICE_SCL_PIN 0\r\n    #define DEVICE_SDA_PIN 1\r\n    \r\n    /*Common addresses definition for accelereomter. */\r\n    #define TEMP_ADDR        (0x18U)\r\n    \r\n    #define TEMP_REG_RFU   \t 0x00U\r\n    #define TEMP_REG_CONFIG  0x01U\r\n    #define TEMP_REG_TUPPER  0x02U\r\n    #define TEMP_REG_TLOWER  0x03U\r\n    #define TEMP_REG_TCRIT   0x04U\r\n    #define TEMP_REG_TEMP\t   0x05U\r\n    #define TEMP_REG_MID\t   0x06U\r\n    #define TEMP_REG_DID\t   0x07U\r\n    #define TEMP_REG_RESR    0x08U\r\n    \r\n    \r\n    // [max 255, otherwise \"int16_t\" won't be sufficient to hold the sum\r\n    //  of accelerometer samples]\r\n    #define NUMBER_OF_SAMPLES 20\r\n    \r\n    // XXX YYY Neu\r\n    \r\n    \r\n    \r\n    #define IS_SRVC_CHANGED_CHARACT_PRESENT 0                                 /**< Include the service changed characteristic. If not enabled, the server's database cannot be changed for the lifetime of the device. */\r\n    \r\n    #define CENTRAL_LINK_COUNT              0                                 /**< Number of central links used by the application. When changing this number remember to adjust the RAM settings*/\r\n    #define PERIPHERAL_LINK_COUNT           0                                 /**< Number of peripheral links used by the application. When changing this number remember to adjust the RAM settings*/\r\n    \r\n    #define APP_CFG_NON_CONN_ADV_TIMEOUT    0                                 /**< Time for which the device must be advertising in non-connectable mode (in seconds). 0 disables the time-out. */\r\n    #define NON_CONNECTABLE_ADV_INTERVAL    MSEC_TO_UNITS(1000, UNIT_0_625_MS) /**< The advertising interval for non-connectable advertisement (100 ms). This value can vary between 100 ms and 10.24 s). */\r\n    \r\n    // Eddystone common data\r\n    #define APP_EDDYSTONE_UUID              0xFEAA                            /**< UUID for Eddystone beacons according to specification. */\r\n    #define APP_EDDYSTONE_RSSI              0xEE                              /**< 0xEE = -18 dB is the approximate signal strength at 0 m. */\r\n    \r\n    // Eddystone UID data\r\n    #define APP_EDDYSTONE_UID_FRAME_TYPE    0x00                              /**< UID frame type is fixed at 0x00. */\r\n    #define APP_EDDYSTONE_UID_RFU           0x00, 0x00                        /**< Reserved for future use according to specification. */\r\n    #define APP_EDDYSTONE_UID_ID            0x01, 0x02, 0x03, 0x04, \\\r\n                                            0x05, 0x06                        /**< Mock values for 6-byte Eddystone UID ID instance.  */\r\n    #define APP_EDDYSTONE_UID_NAMESPACE     0xAA, 0xAA, 0xBB, 0xBB, \\\r\n                                            0xCC, 0xCC, 0xDD, 0xDD, \\\r\n                                            0xEE, 0xEE                        /**< Mock values for 10-byte Eddystone UID ID namespace. */\r\n    \r\n    // Eddystone URL data\r\n    #define APP_EDDYSTONE_URL_FRAME_TYPE    0x10                              /**< URL Frame type is fixed at 0x10. */\r\n    #define APP_EDDYSTONE_URL_SCHEME        0x00                              /**< 0x00 = \"http://www\" URL prefix scheme according to specification. */\r\n    #define APP_EDDYSTONE_URL_URL           0x6e, 0x6f, 0x72, 0x64, \\\r\n                                            0x69, 0x63, 0x73, 0x65, \\\r\n                                            0x6d,0x69, 0x00                   /**< \"nordicsemi.com\". Last byte suffix 0x00 = \".com\" according to specification. */\r\n    // Eddystone TLM data\r\n    #define APP_EDDYSTONE_TLM_FRAME_TYPE    0x20                              /**< TLM frame type is fixed at 0x20. */\r\n    #define APP_EDDYSTONE_TLM_VERSION       0x00                              /**< TLM version might change in the future to accommodate other data according to specification. */\r\n    #define APP_EDDYSTONE_TLM_BATTERY       0x00, 0xF0                        /**< Mock value. Battery voltage in 1 mV per bit. */\r\n    #define APP_EDDYSTONE_TLM_TEMPERATURE   0x0F, 0x00                        /**< Mock value. Temperature [C]. Signed 8.8 fixed-point notation. */\r\n    #define APP_EDDYSTONE_TLM_ADV_COUNT     0x00, 0x00, 0x00, 0x03            /**< Running count of advertisements of all types since power-up or reboot. */\r\n    #define APP_EDDYSTONE_TLM_SEC_COUNT     0x00, 0x00, 0x00, 0x04            /**< Running count in 0.1 s resolution since power-up or reboot. */\r\n    \r\n    #define DEAD_BEEF                       0xDEADBEEF                        /**< Value used as error code on stack dump, can be used to identify stack location on stack unwind. */\r\n    \r\n    #define APP_TIMER_PRESCALER             0                                 /**< Value of the RTC1 PRESCALER register. */\r\n    #define APP_TIMER_OP_QUEUE_SIZE         4                                 /**< Size of timer operation queues. */\r\n    \r\n    static ble_gap_adv_params_t m_adv_params;                                 /**< Parameters to be passed to the stack when starting advertising. */\r\n    \r\n    // XXX Neu\r\n    \r\n    //static uint8_t eddystone_url_data[] =   /**< Information advertised by the Eddystone URL frame type. */\r\n    //{\r\n    //    APP_EDDYSTONE_URL_FRAME_TYPE,   // Eddystone URL frame type.\r\n    //    APP_EDDYSTONE_RSSI,             // RSSI value at 0 m.\r\n    //    APP_EDDYSTONE_URL_SCHEME,       // Scheme or prefix for URL (\"http\", \"http://www\", etc.)\r\n    //    APP_EDDYSTONE_URL_URL           // URL with a maximum length of 17 bytes. Last byte is suffix (\".com\", \".org\", etc.)\r\n    //};\r\n    \r\n    /** @snippet [Eddystone UID data] */\r\n    //static uint8_t eddystone_uid_data[] =   /**< Information advertised by the Eddystone UID frame type. */\r\n    //{\r\n    //    APP_EDDYSTONE_UID_FRAME_TYPE,   // Eddystone UID frame type.\r\n    //    APP_EDDYSTONE_RSSI,             // RSSI value at 0 m.\r\n    //    APP_EDDYSTONE_UID_NAMESPACE,    // 10-byte namespace value. Similar to Beacon Major.\r\n    //    APP_EDDYSTONE_UID_ID,           // 6-byte ID value. Similar to Beacon Minor.\r\n    //    APP_EDDYSTONE_UID_RFU           // Reserved for future use.\r\n    //};\r\n    /** @snippet [Eddystone UID data] */\r\n    \r\n    // XXX Neu\r\n    \r\n    static uint8_t eddystone_tlm_data[] =   /**< Information advertised by the Eddystone TLM frame type. */\r\n    {\r\n        APP_EDDYSTONE_TLM_FRAME_TYPE,   // Eddystone TLM frame type.\r\n        APP_EDDYSTONE_TLM_VERSION,      // Eddystone TLM version.\r\n        APP_EDDYSTONE_TLM_BATTERY,      // Battery voltage in mV/bit.\r\n        APP_EDDYSTONE_TLM_TEMPERATURE,  // Temperature [C].\r\n        APP_EDDYSTONE_TLM_ADV_COUNT,    // Number of advertisements since power-up or reboot.\r\n        APP_EDDYSTONE_TLM_SEC_COUNT     // Time since power-up or reboot. 0.1 s increments.\r\n    };\r\n    \r\n    \r\n    \r\n    // XXX YYY Neu\r\n    \r\n    \r\n    typedef struct\r\n    {\r\n    \t\tuint8_t MSB_Data;\r\n    \t\tuint8_t LSB_Data;\r\n    \t\r\n    } sample_t;\r\n    \r\n    sample_t Temp_Sensor;\r\n    \r\n    /* Buffer for samples. */\r\n    static sample_t m_sample_buffer[NUMBER_OF_SAMPLES] = {0};\r\n    \r\n    /* Indicates if reading operation from accelerometer has ended. */\r\n    static volatile bool m_xfer_done = true;\r\n    /* Indicates if setting mode operation has ended. */\r\n    static volatile bool m_set_mode_done = false;\r\n    /* TWI instance. */\r\n    static const nrf_drv_twi_t m_twi_mcp9808 = NRF_DRV_TWI_INSTANCE(0);\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    // XXX YYY Neu\r\n    \r\n    \r\n    /**@brief Callback function for asserts in the SoftDevice.\r\n     *\r\n     * @details This function will be called in case of an assert in the SoftDevice.\r\n     *\r\n     * @warning This handler is an example only and does not fit a final product. You need to analyze\r\n     *          how your product is supposed to react in case of Assert.\r\n     * @warning On assert from the SoftDevice, the system can only recover on reset.\r\n     *\r\n     * @param[in]   line_num   Line number of the failing ASSERT call.\r\n     * @param[in]   file_name  File name of the failing ASSERT call.\r\n     */\r\n    void assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name)\r\n    {\r\n        app_error_handler(DEAD_BEEF, line_num, p_file_name);\r\n    }\r\n    \r\n    /**@brief Function for initializing the advertising functionality.\r\n     *\r\n     * @details Encodes the required advertising data and passes it to the stack.\r\n     *          Also builds a structure to be passed to the stack when starting advertising.\r\n     */\r\n    static void advertising_init(void)\r\n    {\r\n        uint32_t      err_code;\r\n    \t\tint32_t\t\t\t\ttemp;\r\n    \t\tuint8_t \t\t\ttemp_a;\r\n    \t\tuint8_t \t\t\ttemp_b;\r\n        ble_advdata_t advdata;\r\n        uint8_t       flags = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;\r\n        ble_uuid_t    adv_uuids[] = {{APP_EDDYSTONE_UUID, BLE_UUID_TYPE_BLE}};\r\n    \r\n        uint8_array_t eddystone_data_array;                             // Array for Service Data structure.\r\n    /** @snippet [Eddystone data array] */\r\n    \t\t \t\r\n    \t\t\r\n    \t\t// XXX Neu\r\n    \t\tsd_temp_get(&temp);\r\n    \t\t\r\n    \t\ttemp_a = temp; \r\n    \t\ttemp_b = temp;\r\n    \t\ttemp_a >>= 2;\r\n    \t\ttemp_b <<= 6;\r\n    \r\n    \r\n    \t\t\r\n    \t\teddystone_tlm_data [4] = temp_a;\r\n    \t\teddystone_tlm_data [5] = temp_b; \r\n    \t\t\r\n        eddystone_data_array.p_data = (uint8_t *) eddystone_tlm_data;   // Pointer to the data to advertise.\r\n        eddystone_data_array.size = sizeof(eddystone_tlm_data);         // Size of the data to advertise.\r\n    /** @snippet [Eddystone data array] */\r\n    \r\n        ble_advdata_service_data_t service_data;                        // Structure to hold Service Data.\r\n        service_data.service_uuid = APP_EDDYSTONE_UUID;                 // Eddystone UUID to allow discoverability on iOS devices.\r\n        service_data.data = eddystone_data_array;                       // Array for service advertisement data.\r\n    \r\n        // Build and set advertising data.\r\n        memset(&advdata, 0, sizeof(advdata));\r\n    \r\n        advdata.name_type               = BLE_ADVDATA_NO_NAME;\r\n        advdata.flags                   = flags;\r\n        advdata.uuids_complete.uuid_cnt = sizeof(adv_uuids) / sizeof(adv_uuids[0]);\r\n        advdata.uuids_complete.p_uuids  = adv_uuids;\r\n        advdata.p_service_data_array    = &service_data;                // Pointer to Service Data structure.\r\n        advdata.service_data_count      = 1;\r\n    \r\n        err_code = ble_advdata_set(&advdata, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        // Initialize advertising parameters (used when starting advertising).\r\n        memset(&m_adv_params, 0, sizeof(m_adv_params));\r\n    \r\n        m_adv_params.type        = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;\r\n        m_adv_params.p_peer_addr = NULL;                                // Undirected advertisement.\r\n        m_adv_params.fp          = BLE_GAP_ADV_FP_ANY;\r\n        m_adv_params.interval    = NON_CONNECTABLE_ADV_INTERVAL;\r\n        m_adv_params.timeout     = APP_CFG_NON_CONN_ADV_TIMEOUT;\r\n    }\r\n    \r\n    \r\n    /**@brief Function for starting advertising.\r\n     */\r\n    static void advertising_start(void)\r\n    {\r\n        uint32_t err_code;\r\n    \r\n        err_code = sd_ble_gap_adv_start(&m_adv_params);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**@brief Function for initializing the BLE stack.\r\n     *\r\n     * @details Initializes the SoftDevice and the BLE event interrupt.\r\n     */\r\n    static void ble_stack_init(void)\r\n    {\r\n        uint32_t err_code;\r\n        \r\n    // XXX Neu\t\r\n    // see nrf_sdm.h for more details\r\n    nrf_clock_lf_cfg_t clock_lf_cfg = \r\n    {\r\n        .source = NRF_CLOCK_LF_SRC_RC,\r\n        .rc_ctiv = 16, // Interval in 0.25 s, 16 * 0.25 = 4 sec\r\n        .rc_temp_ctiv = 2, // Check temperature every .rc_ctiv, but calibrate every .rc_temp_ctiv \r\n        .xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_250_PPM,\r\n    };\r\n        \r\n        // Initialize the SoftDevice handler module.\r\n        SOFTDEVICE_HANDLER_INIT(&clock_lf_cfg, NULL);\r\n        \r\n        ble_enable_params_t ble_enable_params;\r\n        err_code = softdevice_enable_get_default_config(CENTRAL_LINK_COUNT,\r\n                                                        PERIPHERAL_LINK_COUNT,\r\n                                                        &ble_enable_params);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        //Check the ram settings against the used number of links\r\n        CHECK_RAM_START_ADDR(CENTRAL_LINK_COUNT,PERIPHERAL_LINK_COUNT);\r\n        \r\n        // Enable BLE stack.\r\n        err_code = softdevice_enable(&ble_enable_params);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    /**@brief Function for doing power management.\r\n     */\r\n    static void power_manage(void)\r\n    {\r\n        uint32_t err_code = sd_app_evt_wait();\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    /**\r\n     * @brief Function XXX YYY Neu for i2c.\r\n     */\r\n    \r\n    /**\r\n     * @brief Function for setting active mode on mcp9808.\r\n     */\r\n    void mcp9808_set_mode(void)\r\n    {\r\n        ret_code_t err_code;\r\n        uint8_t reg[1] = {TEMP_REG_TEMP};\r\n    \r\n        err_code = nrf_drv_twi_tx(&m_twi_mcp9808, TEMP_ADDR, reg, sizeof(reg), false);  \r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        while(m_set_mode_done == false);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @brief TWI events handler.\r\n     */\r\n    void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n    {   \r\n        ret_code_t err_code;\r\n        static sample_t m_sample;\r\n        \r\n        switch(p_event->type)\r\n        {\r\n            case NRF_DRV_TWI_EVT_DONE:\r\n                if ((p_event->type == NRF_DRV_TWI_EVT_DONE) &&\r\n                    (p_event->xfer_desc.type == NRF_DRV_TWI_XFER_TX))\r\n                {\r\n                    if(m_set_mode_done != true)\r\n                    {\r\n                        m_set_mode_done  = true;\r\n                        return;\r\n                    }\r\n                    m_xfer_done = false;\r\n                    /* Read 4 bytes from the specified address. */\r\n                    err_code = nrf_drv_twi_rx(&m_twi_mcp9808, TEMP_ADDR, (uint8_t*)&m_sample, sizeof(m_sample));\r\n                    APP_ERROR_CHECK(err_code);\r\n                }\r\n                else\r\n                {\r\n                    Temp_Sensor = m_sample;\r\n                    m_xfer_done = true;\r\n                }\r\n                break;\r\n            default:\r\n                break;        \r\n        }   \r\n    }\r\n    \r\n    \r\n    void twi_init (void)\r\n    {\r\n        ret_code_t err_code;\r\n        \r\n        const nrf_drv_twi_config_t twi_mcp9808_config = {\r\n    \t\t\t.scl                = DEVICE_SCL_PIN,\r\n           .sda                = DEVICE_SDA_PIN,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n        };\r\n        \r\n        err_code = nrf_drv_twi_init(&m_twi_mcp9808, &twi_mcp9808_config, twi_handler, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_twi_enable(&m_twi_mcp9808);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    // XXX YYY Neu\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    /**\r\n     * @brief Function for application main entry.\r\n     */\r\n    int main(void)\r\n    {\r\n        uint32_t err_code;\r\n    \t\tuint32_t pin = 2;\r\n    \t\tnrf_gpio_cfg_output(pin);\r\n    \t\tnrf_gpio_pin_set(pin);\r\n        // Initialize.\r\n        APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);\r\n        err_code = bsp_init(BSP_INIT_LED, APP_TIMER_TICKS(100, APP_TIMER_PRESCALER), NULL);\r\n     //  \terr_code = 0x0; //XXX Neu\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n        ble_stack_init();\r\n        advertising_init();\r\n        twi_init();\r\n    \t  mcp9808_set_mode(); \t\r\n    //    LEDS_ON(LEDS_MASK);\r\n        // Start execution.\r\n        advertising_start();\r\n    \r\n    \r\n    \r\n    \t  uint8_t reg = TEMP_REG_TEMP;\r\n        ret_code_t err_code_sens;\r\n    \t\r\n        // Enter main loop.\r\n        for (;; )\r\n        {\r\n            nrf_delay_ms(100);\r\n        /* Start transaction with a slave with the specified address. */\r\n            do\r\n            {\r\n                __WFE();\r\n            }while(m_xfer_done == false);\r\n            err_code_sens = nrf_drv_twi_tx(&m_twi_mcp9808, TEMP_ADDR, &reg, sizeof(reg), true);\r\n            APP_ERROR_CHECK(err_code_sens);\r\n            m_xfer_done = false;\r\n    \t\t\t\t\r\n            power_manage();\r\n    \t\t\t\tadvertising_init();\t//XXX Neu\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @}\r\n     */\r\n\r\n\r\nThanks!\r\n\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "sdk11 pwm frequency control Hi, i used sdk11 and softdevice version s130_2.0.\r\n\r\nAnd i used pwm library.\r\n\r\ni try to make pwm pulse accurate 38khz.\r\n\r\nWhen i used sdk 6.0, i could control timer used to prescaler and cc[0]. \r\n\r\nbut sdk 11, i couldn't find prescaler and cc[0]. \r\n\r\ni want to control timer period.\r\n\r\nWhat can i do to control pwm pulse ?",
    "tag": "pwm"
  },
  {
    "text": "TWI clock pull up The data sheet recommends that both the TWI clock and data lines use pull ups and the GPIOs should be set to S0D1, essentially open collector drive. I can see the need for this on the data line, but if my I2C device does not do any clock stretching, is it safe to omit the pullup on the clock line and set the GPIO to S0S1?\r\n\r\nI have tried this on my board and have seen no ill effects.\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "how to occur interrupt on SPIM with easyDMA END event? Hi\r\n\r\nI want to get external acceleration sensor values with SPIM using easyDMA on the sensor interruption (using GPIOTE). then after getting all data, I want to calculate them using algorithm on CPU.\r\n\r\nIn other words, getting the sensor data without CPU and calculate the data using CPU on the SPI easyDMA END event.\r\n\r\nplease tell me how to implement this.\r\n\r\nThank you.",
    "tag": "interrupt"
  },
  {
    "text": "I2C reset problem I am running the TWI find device example by Martin B\u00f8rs-Lind, as he suggests on [this](https://devzone.nordicsemi.com/question/48894/hardware-twii2c-example/) post. I am using pins 3 and 4 for the I2C and I connect my I2C component there. I am using a PCA10040 board with a nRF52832 on it.\r\n\r\nThe issue here is if I turn the board off and on again by using the on/off switch the program works well and it sees the I2C device. Instead, if I reset the program by using the reset button the I2C is never found. Again, I use the off/on switch and it works well.\r\n\r\nI am having similar trouble with some code of my own, though I don't discard having my own errors there. Has anyone experience any similar problem?",
    "tag": "i2c"
  },
  {
    "text": "Timing inaccuracy in low power PWM I was trying out the low power PWM example and noticed the timing inaccuracy that was mentioned in [documentation](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v11.0.0%2Flib_low_power_pwm.html&cp=4_0_0_3_14).\r\n\r\nFor example, with low_power_pwm_0, \r\n\r\n - period = 220 ticks\r\n - duty cycle = 20 ticks\r\n\r\nGiven a clock frequency of 32,768 Hz (period = 30.52 us), the PWM period should be 6714 us and the pulse width 610 us. \r\n\r\nThe period and pulse width measured on the scope were 6200 us and 680 us, respectively. \r\n\r\nSimilarly, with low_power_pwm_1, period = 200 ticks and duty cycle = 150 ticks. The theoretical period and pulse width were 6104 and 4578 us, respectively. The measured period and pulse width were 5320 and 3880 us, respectively. \r\n\r\nIs this discrepancy of about 10 - 20% expected?\r\n\r\nThe current consumption was switching between 5.4 and 10 mA, which seems rather high. (I pressed reset a few times and so it shouldn't be in debug mode, should it?)\r\n",
    "tag": "pwm"
  },
  {
    "text": "pin_change_int example void in_pin_handler (nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)  \r\n{\r\n  nrf_drv_gpiote_out_toggle(PIN_OUT);\r\n\t\r\n}\r\n\r\nThis function work with interupt event (push button). I can't understand where we use its 2 parameters (pin and action) or it's not usual function.",
    "tag": "interrupt"
  },
  {
    "text": "SPI slave peripheral receive interrupt processing SPI Slave configuration On nRF52 \r\n\r\nHi, \r\n\r\n   I am trying to configure the SPI slave peripheral for interrupt based communicaton with a SPI master\r\n   In previous work with ARM based chips, the typical sequence I have followed would be : \r\n\r\n   1) configure the SPI slave peripheral\r\n\r\n   2) configure the SPI data processing task \r\n\r\n   2) Enable the SPI receive interrupt (to handle receive data in the ISR) \r\n\r\n   During regular operation the sequence that would typically be followed is then : \r\n\r\n   1) In IRQ, check status bits and clock in the SPI peripheral data \r\n\r\n   2) Upon completion of a frame, the following may then be done ( there are various ways, but this is the simplest way ) \r\n\r\n   a) disable the RX IRQ \r\n\r\n   b) signal the SPI data processing task, which will then process the data and then if necessary \r\ntransmit a response ( again via the SPI peripheral) \r\n\r\n   c) re-enable the SPI RX IRQ. \r\n      \r\n   And the process would repeat. The tpyical error handling management is left out for conditions like over-run etc. But, this is \r\n   typically the basis of what I have done in the past. \r\n   Most of this has been done at the CMSIS level ( or something close to this). This is the first time I have used the nRF52 SDK\r\n   \r\n   I looked thru the SPI slave example and have a couple of questions based on the exposed API and the functionality in the SPI slave main.c \r\n\r\n   1) It is not clear how the SPI slave can be configured to handle receive functionality. Does the registered event handler also get called in the\r\n      event that the SPI slave peripheral detects incoming data. If so, what is the sequence of events that causes the event handler to be invoked \r\n      ( is this based upon assertion of the /CS or clocking of incoming data or ...) \r\n      The documentation that I read on the infocenter \r\n      ( https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk52.v0.9.2%2Fhardware_driver_spi_master.html)\r\n      is not clear on how the sequence of events transpires on a spi slave receive operation \r\n\r\n   2) Is it possible to reconfigure the SPI interrupt based on incoming frames and the state of reception ",
    "tag": "interrupt"
  },
  {
    "text": "Specifications about Low Power PWM with NRF52 SDK12 Hi,\r\n\r\nWe search some technical informations about Low Power mode PWM. What is the Max Frequency ?\r\nWhat is the current consommation ?\r\nSomeone knows these informations or a technical document with the answer ?\r\n\r\nSincerely yours",
    "tag": "pwm"
  },
  {
    "text": "52832 SDK12 PWM Hi,\r\nHW:PCA10040\r\nSDK:v12.0\r\nQUESTION:PWM\r\n\r\nI want to use SDK 12  to get 4 pwm , so i search in [pwm](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v11.0.0%2Fhardware_driver_pwm.html&cp=6_0_0_2_8), i start my program like this , but i can't find nrf_drv_pwm_config_t structure and nrf_drv_pwm.h file . Can you help me ? \r\n\r\nThank you very much !",
    "tag": "pwm"
  },
  {
    "text": "NRF52 + MPU 6050 + I2C Hi!\r\n\r\nI am new to the embedded world and am trying to interface a NRF52 DK with a MPU 6050 accelerator/gyroscope. Right now, I have been able to interface the MPU 6050 with an arduino. Now, I want to include bluetooth capability. Is there any library for the MPU 6050 for the NRF52? \r\n\r\nThank you!",
    "tag": "i2c"
  },
  {
    "text": "How to use Interrupt in BLE Central Hi all Nordic Developer,\r\n\r\nCurrently I am working on nrf51-dk(as a BLE central) and I wish to connect one of its pin to a power supply(as a input). If the power breakdown, it should send out a warning message. I guess using an interrupt might be a good idea to handle it. \r\nHow can I do this??\r\n\r\nThanks\r\n\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "nRF51 GPIO interrupt Hello,\r\n\r\nI am having interface nRF51 with RF receiver. Output of RF receiver connected with GPIO pin of nRF51.\r\n\r\nHow can I detect interrupt on gpio pin?\r\n\r\nThanks & Regards,\r\nRajneesh ",
    "tag": "interrupt"
  },
  {
    "text": "MY BLE connection lost during run time! I mounted the chip onto my own PCB, I am not using a devkit, My board is \"Wireless-Tag WT51822-S2\", it is a module that uses nRF51822-QFAA as (SoC)\r\n\r\nI am the ble_app_uart example inside sdkv10.0.0 as a framework to my application.\r\n\r\nMy application is simply a smart-remote which contains two interrupts:\r\n1- TIMER1 interrupt (I am using it as a scheduler to run a background code inside the main \r\n    function).\r\n2- GPIOTE Interrupt that fires when an input pin toggles.\r\n\r\nThe input pin is sensing the IR receiver sensor and generates an interrupts with each edge, Inside the interrupt I calculate the time between edges.\r\n\r\nI load these times into an array, run my algorithm, pack my ble payload, then send the frame to my smart phone.\r\n\r\nSo when I push any button on my remote-control I am expecting to get a message nRF Toolbox.\r\n\r\nBut in reality I get a correct responses each push button, and after some trials/time (random) I get my connection lost!!\r\n\r\nI don't know exactely why it loses the connection, could anyone help please ? :)",
    "tag": "interrupt"
  },
  {
    "text": "app pwm nrf52 Hi All,\r\n\r\nI am attempting to use 6 PWM channels with the app_pwm library on the nRF52 and am only able to successfully get 4 pwm outputs. Upon changing the 6th channel (PWM2 below ch 0) the softdevice would disconnect. I was able to stop the disconnection adding enable and disable calls before the PWM2 app_pwm_channel_duty_set call but this results in the PWM not being set correctly. \r\n\r\nAny suggestions on what to do? I'm going to dig into the raw nrf_drv_pwm driver tomorrow to see if I can get that to perform as intended since I only need fixed pwm cycles for now.\r\n\r\nAll help is appreciated!!!\r\n\r\nPlease find the code below:\r\n\r\nGlobals:\r\n\r\n    APP_PWM_INSTANCE(PWM0,3);                   // Create the instance \"PWM0\" using TIMER3.\r\n    APP_PWM_INSTANCE(PWM1,1);                   // Create the instance \"PWM1\" using TIMER1.\r\n    APP_PWM_INSTANCE(PWM2,4);                   // Create the instance \"PWM2\" using TIMER4.\r\n\r\nInitialization:\r\n\r\n\tnrf_gpio_cfg_output(RED1_PIN);\r\n\tnrf_gpio_cfg_output(RED2_PIN);\r\n\tnrf_gpio_cfg_output(RED3_PIN);\r\n\tnrf_gpio_cfg_output(BLUE1_PIN);\r\n\tnrf_gpio_cfg_output(BLUE2_PIN);\r\n\tnrf_gpio_cfg_output(BLUE3_PIN);\r\n\t\r\n\r\n\tnrf_gpio_pin_clear(RED1_PIN);\r\n\tnrf_gpio_pin_clear(RED2_PIN);\r\n\tnrf_gpio_pin_clear(RED3_PIN);\r\n\tnrf_gpio_pin_clear(BLUE1_PIN);\r\n\tnrf_gpio_pin_clear(BLUE2_PIN);\r\n\tnrf_gpio_pin_clear(BLUE3_PIN);\r\n\r\n\t/* 2-channel PWM, 200Hz, output on DK LED pins. */\r\n\tapp_pwm_config_t pwm0_cfg = APP_PWM_DEFAULT_CONFIG_2CH(5000L, RED1_PIN, BLUE1_PIN);\r\n\tapp_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(5000L, RED2_PIN,  BLUE2_PIN);\r\n\tapp_pwm_config_t pwm2_cfg = APP_PWM_DEFAULT_CONFIG_2CH(5000L, RED3_PIN, BLUE3_PIN);\r\n\t\r\n\t/* Initialize and enable PWM. */\r\n\r\n\tuint32_t err_code;\r\n\terr_code = app_pwm_init(&PWM0,&pwm0_cfg,pwm_ready_callback);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\tapp_pwm_enable(&PWM0);\r\n\terr_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\tapp_pwm_enable(&PWM1);\t\r\n\terr_code = app_pwm_init(&PWM2,&pwm2_cfg,pwm_ready_callback);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\tapp_pwm_enable(&PWM2);\r\n\r\nSoftdevice events trigger:\r\n\r\n    void TurnItOff(void)\r\n    {\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM0, 0, OFF_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM1, 0, OFF_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM2, 0, OFF_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM0, 1, OFF_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM1, 1, OFF_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM2, 1, OFF_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n    }\r\n    void MakeItHot()\r\n    {\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM0, 0, RED_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM1, 0, RED_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM2, 0, RED_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n    }\r\n\r\n    void MakeItBlue(void)\r\n    {\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM0, 1, BLUE_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM1, 1, BLUE_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n\tready_flag = false;\r\n\tapp_pwm_channel_duty_set(&PWM2, 1, BLUE_DUTYCYCLE);\r\n\twhile(!ready_flag);\r\n    }",
    "tag": "pwm"
  },
  {
    "text": "nRF52 SPI Master - Interrupt Hi,\r\n\r\nI'm using the nRF52 as a master and an external RF chip as a slave. After configuring my spi bus using nrf_drv_spi_init(&spi, NULL, NULL), in my main loop, how do I get an interrupt to know if the slave is going send data over so I can read the buffer? Is it conceptually different from GPIOTE?",
    "tag": "interrupt"
  },
  {
    "text": "Adding PWM pins NRF51822 for Production Hello,\r\n\r\nI am thinking of creating a project that I intend to manufacture that needs to operate 10 dc motors via Bluetooth.\r\n\r\nWould this be a logical and cost effective setup:\r\n- NRF51822 as a Bluetooth transceiver and processor\r\n- PCA9685 chip to increase PWM to 16 pins (https://www.adafruit.com/product/815)\r\n- L9110 to drive the motors at a speed depending on the PWM (http://me.web2.ncut.edu.tw/ezfiles/39/1039/img/617/L9110_2_CHANNEL_MOTOR_DRIVER.pdf)\r\n\r\nI plan to remove the breakout boards of all the chips when I do start manufacturing.\r\n\r\nPlease let me know your thoughts on this setup or let me know how I can improve it with different components.",
    "tag": "pwm"
  },
  {
    "text": "Clearing GPIO Driver Interrupt Event Hi there,\r\n\r\nI'm using an input GPIOTE based on SDK11. The interrupt is consistently being fired. On the other hand, if I use \"if(Pin_6)\" to check the trigger, it does not get fired continuously. Is there a command in the nrf_drv to clear the gpio interrupt flag, the current command i'm using isnt working? I'm using 'globalflag' to turn on certain segments of my main loop. Below is a segment of the code:\r\n\r\n\r\n    void gpiote_event_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action) \r\n    {\r\n    \t// Event not clearing\r\n            nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_IN_0);\r\n            globalflag = true;\r\n    }\r\n\r\n\r\n----------\r\n\r\n       static void gpiote_init(void) \r\n       {\r\n        \t// Initialize GPIO Interrupt Driver\r\n        \tnrf_drv_gpiote_init();\r\n        \r\n        \t// Initialize PIN_6 as GPIOTE Input Pin\r\n        \tnrf_drv_gpiote_in_config_t config = GPIOTE_CONFIG_IN_SENSE_LOTOHI(true);\r\n        \tnrf_drv_gpiote_in_init(PIN_6, &config, gpiote_event_handler);\r\n        \r\n                nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_IN_0);\r\n        \t// Enable GPIO event and it's corresponding interrupt\r\n        \tnrf_drv_gpiote_in_event_enable(PIN_6, true);\r\n        \treturn; \r\n        }\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "nRF51 BLE and PWM doesn't work simultaneously \r\nHi\r\n\r\nI'm using a custom board with nRF51822 and mbed.\r\nThen, I would like to generate 25kHz PWM and use BLE simultaneously.\r\nSo, I read this thread, write like the attachment code and could generate 25kHz PWM.\r\nhttps://devzone.nordicsemi.com/question/18948/problem-running-a-10khz-pwm-on-a-timer/\r\n[source code.txt](/attachment/0bb469bed8dea6c51463852da061dbb7)\r\n\r\nHowever, I couldn't use BLE while my board generates PWM.\r\nAlthough I changed the frequency of PWM, I couldn't detect BLE. \r\nAre there anyone who face the same problem?\r\nIf there are, please tell me how to solve this problem.\r\n\r\nBest regards\r\nIshikawa\r\n",
    "tag": "pwm"
  },
  {
    "text": "TWI,SPI,ADC sensor data through bluetooth Hi,\r\n\r\nI am a newbie to nRF devices. I have different sensors connected to TWI,SPI,ADC etc. and need to send these data to a cellphone through BLE. Does anyone has a sample code for this for \r\nPCA10040? I got a code which takes ADC readings and sending those through BLE and is working. \r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "I2C code conversion help needed   Hi,\r\n\r\nI need to read data from MLX90615. It is a temperature sensor which follows I2C to read data. I got a sample code for this which is given below. \r\n\r\n    float receiveTemperature(int Temperature_type) {\r\n\t\tint dev = (0x5B << 1);                               // 5B is the device address\r\n\t\tchar dataLow = 0;                              // initially setting data low as zero\r\n\t    char dataHigh = 0;                             // initially setting data high as zero\r\n\t\tchar pec = 0;\r\n\t\tfloat celcius = 0.0;\r\n\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tstart(dev | I2C_WRITE);                        // start by sending device address\r\n\t\twrite(Temperature_type);                       // choosing ambient or object temperature\r\n\t\t// read\r\n\t\trestart(dev | I2C_READ);                       // restart \r\n\t\tdataLow = read(false);                         // reading lower bytes\r\n\t\tdataHigh = read(false);                        // reading higher bytes\r\n\t\tpec = read(true);                              // reading packet error code\r\n\t\tstop();\r\n\r\n\t\t// This combines high and low bytes together and processes temperature, MSB is a error bit and is ignored for temps\r\n\t\tdouble resolutionFactor = 0.02;                // resolution factor of the MLX90614\r\n\t\tdouble temperature = 0x0000; \r\n\t\tint frac;                                      // data past the decimal point\r\n\r\n\t\t\r\n\t\ttemperature = (double)(((dataHigh & 0x007F) << 8) | dataLow); // removes error bit of high byte by shifting and adds the low byte \r\n\t\ttemperature= (temperature * resolutionFactor) - 0.01;         // multiplying temperature value with resolutionFactor \r\n        celcius = (float)(temperature- 273.15);\r\n\r\n\t\treturn celcius;                                               // return the value of temperature in celcius\r\n\t\t\t\r\n\t}\r\n\r\n\r\nIn this, how can I change the API to nRF TWI drivers? I know the question is so stupid. But as a new comer the nRF APIs seems to be tougher for me. ",
    "tag": "i2c"
  },
  {
    "text": "RGB LED PWM driver with nrf51 Greetings,\r\n\r\nHere's an implementation of controlling the color of a RGB LED with a TIMER of nRF51. It works well most of the time, although it inverts polarity kind of randomly, especially when the r,g,b values are low. We know of the issue of PWM inversion with nRF51, but in this case, the timer is stopped before setting the CC values and then started again. Could any light be shed on this issue? Note: we can't use the standard PWM driver as using a timer peripheral supports only two channels, not three required for a RGB LED.\r\n\r\nThanks!\r\n\r\n[rgb_timer.c](/attachment/796756f2ecf55cea918abb5f5c35fb1c)\r\n[rgb_timer.h](/attachment/eb659a4acf5b7605f3f63f3e62799035)\r\n",
    "tag": "pwm"
  },
  {
    "text": "HardFault when running app_pwm_init() I am trying to add PWM library functionality to my \"template\" PWM application and observe that:\r\n\r\n  - If I place `app_pwm_init()` before BLE initialization, I have Invalid Parameter error originated from the call to `nrf_drv_timer_init()` in that function.\r\n  - If I place `app_pwm_init()` after BLE initialization, I crash right into HardFault error after reaching `pwm_dealloc()`\r\n\r\nMy PWM initialization is not anything special yet. I am 99% only following the sample code in the [PWM Library documentation](https://infocenter.nordicsemi.com/index.jsp). The only different thing is variable names and parameter values (period, pin number).\r\n\r\nWhat could be going wrong here?\r\n\r\nI am also attaching the project here for reference. The folder is supposed to be placed on the same level as ble_app_uart example in SDK v10.\r\n[music_error.zip](/attachment/be345d917a287aff65107b95095fa9f3)\r\n",
    "tag": "pwm"
  },
  {
    "text": "BLE not advertising when TWI pins are changed Hi devs,\r\n\r\nI am working in an nRF52 DK.\r\nThe attached example is not working when I change the SCL and SDA pins of TWI1 module. This is also not working if I disable TWI1 and enable TWI0!! The device doesn't get detected in nRF uart app or nRF connect apps.\r\n[nRF5_SDK_11.0.0_MPU6050_Acc_X_Output.7z](/attachment/8f3de1d339e38bd8a5fd8909e6c54f63)\r\n\r\n\r\nI also tried the nrf5-mpu-simple program from this [nrf5-mpu-examples-master.zip](/attachment/5c4d23ff7d402d3ff03d3881bd70f3a3), which I got from github.\r\nplease help.\r\n\r\nthanks & regards,\r\nVishnu",
    "tag": "i2c"
  },
  {
    "text": "NRF52 Dim LED with PWM Driver I am migrating from nrf51 to nrf52. Using SDK12.1\r\n\r\nOn NRF51, I used the PWM Library to use 2 buttons on the DK to dim up or down onboard LED1 (called OUTPUT_LED).\r\nIt worked great (not sure if it did it properly or not).\r\nThe code was fairly simple.\r\n\r\nI set up the PWM\r\n\r\n    APP_PWM_INSTANCE(PWM1,1);\r\n\r\nI then initialize PWM:\r\n\r\n    app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(5000L, OUTPUT_LED);\r\n\r\n \tapp_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n\r\n    app_pwm_enable(&PWM1);\r\n    \r\n    while (app_pwm_channel_duty_set(&PWM1, 0, pwm_value) == NRF_ERROR_BUSY);\r\n\r\n\r\nI then call the code in the button handler to dim up or down.\r\n    \r\n\r\n\r\n\r\n    if (button_action == APP_BUTTON_PUSH)  { \r\n    \r\n    switch (pin_no)\r\n    {\r\n        case DIM_UP_BUTTON:\r\n            if (pwm_value<100)\r\n            {\r\n               ++pwm_value; \r\n            }\r\n                \r\n            while (app_pwm_channel_duty_set(&PWM1, 0, pwm_value) == NRF_ERROR_BUSY);\r\n            break;\r\n\r\n        case DIM_DOWN_BUTTON:\r\n            if (pwm_value >1)\r\n            {\r\n                --pwm_value;    \r\n            }\r\n            \r\n            while (app_pwm_channel_duty_set(&PWM1, 0, pwm_value) == NRF_ERROR_BUSY);\r\n            \r\n            break;\r\n            \r\n        default:\r\n            APP_ERROR_HANDLER(pin_no);\r\n            break;}\r\n\r\nI am looking at the examples for using the hardware PWM driver that the nrf52 has. They look super confusing! So many parameters.I just want to dim an LED at a set frequency.\r\nCan someone help me with a code example for the PWD driver that will work similarly? I would like to do this using the nrf52 hardware PWM versus using the extra resources needed with the PWM library method.\r\nI appreciate the help!,\r\nBryan",
    "tag": "pwm"
  },
  {
    "text": "software I2C for nRF52832 Hi,\r\n\r\nIs there any software I2c library or example projects for nRF52 devices (PCA10400) with pin configuration, read and write functions? I am using an SMBus based sensor and the inbuilt TWI drivers are not working. \r\n\r\nThanks,\r\nVishnu",
    "tag": "i2c"
  },
  {
    "text": "waking from sleep Hi,\r\n\r\nI am having some trouble getting the nrf51422 (running the s130 soft device) to wake up after entering sleep mode.  I have successfully entered sleep mode using NRF_POWER->SYSTEMOFF = 1, and sd_power_system_off() (both seem to be effective).  However, when I attempt to wake up on a pin change, the chip appears to enter an unresponsive state where it consumes excessive current. \r\n\r\ninitialize input pin:\r\n\r\n    ret_code_t err_code;\r\n    \r\n        //init gpiote module if not already initialized\r\n        if (!nrf_drv_gpiote_is_init())\r\n        {\r\n            err_code = nrf_drv_gpiote_init();\r\n            APP_ERROR_CHECK(err_code);\r\n        }\r\n        \r\n        //uint32_t out_pin_initial_state = 0; //for the 3v3 enable\r\n        \r\n        /********** HALL INPUT PIN  *******/\r\n        nrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n        in_config.pull = NRF_GPIO_PIN_PULLDOWN;\r\n    \r\n        err_code = nrf_drv_gpiote_in_init(SCOPE_HALL_PIN, &in_config, in_pin_handler); //set pin and event handler\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_in_event_enable(SCOPE_HALL_PIN, true); //enable event handling\r\n\r\n\r\nsleep:\r\n\r\n    NRF_POWER->SYSTEMOFF = 1;  \r\n\r\npin change handler:\r\n\r\n    void in_pin_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)\r\n    {\r\n        SEGGER_RTT_printf(0, \"pin change \\n\");\r\n    \r\n        sd_nvic_SystemReset();\r\n    }\r\n\r\nIf I do not enter sleep mode, the pin handler works normally (resulting in a restart).  However, it doesn't perform as expected when the device is sleeping.  I can't tell if the code in the pin change handler actually runs, as the chip becomes unresponsive and nothing is printed.  It definitely stops sleeping on pin change though (and consumes much more current than it does in normal operation).  Any suggestions on how to properly wake the device would be greatly appreciated.  Thanks!",
    "tag": "interrupt"
  },
  {
    "text": "Need NRF8001 to advertise while Microcontroller asleep. I'm using an NRF8001 with an ATMEL ATMEGA 328P (the microcontroller from an Arduino). I need the microcontroller to go to sleep, but still allow the BLE chip to advertise and wake the microcontroller upon connection. It seems as though the BLE chip should advertise (after calling BTLEserial.pollACI()) while the microcontroller is sleeping, but this is not the case. Is this possible? If so how? Thanks in advanced.\r\n\r\n    void sleepNow(){ \r\n        set_sleep_mode(SLEEP_MODE_PWR_DOWN);\r\n        sleep_enable();         \r\n        attachInterrupt(0,ADAFRUITBLE_RDY, LOW); //Pin 2 is interrupt\r\n        sleep_mode();            \r\n        sleep_disable();        \r\n        detachInterrupt(0);\r\n    }\r\n    void loop() {  \r\n      BTLEserial.pollACI();\r\n      digitalWrite(7,HIGH); //Flashes an LED\r\n      delay(1000);\r\n      digitalWrite(7,LOW);\r\n      sleepNow();\r\n    }\r\n       ",
    "tag": "interrupt"
  },
  {
    "text": "Nrf24le1 gpio interrupt falling edge I want to use gpio interrupt int1,falling edge. I can trigger success, but one falling edge will trigger many times. Do i config wrong?\r\n[GPIO_INT.rar](/attachment/a3caf0a05b323052d100f9c6b19bb53d)",
    "tag": "interrupt"
  },
  {
    "text": "PPI does not work with PWM **URGENT**\r\n\r\nFirst of all, I have to mention that I dont understand PPI. \r\n\r\nI have application which uses PWM to control a pump which is connected to the nRF52. To the nRF52 is a sensor connected, which gives me a frequency. \r\n\r\nTo measure this frequency I use this example:\r\n\r\nhttps://devzone.nordicsemi.com/question/50171/measuring-input-gpio-pin-frequency-with-soft-device-running/\r\n\r\nNow when I add this code to my application, then the pwm wont work anymore.\r\nWhy?\r\n\r\nWhat does PPI have to do with PWM?\r\n\r\nHere is my setup of the pwm:\r\n\r\n\r\n    APP_PWM_INSTANCE(PWM1,0);\r\n\r\n    static void PWMinit(void)\r\n    {\r\n\t app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(9000,27);\r\n\t pwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n\t app_pwm_init(&PWM1, &pwm1_cfg, pwm_ready_callback);\r\n\t app_pwm_enable(&PWM1);\r\n    }\r\n\r\nAnd here the frequency measuring part:\r\n\r\n    static void timer_init()\r\n    {\r\n     NRF_TIMER1->TASKS_STOP = 1;\r\n     NRF_TIMER1->MODE = TIMER_MODE_MODE_Timer;\r\n     NRF_TIMER1->PRESCALER = 8;  // Fhck / 2^8 \r\n     NRF_TIMER1->CC[0] = 62500;  // 62500 - 1s\r\n\r\n     NRF_TIMER1->BITMODE = (TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos);   \r\n\r\n     NRF_TIMER1->TASKS_CLEAR = 1;\r\n     NRF_TIMER1->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);\r\n\r\n     NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n    }\r\n\r\n    static void counter_init()\r\n    {\r\n     NRF_TIMER2->TASKS_STOP = 1; \r\n     NRF_TIMER2->MODE = TIMER_MODE_MODE_Counter;\r\n     NRF_TIMER2->BITMODE = (TIMER_BITMODE_BITMODE_24Bit << TIMER_BITMODE_BITMODE_Pos);\r\n     NRF_TIMER2->TASKS_CLEAR = 1;\r\n     NRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n    }\r\n\r\n    static void gpiote_init(uint32_t pin)\r\n    {\r\n     NRF_GPIOTE->CONFIG[0]   =   0x01 << 0;                              // MODE: Event\r\n     NRF_GPIOTE->CONFIG[0]   |=  pin << 8;                               // Pin number\r\n     NRF_GPIOTE->CONFIG[0]   |=  GPIOTE_CONFIG_POLARITY_LoToHi  << 16;   // Event rising edge    \r\n    }\r\n\r\n    static void ppi_timer_stop_counter_init()\r\n    {\r\n     NRF_PPI->CHEN |= 1 << 0;\r\n     *(&(NRF_PPI->CH0_EEP)) = (uint32_t)&NRF_TIMER1->EVENTS_COMPARE[0];\r\n     *(&(NRF_PPI->CH0_TEP)) = (uint32_t)&NRF_TIMER2->TASKS_STOP;\r\n     NRF_PPI->CHENSET |= 1 << 0;\r\n    }\r\n\r\n    static void ppi_gpiote_counter_init()\r\n    {\r\n     NRF_PPI->CHEN |= 1 << 1;\r\n     *(&(NRF_PPI->CH1_EEP)) = (uint32_t)&NRF_GPIOTE->EVENTS_IN[0];\r\n     *(&(NRF_PPI->CH1_TEP)) = (uint32_t)&NRF_TIMER2->TASKS_COUNT;\r\n     NRF_PPI->CHENSET |= 1 << 1;\r\n    }\r\n\r\n    void TIMER1_IRQHandler(void) \r\n    {\r\n      if (NRF_TIMER1->EVENTS_COMPARE[0] != 0)\r\n      {\r\n        NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n        NRF_TIMER2->TASKS_CAPTURE[0] = 1;\r\n\r\n\t   frequency = NRF_TIMER2->CC[0];\r\n\r\n        NRF_TIMER1->TASKS_CLEAR = 1;\r\n        NRF_TIMER2->TASKS_CLEAR = 1;    \r\n\r\n        NRF_TIMER2->TASKS_START = 1;            \r\n      }\r\n    }\r\n\r\nIs it possible that they use the same PPI channel? How can I choose the channel of PWM PPI?\r\n\r\nAny hints?\r\n\r\nOn what I have to pay attention when I use PWM and PPI?\r\n\r\n**UPDATE**\r\n\r\nI think the problem is not in the PPI. I changed all of them. And the same for the timers.\r\n\r\nWhat else can I do? \r\n\r\nThe problem is between PWMinit() and gpiote_init functions.\r\n\r\nBut this is strange. Because in the gpiote_init function I only choose a mode,pin and polaritity.",
    "tag": "pwm"
  },
  {
    "text": "Build example into chips with preinstalled SOFTDEVICE ![image description](/attachment/076898f65295ac5294dc8810492336bf)Hello to everyone. I'll need to use ble things with pwm. I'm trying to play around with pwm library it's ok, but it's build only on erased chip, trying to flash it into chip with preinstalled sdk 2.1.0  raise an error: Flash Download failed - \"Cortex- M4\" (KEIL). I guess that it refers to using flash memory or stuff like that, but my next step will be to use pwm along with ble (that as I understand need preinstalled sdk)",
    "tag": "pwm"
  },
  {
    "text": "Trying to read a 24-bit register using I2C Hi, I am trying to read a 24-bit register (with 8-bit address) using the I2C (nrf52). And the timing diagram is given below.\r\n\r\n![image description](/attachment/3c26e610e93c503969abc5249e692976)\r\n\r\nBasically I created a 3-element array (24-bit in total) \r\n\r\n    static uint8_t m_sample[3];\r\n\r\nand use **nrf_drv_twi_rx** to store the value into the array.\r\n    \r\n    void read_register(uint8_t address){ \t\r\n    \tret_code_t err_code;\r\n    \t\t\r\n    \tm_xfer_done = false;\r\n    \terr_code = nrf_drv_twi_tx(&m_twi, SLAVE_ADDR, &address, 1, false);\r\n        APP_ERROR_CHECK(err_code);\r\n        while (m_xfer_done == false);\r\n    \t\r\n    \tm_xfer_done = false;\r\n    \r\n        /* Read from register */\r\n        err_code = nrf_drv_twi_rx(&m_twi, SLAVE_ADDR, m_sample, sizeof(m_sample));\r\n        APP_ERROR_CHECK(err_code);\r\n    \t\r\n    \twhile (m_xfer_done == false){};\r\n    }\r\n\r\nCan anyone tell me if this works? Thank you very much.\r\n\r\nP.S. How does the ACK and NACK work in nrf52? How can I control these two bit?",
    "tag": "i2c"
  },
  {
    "text": "i2c/twi detup on register level Hello I'm trying to setup i2c/twi communication between nrf52832 with oled driver SH1107 but i need to do it in hardware instead of software but on the register level. \r\n\r\n\r\n\r\n\r\n    void initI2c()\r\n    {\r\n    \tNRF_TWIM0->SHORTS = 0x00001780;\r\n    \tNRF_TWIM0->INTEN = 0x019C0022;\r\n    \tNRF_TWIM0->ERRORSRC = 0x00000006;\r\n    \tNRF_TWIM0->PSEL.SCL\t= 0x0000000D;\r\n    \tNRF_TWIM0->PSEL.SDA = 0x0000000E;\r\n    \tNRF_TWIM0->FREQUENCY = 0x06400000;\r\n    \tNRF_TWIM0->ADDRESS = 0x0000078;\r\n    \tNRF_TWIM0->ENABLE = 0x00000006;\r\n    }\r\n    \r\n    void WriteTwiCommand (unsigned char Data)\r\n    {\r\n    \t#define BUFFER_SIZE 2\r\n    \ttypedef struct ArrayList\r\n    \t{\r\n    \t\tuint8_t buffer[BUFFER_SIZE];\r\n    \t} ArrayList_type;\r\n    \tArrayList_type MyArrayList[2];\r\n    \tNRF_TWIM0->TXD.MAXCNT = BUFFER_SIZE;\r\n    \tNRF_TWIM0->TXD.PTR = &MyArrayList;  // here it says (incompativle pointer to integer conversion when i copied that from the datasheet) \r\n    \tNRF_TWIM0->TASKS_STARTTX;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\nthis is my code guys for the twi initialization and for sending transmission to slave. i need my nrf52 to act as a master only so i chose TWIM for that reason. im very new to communication protocols so please be patient with me. also if something in my question is not clear or missing, please let me know so i can clear it up as best i can. ",
    "tag": "i2c"
  },
  {
    "text": "adding pwm to ble_template Hello everyone! \r\nI'm very shy to ask probably a stupid question, but...\r\nI'm trying get abitity to change pwm signal via ble. \r\nI've created service, characteristic, then I try to add some code from pwm_library example but Keil doesn't like my idea to add \r\nAPP_PWM_INSTANCE(PWM1, 2) \r\nthe error is *..\\..\\..\\main.c(105): error:  #20: identifier \"TIMER0_ENABLED\" is undefined*\r\nI understand that timer I'm gonna use for pwm (TIMER 1 I think) is disabled. I've tried change in sdk_config.h \r\n\r\ndefine TIMER1_ENABLED 0\r\nto\r\ndefine TIMER1_ENABLED 1\r\nbut nothing change.\r\n\r\n![image description](/attachment/61b81ea45cb20d56d58708f390bc4306)",
    "tag": "pwm"
  },
  {
    "text": "soft pwm with rtc I would need more pwm channels, than there is possible with pwm library on nrf51822 (That is 16 channels).\r\nI would like to do it in a fashion, similar to [this](https://github.com/g4lvanix/AVR-tutorials/blob/master/Software%20PWM%202/main.c), using a prescaler of 15, so pwm frequency would be 2.048 kHz.\r\n\r\nMy questions are:\r\n\r\n- can i toggle multiple pins in one go (similar to PORTD in avr)\r\n- would this work with soft device\r\n- would this work at all, since approach in avr is specific with ORCR1A value increasing manually.\r\n\r\nSimple example would be excellent.\r\n\r\n\r\nThank you. ",
    "tag": "pwm"
  },
  {
    "text": "GPIOTE IN_EVENT Current Hello,\r\n\r\nI am currently using the GPIOTE Driver (nrf_drv_gpiote) to detect external interrupts from a sensor on a custom board using the nRF51822 with the S130 v2.0.0 SoftDevice and SDK 11. I currently have the interrupts setup to use the GPIOTE IN_EVENT instead of the PORT event because I need to detect fast changing signals that are missed when using the PORT events. I have been looking through other posts on the Devzone and I am aware that using the IN_EVENT over the PORT event will increase the current consumption which is fine during normal operation. The problem I am having is that when I attempt to enter and Idle/Low-Power state (not System Off), I can't seem to reduce the current from the ~1mA that I am seeing after the interrupt triggers the IN_EVENT.\r\n\r\nI have tried everything I can think of but no matter what I do I can't reduce the current consumption. I have tried:\r\n\r\n - Using `nrf_drv_gpiote_in_event_disable(pin)` to disable the interrupt\r\n - Using `nrf_drv_gpiote_in_uninit(pin)` to uninitialize the module for the pin\r\n - Using `NRF_POWER->TASKS_LOWPWR = 1` to turn off the HFCLK (suggested by Ole [here](https://devzone.nordicsemi.com/question/70789/1ma-active-mode-troubleshooting/))\r\n - Using `NRF_CLOCK->TASKS_HFCLKSTOP = 1` to stop the HFCLK\r\n - Using every combination of the above\r\n\r\nI am using `NRF_CLOCK_LF_SRC_XTAL` as my clock source and I am certain that the GPIOTE IN_EVENT is causing the increased current consumption. When I enter the idle state mentioned above, I am calling `sd_app_evt_wait()` until I leave the idle state.\r\n\r\nIs there anything I can do to reduce the current consumption after a GPIOTE IN_EVENT is triggered?\r\n\r\nAny help anyone can offer is greatly appreciated.\r\n\r\nThanks!\r\n\r\n-Cory",
    "tag": "interrupt"
  },
  {
    "text": "rtc and app_timer Hi,\r\n\r\nIs it possible to use RTC for timekeeping along with app_timer functionality?\r\nFor example, I want to use simple RTC counter register and overflow interrupt to provide time tracking, but also need the app_timers. The second timer is used for low power pwm library.",
    "tag": "pwm"
  },
  {
    "text": "External flash for nrf52832 Hello Everyone!!!\r\n\r\nI want to interface an external flash with nrf52832. I will be using it to store the new image downloaded during OTA-DFU. Also, some data will be residing in it. It should be spi or i2c interfaced. Also, I am planning to run my system at around 1.8V.\r\n\r\nCan you guys please suggest me any flash satisfying the mention criteria?\r\nDo we have a flash driver for it? If not exact, a reference driver to look for?\r\n\r\nAll suggestions are welcomed.\r\n\r\nRegards,\r\nPrasad.",
    "tag": "i2c"
  },
  {
    "text": "nRF52 timer has no modulus? I'm learning about the nRF52 series and so far love everything I see, especially the SDK. But I just got to the point where I'd like to generate precisely timed output, and there is something I don't understand: the nRF52832 timer seems to have no modulus (wraparound) setting. From what I understand, you can set the prescaler and the bit width, but the timer will still run over the full range of values allowed by the bit width.\r\n\r\nThis seems to imply that you can't produce arbitrary PWM output, only a specific set of PWM periods is supported.\r\n\r\nAm I missing something?",
    "tag": "pwm"
  },
  {
    "text": "nRF52 and PN532 on the same board Hi Nordic, \r\n\r\nI have managed to make a board which has both the nRF52 and PN532 modules  on the same board [(picture)](/attachment/2a6c3cc6592c54667f2c2c8a64b67513), connecting it through I2C as shown on the example [here](https://devzone.nordicsemi.com/blogs/920/how-to-test-nrf52-nfc-tag-with-reader-adafruit-tag/). Programming can be done with a Sagger J-link. \r\n\r\nI was thinking of launching a Kickstarter campaign to promote the board and also get a first batch produced, but I would like also the opinion of Developer Zone. What do you think? \r\n\r\nThank you. \r\n\r\nBest wishes,\r\n\r\nCristian",
    "tag": "i2c"
  },
  {
    "text": "NRF51 with interrupts Hello developers,\r\nI am struggling badly to use interrupt in my application. I am using softdevice S130 and ble_nus, ble_bas and ble_hrm services. All I want is to trigger a timer on interrupt event by pressing a button. \r\nI have tried every possible thing gpiote, app_gpiote also many examples including pin_change_int but I am not able to make it work, please help me with this.\r\n\r\nRegards,\r\nSid",
    "tag": "interrupt"
  },
  {
    "text": "12 bit duty cycle resolution at 25 KHz PWM frequency Hi,\r\n\r\nDoes anyone know if there is a way to achieve 12 bit duty cycle resolution at 25 KHz PWM frequency for 5 channels (individual duty cycle for each channel) using the NRF52823 ?",
    "tag": "pwm"
  },
  {
    "text": "nRF51822 PWM and GPIOTE: differrences between Keil MDK(ARMCC) and GNU_GCC_ARM Compiler Hello everybody!\r\n\r\nI have a problem with compilers for nRF51822.\r\nMy problems: I create a pwm signal ~38Khz, duty 30% at pin 30 of nRF51822. This process is work well. I want use the function: \r\n\r\n    nrf_drv_gpiote_out_task_enable(pin)\r\n    nrf_drv_gpiote_out_task_disable(pin)\r\n\r\nto  Enable and Disable pwm signal to GPIO (pin 30). With Keil MDK is good (as the followd picture), but with gcc compiler is not good (as the second picture).\r\nI use SDK11, pwm_library example\r\n\r\n\r\n\r\nSource code:\r\n\r\n\r\n    APP_PWM_INSTANCE(PWM1,1);                   // Create the instance \"PWM1\" using TIMER1.\r\n    \r\n    static volatile bool ready_flag;            // A flag indicating PWM status.\r\n    \r\n    void pwm_ready_callback(uint32_t pwm_id)    // PWM callback function\r\n    {\r\n        ready_flag = true;\r\n    }\r\n    \r\n    #define enable_pwm_out(pin)\t\t\tnrf_drv_gpiote_out_task_enable(pin)\r\n    #define disable_pwm_out(pin)\t\tnrf_drv_gpiote_out_task_disable(pin)\r\n    int main(void)\r\n    {\r\n        ret_code_t err_code;\r\n        \r\n    \t\r\n    \t/*2 channels PWM, 38,4Khz - 26us, p30 and p8*/\r\n        app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(26L, 30, 8);\r\n        \r\n        /* Switch the polarity of the second channel. */\r\n    \t\tpwm1_cfg.pin_polarity[0] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n        pwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH;\r\n        \r\n        /* Initialize and enable PWM. */\r\n        err_code = app_pwm_init(&PWM1,&pwm1_cfg,pwm_ready_callback);\r\n        APP_ERROR_CHECK(err_code);\r\n        app_pwm_enable(&PWM1);\r\n        \r\n        \r\n        while(true)\r\n        {\r\n    \t\t\t\r\n    \t\t\t\tdisable_pwm_out(30);\r\n    \t\t\t\twhile (app_pwm_channel_duty_set(&PWM1, 0, 30) == NRF_ERROR_BUSY);\r\n    \t\t\t\t//while (app_pwm_channel_duty_set(&PWM1, 1, 70) == NRF_ERROR_BUSY);\r\n    \t\t\t\t\r\n    \t\t\t\t//Create timing\r\n    \t\t\t\twhile(1){\r\n    \t\t\t\t\t\r\n    \t\t\t\t\tenable_pwm_out(30);\t\r\n    \t\t\t\t\tnrf_delay_us(2400);\r\n    \t\t\t\t\t\r\n    \t\t\t\t\tdisable_pwm_out(30);\r\n    \t\t\t\t\tnrf_delay_us(600);\r\n    \t\t\t\t\t\r\n    \t\t\t\t\tenable_pwm_out(30);\t\r\n    \t\t\t\t\tnrf_delay_us(1200);\r\n    \t\t\t\t\t\r\n    \t\t\t\t\tdisable_pwm_out(30);\r\n    \t\t\t\t\tnrf_delay_us(600);\r\n    \t\t\t\t\t\r\n    \t\t\t\t\tenable_pwm_out(30);\t\r\n    \t\t\t\t\tnrf_delay_us(600);\r\n    \t\t\t\t\t\r\n    \t\t\t\t\tdisable_pwm_out(30);\t\r\n    \t\t\t\t\tnrf_delay_us(600);\r\n    \t\t\t\t}\r\n        }\r\n        \r\n    }\r\n\r\n\r\n\r\nResults with Keil MDK:\r\n![image description](/attachment/df956c0a604dd15ed4165698e7cc1b62)\r\n\r\nResults with ARM_GCC:\r\n![image description](/attachment/568b1efaf63dcb5ffba2a5169cfb3c5f)\r\n\r\nI do not understand why gcc_arm compiler is not good with my problems.\r\nThanks for your watching!\r\n",
    "tag": "pwm"
  },
  {
    "text": "SDK 12 PWM Driver + Softdevice 132 + NRF52832 Hi Devzone. \r\n\r\nI've taken the ble_app_hrs example, \r\nand then added the example code from the PWM Driver example. \r\n\r\nThe PWM module is mostly functional, \r\nhowever I have a fatal error that is prohibiting operation for more than a minute. \r\nThis only occurs when I use a PWM handler, which leads me to believe I have a sync issue. \r\n\r\nThe overall architecture is - \r\n\r\n - begin using PWM0 with sequence A \r\n - when sequence A finishes, the PWM handler sets a flag for the task function to switch to sequence B\r\n - when sequence B finishes, the PWM handler sets a flag for the task function to switch to sequence A\r\n - I am using this approach because I am switching physical pins. Sequence A is on pin A, sequence B is on pin B. \r\n\r\nI'm using simple playback with NRF_DRV_PWM_FLAG_STOP. \r\nI have added FreeRTOS Semaphores and task functions for synchronization. \r\nThis is using nRF SDK12 with a nrf52832.\r\n\r\nI am seeing a few failure modes, using both ARMGCC and Keil compilers. \r\n\r\n - The NRF_DRV_PWM_EVT_FINISHED event occurs but the NRF_DRV_PWM_EVT_STOPPED does not. This halts my PWM sequences.\r\n - The handler does not execute, leaving my task function without any flags to act upon.\r\n - The task function itself stops running\r\n\r\nHere is my handler function (it has support for all 3 PWM modules, each with their own semaphore)\r\n\r\n    if( xSemaphoreTakeFromISR( *pwm_sem_ptr, NULL ) == pdTRUE )\r\n    {\r\n        switch(event_type)\r\n        {\r\n            case NRF_DRV_PWM_EVT_FINISHED: // using stopped vs finished\r\n                printf(\"\\t\\tFINISHED %d\\r\\n\", *pwm_state_ptr);\r\n                break;\r\n            case NRF_DRV_PWM_EVT_END_SEQ0: // not using complex playback\r\n                printf(\"\\t\\tEND_SEQ0\\r\\n\");\r\n                break;\r\n            case NRF_DRV_PWM_EVT_END_SEQ1: // not using complex playback\r\n                printf(\"\\t\\tEND_SEQ1\\r\\n\");\r\n                break;\r\n            case NRF_DRV_PWM_EVT_STOPPED:\r\n                nrf_drv_pwm_uninit(pwm_instance_ptr);\r\n                m_change |= CHANGE_PWM(pwm_instance_num);\r\n                printf(\"\\t\\tSTOPPED %d\\r\\n\", *pwm_state_ptr);\r\n                break;\r\n        }\r\n        xSemaphoreGiveFromISR( *pwm_sem_ptr, NULL );\r\n    }    \r\n\r\nHere is my task function for PWM0 (the rest are disabled while I figure this out)\r\n\r\n    vTaskDelay(50 / portTICK_PERIOD_MS);\r\n    \r\n    if( xSemaphoreTake( xSemaphore0, 10 ) == pdTRUE )\r\n    {\r\n        if (m_change & 0x01)\r\n        {\r\n            m_change &= ~0x01;\r\n            switch(m_state_pwm0)\r\n            {\r\n                case PWM_IDLE:\r\n                    break;\r\n                case PWM_SEQA:\r\n                    pwm_seqb(PWM0);\r\n                    break;\r\n                case PWM_SEQB:\r\n                    pwm_seqa(PWM0);\r\n                    break;\r\n            }\r\n        }\r\n        xSemaphoreGive( xSemaphore0 );\r\n    }\r\n\r\nThis is how the pwm sequences are initiated:\r\n\r\n    config.output_pins[0] = BSP_LED_2 | NRF_DRV_PWM_PIN_INVERTED;\r\n    err_code = nrf_drv_pwm_init(&m_pwm0, &config, handler0);\r\n    APP_ERROR_CHECK(err_code);\r\n    m_used |= USED_PWM(PWM0);\r\n    m_state_pwm0 = PWM_SEQA;\r\n    nrf_drv_pwm_simple_playback(&m_pwm0, &pwm_seq_a, 1,\r\n                                 NRF_DRV_PWM_FLAG_STOP );\r\n\r\nI see some older versions of the SDK have a USE_WITH_SOFTDEVICE boolean, however I do not see that anywhere in SDK 12. Is there something obvious I missed in the docs/examples? \r\n",
    "tag": "pwm"
  },
  {
    "text": "PWM Driver starting new sequence with NRF52 I am not sure how exactly the NRF52 handles a call to start a new sequence. There are 3 different scenarios (trying to start a new sequence before, right after and way after the current sequence):\r\n\r\n1) When the current sequence hasn't finished yet and I try to start a new sequence (e.g. nrf_drv_pwm_simple_playback() ). What I saw happening here was actually a complete stop of the PWM driver (it seems to crash it). Is that what I should expect? So the only way to interrupt a sequence and start a new one is to actually explicitly stopping the current sequence and then running a new one (which may be visible when driving LEDs)?\r\n\r\n2) When you get a NRF_DRV_PWM_EVT_END_SEQx event, and even though you might have a long PWM cycle or a big repeat number, if you call for a new sequence here, it will actually wait the end of the execution of the current sequence and run the new one continuously. This is what I saw happening, is that correct?\r\n\r\n3) When you run a sequence without LOOP so it keeps running the last PWM cycle of the sequence after it finishes and then you call a new sequence. Even though your previous sequence has already finished before, the PWM driver is still repeating the last duty cycle (in case you don't stop the module). So if I call a new sequence here, will it interrupt the current duty cycle and run the new sequence straight away (since the previous one already finished before) or it still waits for the end of the current duty cycle before starting the new one?\r\n\r\nThanks in advance",
    "tag": "pwm"
  },
  {
    "text": "nRF52832 No accurate 4MHz PWM output with SoftwateDevice 332 in SDK11.0.0 SDK:11.0.0\r\n\r\nMCU:nRF52832\r\n\r\nUsing example:ble_ant_app_hrm\r\n\r\nSoftwateDevice Version:s332\r\n\r\nPWM is turned on and accurate 4MHz is available before entering ble_stack_init();\r\n\r\nPWM is unstable after enterd SOFTDEVICE_HANDLER_INIT(&clock_lf_cfg, NULL); in ble_stack_init(); \r\n\r\nHow to keep 32MHz external crystal always running with SoftwateDevice Version:s332?\r\n\r\nHow can I keep accurate 4MHz PWM output after  enterd ble_stack_init();?\r\n\r\nI really need ACCURATE 4MHz PWM output.\r\n\r\nWaiting online,Thanks for help",
    "tag": "pwm"
  },
  {
    "text": "Call SOC Library functions with Sofdevice disabled Hi there,\r\n\r\nIs it possible to call SOC library functions before calling sd_softdevice_enable()?\r\n\r\nIn particular, i want to set up my interrupts with sd_nvic_SetPriority() and sd_nvic_EnableIRQ() before enabling the softdevice with sd_softdevice_enable(). This is because sd_softdevice_enable() takes quite a while and i want my interrupts running before that.\r\n\r\nI use nRF5 SDK v12.2.0 and S130 SoftDevice v2.0.1\r\n\r\nThanks for your help",
    "tag": "interrupt"
  },
  {
    "text": "nrf51822 pwm working some minutes will loss. \r\n\r\n    APP_PWM_INSTANCE(PWM1,1); \r\n    \r\n    \r\n    void PWM_init(void)\r\n    {\r\n        u32 err_code;\r\n    \r\n        app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_1CH(1000, 8);   \r\n    \t\r\n        err_code = app_pwm_init(&PWM1,&pwm1_cfg,NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        app_pwm_enable(&PWM1);\r\n        while (app_pwm_channel_duty_set(&PWM1, 0, 0) == NRF_ERROR_BUSY); \r\n    }\r\n    \r\n    \r\n    void PWM_Set( u8 duty )\r\n    {\r\n        if ( duty>100 )    duty = 100;\r\n    \t\r\n        while (app_pwm_channel_duty_set(&PWM1, 0, duty) == NRF_ERROR_BUSY);\r\n    }\r\n\r\nhi,anybody! I have a issue When a device receives the bluetooth data will set the function PWM_Set() , duty take any value.\r\n",
    "tag": "pwm"
  },
  {
    "text": "Download firmware over I2C for another MCU Hello,\r\n\r\nI have a custom board which has NRF52832 SOC(i.e. main MCU) and another ARM Core-M0-based MCU(i.e. target MCU). These two are connected over I2C. I wonder how to download firmware of target MCU from NRF52832 SOC to this target MCU over I2C?\r\n\r\nI know we can flash SoftDevice, Bootloader, and Application to NRF52832 by using nRFgo Studio, but what about firmware for target MCU? How do I attach the target MCU's firmware(*.HEX) to the HEX files mentioned above and then doing the target MCU firmware downloading between main MCU and target MCU over I2C?\r\n\r\nIm using Nordicsemi nRF5 SDK v11.0.0.\r\n\r\nI'm very new to this area and hence your suggestions and experience in this regard will be very helpful.\r\n\r\nMany thanks in advance.",
    "tag": "i2c"
  },
  {
    "text": "nRF24LU1 wakeup interrupt Hi, Nordic\r\nI see two interrupts:\r\n\r\n    #define USB_WU_ISR()    void usb_wu_isr(void)   interrupt INTERRUPT_USB_WU  // USB wakeup interrupt (0x5b)\r\n    #define WU_ISR()        void wu_isr(void)       interrupt INTERRUPT_WU      // Internal wakeup interrupt (0x6b)\r\n   maybe WU_ISR() is one function USB Dongle auto resume itselft, now I need if USB Dongle enter suspend state, USB Dongle can resume itselft, can I use it? If yes, plz tell me how to do.\r\n\r\nThanks.",
    "tag": "interrupt"
  },
  {
    "text": "SPI and TWI at same time Can I use two TWI modules (TWI0 and TWI1) and one SPI module in one application for nrf52832? ",
    "tag": "i2c"
  },
  {
    "text": "Disable interrupts Hi,\r\nI want to do this cycle with GPIO without interrupting it on NRF51 with BLE softdevice:\r\n\r\n1) PIN1 to HIGH level\r\n2) read value of PIN2\r\n3) PIN1 to LOW level\r\n\r\nRepeat this 25 times (between cycles interrupts can happen)\r\n\r\nWhat is the easiest way to accomplish that?",
    "tag": "interrupt"
  },
  {
    "text": "How to send accelerometer axis data over BLE to an android phone. nRF51822 BLE Nano Hello i am quite new to using BLE for data collection. I am using a Readbear BLE Nano with a Nordic nRF51822 on it.\r\n\r\nI want to read a Sparkfun MMA8452Q accelerometer's X, Y, and Z coordinates over I2C and then write the readings to a connected android phone over BLE. So far I haven't found any good examples or literature on how to send accelerometer data over BLE. Is there an Acceleration Service or do I have to incorporate these coordinates into a different type of service?\r\n\r\nAny literature or work in this direction and context will be very helpful.",
    "tag": "i2c"
  },
  {
    "text": "I2C with Softdevice nrf_drv_twi_enable hangs Using SDK 12.1.0\r\n\r\nI2C with SoftDevice works on PCA10040 Eval Board with nRF52832 but\r\nhangs in the nrf_drv_twi_enable function with TY module EBSGCNZWY which is an \r\nnRF51822 version F1.\r\nRunning without the SoftDevice on the TY module, the I2C works fine.\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "why should I clear event in the interrupt handler as far as I am concerned, when I use PPI or SHORTS without interrupts, I DON'T need to clear the corresponding event registers, and task will be triggered once the event is generated. But when I enable interrupt, I have to clear the event register, otherwise, something wrong happened. Is it true that without interrupts, events will be cleared automatically? What's the differences between them?",
    "tag": "interrupt"
  },
  {
    "text": "GPIOTE simultaneous interrupts nRF52, SDK12.1, Eclipse, gcc 5.4.1, FreeRTOS, no soft-device.\r\n\r\nI am having a problem with GPIOTE. I have six interrupts programmed on six different pins. As long as the signals do not transition at the same time, the firmware receives interrupts from all pins independently; everything works fine. However, if any two signals change simultaneously, the GPIOTE seems to stop responding altogether: no further interrupts are generated.\r\n\r\nFive of the interrupts are configured like so:\r\n\r\n    nrf_drv_gpiote_in_config_t config = GPIOTE_CONFIG_IN_SENSE_LOTOHI(false);\r\n    config.pull = NRF_GPIO_PIN_PULLDOWN;\r\n    ret_val = nrf_drv_gpiote_in_init(adxl_isr_pin[i], &config, adxl_event_handler);\r\n\r\n\r\nThe sixth interrupt is configured using NRF_GPIOTE_POLARITY_TOGGLE as it must interrupt on both edges. There are three different event handlers.\r\n\r\n\r\nIn [this](https://devzone.nordicsemi.com/question/105056/gpiote-handler-module-or-gpiote-driver-for-port-interrupt/) post is the following quote:\r\n\r\n> If power-consumption is not an issue and the signals may transition at the same time, then I would initialize the pins with nrf_drv_gpiote_in_init with a nrf_drv_gpiote_in_config_t struct where hi_accuracy is set to true and register a separate event handler for each of the pins. \r\n\r\nThis post implies that signals that transition simultaneously must use high accuracy. Is this true? If a GPIOTE event is configured for \"low accuracy\", can multiple simultaneous events be detected? Assuming that simultaneous events cannot be detected, is this restriction removed / eliminated if \"high accuracy\" is used? Why does this happen?\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Problems with I2C & mma8652fc Hello,\r\n\r\nwe developed a custom board using the nRF52832. We are having problems communicating with the  mma8652fc accelerometer using I2C. We also have a Rigado BMD-200 EVAL board (based on nRF51822), which has the same accelerometer on. With the Rigado board we can successfully communicate with the accelerometer, and are having no problems whatsoever.\r\n\r\nOur custom board was soldered by a professional Pick and place company, so the pins are probably soldered ok. We have 6 boards and we are having problems with all of them, so it may be a problem on our side. I attached the accelerometer schematic at the bottom.\r\n\r\nDid anyone had similar problems, or anyone has some pointers to guide is in the right direction? :)\r\n\r\nI can provide more details if required.\r\n\r\nThanks!\r\n\r\n![image description](/attachment/2a1dbaa7ff81e4f58ee87d8a252531aa)\r\n\r\n![image description](/attachment/a8ab7b5638c4ac22d167df072cf91a21)",
    "tag": "i2c"
  },
  {
    "text": "Problem using I2C Hello Everyone) Have new unsolved problem. My custom PCB based on nrf52832 SoC has only controller, FXOS8700 accelerometer and MAX30205 health temperature sensor. For communication between ICs I'm using I2C Bus, BUTTTTT (I'm using mbed 5.0) when I try to write something to register, my app never return (i2c.write).....Tried on all frequencies..... I'm using TI TPS63031 DCDC converter for Vdd_nrf and don't use shielded Inductor....Can it be cause of the problem?????Thank for YOUR RESPONSE))))\r\nUPDATE: 6.02\r\nI2C work on other ports, but if I use port 7 and port 5, it don't work....",
    "tag": "i2c"
  },
  {
    "text": "I2C Returning Same Wrong Value Trying to keep this as short as possible. I have 3 I2C devices on a bus. A LSM303(accelerometer + magnetometer), a high precision temp sensor, tricolor LED driver TCA6057,and a L3GD20(gyroscope). The gyro and the accelo are made by the same company and have virtually identical register mappings. I base my library on the arduino library for the LSM303. I can read the accelo just fine and every seems to be working. \r\n\r\nI used a similar arduino library to interact with the L3GD20. The arduino library works fine interacting with the device. However whenever I try to interact with it using my port of the arduino library it basically just returns the last address value that I set. so for example if I set it to 0x6F, and I attempt to call the readGyroReg method it returns 6F not matter what register I try to read. It has something to do with the enable method because we acutally started up our circuit and attempted a read, got 0x6F, then wired in the arduino, ran the arduino enable method, then had our device do a read and it read the values fine. I feel like I may be using the TWI functions incorrectly even though it works using almost an identical protocol for the LSM303. The problem is driving me crazy.\r\n\r\nhere is my library code where I implement the twi any ideas. relatively new to proper controller c code so criticism is welcome, but don't make me cry ;)\r\n\r\nCode I am referring to and full files attached below.\r\n\r\n***CODE***\r\n\r\n    void writeGyro(uint8_t* valToWrite, uint8_t numBytesToWrite){\r\n        uint32_t err_code;\r\n        m_tx_done = false;\r\n        err_code = nrf_drv_twi_tx(&m_twi_device, D20_SA0_HIGH_ADDRESS, (uint8_t*)valToWrite, numBytesToWrite, false);  \r\n        APP_ERROR_CHECK(err_code);\r\n        while(!m_tx_done);\r\n    }\r\n    \r\n    uint8_t* readGyro(uint8_t addrToRead,uint8_t numBytesToRead){\r\n        uint32_t err_code;\r\n        writeGyro(&addrToRead, 1);\r\n        m_rx_done = false;\r\n        err_code = nrf_drv_twi_rx(&m_twi_device, D20_SA0_HIGH_ADDRESS, (uint8_t*)&m_fromI2Cdevice, numBytesToRead);\r\n        APP_ERROR_CHECK(err_code);\r\n        while(!m_rx_done);\r\n        return m_fromI2Cdevice;\r\n    }\r\n    \r\n    uint8_t readGyroReg(uint8_t addrToRead){\r\n        uint32_t err_code;\r\n        m_fromI2Cdevice[0] = 0x00;\r\n        writeGyro(&addrToRead, 1);\r\n        m_rx_done = false;\r\n        err_code = nrf_drv_twi_rx(&m_twi_device, D20_SA0_HIGH_ADDRESS, (uint8_t*)&m_fromI2Cdevice, 1);\r\n        APP_ERROR_CHECK(err_code);\r\n        while(!m_rx_done);\r\n        return m_fromI2Cdevice[0];\r\n    }\r\n    \r\n    void enableGyro(){\r\n        // 0x00 = 0b00000000\r\n        // Low_ODR = 0 (low speed ODR disabled)\r\n        uint8_t setCtrlReg[2] = {LOW_ODR,0x00};\r\n        writeGyro(setCtrlReg, 2);\r\n        nrf_delay_ms(10);\r\n        // 0x6F = 0b01101111\r\n        // DR = 01 (200 Hz ODR); BW = 10 (50 Hz bandwidth); PD = 1 (normal mode); Zen = Yen = Xen = 1 (all axes enabled)\r\n        setCtrlReg[0] = CTRL1G;\r\n        setCtrlReg[1] = 0x6F;\r\n        writeGyro(setCtrlReg,2);//CTRL1G, 0x6F);\r\n        nrf_delay_ms(10);\r\n        // 0x00 = 0b00000000\r\n        // FS = 00 (+/- 250 dps full scale)\r\n        setCtrlReg[0] = CTRL4G;\r\n        setCtrlReg[1] = 0x00;\r\n        writeGyro(setCtrlReg,2);//CTRL4G, 0x00);\r\n        nrf_delay_ms(10);   \r\n    }\r\n    \r\n    int16_t* readGyroXYZ(){\r\n    \r\n        uint8_t msbassert = (OUT_X_L_G | (1 << 7));\r\n        \r\n        uint8_t* results = readGyro(msbassert,6);\r\n        \r\n        uint8_t xla = results[0];\r\n        uint8_t xha = results[1];\r\n        \r\n        uint8_t yla = results[2];\r\n        uint8_t yha = results[3];\r\n        \r\n        uint8_t zla = results[4];\r\n        uint8_t zha = results[5];\r\n    \r\n        // combine high and low bytes\r\n        // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0\r\n        // (12-bit resolution, left-aligned). The D has 16-bit resolution\r\n        int16_t gx = (int16_t)(xha << 8 | xla);\r\n        int16_t gy = (int16_t)(yha << 8 | yla);\r\n        int16_t gz = (int16_t)(zha << 8 | zla);\r\n        \r\n        gyroVals[0] = gx;\r\n        gyroVals[1] = gy;\r\n        gyroVals[2] = gz;\r\n    \r\n        return gyroVals; \r\n    }\r\n\r\n\r\n\r\n\r\n[TCA6057.c](/attachment/2c060d1145c21a07b1452ba7bfdb899c)\r\n[TCA6057.h](/attachment/0dd3c1b6489354ee60949ca05dc7691a)",
    "tag": "i2c"
  },
  {
    "text": "I2c + timer1 + timer2 + softdevice(S210) Hi Nordic,\r\n\r\nMy application does the following:\r\n\r\n - Timer 2 takes care of controlling a shift register (CLK and DATA)\r\n - Timer 1 takes care of polling data from sensor via I2C, each 10ms\r\n - We are continuously sending and receiving data from one opened ANT channel\r\n\r\nThe thing is that everything works good except when I try to read data from I2C at each timer 1 tick. What is more strange is that if I manually reset the microprocessor, sometimes everything works, and some other nothing works.\r\n\r\nI am having the feeling that this may have to do with interrupt priority? But I have no idea.. Maybe timer 1 is already being used by I2C driver? \r\n\r\nEDIT: timers code:\r\n\r\n    static void timer1_init()\r\n    {\r\n    \t\tNVIC_EnableIRQ(TIMER1_IRQn);\r\n        NVIC_SetPriority(TIMER1_IRQn, NRF_APP_PRIORITY_LOW);\r\n        NRF_TIMER1->TASKS_STOP = 1;\r\n        NRF_TIMER1->MODE = TIMER_MODE_MODE_Timer;\r\n        NRF_TIMER1->PRESCALER = 4;  // Fhck / 2^4 \r\n    \t\tconst uint32_t PRESCALER_VALUE = 100;\r\n    \t\tNRF_TIMER1->CC[0] = PRESCALER_VALUE & 0xFFFF;  // 10000 - 10ms \r\n    \t\r\n        NRF_TIMER1->BITMODE = (TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos);   \r\n    \r\n        NRF_TIMER1->TASKS_CLEAR = 1;\r\n        NRF_TIMER1->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);\r\n    \r\n        NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n    \t\r\n    \t\r\n    \t// start timer\r\n    \tNRF_TIMER1->TASKS_START = 1;\r\n    }\r\n    \r\n    static void timer2_init()\r\n    {\r\n    \t\tNVIC_EnableIRQ(TIMER2_IRQn);\r\n        NVIC_SetPriority(TIMER2_IRQn, NRF_APP_PRIORITY_LOW);\r\n        NRF_TIMER2->TASKS_STOP = 1;\r\n        NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;\r\n        NRF_TIMER2->PRESCALER = 4;  // Fhck / 2^4 \r\n    \t\tconst uint32_t PRESCALER_VALUE = 100;\r\n    \t\tNRF_TIMER2->CC[0] = PRESCALER_VALUE & 0xFFFF;  // 10000 - 10ms \r\n    \t\r\n        NRF_TIMER2->BITMODE = (TIMER_BITMODE_BITMODE_16Bit << TIMER_BITMODE_BITMODE_Pos);   \r\n    \r\n        NRF_TIMER2->TASKS_CLEAR = 1;\r\n        NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);\r\n    \r\n        NRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n    \t\r\n    \t\r\n    \t// start timer\r\n    \tNRF_TIMER2->TASKS_START = 1;\r\n    }\r\n\r\n\r\n[...]\r\n\r\n    void TIMER1_IRQHandler(void) \r\n    {\r\n        if (NRF_TIMER1->EVENTS_COMPARE[0] != 0)\r\n        {\r\n            NRF_TIMER1->EVENTS_COMPARE[0] = 0;\r\n            NRF_TIMER1->TASKS_CLEAR = 1;\r\n    \tmpu_handle_timer_interrupt(); // here is where I send things over I2C\r\n    \t\t\t\t\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    void TIMER2_IRQHandler(void) \r\n    {\r\n        if (NRF_TIMER2->EVENTS_COMPARE[0] != 0)\r\n        {\r\n            NRF_TIMER2->EVENTS_COMPARE[0] = 0;\r\n            NRF_TIMER2->TASKS_CLEAR = 1;\r\n    \tleds_handle_timer_interrupt();\r\n        }\r\n    }\r\n\r\nEDIT2: mpu function:\r\n\r\n    void mpu_handle_timer_interrupt()\r\n    {\r\n    \t\r\n    \t\tstatic bool var = false; // detect change in breaking level. When theres a positive edge, var = true and stays like that. When theres a negative edge, var = false and stays until positive edge\r\n    \t\tstatic uint16_t mpu_counter = 0;\r\n    \t\tif (mpu_counter > 50)\r\n    \t\t{\r\n    \t\t\tmpu_counter = 0;\r\n    \t\t\t//az = MPU6050_getAccelerationZ(&mpu);\r\n    \t\t\tMPU6050_getMotion6(&mpu, &ax, &ay, &az, &gx, &gy, &gz);\r\n    \t\t\tzAcc = az;\r\n                   zAccAvg = smooth(zAcc);\r\n                  if (zAccAvg > lowerB)\r\n                  {\r\n                      nrf_gpio_pin_set(break_pin);\r\n                      lowerB = minVal + hist;\r\n                      var = true;\r\n                  }\r\n                  else \r\n                  {\r\n                    if (var) // if out of threshold zone, turn off breaking pin. var is for edge detection\r\n                    {\r\n                       var = false;\r\n                       nrf_gpio_pin_clear(break_pin);\r\n                       lowerB = minVal;\r\n                   }\r\n    \t\t\t\t\r\n          }\r\n    \r\n    \t\t}\r\n    \t\telse\r\n    \t\t{\r\n    \t\t\tmpu_counter++;\r\n    \t\t}\r\n    }\r\n\r\n\r\nEDIT3: i2c driver .c\r\n\r\n    #include \"app_util_platform.h\"\r\n    #include \"i2cdev.h\"\r\n    \r\n    \r\n    \r\n    \r\n    /**\r\n     * @brief TWI events handler.\r\n     */\r\n    static void twi_handler(nrf_drv_twi_evt_t const * p_event, void * p_context)\r\n    {   \r\n        switch(p_event->type)\r\n        {\r\n            case NRF_DRV_TWI_RX_DONE:\r\n    \t\t\t\t\t\ttwi_rx_done = 0x01;\r\n                break;\r\n            case NRF_DRV_TWI_TX_DONE:\r\n    \t\t\t\t\t\ttwi_tx_done = 0x01;\r\n                break;\r\n            default:\r\n                break;        \r\n        }   \r\n    }\r\n    \r\n    void twi_init (void)\r\n    {\r\n        ret_code_t err_code;\r\n        \r\n        const nrf_drv_twi_config_t twi_mma = {\r\n           .scl                = SCL_PIN,\r\n           .sda                = SDA_PIN,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n        };\r\n        \r\n        err_code = nrf_drv_twi_init(&m_twi, &twi_mma, twi_handler, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n        \r\n        nrf_drv_twi_enable(&m_twi);\r\n    }\r\n    \r\n    \r\n    static bool wrapper_nrf_drv_twi_tx(nrf_drv_twi_t const * const p_instance,\r\n                              uint8_t                     address,\r\n                              uint8_t const *             p_data,\r\n                              uint32_t                    length,\r\n                              bool                        xfer_pending)\r\n    {\r\n    \t\tuint32_t err_code;\r\n    \t\terr_code = nrf_drv_twi_tx(p_instance, address, p_data, length, xfer_pending);\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t\twhile(twi_tx_done == 0x00); // maybe make timeout here?\r\n    \t\ttwi_tx_done = 0x00;\r\n    \t\treturn true; // how or when return false?\r\n    }\r\n    \r\n    \r\n    static bool wrapper_nrf_drv_twi_rx(nrf_drv_twi_t const * const p_instance,\r\n                              uint8_t                     address,\r\n                              uint8_t *                   p_data,\r\n                              uint32_t                    length,\r\n                              bool                        xfer_pending)\r\n    {\r\n    \t\tuint32_t err_code;\r\n    \t\terr_code = nrf_drv_twi_rx(p_instance, address, p_data, length, xfer_pending);\r\n    \t\tAPP_ERROR_CHECK(err_code);\r\n    \t\twhile(twi_rx_done == 0x00); // maybe make timeout here?\r\n    \t\ttwi_rx_done = 0x00; // how or when return false?\r\n    \t\treturn true;\r\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    \r\n    void i2c_read_bytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data) \r\n    {\r\n    \t\twrapper_nrf_drv_twi_tx(&m_twi, devAddr, &regAddr, 1, true);\r\n    \t\twrapper_nrf_drv_twi_rx(&m_twi, devAddr, data, length, false);\r\n    }\r\n    \r\n    void i2c_write_byte(uint8_t devAddr, uint8_t regAddr, uint8_t data)\r\n    {\t\r\n    \t\tuint8_t w2_data[2];\r\n    \r\n        w2_data[0] = regAddr;\r\n        w2_data[1] = data;\r\n    \r\n    \t\twrapper_nrf_drv_twi_tx(&m_twi, devAddr, w2_data, 2, false);\r\n    }\r\n    \r\n    void i2c_write_bytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data)\r\n    {\t\r\n    \t\twrapper_nrf_drv_twi_tx(&m_twi, devAddr, data, length, false);\r\n    }\r\n    \r\n    void i2c_read_byte(uint8_t devAddr, uint8_t regAddr, uint8_t *data)\r\n    {\r\n    \ti2c_read_bytes(devAddr, regAddr, 1, data);\r\n    }\r\n    \r\n    void i2c_read_bit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data)\r\n    {\r\n    \t\tuint8_t b;\r\n        i2c_read_byte(devAddr, regAddr, &b);\r\n        *data = b & (1 << bitNum); // returns in data a 1 or a 0, corresponding to that bit.\r\n    }\r\n    \r\n    void i2c_read_bits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data) {\r\n        // 01101001 read byte\r\n        // 76543210 bit numbers\r\n        //    xxx   args: bitStart=4, length=3\r\n        //    010   masked\r\n        //   -> 010 shifted\r\n        uint8_t b;\r\n        i2c_read_byte(devAddr, regAddr, &b);\r\n    \t\tuint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\r\n    \t\tb &= mask;\r\n    \t\tb >>= (bitStart - length + 1);\r\n    \t\t*data = b;\r\n    }\r\n    \r\n    void i2c_write_bit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data)\r\n    {\r\n    \t\tuint8_t b;\r\n        i2c_read_byte(devAddr, regAddr, &b);\r\n        b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));\r\n        i2c_write_byte(devAddr, regAddr, b);\r\n    }\r\n    \r\n    void i2c_write_bits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {\r\n        //      010 value to write\r\n        // 76543210 bit numbers\r\n        //    xxx   args: bitStart=4, length=3\r\n        // 00011100 mask byte\r\n        // 10101111 original value (sample)\r\n        // 10100011 original & ~mask\r\n        // 10101011 masked | value\r\n        uint8_t b;\r\n        i2c_read_byte(devAddr, regAddr, &b);\r\n    \t\tuint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\r\n    \t\tdata <<= (bitStart - length + 1); // shift data into correct position\r\n    \t\tdata &= mask; // zero all non-important bits in data\r\n    \t\tb &= ~(mask); // zero all important bits in existing byte\r\n    \t\tb |= data; // combine data with existing byte\r\n    \t\ti2c_write_byte(devAddr, regAddr, b);\r\n    }\r\n    \r\n    \r\n    void i2c_write_words(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data)\r\n    {\r\n    \t\r\n    \twrapper_nrf_drv_twi_tx(&m_twi,devAddr,&regAddr,1,true);\r\n    \r\n    \tfor (int i=0;i<length;i++)\r\n    \t{\r\n    \t\tuint8_t d[2];\r\n    \t\td[0]=data[i]>>8;\r\n    \t\td[1]=data[i]&0xff;\r\n    \t\tbool pending = i < length - 1;\r\n    \t\twrapper_nrf_drv_twi_tx(&m_twi, devAddr, d, 2, pending);\r\n    \t}\r\n    }\r\n    \r\n    void i2c_write_word(uint8_t devAddr, uint8_t regAddr, uint16_t data) \r\n    {\r\n    \ti2c_write_words(devAddr, regAddr, 1, &data);\r\n    }\r\n\r\n\r\nThanks a lot!\r\n",
    "tag": "i2c"
  },
  {
    "text": "pwm dimming led rgb with trouble on third and thourth channel. i am having trouble with pwm module 2. only two of the channels are working but not the third nor the fourth.\r\ni tried pwm module 1 but im having the same problem there.  i cant tell what im missing :/\r\n\r\nthe third channel only works if i declare it on its with \"NRF_PWM2->PSEL.OUT\" and passing only zeros to other elements in \"pwm_seq[4]\" even tho i did not activate the other channels/assign them to any physical pin.\r\n\r\nplease help.\r\n\r\n\r\n    void initRgbPwm(int32_t pwmFreq)  \r\n    {                                      \t\t\t\r\n    \t\trgbCounterTop = 0;\t\r\n    \t\tuint32_t baseFreq = 500000;\r\n    \t\tuint8_t preSc = 5;\r\n    \t\twhile(rgbCounterTop <= 100 && baseFreq <= 16000000)\r\n    \t\t{\r\n    \t\t\trgbCounterTop = (baseFreq / pwmFreq);\r\n    \t\t\tif(rgbCounterTop <= 100 && baseFreq <= 16000000)\r\n    \t\t\t{\r\n    \t\t\t\tbaseFreq = baseFreq * 2;\r\n    \t\t\t\tpreSc--;\r\n    \t\t\t}\telse break;\r\n    \t\t}\r\n    \t\t\r\n    \t\tIf(rgbCounterTop > 100)   \r\n    \t\t{\r\n    \t\t\t\tuint16_t pwm_seq[4] = {0, 0, 0, 0};\r\n    \t\t\t\r\n    \t\t\tNRF_PWM2->PSEL.OUT[0] = 0x0000001A;\t// red rgb.\r\n    \t\t\tNRF_PWM2->PSEL.OUT[1] = 0x00000006;\t// green rgb.\r\n    \t\t\tNRF_PWM2->PSEL.OUT[2] = 0x0000001B;\t// blue rgb.\r\n    \t\t\t\r\n    \t\t\tNRF_PWM2->ENABLE = 1;   \r\n    \t\t\tNRF_PWM2->MODE = 0;   \r\n    \t\t\tNRF_PWM2->PRESCALER = preSc;   \r\n    \t\t\tNRF_PWM2->COUNTERTOP = rgbCounterTop;    \r\n    \t\t\tNRF_PWM2->LOOP = 0;   \r\n    \t\t\tNRF_PWM2->DECODER = 0X00000102;    \r\n    \t\t\tNRF_PWM2->SEQ[0].PTR  = ((uint32_t)(pwm_seq) << PWM_SEQ_PTR_PTR_Pos);    \r\n    \t\t\tNRF_PWM2->SEQ[0].CNT  = ((sizeof(pwm_seq) / sizeof(uint16_t)) << PWM_SEQ_CNT_CNT_Pos);   \r\n    \t\t\tNRF_PWM2->TASKS_SEQSTART[0] = 1;    \r\n    \t\t}\r\n    }\r\n    \r\n    void rgbPwm(uint8_t dutyCycleRed, uint8_t dutyCycleGreen, uint8_t dutyCycleBlue)\r\n    {\r\n    \tuint16_t dutyCycleCh1 = (dutyCycleRed * rgbCounterTop)/100;  \r\n    \tuint16_t dutyCycleCh2 = (dutyCycleGreen * rgbCounterTop)/100; \r\n    \tuint16_t dutyCycleCh3 = (dutyCycleBlue * rgbCounterTop)/100; \r\n    \t\r\n    \tuint16_t pwm_seq[4] = {dutyCycleCh1  | 0x8000, dutyCycleCh2  | 0x8000, dutyCycleCh3  | 0x8000, 0};\r\n\r\n    \tNRF_PWM2->SEQ[0].PTR  = ((uint32_t)(pwm_seq) << PWM_SEQ_PTR_PTR_Pos);\r\n    \tNRF_PWM2->SEQ[0].CNT  = ((sizeof(pwm_seq) / sizeof(uint16_t)) << PWM_SEQ_CNT_CNT_Pos);\r\n    \tNRF_PWM2->TASKS_SEQSTART[0] = 1;\r\n    }",
    "tag": "pwm"
  },
  {
    "text": "Low-power PWM library: PWM doesnt stop if low_power_pwm_stop is called from handler. Is this a bug? I am using SDK 12.0.0. \r\n\r\nI am working with low_power_pwm_init() to initialise the pwm and I have passed a handler while initialising. I want to stop the pwm from the handler hence I am calling low_power_pwm_stop() from the handler. I observe that the pwm doesnt stop. \r\n\r\nI tried to investigate the reason for this and found that pwm_timeout_handler() in low_power_pwm.c is restarting the pwm. Below is the snippet that is suspect. \r\n\r\n    if (p_pwm_instance->pwm_state == NRF_DRV_STATE_INITIALIZED)\r\n    {\r\n        p_pwm_instance->pwm_state = NRF_DRV_STATE_POWERED_ON;\r\n        err_code = app_timer_start(*p_pwm_instance->p_timer_id, p_pwm_instance->timeout_ticks, p_pwm_instance);\r\n        APP_ERROR_CHECK(err_code);\r\n    }\r\n\r\nIn low_power_pwm_stop(), p_pwm_instance->pwm_state is assigned NRF_DRV_STATE_INITIALIZED and in the above snippet the timer is started if the driver state is NRF_DRV_STATE_INITIALIZED, causing the pwm to be ON again. \r\n\r\nIs this a bug?",
    "tag": "pwm"
  },
  {
    "text": "Write command for HRMI board using TWI Hello,\r\n\r\nI am trying to implement a [Heart Rate Monitor Interface](https://www.sparkfun.com/products/8661) (HRMI) board with my nRF52, using the TWI_sensor example from SDK 12.2. I am running into trouble Writing to commands to the peripheral I2C address. Here is the driver I have written to do so:\r\n\r\n`#define HRMI_I2C_ADDR1      127`\r\n`#define HRMI_SET_MODE      0x53`\r\n`#define HRMI_GET_HR_DATA\t 0x47`\r\n\r\n    ret_code_t HRMI_set_mode() {\r\n    ret_code_t ret_code;\r\n    uint8_t command_address2 = HRMI_SET_MODE; // <0x53>\r\n    ret_code = nrf_drv_twi_tx(&m_twi, HRMI_I2C_ADDR, &command_address2, 1, false);\r\n    return ret_code;}\r\n\r\n    ret_code_t start_HR() {\r\n    ret_code_t ret_code;\r\n    uint8_t command_address = HRMI_GET_HR_DATA; // <0x47>\r\n    ret_code = nrf_drv_twi_tx(&m_twi, HRMI_I2C_ADDR, &command_address, 3, false);\r\n    return ret_code;}\r\n\r\n    ret_code_t fetch_HR(uint8_t * hr){\r\n    ret_code_t ret_code;\r\n    uint8_t returned_over_I2C[3]; //Array to hold returned data\r\n\t\tint data;\r\n    ret_code = nrf_drv_twi_rx(&m_twi, HRMI_I2C_ADDR, returned_over_I2C, sizeof(returned_over_I2C)); \r\n    nrf_delay_ms(10);\r\n\t\t*hr = returned_over_I2C[2];\r\n\t\treturn ret_code;}\r\n\r\n    int main(void){\r\n\t\t\r\n    ret_code_t err_code;  \r\n    uint8_t hr;\t\r\n    /* Initializing TWI master  */\r\n    err_code = twi_master_init();\r\n    HRMI_set_mode(); //write command <0x53> to I2C address to set heart rate algorithm mode\r\n    APP_ERROR_CHECK(err_code);\r\n\t\t\r\n    while (true)\r\n    {           \r\n        nrf_delay_ms(500);\r\n\t    start_HR(); //write command <0x47> to I2C address to Get Heart Rate Data\r\n        nrf_delay_ms(500);\r\n        fetch_HR(&hr);  \r\n        SEGGER_RTT_printf(0, \"Heart Rate: \");\r\n\t    SEGGER_RTT_printf(0, \"%d\\n\", hr);}}\r\n\r\nMy code is not working and I believe I know why. The HRMI datasheet lists the I2C commands in a different way than I've seen using the nRF52. For example, the I2C command to set the mode is `<0x53><N>`, where <N> is a 3-bit mask value where bit-place zero should be set to '1' to set average mode.\r\n\r\nAdditionally, the I2C command to Get Heart Rate Data is `<0x47><N>` where `<N>` is the number of HR values requested. I would like to access 1 value.\r\n\r\nI believe I am not writing the correct values to the I2C register because of the format with these `<N>` values. Currently, the nRF52 shows a `*hr = returned_over_I2C[2];` value of ASCII \"244\", and this appears even if my SDA and SCL lines are disconnected from the nRF52. \r\n\r\nMy question is: How can I make sure my Write commands are for the command and the following arguments using the nrf_drv_twi_tx() function? \r\n\r\nThank you for your time.\r\n",
    "tag": "i2c"
  },
  {
    "text": "what is the maximum limit for PWM outputs pins on nrf52832? Can we use all the GPIO pins as a PWM output? Hello\r\n\r\nwhat is the maximum limit for PWM outputs pins on nrf52832? Can we use all the GPIO pins as a PWM output?\r\n\r\nFor ADC, i can see there are 8 dedicated pins , but i want to confirm for PWM that if there are any GPIO pins which can't be used as PWM o/p.\r\n\r\nThanks for your time",
    "tag": "pwm"
  },
  {
    "text": "pwm_driver period is always 50Hz.WHY? Hello all,\r\n\r\nI have created a BLE application on nRF52 PCA10040 devboard with S132 SD, in which I would like to use a PWM with the [PWM_Driver](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v12.0.0%2Fhardware_driver_pwm.html&cp=4_0_0_2_10).\r\nMy pwm source code as below wants to control an RGB LED on GPIO outputs:\r\n\r\n    #define TOPVALUE 1000\t/* Value up to which the pulse generator counter counts */\r\n    static nrf_drv_pwm_t pwm \t= NRF_DRV_PWM_INSTANCE(1);\r\n    static nrf_pwm_values_individual_t seq_values_pwm;\t\t/* Duty cycle values */\r\n    static nrf_pwm_sequence_t const seq_pwm =\t\t\t\t/* Sequence of duty cycle values */\r\n\t{\r\n\t\t.values.p_individual = &seq_values_pwm,\r\n\t\t.length\t\t\t\t = NRF_PWM_VALUES_LENGTH(seq_values_pwm),\r\n\t\t.repeats\t\t\t = 0,\r\n\t\t.end_delay\t\t\t = 0\r\n\t};\r\n    void PWM_Init_f(void){\r\n\r\n\t   ret_code_t err_code;\r\n\r\n\t   nrf_drv_pwm_config_t const config_pwm =\r\n\t   {\r\n\t\t   .output_pins =\r\n\t\t   {\r\n\t\t\tGPIO_O_PWM_RGB_R | NRF_DRV_PWM_PIN_INVERTED,\t\t\t/* Channel 0 - RED   */\r\n\t\t\tGPIO_O_PWM_RGB_G | NRF_DRV_PWM_PIN_INVERTED,\t\t\t/* Channel 1 - GREEN */\r\n\t\t\tGPIO_O_PWM_RGB_B | NRF_DRV_PWM_PIN_INVERTED, \t\t\t/* Channel 2 - BLUE  */\r\n\t\t\tGPIO_O_PWM_W     | NRF_DRV_PWM_PIN_INVERTED\t\t\t\t/* Channel 3 - WHITE */\r\n\t\t   },\r\n\t\t   .irq_priority = APP_IRQ_PRIORITY_LOW,\r\n           .base_clock   = NRF_PWM_CLK_1MHz,\t\t/* Base Clock */\r\n           .count_mode   = NRF_PWM_MODE_UP,\r\n           .top_value    = TOPVALUE,\r\n           .load_mode    = NRF_PWM_LOAD_INDIVIDUAL,\r\n           .step_mode    = NRF_PWM_STEP_AUTO\r\n\t   };\r\n\t   err_code = nrf_drv_pwm_init(&pwm, &config_pwm, NULL);\r\n\t   APP_ERROR_CHECK(err_code);\r\n       }\r\n    void PWM_Update_f(int16_t dutyR, int16_t dutyG, int16_t dutyB, int16_t dutyW)\r\n    {\r\n\t   /* TOPVALUE - : because the LEDs are woring with negative logic */\r\n\t   seq_values_pwm.channel_0 = TOPVALUE - dutyR;\r\n\t   seq_values_pwm.channel_1 = TOPVALUE - dutyG;\r\n\t   seq_values_pwm.channel_2 = TOPVALUE - dutyB;\r\n   \t   seq_values_pwm.channel_3 = TOPVALUE - dutyW;\r\n\t\r\n\t   nrf_drv_pwm_simple_playback(&pwm, &seq_pwm, 1, NRF_DRV_PWM_FLAG_STOP);\r\n    }\r\n\r\n\r\nAnd it is triggered in void main() while a button is pressed:\r\n\r\n    ...\r\n    PWM_Init_f();\r\n    while (true)\r\n    {\r\n\t\tsd_app_evt_wait();\r\n\r\n\t\tif(nrf_gpio_pin_read(GPIO_I_BUTTON_4) == BUTTON_PRESSED)\r\n\t\t{\r\n\t\t\tPWM_Update_f(100, 200, 500, 1000);\r\n\t\t}\r\n    }\r\n\r\nI detect the signals with an oscilloscope on GPIO output, and **I always get 50 Hz (20 msec) periods** between the edges. \r\nDo you know what I did wrong? I would like to have more than 120 Hz period between the edges because of dimming an RGB LED.\r\nHow is it possible?\r\n\r\nThank you in advance!\r\n\r\nRegards,\r\n\r\nDaniel\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "PWM input signal Hi,\r\n\r\nIs it possible to have a PWM input signal with a nRF51822? Is there any example of how it works?\r\nI want to read the dutycycle of a PWM signal.",
    "tag": "pwm"
  },
  {
    "text": "Is it possible to use twi on bootloader? Hi there! \r\n\r\nI'm working with secure_bootloader example  (SDK 12.1.0) and trying to use i2c communication on bootloader. I'm using the debug code and checking via LOG (uart), but when I added the initialization process of twi (nrf_drv_twi_init) I receive an error:\r\n:ERROR:received an error: 0x00001001!\r\n\r\nWhat that error means? Is it possible to use i2c on bootloader? \r\n\r\nThanks,\r\nLuccas Casagrande.",
    "tag": "i2c"
  },
  {
    "text": "using twi on bootloader Hi there! \r\n\r\nI'm working with secure_bootloader example  (SDK 12.1.0) and trying to use i2c communication on bootloader. I'm using the debug code and checking via LOG (uart), but when I added the initialization process of twi (nrf_drv_twi_init) I receive an error:\r\n:ERROR:received an error: 0x00001001!\r\n\r\nWhat that error means? Is it possible to use i2c on bootloader? \r\n\r\nThanks,\r\nLuccas Casagrande.",
    "tag": "i2c"
  },
  {
    "text": "Use internal nRF52 pull-up w/ TWIM? Hi all --\r\n\r\nI have a tricky layout \"issue\" where unfortunately, I've ended up connecting my I2C device to the BlueTooth module on the side of the module where my VDD isn't routed (two-layer board + a solid GND plane on the bottom layer == tricky layout / using 0R resistors to jump traces...).\r\n\r\nI have a set of 10K PU in my schematic right now to VDD -- on some parts I've used in the past, the PU/PD functionality of a given pin is tied to the GPIO 'peripheral' usage -- i.e., if that pin is given to a SPI/I2C or other peripheral, the pull-up / pull-down control is lost.\r\n\r\nI expect that the internal PU is slightly weaker than 10k, but I only have a single I2C device on the board. **Can I configure a pin to have the internal pull-up on in addition to being the TWIM SCL and SDA pins?**",
    "tag": "i2c"
  },
  {
    "text": "Does the NFC Type 4 library globally disable interrupts at any point? Does the NFC library globally disable interrupts at any point?  We're trying to track down an issue where our code occasionally misses an I2C event during NFC read/write. ",
    "tag": "interrupt"
  },
  {
    "text": "nrf52 i2c initialization hello,\r\n\r\nAccording to the \"twi_scanner\" example from the SDK12.2 I don't understand how the respective I2C pins/GPIOs are set up.\r\nThere is this function that I found \"nrf_gpio_cfg()\" in the \"nrf_gpio.h\" but in the example this function is not called. So how are the pull-ups for SCL and SDA activated then?\r\n\r\nThank you\r\nHannes",
    "tag": "i2c"
  },
  {
    "text": "I2c with Grid eye sensor hello ,\r\n\r\nI am interfacing Grideye AMG8832 with Nrf51822. The initialization part is executed without errors but ON trying to recieve or transmit it gives error of TWI as shown in the screenshot attached.I have tried with 0x68 address and even with variants of memory address.\r\n\r\nI am using SDK 9 with the example  [link text](https://devzone.nordicsemi.com/attachment/1b6ea057b9358233999b85ed310f4792)\r\n\r\nas shown in this [link text](https://devzone.nordicsemi.com/question/48894/hardware-twii2c-example/)\r\n\r\nplease guide through this!\r\n\r\n[main.c](/attachment/c3de9910dd53e20dced719bdd595dc9e)\r\n\r\nthank you\r\n\r\n![image description](/attachment/8e110b4781358589d9388f13c599e4c9)",
    "tag": "i2c"
  },
  {
    "text": "Setting up clock on nRF24le1 for I2C > \r\n\r\nI used the following code to verify the working of the clock (at P04) of nRF24le1.\r\nI used a 4.7K pull up resistor with a VDD of 3.3V, which was output from the nRF. \r\nNote that this setup was in isolation, without the slave.\r\n\r\nHowever, when I measure the clock signal using an oscilloscope, all I see is a constant high logic of 3.3V. I do not see any toggling and I don't understand why.\r\n\r\nCan you please tell me if you see any mistakes with this?\r\n\r\n\r\nvoid main() {\r\n\t\r\n\tP0DIR = 0x00;\t\t\t\t\t\t\t\t\t\t\t// Initiating IO pins \r\n\thal_w2_configure_master(HAL_W2_400KHZ);\r\n\r\n}",
    "tag": "i2c"
  },
  {
    "text": "How can I reuse this library into TWI library in nrF52? Hello all,\r\n\r\nI am trying to make use  of some Adafruit libraries for some sensors in my nrF52pca10040, the libraries are these two[Adafruit_BME280.cpp](/attachment/1b396766a2b39c0fb5378a4a618a4372), [Adafruit_BME280.h](/attachment/dd62aafff694afb5768b602308d0212c) and [Adafruit_TSL2591.h](/attachment/eb01ab394b920bdafff66baf0211d708),[Adafruit_TSL2591.cpp](/attachment/c502aa4f386182b2623c3b653d980376)\r\n\r\nThey both make use of either SPI or I2C interfaces, I am interested on I2C, so I was trying to port both to the nrF52, I have started with the BME280 one. Using SEGGER I am compiling them but I am getting an error when reaching the method  ` Wire.begin();` on `Adafruit_BME280::begin(uint8_t a)`, which is expected since this function is from Arduino.\r\n\r\nI have looked into the example `twi_sensor` and I see that there the `twi_init` is configured as\r\n\r\n    const nrf_drv_twi_config_t twi_lm75b_config = {\r\n       .scl                = ARDUINO_SCL_PIN,\r\n       .sda                = ARDUINO_SDA_PIN,\r\n       .frequency          = NRF_TWI_FREQ_100K,\r\n       .interrupt_priority = APP_IRQ_PRIORITY_HIGH,\r\n       .clear_bus_init     = false\r\n    };\r\n\r\nCan I use the same configuration for my case? What should I change to be able to make use of that library?\r\n\r\nOn the other hand, those libs work a lot with the definitions `HIGH`,`LOW`,`INPUT` or `OUTPUT`, where can I find those definitons for the nrf52 board? As well as functions as configuring the PIN(`pinmode(pin,OUPUT)`)  and writing onto it (digitalWrite(pin,HIGH)) ?\r\n\r\nThank you very much in advance,\r\n\r\nKind regards\r\n\r\nEdit: following the advice of Jorgen, I have created my own version of the begin, read and write, however, even though there is no compilation errors, debuging the lib it gets stack when reaching the condition `if (read8(BME280_REGISTER_CHIPID) != 0x60)` in the begin() method.\r\n\r\n    bool Adafruit_BME280::begin(uint8_t a) {\r\n      _i2caddr = a;\r\n    \r\n      if (_cs == -1) {\r\n        // i2c\r\n        //Wire.begin();\r\n    \r\n        ret_code_t err_code;\r\n    \r\n        const nrf_drv_twi_config_t twi_BME280_config = {\r\n           .scl                = ARDUINO_SCL_PIN,\r\n           .sda                = ARDUINO_SDA_PIN,\r\n           .frequency          = NRF_TWI_FREQ_100K,\r\n           .interrupt_priority = APP_IRQ_PRIORITY_HIGH,\r\n           .clear_bus_init     = false\r\n        };\r\n    \r\n        err_code = nrf_drv_twi_init(&m_twi, &twi_BME280_config, twi_handler, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_twi_enable(&m_twi);\r\n    \r\n      } else {\r\n    //    digitalWrite(_cs, HIGH);\r\n    //    pinMode(_cs, OUTPUT);\r\n    //\r\n    //    if (_sck == -1) {\r\n    //      // hardware SPI\r\n    //      SPI.begin();\r\n    //    } else {\r\n    //      // software SPI\r\n    //      pinMode(_sck, OUTPUT);\r\n    //      pinMode(_mosi, OUTPUT);\r\n    //      pinMode(_miso, INPUT);\r\n    //    }\r\n      }\r\n    \r\n      if (read8(BME280_REGISTER_CHIPID) != 0x60)\r\n        return false;\r\n    \r\n      readCoefficients();\r\n    \r\n      //Set before CONTROL_meas (DS 5.4.3)\r\n      write8(BME280_REGISTER_CONTROLHUMID, 0x05); //16x oversampling \r\n    \r\n      write8(BME280_REGISTER_CONTROL, 0xB7); // 16x ovesampling, normal mode\r\n      return true;\r\n    }\r\n\r\n    void Adafruit_BME280::write8(byte reg, byte value)\r\n    {\r\n      if (_cs == -1) {\r\n    \r\n        ret_code_t err_code;\r\n        err_code = nrf_drv_twi_tx(&m_twi, _i2caddr, (const byte*)reg, sizeof(reg), false);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        err_code = nrf_drv_twi_tx(&m_twi, _i2caddr, (byte*)value, sizeof(value), false);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n    \r\n    //    Wire.beginTransmission((uint8_t)_i2caddr);\r\n    //    Wire.write((uint8_t)reg);\r\n    //    Wire.write((uint8_t)value);\r\n    //    Wire.endTransmission();\r\n    }}\r\n    uint8_t Adafruit_BME280::read8(byte reg)\r\n    {\r\n      uint8_t value = 0;\r\n      uint8_t valueAux = 0;\r\n    \r\n      if (_cs == -1) {\r\n      \r\n        ret_code_t err_code = nrf_drv_twi_rx(&m_twi, _i2caddr, &valueAux, sizeof(byte));\r\n        APP_ERROR_CHECK(err_code);\r\n        if (m_rxfer_done) {\r\n          value = valueAux;//getting the value of the pointer\r\n          m_rxfer_done = false;\r\n        }\r\n    \r\n    \r\n    //    Wire.beginTransmission((uint8_t)_i2caddr);\r\n    //    Wire.write((uint8_t)reg);\r\n    //    Wire.endTransmission();\r\n    //    Wire.requestFrom((uint8_t)_i2caddr, (byte)1);\r\n    //    value = Wire.read();\r\n    \r\n      } \r\n      return value;\r\n    }\r\n\r\n    void Adafruit_BME280::twi_handler(nrf_drv_twi_evt_t const *p_event, void *p_context) {\r\n      switch (p_event->type) {\r\n      case NRF_DRV_TWI_EVT_DONE:\r\n        if (p_event->xfer_desc.type == NRF_DRV_TWI_XFER_RX) {\r\n          m_rxfer_done = true;\r\n        } else if (p_event->xfer_desc.type == NRF_DRV_TWI_XFER_TX) {\r\n          m_txfer_done = true;\r\n        }\r\n    \r\n        break;\r\n      default:\r\n        break;\r\n      }\r\n    }\r\n\r\nEDIT2![image description](/attachment/e1ab06f511ef2b4850dcc1b7db494281) Debug \r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Outputting a PWM signal at 8Mhz with 50% dutcy cycle We are working with SDK 12.1 and are noticing the max value we can output using the PWM driver is about 5.3Mhz (top value to 3 and 16Mhz for the clock) this isn't a 50% duty cycle either. This is confirmed in the data sheet as by looking at the COUNTERTOP.\r\n\r\nUsing the code below\r\n\r\n    static void start_pwm(void)\r\n    {\r\n        uint32_t err_code;\r\n        nrf_drv_pwm_config_t const config0 =\r\n        {\r\n            .output_pins =\r\n            {\r\n                IND_PWM_PIN,                          // channel 0\r\n                NRF_DRV_PWM_PIN_NOT_USED,             // channel 1\r\n                NRF_DRV_PWM_PIN_NOT_USED,             // channel 2\r\n                NRF_DRV_PWM_PIN_NOT_USED,             // channel 3\r\n            },\r\n            .irq_priority = APP_IRQ_PRIORITY_HIGH,\r\n            .base_clock   = NRF_PWM_CLK_8MHz,\r\n            .count_mode   = NRF_PWM_MODE_UP,\r\n            .top_value    = 2,\r\n            .load_mode    = NRF_PWM_LOAD_COMMON,\r\n            .step_mode    = NRF_PWM_STEP_AUTO\r\n        };\r\n        err_code = nrf_drv_pwm_init(&m_pwm, &config0, NULL);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        static uint16_t seq_values[] ={1};\r\n    \r\n        nrf_pwm_sequence_t const seq =\r\n        {\r\n            .values.p_common = seq_values,\r\n            .length          = NRF_PWM_VALUES_LENGTH(seq_values),\r\n            .repeats         = 0,\r\n            .end_delay       = 0\r\n        };\r\n    \r\n        nrf_drv_pwm_simple_playback(&m_pwm, &seq, 0,  NRF_DRV_PWM_FLAG_LOOP);\r\n    }\r\n\r\nI am able to generate a PWM output of 4Mhz with a 50% duty cycle.If we change the base clock to 16Mhz we don't see a signal.\r\n\r\nIs is possible to achieve an 8Mhz output with 50% duty cycle?  If so, what do we have to change with the above code?\r\n",
    "tag": "pwm"
  },
  {
    "text": "NRF52 soft i2c problem Hi. I tri to use my soft i2c lib\r\nIt works well at nrf51 and other mcu's. But nrf52 i2c_read doesnt works properly.\r\nOther funcs works well. \r\n\r\nWhen i read byte from i2c slave the adress write operation is executing well, after when nrf52 started to read a byte it's clock signal goes down to lesss then 0.5 volts\r\n![image description](/attachment/f840c68bd627548bbcf7c9dd1205d9df)\r\n\r\nMy i2c.c .h files Further\r\n[i2c.c](/attachment/13f4ad9a7496d5e282d5c50662292a74)\r\n[i2c.h](/attachment/0201876baeb7df1dd4acd0585868290e)",
    "tag": "i2c"
  },
  {
    "text": "Not in changelist - change to nrf_drv_timer.c in SDK 13.0.0 Not a question - but information for anyone similarly caught out.\r\n\r\nIn SDK 13.0.0 nrf_drv_timer_init() the p_config parameter must not be NULL.\r\nIn SDK 12.2.0 and earlier NULL gave a default config.\r\n\r\nSomehow my timer code, brought over from the earlier SDK, was still working - even with a NULL parameter - in SDK 13.0.0\r\n\r\nOr rather it worked - until I added twis / i2c slave support - which casued the timer callback never to be called, but no other issues.\r\n\r\nYou can try this in the SDK timer example - change the 2nd parameter to NULL, and the exampel still runs.",
    "tag": "i2c"
  },
  {
    "text": "Power consumption for nrf52 with TWI & GPIOTE Hi,\r\n\r\nI have an issue about power consumption with a board nrf52 10040. The consumption should be 100\u00b5A but is 500\u00b5A. I found an errata about that in 'http://infocenter.nordicsemi.com/pdf/nRF52832_Engineering_C_Errata_v1.5.pdf' (3.27).\r\n\r\nI tried to do what is written. The consumption is at 100\u00b5A but have some trouble on TWI. I can't communicate in TWI with the modules after that.\r\n\r\nI have some question about this errata:\r\n\r\n - The errata is just about TWI. So, I can init gpiote where i want?\r\n - All I need is to paste the patch and call 'nrf_drv_twi_init' & 'nrf_drv_twi_enable' after that?\r\n\r\nThanks in advance.\r\n",
    "tag": "i2c"
  },
  {
    "text": "I2C doesn't work on nRF51822 MBED Hello, \r\nI have a problem running nRF51822DK with temp. sensors while running BLE. I tried DS18B20 but it doesn't work at all, then TMP36 with ADC reading and as it works \"as a standalone\" without enabling BLE it gives false readings when BLE stuff is in the code. Same thing is with ADT7410. The library is working fine in basic example, but when I try to run it with BLE in a \"custom gatt example\" or similar it does not. \r\n\r\nI've read that there are timing issues caused by clock change to 32kHz, but there has to be a proper way to run them both. I use MBED, Tom Kreyche / ADT7410 lib.",
    "tag": "i2c"
  },
  {
    "text": "TWI Failing to read/write Hello,\r\n\r\nI've connected an ADXL345 accelerometer sensor via I2C to nrf52 board. I connected SDA > SDA, SCL > SCL, GND > GND and VCC > VDD (3.3V). Here's my code:\r\n\r\n        twi_init();\r\n\t\t\r\n\t\tdo {\r\n\t\t\terr_code = nrf_drv_twi_rx(&m_twi, 0x53, &sample_data, sizeof(sample_data));\r\n\t\t\t\r\n\t\t\tif (err_code != NRF_SUCCESS)\r\n\t\t\t{\r\n\t\t\t\t\tSEGGER_RTT_printf(0, \"Fail!!\");\r\n\t\t\t}\r\n\t\t} while (err_code != NRF_SUCCESS);\r\n\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\t\tSEGGER_RTT_printf(0, \"Data successfully received from I2C!!\");\r\n\t\t}\r\n\r\ntwi_init() and all other necessary code is from TWI Scanner example. Here's the output:\r\n\r\n> Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Data successfully received from I2C!!\r\n\r\nSometimes it prints \"Fail\" only two times. I tried to connect VCC to 5V (since this ADXL345 board has an on-board power regulator) and things are a little bit better. Now it only fails once:\r\n\r\n> Fail!!Data successfully received from I2C!!\r\n\r\nDo you have any idea what could be the problem? Maybe I'm missing some pull-up resistors? Or some configuration? Here's my init function:\r\n\r\n      /* TWI instance ID. */\r\n      #define TWI_INSTANCE_ID     0\r\n\r\n      /* TWI instance. */\r\n      static const nrf_drv_twi_t m_twi = NRF_DRV_TWI_INSTANCE(TWI_INSTANCE_ID);\r\n\r\n     /**\r\n      * @brief TWI initialization.\r\n      */  \r\n     void twi_init (void)\r\n     {\r\n         ret_code_t err_code;\r\n     \r\n         const nrf_drv_twi_config_t twi_config = {\r\n            .scl                = ARDUINO_SCL_PIN,\r\n            .sda                = ARDUINO_SDA_PIN,\r\n            .frequency          = NRF_TWI_FREQ_100K,\r\n            .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n         };\r\n     \r\n         err_code = nrf_drv_twi_init(&m_twi, &twi_config, NULL, NULL);\r\n         APP_ERROR_CHECK(err_code);\r\n\r\n         nrf_drv_twi_enable(&m_twi);\r\n     }\r\n\r\nAnd here's my nrf_drv_config.h:\r\n\r\n\t#define TWI0_ENABLED 1\r\n\r\n\t#if (TWI0_ENABLED == 1)\r\n\t#define TWI0_USE_EASY_DMA 0\r\n\r\n\t#define TWI0_CONFIG_FREQUENCY    NRF_TWI_FREQ_100K\r\n\t#define TWI0_CONFIG_SCL          0\r\n\t#define TWI0_CONFIG_SDA          1\r\n\t#define TWI0_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t#define TWI0_INSTANCE_INDEX      0\r\n\t#endif\r\n\r\n\t#define TWI1_ENABLED 0\r\n\r\n\t#if (TWI1_ENABLED == 1)\r\n\t#define TWI1_USE_EASY_DMA 0\r\n\r\n\t#define TWI1_CONFIG_FREQUENCY    NRF_TWI_FREQ_100K\r\n\t#define TWI1_CONFIG_SCL          0\r\n\t#define TWI1_CONFIG_SDA          1\r\n\t#define TWI1_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t#define TWI1_INSTANCE_INDEX      (TWI0_ENABLED)\r\n\t#endif\r\n\r\n\t#define TWI_COUNT                (TWI0_ENABLED + TWI1_ENABLED)\r\n\r\n\t/* TWIS */\r\n\t#define TWIS0_ENABLED 0\r\n\r\n\t#if (TWIS0_ENABLED == 1)\r\n\t\t\t#define TWIS0_CONFIG_ADDR0        0\r\n\t\t\t#define TWIS0_CONFIG_ADDR1        0 /* 0: Disabled */\r\n\t\t\t#define TWIS0_CONFIG_SCL          0\r\n\t\t\t#define TWIS0_CONFIG_SDA          1\r\n\t\t\t#define TWIS0_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t\t\t#define TWIS0_INSTANCE_INDEX      0\r\n\t#endif\r\n\r\n\t#define TWIS1_ENABLED 0\r\n\r\n\t#if (TWIS1_ENABLED ==  1)\r\n\t\t\t#define TWIS1_CONFIG_ADDR0        0\r\n\t\t\t#define TWIS1_CONFIG_ADDR1        0 /* 0: Disabled */\r\n\t\t\t#define TWIS1_CONFIG_SCL          0\r\n\t\t\t#define TWIS1_CONFIG_SDA          1\r\n\t\t\t#define TWIS1_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t\t\t#define TWIS1_INSTANCE_INDEX      (TWIS0_ENABLED)\r\n\t#endif\r\n\r\n\t#define TWIS_COUNT (TWIS0_ENABLED + TWIS1_ENABLED)\r\n\t/* For more documentation see nrf_drv_twis.h file */\r\n\t#define TWIS_ASSUME_INIT_AFTER_RESET_ONLY 0\r\n\t/* For more documentation see nrf_drv_twis.h file */\r\n\t#define TWIS_NO_SYNC_MODE 0\r\n\r\nThank you!",
    "tag": "i2c"
  },
  {
    "text": "TWI Fails to receive/send Hello,\r\n\r\nI've connected an ADXL345 accelerometer sensor via I2C to nrf52 board. I connected SDA > SDA, SCL > SCL, GND > GND and VCC > VDD (3.3V). Here's my code:\r\n\r\n        twi_init();\r\n\t\t\r\n\t\tdo {\r\n\t\t\terr_code = nrf_drv_twi_rx(&m_twi, 0x53, &sample_data, sizeof(sample_data));\r\n\t\t\t\r\n\t\t\tif (err_code != NRF_SUCCESS)\r\n\t\t\t{\r\n\t\t\t\t\tSEGGER_RTT_printf(0, \"Fail!!\");\r\n\t\t\t}\r\n\t\t} while (err_code != NRF_SUCCESS);\r\n\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\t\tSEGGER_RTT_printf(0, \"Data successfully received from I2C!!\");\r\n\t\t}\r\n\r\ntwi_init() and all other necessary code is from TWI Scanner example. Here's the output:\r\n\r\n> Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Fail!!Data successfully received from I2C!!\r\n\r\nSometimes it prints \"Fail\" only two times. I tried to connect VCC to 5V (since this ADXL345 board has an on-board power regulator) and things are a little bit better. Now it only fails once:\r\n\r\n> Fail!!Data successfully received from I2C!!\r\n\r\nDo you have any idea what could be the problem? Maybe I'm missing some pull-up resistors? Or some configuration? Here's my init function:\r\n\r\n      /* TWI instance ID. */\r\n      #define TWI_INSTANCE_ID     0\r\n\r\n      /* TWI instance. */\r\n      static const nrf_drv_twi_t m_twi = NRF_DRV_TWI_INSTANCE(TWI_INSTANCE_ID);\r\n\r\n     /**\r\n      * @brief TWI initialization.\r\n      */  \r\n     void twi_init (void)\r\n     {\r\n         ret_code_t err_code;\r\n     \r\n         const nrf_drv_twi_config_t twi_config = {\r\n            .scl                = ARDUINO_SCL_PIN,\r\n            .sda                = ARDUINO_SDA_PIN,\r\n            .frequency          = NRF_TWI_FREQ_100K,\r\n            .interrupt_priority = APP_IRQ_PRIORITY_HIGH\r\n         };\r\n     \r\n         err_code = nrf_drv_twi_init(&m_twi, &twi_config, NULL, NULL);\r\n         APP_ERROR_CHECK(err_code);\r\n\r\n         nrf_drv_twi_enable(&m_twi);\r\n     }\r\n\r\nAnd here's my nrf_drv_config.h:\r\n\r\n\t#define TWI0_ENABLED 1\r\n\r\n\t#if (TWI0_ENABLED == 1)\r\n\t#define TWI0_USE_EASY_DMA 0\r\n\r\n\t#define TWI0_CONFIG_FREQUENCY    NRF_TWI_FREQ_100K\r\n\t#define TWI0_CONFIG_SCL          0\r\n\t#define TWI0_CONFIG_SDA          1\r\n\t#define TWI0_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t#define TWI0_INSTANCE_INDEX      0\r\n\t#endif\r\n\r\n\t#define TWI1_ENABLED 0\r\n\r\n\t#if (TWI1_ENABLED == 1)\r\n\t#define TWI1_USE_EASY_DMA 0\r\n\r\n\t#define TWI1_CONFIG_FREQUENCY    NRF_TWI_FREQ_100K\r\n\t#define TWI1_CONFIG_SCL          0\r\n\t#define TWI1_CONFIG_SDA          1\r\n\t#define TWI1_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t#define TWI1_INSTANCE_INDEX      (TWI0_ENABLED)\r\n\t#endif\r\n\r\n\t#define TWI_COUNT                (TWI0_ENABLED + TWI1_ENABLED)\r\n\r\n\t/* TWIS */\r\n\t#define TWIS0_ENABLED 0\r\n\r\n\t#if (TWIS0_ENABLED == 1)\r\n\t\t\t#define TWIS0_CONFIG_ADDR0        0\r\n\t\t\t#define TWIS0_CONFIG_ADDR1        0 /* 0: Disabled */\r\n\t\t\t#define TWIS0_CONFIG_SCL          0\r\n\t\t\t#define TWIS0_CONFIG_SDA          1\r\n\t\t\t#define TWIS0_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t\t\t#define TWIS0_INSTANCE_INDEX      0\r\n\t#endif\r\n\r\n\t#define TWIS1_ENABLED 0\r\n\r\n\t#if (TWIS1_ENABLED ==  1)\r\n\t\t\t#define TWIS1_CONFIG_ADDR0        0\r\n\t\t\t#define TWIS1_CONFIG_ADDR1        0 /* 0: Disabled */\r\n\t\t\t#define TWIS1_CONFIG_SCL          0\r\n\t\t\t#define TWIS1_CONFIG_SDA          1\r\n\t\t\t#define TWIS1_CONFIG_IRQ_PRIORITY APP_IRQ_PRIORITY_LOW\r\n\r\n\t\t\t#define TWIS1_INSTANCE_INDEX      (TWIS0_ENABLED)\r\n\t#endif\r\n\r\n\t#define TWIS_COUNT (TWIS0_ENABLED + TWIS1_ENABLED)\r\n\t/* For more documentation see nrf_drv_twis.h file */\r\n\t#define TWIS_ASSUME_INIT_AFTER_RESET_ONLY 0\r\n\t/* For more documentation see nrf_drv_twis.h file */\r\n\t#define TWIS_NO_SYNC_MODE 0\r\n\r\nThank you!\r\n\r\nEDIT:\r\n\r\nI'm sorry, I'm not really an expert with low level programming and I2C, I'm used to Arduino and object-oriented libraries for sensors :)\r\n\r\nNow I wrote this code:\r\n\r\n                uint8_t address = 0x53;\r\n\t\tuint8_t sample_data;\r\n                uint8_t reg_addr = BW_RATE;\r\n\t\t\r\n\t\ttwi_init();\r\n\t\t\r\n\t\tSEGGER_RTT_printf(0, \"Sending register address 0x%02x to read from .... \", reg_addr);\r\n\t\terr_code = nrf_drv_twi_tx(&m_twi, address, &reg_addr, 1, true);\r\n\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\t\tSEGGER_RTT_printf(0, \"SUCCESS!\\n\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\tSEGGER_RTT_printf(0, \"FAIL! Error code: %d\\n\", err_code);\r\n\t\t}\r\n\t\t\r\n\t\tSEGGER_RTT_printf(0, \"Reading from I2C .... \", reg_addr);\r\n\t\terr_code = nrf_drv_twi_rx(&m_twi, address, &sample_data, sizeof(sample_data));\r\n\t\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\tSEGGER_RTT_printf(0, \"SUCCESS! Data: 0x%02x\\n\", sample_data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\tSEGGER_RTT_printf(0, \"FAIL! Error code: %d\\n\", err_code);\r\n\t\t}\r\n\t\t\r\n\t\tSEGGER_RTT_printf(0, \"Sending data 0x%xx to register 0x%02x .... \", reg_addr, 0x0A);\r\n\t\tuint8_t tx_data[2] = {BW_RATE,0x0A};\t\t\r\n\t\terr_code = nrf_drv_twi_tx(&m_twi, 0x53, tx_data, sizeof(tx_data), true);\r\n\t\t\t\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\t\tSEGGER_RTT_printf(0, \"SUCCESS!\\n\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\tSEGGER_RTT_printf(0, \"FAIL! Error code: %d\\n\", err_code);\r\n\t\t}\r\n\t\t\r\n\t\tSEGGER_RTT_printf(0, \"Sending register address 0x%02x to read from .... \", reg_addr);\r\n\t\terr_code = nrf_drv_twi_tx(&m_twi, address, &reg_addr, 1, true);\r\n\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\t\tSEGGER_RTT_printf(0, \"SUCCESS!\\n\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\tSEGGER_RTT_printf(0, \"FAIL! Error code: %d\\n\", err_code);\r\n\t\t}\r\n\t\t\r\n\t\tSEGGER_RTT_printf(0, \"Reading from I2C .... \", reg_addr);\r\n\t\terr_code = nrf_drv_twi_rx(&m_twi, address, &sample_data, sizeof(sample_data));\r\n\t\t\t\r\n\t\tif (err_code == NRF_SUCCESS)\r\n\t\t{\r\n\t\t\tSEGGER_RTT_printf(0, \"SUCCESS! Data: 0x%02x\\n\", sample_data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\tSEGGER_RTT_printf(0, \"FAIL! Error code: %d\\n\", err_code);\r\n\t\t}\r\n\r\nAnd the result is this:\r\n\r\n>     0> Sending register address 0x2C to read from .... FAIL! Error code: 3\r\n    0> Reading from I2C .... SUCCESS! Data: 0xE5\r\n    0> Sending data 0x0A to register 0x2C .... SUCCESS!\r\n    0> Sending register address 0x2C to read from .... SUCCESS!\r\n    0> Reading from I2C .... SUCCESS! Data: 0x0A\r\n\r\nAs you can see, it fails again at the first TX command. It works fine afterwards, though. And also it seems that the value has been correctly read at the first time, so seems that this first TX actually has passed through to sensor (the sensor knows which register to return value for), but for some reason, it returns error code 3.\r\n\r\nThank you!",
    "tag": "i2c"
  },
  {
    "text": "nrf_drv_twi doesnt read multiple bytes in SDK 12.2 I am trying to use the function or any function with my BLE UART application. I have a timer that expires to kickoff reading of some sensors and then when I try to read my sensor it only writes the address and data register then reads the the device address and stops at one byte regardless of what argument I place in length to receive.  The even wierder thing is in a stnadalone non softdevice application I test my I2C devices and it reads all 3 data bytes if I place a breakpoint before the read here is my code snippet.\r\n\r\n\r\nstatic void read_sensor_data()\r\n\r\n\t\tret_code_t err_code = 0;\r\n\t\tm_xfer_done = false;\r\n\t\tuint8_t m_txbuf = LM75B_REG_TEMP;\r\n\t\tuint8_t m_sample = 0;\r\n\r\n\t\tnrf_drv_twi_tx(&m_twi, LM75B_ADDR, &m_txbuf, 1, false);\r\n\t\twhile (m_xfer_done == false);\r\n\r\n\t\tm_xfer_done = false;\r\n    /* Read 1 byte from the specified address - skip 3 bits dedicated for fractional part of temperature. */\r\n    ret_code_t err_code = nrf_drv_twi_rx(&m_twi, LM75B_ADDR, &m_sample, 3);\r\n\t\twhile (!m_xfer_done);",
    "tag": "i2c"
  },
  {
    "text": "Using 12 hardware and 1 software channel for pwm on nrf52 Hello\r\n I am new to work on nrf52,\r\n\r\nPlease can someone help me regarding how to use hardware and software pwm together. I have a need of using 13 leds , so i need 13 pwm. As max h/w pwm is 12 so i plan to use 12 h/w pwm using pwm driver, and 1 s/w pwm using pwm library.\r\n\r\nWhen i merge the code from the examples, i copied the code from pwm library to pwm driver and added respective files like\r\n \u00a0app_pwm.h\r\n\u00a0 \u00a0app_pwm.c\r\n\u00a0 \u00a0nrf_drv_ppi.c\r\n\u00a0 \u00a0nrf_drv_timer.c\r\n\r\nto the driver, but it still gives an error that .--  #20: identifier \"TIMER0_ENABLED\" is undefined\u00a0----\r\n\r\n\r\n\r\nAlso when i try to do the converse, by adding code from pwm driver to pwm library, it gives error\r\n\r\n cannot open source input file \"nrf_drv_pwm.h\": No such file or directory\r\n\r\n\r\nEven though i added \"nrf_drv_pwm.h\" from the components folder of sdk 12.2 on nrf52.\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Using I2C with two devices on App Timer gets Hardfault Hello,\r\n\r\nI have two devices sharing an I2C bus.  These devices are the MAX86150 and the MLX90614.  DMA is being used.  I2C is running at 100 KHz.\r\n\r\nAfter initializing both devices, the application timer is configured to interrupt every 10 ms.  A process function for each device executes every 100 ms based upon this time.  Basically, every 100 ms various registers within each device are read and these values are updated within data structures in RAM.  The devices are read back-to-back, first the MLX and then the MAX; there is no delay between the reading of these devices, and the I2C is not reconfigured.\r\n\r\nAfter 5 - 10 minutes of normal operation while debugging through Keil, a hard fault happens.  I have no idea why this is happening, and I need some insight in how to troubleshoot this further.  \r\n\r\nI cannot see in the call stack the code execution that lead to the hard fault.  How can I identify the code that lead to this?  Also, are there any known issues with this.  \r\n\r\nAs another detail, my bus is made of twisted pair wires and may not be the best for impedance, but as I said, it works for a relatively long time before faulting.\r\n\r\nThank you,\r\n\r\nNoah",
    "tag": "i2c"
  },
  {
    "text": "pwm hardware individual loading mode nrf52 Please can anyone help me on how to use(program) PWM hardware with individual loading mode? My goal is to control 12 LEDs individually with different duty cycles and playbacks using pwm hardware which has 12 outputs to make a kind of led chaser.\r\n\r\nThanks in advance",
    "tag": "pwm"
  },
  {
    "text": "Timer interrupt handler not getting called, please help I have enabled Timer 2 with 31250Hz frequency. I wanted to call an interrupt after 10ms, ie 312 ticks for the timer.  But the interrupt is not getting called, I have spent some time finding the problem, but couldn't find.\r\n\r\nPlease check the following code, and help me to fix it.\r\n\r\n\r\n\r\n    \r\n    #define UART_TX_BUF_SIZE 256                                                          /**< UART TX buffer size. */\r\n    #define UART_RX_BUF_SIZE 1                                                            /**< UART RX buffer size. */\r\n    \r\n    const nrf_drv_timer_t decode_timeout_timer = NRF_DRV_TIMER_INSTANCE(2); //Time out timer, used to stop decoding\r\n    static bool\t\t\tm_timer_on;\r\n    static uint32_t m_tsop_pin;\r\n    static uint32_t err_code = NRF_SUCCESS;\r\n    static uint16_t m_array_index;\r\n    \r\n    static void decode_timeout_timer_event_handler(nrf_timer_event_t event_type, void * p_context)\r\n    {    \r\n    \tprintf(\"decode timeout event handler got called\\n\");\r\n        if(event_type == NRF_TIMER_EVENT_COMPARE0)\r\n        {\r\n    \t\t\tprintf(\"TIMEOUT\\n\");\r\n    \t\t\tnrf_drv_timer_pause(&decode_timeout_timer);\r\n        }    \r\n    }\r\n    \r\n    void tsop_pin_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)\r\n    {\r\n    \tprintf(\"\\nTimer value is: timer2 %u\\n\", nrf_drv_timer_capture(&decode_timeout_timer, NRF_TIMER_CC_CHANNEL0));\r\n    \tif(pin == m_tsop_pin && action == NRF_GPIOTE_POLARITY_TOGGLE )\r\n    \t{\r\n    \t\tif(!m_timer_on)\r\n    \t\t{\r\n    \t\t\tprintf(\"Starting decoding...\\n\");\r\n    \t\t\tm_timer_on = true;\r\n    \t\t\tnrf_drv_timer_enable(&decode_timeout_timer);\r\n    \t\t}\r\n    \t}\r\n    }\r\n    \r\n    static void gpiote_init()\r\n    {\r\n    \tif(!nrf_drv_gpiote_is_init())\r\n    \t{\r\n        err_code = nrf_drv_gpiote_init();\r\n    \t}\r\n    \t\r\n    \tnrf_drv_gpiote_in_config_t config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n    \tconfig.pull = NRF_GPIO_PIN_PULLUP;\r\n    \t\r\n    \terr_code =  nrf_drv_gpiote_in_init(m_tsop_pin, &config, tsop_pin_handler);\r\n    \tnrf_drv_gpiote_in_event_enable(m_tsop_pin, true);\r\n    \r\n    }\r\n    \r\n    static void decode_timeout_timer_init()\r\n    {\r\n    \tnrf_drv_timer_config_t timer_config =  {\r\n            .frequency          = NRF_TIMER_FREQ_31250Hz,\r\n            .mode               = NRF_TIMER_MODE_TIMER,\r\n            .bit_width          = NRF_TIMER_BIT_WIDTH_16,\r\n            .interrupt_priority = APP_IRQ_PRIORITY_HIGH,\r\n            .p_context          = (void *)(uint32_t) decode_timeout_timer.instance_id\r\n        };\r\n    \t\r\n    \terr_code |= nrf_drv_timer_init(&decode_timeout_timer, &timer_config, decode_timeout_timer_event_handler);\r\n    \t\r\n    \tuint32_t time_out_ms = 10;\r\n      uint32_t time_ticks;\r\n    \ttime_ticks = nrf_drv_timer_ms_to_ticks(&decode_timeout_timer, time_out_ms);\r\n    \tprintf(\"time_ticks: %u\", time_ticks);\r\n    \t//nrf_drv_timer_compare_int_enable(&decode_timeout_timer, NRF_TIMER_CC_CHANNEL0);\r\n      nrf_drv_timer_compare(&decode_timeout_timer, NRF_TIMER_CC_CHANNEL0, time_ticks, true);\r\n    \t \r\n    }\r\n    \r\n    void uart_error_handle(app_uart_evt_t * p_event)\r\n    {\r\n        if (p_event->evt_type == APP_UART_COMMUNICATION_ERROR)\r\n        {\r\n            APP_ERROR_HANDLER(p_event->data.error_communication);\r\n        }\r\n        else if (p_event->evt_type == APP_UART_FIFO_ERROR)\r\n        {\r\n            APP_ERROR_HANDLER(p_event->data.error_code);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @brief Function for application main entry.\r\n     */\r\n    int main(void)\r\n    {\r\n    \r\n        uint32_t err_code;\r\n        const app_uart_comm_params_t comm_params =\r\n         {\r\n             RX_PIN_NUMBER,\r\n             TX_PIN_NUMBER,\r\n             RTS_PIN_NUMBER,\r\n             CTS_PIN_NUMBER,\r\n             APP_UART_FLOW_CONTROL_ENABLED,\r\n             false,\r\n             UART_BAUDRATE_BAUDRATE_Baud38400\r\n         };\r\n    \r\n        APP_UART_FIFO_INIT(&comm_params,\r\n                        UART_RX_BUF_SIZE,\r\n                        UART_TX_BUF_SIZE,\r\n                        uart_error_handle,\r\n                        APP_IRQ_PRIORITY_LOW,\r\n                        err_code);\r\n    \r\n        APP_ERROR_CHECK(err_code);\r\n    \t\t \r\n    \t\t m_tsop_pin = 4;\r\n    \t\t decode_timeout_timer_init();\r\n    \t\tgpiote_init();\r\n    \t\t \r\n        while (true)\r\n        {\r\n            // Do Nothing - GPIO can be toggled without software intervention.\r\n        }\r\n    }\r\n    \r\n    \r\n    /** @} */\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "nRF51 MPU9255 TWI/I2C READ Failed Hi all:\r\n\r\nI used [code](https://github.com/Martinsbl/nrf5-mpu-examples) from Github to read 9 axis data with TWI. But the example in [TWI floder](https://github.com/Martinsbl/nrf5-mpu-examples/tree/master/nrf5-ble-mpu-simple/pca10028/s130/arm5_no_packs/twi) doesn't work.\r\n\r\nDoes somebody have the same issue?\r\n\r\nChip: nRF51422\r\n\r\nBoard: PCA10028\r\n\r\nFirmware: S130_nRF51_2.0.1\r\n\r\nI have checked the TWI pin define, SDA SCL voltage, and the code in mpu_init(). I found a lot of problems in that code. Does somebody have the same issue? Please make a response or even share the ideas with me.\r\n\r\nupdate:\r\nI've checked that my module already has 10K pull-up for SDL and SDA.\r\nI have found the root cause, I should make SDO (ADO) to low for address 0x68 and SDO (ADO) to high for address 0x69. I still don't know what's the purpose of this design? ",
    "tag": "i2c"
  },
  {
    "text": "Errors Combining examples twi_sensor and ble_app_uart Hello,\r\n\r\nI am using SDK 11.0.0 and attempting to integrate the BNO055 IMU into twi_sensor example and then connecting the IMU data over BLE via ble_app_uart.\r\n\r\nI successfully integrated the BNO055 IMU into the twi_sensor example by replacing the target accelerometer with the BMO055 IMU.  The integration works very well with successful testing collecting accelerometer data from the BNO055 at 200 samples per second over I2C.\r\n\r\nI then modified and successfully tested the ble_app_uart example with a transfer interval min of 7.5 mS and max transfer interval of 15 mS.\r\n\r\nI am trying to integrate the modified twi_sensor example into the ble_app_uart example and transfer the collected IMU data over ble.  I copied the appropriate modified code for the BNO055 IMU version in the twi_sensor example into the ble_app_uart example as a starting point.\r\n\r\nHowever, I am getting the following build issue while doing a make from the command line. I have also included below the makefile modifications to add the source files, cflags, and asmflags to the makefile.  I have tried for a couple of days to resolve this issue.  I also came across a comment that possibly having different types of interrupt driven peripherals (I2C and UART) may have issues but I do not think the build would be affected by that.  Once I get a good build, I can address those issues.\r\n\r\n    C:\\NordicSDK11\\examples\\ble_peripheral\\ble_app_uart\\pca10040\\s132\\armgcc>make\r\n    rm -rf _build\r\n    echo  Makefile\r\n    Makefile\r\n    mkdir _build\r\n    Compiling file: app_button.c\r\n    Compiling file: app_error.c\r\n    Compiling file: app_error_weak.c\r\n    Compiling file: app_fifo.c\r\n    Compiling file: app_timer.c\r\n    Compiling file: app_util_platform.c\r\n    Compiling file: fstorage.c\r\n    Compiling file: nrf_assert.c\r\n    Compiling file: nrf_log.c\r\n    Compiling file: retarget.c\r\n    Compiling file: RTT_Syscalls_GCC.c\r\n    Compiling file: SEGGER_RTT.c\r\n    Compiling file: SEGGER_RTT_printf.c\r\n    Compiling file: app_uart_fifo.c\r\n    Compiling file: nrf_delay.c\r\n    Compiling file: nrf_drv_common.c\r\n    Compiling file: nrf_drv_gpiote.c\r\n    Compiling file: nrf_drv_uart.c\r\n    Compiling file: pstorage.c\r\n    Compiling file: bsp.c\r\n    Compiling file: bsp_btn_ble.c\r\n    Compiling file: main.c\r\n    In file included from C:/NordicSDK11/examples/ble_peripheral/ble_app_uart/main.c:30:0:\r\n    C:/NordicSDK11/components/drivers_nrf/twi_master/nrf_drv_twi.h:53:19: error: 'TWI0_USE_EASY_DMA' undeclared here (not in a function)\r\n             (CONCAT_3(TWI, id, _USE_EASY_DMA) == 1 ? \\\r\n                       ^\r\n    C:/NordicSDK11/components/libraries/util/nordic_common.h:43:31: note: in definition of macro 'CONCAT_3'\r\n     #define CONCAT_3(p1, p2, p3)  p1##p2##p3\r\n                                   ^~\r\n    C:/NordicSDK11/components/drivers_nrf/twi_master/nrf_drv_twi.h:88:22: note: in expansion of macro 'NRF_DRV_TWI_PERIPHERAL'\r\n         .reg          = {NRF_DRV_TWI_PERIPHERAL(id)},       \\\r\n                          ^~~~~~~~~~~~~~~~~~~~~~\r\n    C:/NordicSDK11/examples/ble_peripheral/ble_app_uart/main.c:131:43: note: in expansion of macro 'NRF_DRV_TWI_INSTANCE'\r\n     static const nrf_drv_twi_t m_twi_bno055 = NRF_DRV_TWI_INSTANCE(0);\r\n                                               ^~~~~~~~~~~~~~~~~~~~\r\n    C:/NordicSDK11/components/drivers_nrf/twi_master/nrf_drv_twi.h:89:30: error: 'TWI0_INSTANCE_INDEX' undeclared here (not in a function)\r\n         .drv_inst_idx = CONCAT_3(TWI, id, _INSTANCE_INDEX), \\\r\n                                  ^\r\n    C:/NordicSDK11/components/libraries/util/nordic_common.h:43:31: note: in definition of macro 'CONCAT_3'\r\n     #define CONCAT_3(p1, p2, p3)  p1##p2##p3\r\n                                   ^~\r\n    C:/NordicSDK11/examples/ble_peripheral/ble_app_uart/main.c:131:43: note: in expansion of macro 'NRF_DRV_TWI_INSTANCE'\r\n     static const nrf_drv_twi_t m_twi_bno055 = NRF_DRV_TWI_INSTANCE(0);\r\n                                               ^~~~~~~~~~~~~~~~~~~~\r\n    \r\n    \r\nI believe there may be a make file issue with the order of inclusion of source files, cflags, and asmflags.  Here is my ble_app_uart make file with the added source and flags from the twi_sensor example.\r\n    \r\n    PROJECT_NAME := ble_app_uart_s132_pca10040\r\n    \r\n    export OUTPUT_FILENAME\r\n    #MAKEFILE_NAME := $(CURDIR)/$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\r\n    MAKEFILE_NAME := $(MAKEFILE_LIST)\r\n    MAKEFILE_DIR := $(dir $(MAKEFILE_NAME) ) \r\n    \r\n    TEMPLATE_PATH = ../../../../../../components/toolchain/gcc\r\n    ifeq ($(OS),Windows_NT)\r\n    include $(TEMPLATE_PATH)/Makefile.windows\r\n    else\r\n    include $(TEMPLATE_PATH)/Makefile.posix\r\n    endif\r\n    \r\n    MK := mkdir\r\n    RM := rm -rf\r\n    \r\n    #echo suspend\r\n    ifeq (\"$(VERBOSE)\",\"1\")\r\n    NO_ECHO := \r\n    else\r\n    NO_ECHO := @\r\n    endif\r\n    \r\n    # Toolchain commands\r\n    CC              := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-gcc'\r\n    AS              := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-as'\r\n    AR              := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-ar' -r\r\n    LD              := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-ld'\r\n    NM              := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-nm'\r\n    OBJDUMP         := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-objdump'\r\n    OBJCOPY         := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-objcopy'\r\n    SIZE            := '$(GNU_INSTALL_ROOT)/bin/$(GNU_PREFIX)-size'\r\n    \r\n    #function for removing duplicates in a list\r\n    remduplicates = $(strip $(if $1,$(firstword $1) $(call remduplicates,$(filter-out $(firstword $1),$1))))\r\n    \r\n    #source common to all targets\r\n    C_SOURCE_FILES += \\\r\n    $(abspath ../../../../../../components/libraries/button/app_button.c) \\\r\n    $(abspath ../../../../../../components/libraries/util/app_error.c) \\\r\n    $(abspath ../../../../../../components/libraries/util/app_error_weak.c) \\\r\n    $(abspath ../../../../../../components/libraries/fifo/app_fifo.c) \\\r\n    $(abspath ../../../../../../components/libraries/timer/app_timer.c) \\\r\n    $(abspath ../../../../../../components/libraries/util/app_util_platform.c) \\\r\n    $(abspath ../../../../../../components/libraries/fstorage/fstorage.c) \\\r\n    $(abspath ../../../../../../components/libraries/util/nrf_assert.c) \\\r\n    $(abspath ../../../../../../components/libraries/util/nrf_log.c) \\\r\n    $(abspath ../../../../../../components/libraries/uart/retarget.c) \\\r\n    $(abspath ../../../../../../external/segger_rtt/RTT_Syscalls_GCC.c) \\\r\n    $(abspath ../../../../../../external/segger_rtt/SEGGER_RTT.c) \\\r\n    $(abspath ../../../../../../external/segger_rtt/SEGGER_RTT_printf.c) \\\r\n    $(abspath ../../../../../../components/libraries/uart/app_uart_fifo.c) \\\r\n    $(abspath ../../../../../../components/drivers_nrf/delay/nrf_delay.c) \\\r\n    $(abspath ../../../../../../components/drivers_nrf/common/nrf_drv_common.c) \\\r\n    $(abspath ../../../../../../components/drivers_nrf/gpiote/nrf_drv_gpiote.c) \\\r\n    $(abspath ../../../../../../components/drivers_nrf/uart/nrf_drv_uart.c) \\\r\n    $(abspath ../../../../../../components/drivers_nrf/pstorage/pstorage.c) \\\r\n    $(abspath ../../../../../bsp/bsp.c) \\\r\n    $(abspath ../../../../../bsp/bsp_btn_ble.c) \\\r\n    $(abspath ../../../main.c) \\\r\n    $(abspath ../../../../../../components/ble/common/ble_advdata.c) \\\r\n    $(abspath ../../../../../../components/ble/ble_advertising/ble_advertising.c) \\\r\n    $(abspath ../../../../../../components/ble/common/ble_conn_params.c) \\\r\n    $(abspath ../../../../../../components/ble/ble_services/ble_nus/ble_nus.c) \\\r\n    $(abspath ../../../../../../components/ble/common/ble_srv_common.c) \\\r\n    $(abspath ../../../../../../components/toolchain/system_nrf52.c) \\\r\n    $(abspath ../../../../../../components/softdevice/common/softdevice_handler/softdevice_handler.c) \\\r\n    # additional source files from twi_sensor\r\n    $(abspath ../../../../../../components/drivers_nrf/twi_master/nrf_drv_twi.c) \\\r\n    $(abspath ../../../../../../components/drivers_ext/imu_bno055/bno055.c) \\\r\n    \r\n    #assembly files common to all targets\r\n    ASM_SOURCE_FILES  = $(abspath ../../../../../../components/toolchain/gcc/gcc_startup_nrf52.s)\r\n    \r\n    #includes common to all targets\r\n    INC_PATHS  = -I$(abspath ../../../config/ble_app_uart_s132_pca10040)\r\n    INC_PATHS += -I$(abspath ../../../config)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/config)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/timer)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/fifo)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/fstorage/config)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/delay)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/softdevice/s132/headers/nrf52)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/util)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/uart)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/ble/common)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/pstorage)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/uart)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/device)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/button)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/fstorage)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/libraries/experimental_section_vars)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/softdevice/s132/headers)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/gpiote)\r\n    INC_PATHS += -I$(abspath ../../../../../../external/segger_rtt)\r\n    INC_PATHS += -I$(abspath ../../../../../bsp)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/ble/ble_services/ble_nus)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/toolchain/CMSIS/Include)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/hal)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/toolchain/gcc)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/toolchain)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/common)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/ble/ble_advertising)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/softdevice/common/softdevice_handler)\r\n    # additional include paths from twi_sensor example\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_nrf/twi_master)\r\n    INC_PATHS += -I$(abspath ../../../../../../components/drivers_ext/imu_bno055)\r\n    INC_PATHS += -I$(abspath ../../../../../../examples/peripheral/twi_sensor/config/twi_sensor_pca10040)\r\n    \r\n    OBJECT_DIRECTORY = _build\r\n    LISTING_DIRECTORY = $(OBJECT_DIRECTORY)\r\n    OUTPUT_BINARY_DIRECTORY = $(OBJECT_DIRECTORY)\r\n    \r\n    # Sorting removes duplicates\r\n    BUILD_DIRECTORIES := $(sort $(OBJECT_DIRECTORY) $(OUTPUT_BINARY_DIRECTORY) $(LISTING_DIRECTORY) )\r\n    \r\n    #flags common to all targets\r\n    CFLAGS  = -DNRF52\r\n    # tried to include following cflag from twi_sensor example but caused bsp build errors\r\n    #CFLAGS += -DBSP_DEFINES_ONLY\r\n    CFLAGS += -DSOFTDEVICE_PRESENT\r\n    CFLAGS += -DBOARD_PCA10040\r\n    CFLAGS += -DNRF52_PAN_12\r\n    CFLAGS += -DNRF52_PAN_15\r\n    CFLAGS += -DNRF52_PAN_58\r\n    CFLAGS += -DNRF52_PAN_55\r\n    CFLAGS += -DNRF52_PAN_54\r\n    CFLAGS += -DNRF52_PAN_31\r\n    CFLAGS += -DNRF52_PAN_30\r\n    CFLAGS += -DNRF52_PAN_51\r\n    CFLAGS += -DNRF52_PAN_36\r\n    CFLAGS += -DNRF52_PAN_53\r\n    CFLAGS += -DNRF_LOG_USES_UART=1\r\n    CFLAGS += -DS132\r\n    CFLAGS += -DCONFIG_GPIO_AS_PINRESET\r\n    CFLAGS += -DBLE_STACK_SUPPORT_REQD\r\n    CFLAGS += -DSWI_DISABLE0\r\n    CFLAGS += -DNRF52_PAN_20\r\n    CFLAGS += -DNRF52_PAN_64\r\n    CFLAGS += -DNRF52_PAN_62\r\n    CFLAGS += -DNRF52_PAN_63\r\n    CFLAGS += -mcpu=cortex-m4\r\n    CFLAGS += -mthumb -mabi=aapcs --std=gnu99\r\n    CFLAGS += -Wall -Werror -O0 -g3\r\n    CFLAGS += -mfloat-abi=hard -mfpu=fpv4-sp-d16\r\n    # keep every function in separate section. This will allow linker to dump unused functions\r\n    CFLAGS += -ffunction-sections -fdata-sections -fno-strict-aliasing\r\n    CFLAGS += -fno-builtin --short-enums \r\n    # keep every function in separate section. This will allow linker to dump unused functions\r\n    LDFLAGS += -Xlinker -Map=$(LISTING_DIRECTORY)/$(OUTPUT_FILENAME).map\r\n    LDFLAGS += -mthumb -mabi=aapcs -L $(TEMPLATE_PATH) -T$(LINKER_SCRIPT)\r\n    LDFLAGS += -mcpu=cortex-m4\r\n    LDFLAGS += -mfloat-abi=hard -mfpu=fpv4-sp-d16\r\n    # let linker to dump unused sections\r\n    LDFLAGS += -Wl,--gc-sections\r\n    # use newlib in nano version\r\n    LDFLAGS += --specs=nano.specs -lc -lnosys\r\n    \r\n    # Assembler flags\r\n    ASMFLAGS += -x assembler-with-cpp\r\n    ASMFLAGS += -DNRF52\r\n    ASMFLAGS += -DSOFTDEVICE_PRESENT\r\n    ASMFLAGS += -DBOARD_PCA10040\r\n    ASMFLAGS += -DNRF52_PAN_12\r\n    ASMFLAGS += -DNRF52_PAN_15\r\n    ASMFLAGS += -DNRF52_PAN_58\r\n    ASMFLAGS += -DNRF52_PAN_55\r\n    ASMFLAGS += -DNRF52_PAN_54\r\n    ASMFLAGS += -DNRF52_PAN_31\r\n    ASMFLAGS += -DNRF52_PAN_30\r\n    ASMFLAGS += -DNRF52_PAN_51\r\n    ASMFLAGS += -DNRF52_PAN_36\r\n    ASMFLAGS += -DNRF52_PAN_53\r\n    ASMFLAGS += -DNRF_LOG_USES_UART=1\r\n    ASMFLAGS += -DS132\r\n    ASMFLAGS += -DCONFIG_GPIO_AS_PINRESET\r\n    ASMFLAGS += -DBLE_STACK_SUPPORT_REQD\r\n    ASMFLAGS += -DSWI_DISABLE0\r\n    ASMFLAGS += -DNRF52_PAN_20\r\n    ASMFLAGS += -DNRF52_PAN_64\r\n    ASMFLAGS += -DNRF52_PAN_62\r\n    ASMFLAGS += -DNRF52_PAN_63\r\n    # tried to include following asmflag from twi_sensor example but caused bsp build errors\r\n    #ASMFLAGS += -DBSP_DEFINES_ONLY\r\n    \r\n    #default target - first one defined\r\n    default: clean nrf52832_xxaa_s132\r\n    \r\n    #building all targets\r\n    all: clean\r\n    \t$(NO_ECHO)$(MAKE) -f $(MAKEFILE_NAME) -C $(MAKEFILE_DIR) -e cleanobj\r\n    \t$(NO_ECHO)$(MAKE) -f $(MAKEFILE_NAME) -C $(MAKEFILE_DIR) -e nrf52832_xxaa_s132\r\n    \r\n    #target for printing all targets\r\n    help:\r\n    \t@echo following targets are available:\r\n    \t@echo \tnrf52832_xxaa_s132\r\n    \t@echo \tflash_softdevice\r\n    \r\n    C_SOURCE_FILE_NAMES = $(notdir $(C_SOURCE_FILES))\r\n    C_PATHS = $(call remduplicates, $(dir $(C_SOURCE_FILES) ) )\r\n    C_OBJECTS = $(addprefix $(OBJECT_DIRECTORY)/, $(C_SOURCE_FILE_NAMES:.c=.o) )\r\n    \r\n    ASM_SOURCE_FILE_NAMES = $(notdir $(ASM_SOURCE_FILES))\r\n    ASM_PATHS = $(call remduplicates, $(dir $(ASM_SOURCE_FILES) ))\r\n    ASM_OBJECTS = $(addprefix $(OBJECT_DIRECTORY)/, $(ASM_SOURCE_FILE_NAMES:.s=.o) )\r\n    \r\n    vpath %.c $(C_PATHS)\r\n    vpath %.s $(ASM_PATHS)\r\n    \r\n    OBJECTS = $(C_OBJECTS) $(ASM_OBJECTS)\r\n    \r\n    nrf52832_xxaa_s132: OUTPUT_FILENAME := nrf52832_xxaa_s132\r\n    nrf52832_xxaa_s132: LINKER_SCRIPT=ble_app_uart_gcc_nrf52.ld\r\n    \r\n    nrf52832_xxaa_s132: $(BUILD_DIRECTORIES) $(OBJECTS)\r\n    \t@echo Linking target: $(OUTPUT_FILENAME).out\r\n    \t$(NO_ECHO)$(CC) $(LDFLAGS) $(OBJECTS) $(LIBS) -lm -o $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out\r\n    \t$(NO_ECHO)$(MAKE) -f $(MAKEFILE_NAME) -C $(MAKEFILE_DIR) -e finalize\r\n    \r\n    ## Create build directories\r\n    $(BUILD_DIRECTORIES):\r\n    \techo $(MAKEFILE_NAME)\r\n    \t$(MK) $@\r\n    \r\n    # Create objects from C SRC files\r\n    $(OBJECT_DIRECTORY)/%.o: %.c\r\n    \t@echo Compiling file: $(notdir $<)\r\n    \t$(NO_ECHO)$(CC) $(CFLAGS) $(INC_PATHS) -c -o $@ $<\r\n    \r\n    # Assemble files\r\n    $(OBJECT_DIRECTORY)/%.o: %.s\r\n    \t@echo Assembly file: $(notdir $<)\r\n    \t$(NO_ECHO)$(CC) $(ASMFLAGS) $(INC_PATHS) -c -o $@ $<\r\n    # Link\r\n    $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out: $(BUILD_DIRECTORIES) $(OBJECTS)\r\n    \t@echo Linking target: $(OUTPUT_FILENAME).out\r\n    \t$(NO_ECHO)$(CC) $(LDFLAGS) $(OBJECTS) $(LIBS) -lm -o $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out\r\n    ## Create binary .bin file from the .out file\r\n    $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).bin: $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out\r\n    \t@echo Preparing: $(OUTPUT_FILENAME).bin\r\n    \t$(NO_ECHO)$(OBJCOPY) -O binary $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).bin\r\n    \r\n    ## Create binary .hex file from the .out file\r\n    $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).hex: $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out\r\n    \t@echo Preparing: $(OUTPUT_FILENAME).hex\r\n    \t$(NO_ECHO)$(OBJCOPY) -O ihex $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).hex\r\n    \r\n    finalize: genbin genhex echosize\r\n    \r\n    genbin:\r\n    \t@echo Preparing: $(OUTPUT_FILENAME).bin\r\n    \t$(NO_ECHO)$(OBJCOPY) -O binary $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).bin\r\n    \r\n    ## Create binary .hex file from the .out file\r\n    genhex: \r\n    \t@echo Preparing: $(OUTPUT_FILENAME).hex\r\n    \t$(NO_ECHO)$(OBJCOPY) -O ihex $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).hex\r\n    echosize:\r\n    \t-@echo ''\r\n    \t$(NO_ECHO)$(SIZE) $(OUTPUT_BINARY_DIRECTORY)/$(OUTPUT_FILENAME).out\r\n    \t-@echo ''\r\n    \r\n    clean:\r\n    \t$(RM) $(BUILD_DIRECTORIES)\r\n    \r\n    cleanobj:\r\n    \t$(RM) $(BUILD_DIRECTORIES)/*.o\r\n    flash: nrf52832_xxaa_s132\r\n    \t@echo Flashing: $(OUTPUT_BINARY_DIRECTORY)/$<.hex\r\n    \tnrfjprog --program $(OUTPUT_BINARY_DIRECTORY)/$<.hex -f nrf52  --sectorerase\r\n    \tnrfjprog --reset -f nrf52\r\n    \r\n    ## Flash softdevice\r\n    flash_softdevice:\r\n    \t@echo Flashing: s132_nrf52_2.0.0_softdevice.hex\r\n    \tnrfjprog --program ../../../../../../components/softdevice/s132/hex/s132_nrf52_2.0.0_softdevice.hex -f nrf52 --chiperase\r\n    \tnrfjprog --reset -f nrf52",
    "tag": "i2c"
  },
  {
    "text": "need help with oled and NRF52 DK Hi, \r\ni was interfacing oled with nrf52 board. I got some example and modified bit to use it with GCC. \r\nBut it is now working. Oled not at all starting.\r\noled is 0.96 inch, I2C based 128x64.\r\nVdd = 5v\r\nsda = p0.26\r\nscl = p0.27\r\n\r\nHere is code \r\nhttps://github.com/devdprj/olednrf/\r\n",
    "tag": "i2c"
  },
  {
    "text": "PWM Error when using with nrf52 PCA10040  s132 nrf52832 I have implemented pwm as suggested in the info centre of nordiac semiconducter. But it showing the following error as shown below image.\r\n\r\n\r\nPlease Help if any one is aware of it.\r\n\r\nThank you.\r\n\r\n![image description](/attachment/9772de290e1265a9305ffc6d58e6f7c1)",
    "tag": "pwm"
  },
  {
    "text": "PWM Error when using with nrf52 PCA10040  s132 nrf52832 I have implemented pwm as suggested in the info centre of nordiac semiconducter. But it showing the following error as shown below image.\r\n\r\n\r\nPlease Help if any one is aware of it.\r\n\r\nThank you.\r\n\r\n![image description](/attachment/9772de290e1265a9305ffc6d58e6f7c1)",
    "tag": "pwm"
  },
  {
    "text": "Do I have any restriction with HW Pinout Peripheral when using s130? if I use softdevice 130 Enabled, then do I have any restriction with using all of the pinout of NRF51xxx? \r\n\r\nOr if I use Nrf-51 DK, Do I have any restriction with nrf 51xxx's full pinout functionality?\r\n\r\nTo Make it Easy, I've read at some document that, If I use S130, I will have some restriction with some peripheral's such as Timer 0 like this. In this point of view, Do I have any restriction with NRF51xxx's Pinout Such as `I cannot use GPIOTE Pin 32,33 (example) or PWM Pin 32,33 Cause S130 Use those Pins.` ?\r\n\r\nActually I've found lot's of Nordic's document, But I can't find restricted pin's when I use Softdevice 130.\r\n\r\n+ Do I have restriction with  only software Peripheral (such as Timer)? No restriction with Hardware Pins?( ex UART, I2C, PWM, GPIOTE, SPI?)",
    "tag": "pwm"
  },
  {
    "text": "I2C Read on nRF24le1 Hello,\r\n\r\nI'm trying to read from a register of a mCube accelerometer. \r\nThe hal_w2_write() function seems to be working (received a positive ACK).\r\nHowever, the hal_w2_read() function doesn't seem to be working the right way. \r\n\r\nThe waveform attached, is what I get when I issue the read function and this waveform is NOT dependent of the second argument of hal_w2_read() function (2nd argument is a 2 element array, one with the address of the register and the other, a dummy value).\r\nEven after using a different register address in the second argument I get the EXACT same waveform. The first 8 bits represents (slave's address) but the following bits seems to be the same in any case. \r\n\r\nSo if the hal_w2_write() worked, I cannot understand why hal_w2_read() wouldn't? \r\nI'm trying to understand the error here. \r\n\r\nI got the function from the I2C master sample code for an nRF24le1 SLAVE. Could it be because I'm using a different slave that the hal_w2_read() isn't working for me?\r\n\r\nAs you can notice, I'm a newbie at this. Please advise. \r\n\r\nThis is my code. \r\n\r\n    void main() {\r\n\r\n\tP0DIR = 0x00;\r\n\tP1DIR = 0x00;\r\n\tP2DIR = 0xFF;\r\n\tP3DIR = 0x00;\r\n\tEA = 1;\r\n\t\r\n\thal_w2_configure_master(HAL_W2_100KHZ);\r\n\t\r\n\t/* initiation sequence*/\r\n\thal_w2_write(0x6C,i0, 2); \t\t// standby mode\r\n\thal_w2_write(0x6C,i1, 2); \t\t// reset or power on\r\n\tdelay_us(1000);\r\n\thal_w2_write(0x6C, i2, 2);\t\t// specifying I2C interface\r\n\thal_w2_write(0x6C,i3, 2);\t\t// register initialization\r\n\thal_w2_write(0x6C,i4, 2);\r\n\thal_w2_write(0x6C,i5, 2);\r\n\thal_w2_write(0x6C,i6, 2);\r\n\thal_w2_write(0x6C,i7, 2);\r\n\r\n    while(1)\r\n     {\t\r\n     hal_w2_read(0x6C,ad,2 );     // ad[] = {0x15,0xFA}, 0x15- reg. address, 0xFA dummy value \r\n     delay_us(1000);              // delay introduced to better see the sequence on oscilloscope                                                                                                      \r\n     }\r\n\r\n![image description](/attachment/5590d3ad5e1bf295a07e6235164853a6)\r\n\r\n\r\n\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "Port Arduino I2C code with nrf TWI Driver I am in the process of porting arduino library VL53LX01 to the nrf51822 using **nrf_drv_twi** functions. I will use this with S130 and thinking of using **blocking mode**. \r\n\r\nI initialized without giving interrupt handler and hope it will run on blocking mode.\r\n\r\n    err_code = nrf_drv_twi_init(&m_twi, &twi_Vl530x_config, NULL, NULL);\r\n\r\nI am thinking of using \r\n\r\n    err_code = nrf_drv_twi_tx(&m_twi, address, val, 1, false);\r\n\r\nfor the below code block in Arduino library to write.\r\n\r\n  \r\n\r\n      Wire.beginTransmission(address);\r\n      Wire.write(reg);\r\n      Wire.write(value);\r\n      last_status = Wire.endTransmission();\r\n\r\nSimilary\r\n\r\n    ret_code_t err_code = nrf_drv_twi_rx(&m_twi, address, &value, 1);\r\n\r\nfor read byte instead the below code segment\r\n\r\n  \r\n\r\n\r\n      Wire.requestFrom(address, (uint8_t)1);\r\n      value = Wire.read();\r\n\r\nAnyone have any idea whether its correct to do it this way?\r\n\r\nIs there any effect on using blocking mode for s130 functions ?\r\n\r\nPls help\r\n\r\n",
    "tag": "i2c"
  },
  {
    "text": "nrf51 TWI burst write error Hi everybody,\r\n\r\nChip: nRF51422\r\n\r\nBoard: PCA10028\r\n\r\nFirmware: S130_nRF51_2.0.1\r\n\r\nThe system hangs when doing burst write reg.\r\nMPU9255 can work fine if all writes are [reg, data[0]];\r\nHow to solve the problem?\r\n\r\n    uint32_t i2c_write(unsigned char addr, unsigned char reg, uint32_t length, unsigned char* data){\r\n        uint32_t err_code;\r\n        uint32_t timeout = MPU_TWI_TIMEOUT;\r\n\t\r\n        //--work around for multi register data write\r\n        uint8_t *packet;\r\n        packet[0] = reg;\r\n        memcpy((packet+1),data,length);\r\n\t\r\n\t\terr_code = nrf_drv_twi_tx(&m_twi_instance0, MPU_ADDRESS, packet, length+1, false);\r\n\t\t\r\n\t\tif(err_code != NRF_SUCCESS) return err_code;\r\n\r\n        while((!twi_tx_done) && --timeout);\r\n        if(!timeout) return NRF_ERROR_TIMEOUT;\r\n\r\n        twi_tx_done = false;\r\n        return NRF_SUCCESS;  }",
    "tag": "i2c"
  },
  {
    "text": "HardFault when using UART and GPIO interrupt Hello,\r\n\r\nI feel like this question has an answer similair to this question, but I can't seem to get it working https://devzone.nordicsemi.com/question/5027/using-i2c-gpiote-interrupt-with-soft-device-enabled/\r\n\r\nI am using the nrf51422 chip on a board I designed myself and I'm using a UART and GPIO interrupt. The UART interrupt works fine on it's own, but as soon as I generate an interrupt on the GPIO, the software goes into hardfault and thus everything stops working. Without UART the GPIO interrupt was working fine.\r\n\r\nI'm initializing the UART like this:\r\n\r\nvoid init_uart()\r\n{\r\n\tuint32_t err_code;\r\n\t\r\n\tconst app_uart_comm_params_t comm_params =\r\n\t{\r\n\t\tRX_PIN_NUMBER,\r\n\t\tTX_PIN_NUMBER,\r\n\t\tRTS_PIN_NUMBER,\r\n\t\tCTS_PIN_NUMBER,\r\n\t\tAPP_UART_FLOW_CONTROL_DISABLED,\r\n\t\tfalse,\r\n\t\t0x004EBF00 //just about 19230 baud\r\n\t};\r\n\t\t\r\n\tAPP_UART_FIFO_INIT(&comm_params,\r\n\t\t\t\t\t\t\t\t\t UART_RX_BUF_SIZE,\r\n\t\t\t\t\t\t\t\t\t UART_TX_BUF_SIZE,\r\n\t\t\t\t\t\t\t\t\t uart_error_handle,\r\n\t\t\t\t\t\t\t\t\t APP_IRQ_PRIORITY_LOW,\r\n\t\t\t\t\t\t\t\t\t err_code);\r\n\r\n\tAPP_ERROR_CHECK(err_code);\r\n\r\n\r\nand the GPIO interrupt is intitialized like this:\r\n\r\nvoid gpio_init(void)\r\n{\r\n\tret_code_t err_code;\r\n\t\r\n\terr_code = nrf_drv_gpiote_init();\r\n\tAPP_ERROR_CHECK(err_code);\r\n\t\t\r\n\tnrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n\tnrf_drv_gpiote_in_config_t in_config2 = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n\tin_config.pull = NRF_GPIO_PIN_NOPULL;\r\n\tin_config2.pull = NRF_GPIO_PIN_NOPULL;\r\n\t\r\n\terr_code = nrf_drv_gpiote_in_init(encoder_a, &in_config, encoder_a_handler);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\t\r\n\terr_code = nrf_drv_gpiote_in_init(encoder_b, &in_config2, encoder_b_handler);\r\n\tAPP_ERROR_CHECK(err_code);\r\n\t\r\n\tnrf_drv_gpiote_in_event_enable(encoder_a, true);\r\n\tnrf_drv_gpiote_in_event_enable(encoder_b, true);\r\n\r\n\r\nAn interrupt on the UART module is generated like this:\r\n\r\nvoid uart_error_handle(app_uart_evt_t * p_event)\r\n{\r\n\t\tif(p_event->evt_type == APP_UART_DATA_READY)\r\n\t\t{\r\n                                //function to call when data arrives on Rx\r\n\t\t\t\tparse();\r\n\t\t}\r\n}\r\n\r\nAnd the interrupt handlers for the gpio look like this (the other handler is similair):\r\n\r\n\r\nvoid encoder_b_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t NRF_GPIOTE_POLARITY_TOGGLE)\r\n{\r\n\tif(bToggle == false){\r\n\t\tbToggle = true;\r\n\t}\r\n\telse{\r\n\t\tbToggle = false;\r\n\t}\r\n\t\r\n\tif(aToggle == true)\r\n\t{\r\n\t\tencoderCounter--;\r\n\t\ttransfer_completed = true;\r\n\t\tprintNumber();\r\n\t\taToggle = false;\r\n\t\tbToggle = false;\r\n\t}\t\r\n}\r\n\r\nAs I've said: the answer to this question is probably similair to the one linked above. However, I have checked the interrupt priority in the nrf_drv_gpiote.h, but it was already on a low priority and does not seem to do much when I change it from low to high. \r\n\r\nI'm really stumped as to what might cause this problem. Could it the speed at which the UART interrupt is caused? I receive about 33 bytes of data in 17 ms after which I do not receive data for about 58 ms. \r\n\r\n(It seems that the code I put in this post does not line out properly in some places, How do I fix this?)",
    "tag": "interrupt"
  },
  {
    "text": "Hardfault when using both UART and GPIOTE, how can I solve this problem? Hello,\r\n\r\nI feel like this question has an answer similar to this question, but I can't seem to get it working https://devzone.nordicsemi.com/question/5027/using-i2c-gpiote-interrupt-with-soft-device-enabled/\r\n\r\nI am using the nrf51422 chip on a board I designed myself and I'm using a UART and GPIO interrupt. The UART interrupt works fine on it's own, but as soon as I generate an interrupt on the GPIO, the software goes into hardfault and thus everything stops working. Without UART the GPIO interrupt was working fine.\r\n\r\nI'm using the nrf51 DK with the PCA10028 chip on it to program my PCB.\r\n\r\nI'm initializing the UART like this:\r\n\r\n    void init_uart()\r\n    {\r\n    \tuint32_t err_code;\r\n    \t\r\n    \tconst app_uart_comm_params_t comm_params =\r\n    \t{\r\n    \t\tRX_PIN_NUMBER,\r\n    \t\tTX_PIN_NUMBER,\r\n    \t\tRTS_PIN_NUMBER,\r\n    \t\tCTS_PIN_NUMBER,\r\n    \t\tAPP_UART_FLOW_CONTROL_DISABLED,\r\n    \t\tfalse,\r\n    \t\t0x004EBF00 //just about 19230 baud\r\n    \t};\r\n    \t\t\r\n    \tAPP_UART_FIFO_INIT(&comm_params,\r\n    \t\t\t\t\t\t\t\t\t UART_RX_BUF_SIZE,\r\n    \t\t\t\t\t\t\t\t\t UART_TX_BUF_SIZE,\r\n    \t\t\t\t\t\t\t\t\t uart_error_handle,\r\n    \t\t\t\t\t\t\t\t\t APP_IRQ_PRIORITY_LOW,\r\n    \t\t\t\t\t\t\t\t\t err_code);\r\n    \r\n    \tAPP_ERROR_CHECK(err_code);\r\n\r\n\r\nand the GPIO interrupt is intitialized like this:\r\n\r\n    void gpio_init(void)\r\n    {\r\n    \tret_code_t err_code;\r\n    \t\r\n    \terr_code = nrf_drv_gpiote_init();\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \t\t\r\n    \tnrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n    \tnrf_drv_gpiote_in_config_t in_config2 = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n    \tin_config.pull = NRF_GPIO_PIN_NOPULL;\r\n    \tin_config2.pull = NRF_GPIO_PIN_NOPULL;\r\n    \t\r\n    \terr_code = nrf_drv_gpiote_in_init(encoder_a, &in_config, encoder_a_handler);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \t\r\n    \terr_code = nrf_drv_gpiote_in_init(encoder_b, &in_config2, encoder_b_handler);\r\n    \tAPP_ERROR_CHECK(err_code);\r\n    \t\r\n    \tnrf_drv_gpiote_in_event_enable(encoder_a, true);\r\n    \tnrf_drv_gpiote_in_event_enable(encoder_b, true);\r\n\r\n\r\nAn interrupt on the UART module is generated like this:\r\n\r\n    void uart_error_handle(app_uart_evt_t * p_event)\r\n    {\r\n    \t\tif(p_event->evt_type == APP_UART_DATA_READY)\r\n    \t\t{\r\n                                    //function to call when data arrives on Rx\r\n    \t\t\t\tparse();\r\n    \t\t}\r\n    }\r\n\r\nAnd the interrupt handlers for the gpio look like this (the other handler is similair):\r\n\r\n\r\n    void encoder_b_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t NRF_GPIOTE_POLARITY_TOGGLE)\r\n    {\r\n    \tif(bToggle == false){\r\n    \t\tbToggle = true;\r\n    \t}\r\n    \telse{\r\n    \t\tbToggle = false;\r\n    \t}\r\n    \t\r\n    \tif(aToggle == true)\r\n    \t{\r\n    \t\tencoderCounter--;\r\n    \t\ttransfer_completed = true;\r\n    \t\tprintNumber();\r\n    \t\taToggle = false;\r\n    \t\tbToggle = false;\r\n    \t}\t\r\n    }\r\n\r\nAs I've said: the answer to this question is probably similair to the one linked above. However, I have checked the interrupt priority in the nrf_drv_gpiote.h, but it was already on a low priority and does not seem to do much when I change it from low to high. \r\n\r\nI'm really stumped as to what might cause this problem. Could it the speed at which the UART interrupt is caused? I receive about 33 bytes of data in 17 ms after which I do not receive data for about 58 ms. ",
    "tag": "interrupt"
  },
  {
    "text": "making Tune instead of Beep using Bizzer with PWM library i have added pwm into proximity profile example and now i am able to make beep using buzzer with pwm library.Now i want to make some sort of Tune instead of beep.\r\n\r\nCan any one help!....Thanks.",
    "tag": "pwm"
  },
  {
    "text": "TWI: prevent repeated start between non stop transfer Hi,\r\n\r\nI am debugging an SSD1306 OLED library, and in the datasheet, it does not explicitly mention support for repeated start bits. But using the nrf_drv_ API's with `NRF_DRV_TWI_FLAG_TX_NO_STOP` flag set, the successive `nrf_drv_twi_tx` or `nrf_drv_twi_xfer` function starts sending data with a start condition.\r\n\r\n![image description](/attachment/826fad550001912ba5cd77b54630fa95)\r\n\r\nAs shown by the logic analyzer, the Green dot is a start ad red dot is a stop. I dont not want the last green dot to the right. Is this possible using the `nrf_drv_twi_` API ?",
    "tag": "i2c"
  },
  {
    "text": "Infrared Transmitter only with PWM driver on nrf52 Hi all,\r\n\r\nI need to transmit an infrared beacon every X seconds and the beacon does not change over time. I am using the PWM driver on nrf52 to generate the 38kHz carrier frequency and I am currently working on using a timer and PPI to turn on and off the carrier appropriately (mark and space).  \r\n\r\nHowever, I was wondering if it is possible to do the same thing only using the PWM driver. This would make the implementation simpler with less resources used.\r\n\r\nI have the impression that, given the fact that my data is static, I can create a sequence of duty cycles that represents my data and then play it with the PWM driver. The actual duty cycles used would be only two, 50% for the marks and 0% for the spaces. The important thing (that I didn't figure out if it is possible or not yet) is to get the right timing for the marks and spaces. Maybe it is possible to use the `playback_count` in `nrf_drv_pwm_simple_playback` to define how long we should keep the 50% and 0% duty cycle, or maybe it is possible to use `repeats` and `end_delay` in `nrf_pwm_sequence_t`. I still don't have clear how these three parameters work together.\r\n\r\nAny ideas/thoughts?\r\n\r\nThanks!",
    "tag": "pwm"
  },
  {
    "text": "nrf52 bootloader interrupt Hi,\r\n\r\nI'm wondering how to implement interrupt handling with bootloader on nrf52 | SDK v11.0? \r\n\r\nI would like to use rtc (or comp) interrupt to wake up from sleep in bootloader to keep current consumption minimal. \r\n\r\nI couldn't find any info about irq redirection. I'm using reduced version of bootloader example from SDK11 - just GPIO and RTC initialization, but can't figure out how to manage interrupts.\r\n\r\nRegards",
    "tag": "interrupt"
  },
  {
    "text": "Always getting NCK. Hi,\r\n\r\nI'm trying to control LSM6DS3 by TWI communication.\r\nSlave address of the chip is 0xD4 when SDO/SA0 pin is low.\r\n\r\nI'm using SDK13.0.0.\r\n\r\nMy code is like below.\r\n\t\r\n\tret_code_t err_code;\r\n\r\n\tuint8_t flag=0;\r\n\tuint8_t *LSM_DATA;\r\n\r\n\terr_code = twi_init();\r\n\tAPP_ERROR_CHECK(err_code);\r\n\t\r\n\twhile (true)\r\n\t{\r\n\t\ttwi_test();\r\n\t\tnrf_delay_ms(100);\r\n\t\tflag = 0;\r\n\t}\r\n\r\ntwi_init()\r\n\r\n\tret_code_t err_code;\r\n\t\t\r\n    const nrf_drv_twi_config_t twi_config = {\r\n       .scl                = 4,\r\n       .sda                = 3,\r\n       .frequency          = NRF_TWI_FREQ_100K,\r\n       .interrupt_priority = APP_IRQ_PRIORITY_HIGH,\r\n       .clear_bus_init     = false\r\n    };\r\n\t\terr_code = nrf_drv_twi_init(&m_twi_master, &twi_config, NULL, NULL);\r\n\t\tnrf_drv_twi_enable(&m_twi_master);\r\n\t\treturn err_code;\r\n\r\ntwi_test()\r\n\r\n\tret_code_t err_code;\r\n\t\r\n\tuint8_t slv_addr = 0xD4>>1;\r\n\tuint8_t temp1 = 0x12;\r\n\tuint8_t temp3[2] = {temp1, 0x00};\r\n\t\r\n\terr_code = nrf_drv_twi_tx(&m_twi_master, slv_addr, temp3, sizeof(temp3), false);\r\n\treturn err_code;\r\n\r\nIt is almost similar to example code.(twi_sensor_pca10040)\r\nBut I don't know why always NCK.\r\n\r\nI checked hardware and TWI timing diagram and is correct.\r\n\r\nAny help is greatly appreciated.\r\n\r\n==========================================================================================\r\n\r\nOscilloscope capture image\r\n\r\n![image description](/attachment/9654478ae9c1d915dfcc8e6eb7a591a5)\r\n![image description](/attachment/a677ce371e2b481e8761ac4461a35f8a)\r\n![image description](/attachment/d4779f5ebddd95a0e61e5f5d2f91471d)\r\n![image description](/attachment/693d442ffa675349e2db43735a09edb2)",
    "tag": "i2c"
  },
  {
    "text": "PMW problem I opened the examples\\peripherals\\pwm_library file in keil and I try to implement the pwm in another project I have running. I have included all the necessary files to keil but when I enter     \r\n  \r\n     APP_PWM_INSTANCE(PWM1,1);  \r\nKeil outputs the following : `..\\..\\..\\main.c(59): error:  #20: identifier \"TIMER1_INSTANCE_INDEX\" is undefinedned`\r\n  \r\nWhere should I initialize the TIMER_INSTANCE_INDEX ??\r\n",
    "tag": "pwm"
  },
  {
    "text": "nrf51822 PWM failure I am trying to add the example in examples\\peripheral\\pwm_library to another project to get pwm working. In the other project I have included all necessary stuff but I get:\r\n\r\n `..\\..\\..\\main.c(59): error:  #20: identifier \"TIMER1_INSTANCE_INDEX\" is undefined`\r\n\r\nWhere should I define that timer instance??\r\n",
    "tag": "pwm"
  },
  {
    "text": "TWI:  nrf_drv_twi_rx function retun error 3 Hi\r\nI'm interfacing MMA8452Q with nrf51822 using TWI all read-write function working fine but when I try to read acceleration data  nrf_drv_twi_rx & nrf_drv_twi_tx function return error code 3. here is my code flow.\r\n\r\n 1. Read WHO_AM_I register (OK)//Value Read 0x2A\r\n 2. Set CTRL_REG1 register to standby mode(OK) //Write value 0x00\r\n 3. Set M_CTRL_REG1 register(OK)//Write value 0x1F\r\n 4. Set M_CTRL_REG2 register(OK)//Write value 0x20\r\n 5. Set XYZ_DATA_CFG register(OK)//Write value 0x01\r\n 6. Set CTRL_REG1 register to normal mode(OK)  //Write value 0x01\r\n 7. But after this facing error when I again try to read read acc data \r\n\r\nregister read code:\r\n\r\nvoid FXOS8700CQ_I2C_registers_read(uint8_t slave_addr, uint8_t reg_addr,  uint8_t pdata[], uint32_t bytes)\r\n\r\n    {   \r\n            ret_code_t ret_code;\r\n            ret_code = nrf_drv_twi_tx(&p_twi, slave_addr, &reg_addr, bytes, true);\r\n        \t\t#ifdef fxos_debug\r\n        \t\t\t\tSEGGER_RTT_printf(0, \"\\nRead register's tx error code:%x\", ret_code);\r\n        \t\t#endif\r\n        \t\tAPP_ERROR_CHECK (ret_code);\r\n            ret_code = nrf_drv_twi_rx(&p_twi, slave_addr, pdata, bytes);\r\n        \t\t#ifdef fxos_debug\r\n        \t\t\t\tSEGGER_RTT_printf(0, \"\\nRead register's rx error code:%x\", ret_code);\r\n        \t\t\t\tSEGGER_RTT_printf(0, \"\\nRead register's rx byte:%d\", bytes);\r\n        \t\t#endif\r\n        \t\tAPP_ERROR_CHECK (ret_code);\r\n    }\r\n\r\nRegister address:\r\n\r\n    #define FXOS8700CQ_OUT_X_MSB       0x01    \r\n    #define FXOS8700CQ_OUT_X_LSB        0x02\r\n    #define FXOS8700CQ_OUT_Y_MSB       0x03\r\n    #define FXOS8700CQ_OUT_Y_LSB        0x04\r\n    #define FXOS8700CQ_OUT_Z_MSB       0x05\r\n    #define FXOS8700CQ_OUT_Z_LSB        0x06\r\n    #define FXOS8700CQ_WHO_AM_I         0x0D   \r\n    #define FXOS8700CQ_XYZ_DATA_CFG  0x0E\r\n    #define FXOS8700CQ_CTRL_REG1        0x2A\r\n    #define FXOS8700CQ_M_CTRL_REG1    0x5B\r\n    #define FXOS8700CQ_M_CTRL_REG2    0x5C\r\n\r\n\r\nMMA8452 [Datasheet](http://www.nxp.com/assets/documents/data/en/data-sheets/MMA8452Q.pdf)\r\n\r\nNote: Same MMA8452Q sensor working with other micro-controller. There is no issue with hardware.\r\n",
    "tag": "i2c"
  },
  {
    "text": "EVENTS_PWMPERIODEND interrupt not behaving as expected I am trying to use the EVENTS_PWMPERIODEND interrupt to read a GPIO pin on every falling edge of an output GPIO that is driven from the PWM module.\r\n\r\nThe description in the reference manual is:\r\nEVENTS_PWMPERIODEND  0x118   Emitted at the end of each PWM period\r\n\r\n...So I expected that this event could provide that interrupt for me.\r\n\r\nI am setting up the PWM to generate five pulses, like this:\r\n\r\n    data.pwm0_duty[0] = 8;\r\n    data.pwm0_duty[1] = 8;\r\n    data.pwm0_duty[2] = 8;\r\n    data.pwm0_duty[3] = 8;\r\n    data.pwm0_duty[4] = 8;\r\n    NRF_PWM0->MODE = (PWM_MODE_UPDOWN_Up << PWM_MODE_UPDOWN_Pos);\r\n    NRF_PWM0->PRESCALER = (PWM_PRESCALER_PRESCALER_DIV_1 << PWM_PRESCALER_PRESCALER_Pos);\r\n    NRF_PWM0->COUNTERTOP = (32 << PWM_COUNTERTOP_COUNTERTOP_Pos);\r\n    NRF_PWM0->SEQ[0].PTR = ((uint32_t)swd_data.pwm0_duty << PWM_SEQ_PTR_PTR_Pos);\r\n    NRF_PWM0->SEQ[0].CNT = 5;\r\n    NRF_PWM0->SEQ[0].REFRESH = 0;\r\n    NRF_PWM0->SEQ[0].ENDDELAY = 0;\r\n    NRF_PWM0->PSEL.OUT[0] =   (CLK_PIN_NUMBER << PWM_PSEL_OUT_PIN_Pos)\r\n                            | (PWM_PSEL_OUT_CONNECT_Connected << PWM_PSEL_OUT_CONNECT_Pos);\r\n    NRF_PWM0->ENABLE = (PWM_ENABLE_ENABLE_Enabled << PWM_ENABLE_ENABLE_Pos);\r\n    NRF_PWM0->SEQ[0].PTR = ((uint32_t)data.pwm0_duty << PWM_SEQ_PTR_PTR_Pos);\r\n    NRF_PWM0->SEQ[0].CNT = 4;\r\n    NRF_PWM0->DECODER =   (PWM_DECODER_LOAD_Common << PWM_DECODER_LOAD_Pos)\r\n                        | (PWM_DECODER_MODE_RefreshCount << PWM_DECODER_MODE_Pos);\r\n    NRF_PWM0->INTENSET =   (PWM_INTENSET_SEQEND0_Enabled << PWM_INTENSET_SEQEND0_Pos)\r\n                         | (PWM_INTEN_PWMPERIODEND_Enabled << PWM_INTEN_PWMPERIODEND_Pos);\r\n    NRF_PWM0->TASKS_SEQSTART[0] = 1;\r\n\r\n...However, the PWMPERIODEND interrupt only seems to be firing once.\r\n\r\nAm I doing something wrong, or have I interpreted the behavior of this event wrong?\r\n\r\nThanks.\r\n\r\n--ken",
    "tag": "pwm"
  },
  {
    "text": "Can nRF52 have four interfaces active: SPIM, SPIS, TWIM0, TWIM1 It appears that we can use only three at a time. I would like to use SPIM, SPIS and two TWI masters. Is that possible with the nRF52?",
    "tag": "i2c"
  },
  {
    "text": "Interrupt Vectors REMAP How can I relocate or manage the transition between the bootloaders interrupt vector map and the applications interrupt vector map which will be at different addresses in FLASH. On the M3/M4, you can remap this but presumably on the M0, you cant. Is there a method I could use on the NRF51822?\r\n\r\nEdit: We are not using soft devices (we are using proprietary software and protocols).\r\n\r\nIve written the bootloader software running on the NRF51822 which accepts and programs an image sent from a C++ application, and then using some assembler, loads the main image @ 0x8000. The only issue is how to tackle the problem of a non-relocatable vector table (unless I am mistaken) of the Cortex M0.\r\n\r\nNXP and ST's Cortex M0 dont have a VTOR (vector table offset register) but they do have a remap register to set the vector table in SRAM. The vector table could then jump to the correct bootloader vector table (@ 0) or main application vector table (@ 0x8000).\r\n\r\nIf you could investigate if the NRF51822 offers any features/registers to enable relocation of the vector table I would be grateful, thanks.",
    "tag": "interrupt"
  },
  {
    "text": "nRF52- PWM - Generating 8Mhz Clock Hi,\r\n\r\nCan Anyone has experienced with nRF52 PWM clock generation ? I am trying to generate **8-Mhz** clock out of GPIO by configuring it for PWM module.. But so far I can get only 1Mhz clock maximum.. \r\n\r\nIs it possible to generate clock by PWM beyond 1 Mhz ? \r\n",
    "tag": "pwm"
  },
  {
    "text": "NRF52832 PWM limitations Hello,\r\n\r\nWith sdk13 and app_pwm library, I only got 9bits resolution for 32KHz freq.\r\n\r\nThe pwm should have 16bits resolution, with max freq 100KHz?\r\nplease could anyone confirm that.\r\n\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "How to connect temperature sensor to NRF52832 via i2c Hello,\r\n\r\nHere is a newbie question:\r\n\r\nI have NRF52832 (sparkfun breakout board) and ADT7410 temperature sensor and, I want to create a data logger. But, i could not understand how to use i2c interface. I think we will assign the pins manually, but I could not understand how to assign them or use them.\r\n\r\nThank you for your help",
    "tag": "i2c"
  },
  {
    "text": "how do I change PWM port to 1 on example \"low_power_pwm\" Hi,\r\nI have Design a new product based on the NRF52840 I am trying to get the lcd up and running so first thing is the pwm for the backlight. I am using pin 1.08 for the pwm. but I seem to have problem trying to convert LED1 to Port 1 I setup the Low_power_pwm example project and changed the defined board to Custom_board and copied PCA10056.h and renamed it custom_board it compiles fine and works but once I try to change the definition of LED1 It now compiles but will NOT toggle the output P1.8\r\n\r\nhere is the part of custom_board.h that I changed:\r\n\r\noriginal:\r\n/ LEDs definitions for PCA10056\r\n#define LEDS_NUMBER    4\r\n\r\n#define LED_1          NRF_GPIO_PIN_MAP(0,13)\r\n#define LED_2          NRF_GPIO_PIN_MAP(0,14)\r\n#define LED_3          NRF_GPIO_PIN_MAP(0,15)\r\n#define LED_4          NRF_GPIO_PIN_MAP(0,16)\r\n\r\n#define LEDS_ACTIVE_STATE 0\r\n\r\n#define LEDS_LIST { LED_1, LED_2, LED_3, LED_4 }\r\n\r\n#define LEDS_INV_MASK  LEDS_MASK\r\n\r\n#define BSP_LED_0      13\r\n#define BSP_LED_1      14\r\n#define BSP_LED_2      15\r\n#define BSP_LED_3      16\r\n\r\nI made two changes: \r\n#define LED_1          NRF_GPIO_PIN_MAP(1,8)\r\nand the second change\r\n#define BSP_LED_0      8\r\n\r\nthe original compiled and worked in the Preview -DK using P0.13\r\nafter making this change it compiled and I downloaded it to my board and But I have NO output on port 1.8 \r\n\r\nWhat am I missing ?\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Clock control in RTC interrupt Hi all!\r\n\r\nI am developing an nRF52 application that uses RTC interrupt to measure an ADC value every 100 ms. Depending on the measured value the chip shall either go back to sleep or execute an algorithm. We are in the beginning of the project and one of the first tasks is to evaluate if we can get the power consumption low enough. Currently I am just running the RTC interrupt every 100 ms and then go back to sleep. The current is measured with a Keysight power analyzer and the execution time for the interrupt is measured by toggling a GPIO connected to an oscilloscope. My intention was to just use the internal 32 kHz RC oscillator during the interrupt. The RTC timing measurement however indicates that the interrupt is executed in 2.9 us which makes me suspect that it runs on 64 MHz. Calling nrf_drv_clock_hfclk_is_running() however return false.  During this there is a max peak current of 7.2 mA. Just to execute the interrupt without even starting the SAADC uses around 170 nC which is too much for our needs. Calling nrf_drv_clock_hfclk_is_running() however return false. Anyone that can explain what is happening? Also see code pasted below.\r\n\r\nstatic void rtc_handler(nrf_drv_rtc_int_type_t int_type)\r\n{\r\n    uint32_t err_code;\r\n\r\n    if (nrf_drv_clock_hfclk_is_running())\r\n    {\r\n        nrf_gpio_pin_set(ARDUINO_0_PIN);\r\n    }\r\n    else\r\n    {\r\n        nrf_gpio_pin_set(ARDUINO_1_PIN);\r\n    }\r\n\r\n    if (int_type == NRF_DRV_RTC_INT_COMPARE0)\r\n    {\r\n        err_code = nrf_drv_rtc_cc_set(&rtc,0,RTC_CC_VALUE,true);\r\n        APP_ERROR_CHECK(err_code);\r\n        nrf_drv_rtc_counter_clear(&rtc);\r\n    }\r\n    nrf_gpio_pin_clear(ARDUINO_0_PIN);\r\n    nrf_gpio_pin_clear(ARDUINO_1_PIN);\r\n}\r\n\r\nstatic void rtc_config(void) \r\n{\r\n    uint32_t err_code;\r\n\r\n    //Initialize RTC instance\r\n    nrf_drv_rtc_config_t rtc_config;\r\n    rtc_config.prescaler = RTC_FREQ_TO_PRESCALER(10);\r\n    err_code = nrf_drv_rtc_init(&rtc, &rtc_config, rtc_handler);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\n    err_code = nrf_drv_rtc_cc_set(&rtc,0,1,true);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\n    //Power on RTC instance\r\n    nrf_drv_rtc_enable(&rtc);\r\n}\r\n\r\nint main(void)\r\n{\r\n    lfclk_config();\r\n    \r\n    nrf_gpio_cfg_output(ARDUINO_0_PIN);\r\n    nrf_gpio_cfg_output(ARDUINO_1_PIN);\r\n    \r\n    rtc_config();\r\n\r\n    while (true)\r\n    {\r\n        __WFE();\r\n        __SEV();\r\n        __WFE();\r\n\r\n    }\r\n}\r\n\r\nThanks in advance,\r\nMattias   \r\n\r\n  ",
    "tag": "interrupt"
  },
  {
    "text": "GPIOTE freezes on pin value change I currently have a problem with the gpiote setup. I'm using it to detect an interrupt from mma8652 accelerometer.\r\n\r\nhere is an annotated version with the key portions of the code.\r\n\r\n    pin_event_handler()\r\n    {\r\n        NRF_LOG_INFO(\"\\r\\n PIN 26 triggered \\r\\n\");\r\n        NRF_LOG_FLUSH();\r\n    }\r\n\r\n    static void accel_intrpt_pin_config()\r\n    {\r\n        nrf_drv_gpiote_in_config_t config = GPIOTE_CONFIG_IN_SENSE_HITOLO(true);\r\n        config.pull = NRF_GPIO_PIN_PULLUP;\r\n        err_code = nrf_drv_gpiote_in_init(26, &config, pin_event_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n        nrf_drv_gpiote_in_event_enable(26, false);\r\n    }\r\n\r\n    main()\r\n    {\r\n        // basic inits\r\n        ...\r\n        while (1)\r\n        {\r\n            ...\r\n            // wait for interrupt from accelerometer to trigger pin 26 -- I never get past this\r\n            while(nrf_drv_gpiote_in_is_set(26) == 1)\r\n            {\r\n                nrf_delay_ms(1000); // check every second just to be sure we didn't freeze early\r\n                NRF_LOG_INFO(\"\\r\\n PIN 26 value: %u \\r\\n\",nrf_drv_gpiote_in_is_set(26));\r\n                NRF_LOG_FLUSH();\r\n            }\r\n        }\r\n    }\r\n\r\nthis is the ending uart output after which nothing happens\r\n\r\n    APP:INFO:\r\n    PIN 26 value: 1\r\n    APP:INFO:\r\n    PIN 26 value: 1\r\n    APP:INFO:\r\n    PIN 26 value: 0\r\n\r\nso I see the pin changes but I never get to my trigger comment in the event handler. I'm sure I'm missing something but I haven't really been able to figure out what.  When it reached the point in the code where a change was detected, the whole things stops and when I try to flash the code again to restart it, it freezes at the accelerometer register setup and I have to disconnect to remove the power to the MCU and re-connect to get it going again.\r\n\r\nI was using the pin_change_int example to structure this. This wasn't a very complicated thing so I figured that was all I needed. then I was looking on other solved question and I saw all these other things on interrupt and priorities. Is that necessary?\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Is it possible to creat a pwm with 1sec period Dear All :\r\n\r\nIs it possible to creat a pwm with 1sec period?\r\nSince the lowest frequency of the base clock is 125kHz\uff0cthe top count of the pwm with 1sec period will be 125000(for case of up counter)\u3002But the top count is a uint16_t integer that the maximum value is 65536\u3002\r\n\r\nBesides, I find the available base clock frequency can be \r\n0 - 16 MHz\r\n1 - 8 MHz\r\n2 - 4 MHz\r\n3 - 2 MHz\r\n4 - 1 MHz\r\n5 - 500 kHz\r\n6 - 250 kHz\r\n7 - 125 MHz\r\nin [PWM_DEFAULT_CONFIG_BASE_CLOCK](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk51.v10.0.0%2Findex.html).\r\n\r\nBut I can not find the base clock frequency below 125kHz in the structure nrf_pwm_clk_t (in the example pwm deiver); How can I use a base_clock frequency below 125kHz (Is it possible to change the pwm_clock? )\r\n\r\nThank you for your comment and suggestion\u3002\r\nBest Wishes!",
    "tag": "pwm"
  },
  {
    "text": "LPCOMP and ANADETECT with built-in temperature sensor I an trying to wake the chip and record the temperature readings when temperature reaches a certain threshold (eg: 80 deg C), can this be achieved using built-in temperature sensor? \r\nHas anyone successfully implemented something similar?\r\n\r\nRegards,\r\nSid",
    "tag": "interrupt"
  },
  {
    "text": "52810 PWM control I have intention to use 52810's PWM output to drive motor. The timing requirement are critical so \r\nhardware PWM is essential, rather than CPU generated waveform output. \r\n\r\nI have found some posts on forum discussed about pwm related issue like this link (on 51822 though):\r\n\r\nhttps://devzone.nordicsemi.com/question/16698/does-the-nrf51822-have-a-more-sophisticated-pwm-capability-than-toggling-gpios/\uff09\r\n\r\nSeems 51822 has some problem when comes to hardware PWM. As 52810 is a new chip and has higher hardware profile in spec, so my question is:  is 52810 capable of doing hardware PWM other than GPIO toggling ?\r\n\r\n\r\n",
    "tag": "pwm"
  },
  {
    "text": "Getting lots of NRF_ERROR_RESOURCES on notifications We have an external interrupt every 4ms that collects one 24-bit sample from an analog front end via SPI. After Collecting 6 samples (18 bytes) we send a notification with the data which should then be every 4ms * 6 = 24ms. We're based on the ble_app_template example SDK v13 S132 (nRF52832) with default config settings and MIN_CONN_INTERVAL set to 7.5ms however, We're getting lots of NRF_ERROR_RESOURCES, what could be the problem?\r\n\r\nSend function:\r\n\r\n    SEND_ERROR_CHECK(hrz_ecg_send_channel(&m_ecgs, m_ecgs.ecg_channel_1_handles, hrz_channel1, HRZ_ECGS_MAX_BUFFER_SIZE));\r\n\r\nError check:\r\n\r\n    #define SEND_ERROR_CHECK(ERR_CODE)                                  \\\r\n    do                                                              \\\r\n    {                                                               \\\r\n        const uint32_t LOCAL_ERR_CODE = (ERR_CODE);                 \\\r\n        if (LOCAL_ERR_CODE == NRF_ERROR_RESOURCES) {                \\\r\n          NRF_LOG_ERROR(\"Buffer full\\r\\n\");                         \\\r\n        }                                                           \\\r\n        else if ((LOCAL_ERR_CODE != NRF_SUCCESS) &&                 \\\r\n              (LOCAL_ERR_CODE != NRF_ERROR_INVALID_STATE) &&        \\\r\n              (LOCAL_ERR_CODE != BLE_ERROR_GATTS_SYS_ATTR_MISSING)  \\\r\n            )                                                       \\\r\n          {                                                         \\\r\n              NRF_LOG_ERROR(\"Error code: %d\\r\\n\", LOCAL_ERR_CODE);  \\\r\n              APP_ERROR_HANDLER(LOCAL_ERR_CODE);                    \\\r\n          }                                                         \\\r\n    } while (0)\r\n\r\nBLE_GATTS_EVT_HVN_TX_COMPLETE:\r\n\r\n    case BLE_GATTS_EVT_HVN_TX_COMPLETE:\r\n             NRF_LOG_INFO(\"Buffer free \");\r\n             NRF_LOG_INFO(\"Count: %d\\r\\n\",p_ble_evt->evt.gatts_evt.params.hvn_tx_complete.count);\r\n             break;\r\n\r\nMaximum packets per connection event:\r\n\r\n    memset(&ble_cfg, 0, sizeof ble_cfg);\r\n    ble_cfg.conn_cfg.conn_cfg_tag                     = CONN_CFG_TAG;\r\n    ble_cfg.conn_cfg.params.gatts_conn_cfg.hvn_tx_queue_size = 20;\r\n    err_code = sd_ble_cfg_set(BLE_CONN_CFG_GATTS, &ble_cfg, ram_start);\r\n    APP_ERROR_CHECK(err_code);\r\n\r\nConsole output:\r\n![image description](/attachment/f59a29e493709966e5ce1ef6d2c19bd4)",
    "tag": "interrupt"
  },
  {
    "text": "i could not reset the gpiote pin interrupt i am using nrf51822 s110 sdk7.2.0\r\n\r\n1.i had initialized and configure the gpiote interrupt before mainloop for (pin no 10).\r\n2.i had wrote the process on interrupt handler.\r\n3.got the external interrupt successfully.\r\n4. clear the event in interrupt handler.\r\n5. start to do some function like uart operation in that same pin(pin no.10) \r\n6.if i got interrupt i will send 'U'.\r\n7.after finished uart operation i had cleared interrupt and re enabled interrupt to do next time get external interrupt.\r\n\r\nmy problem is , i could stop the interrupt triggering its always triggering the interrupt. that mean always sending 'U'. From the main loop. once i will transfer 'U' then i need to stop the interrupt.\r\n\r\nplease any one help me.\r\n\r\nmainloop function:-\r\n\r\n    \t\r\n    \t\t\t\tExt_interrupt_enable(CLOSE);\r\n    \t\t\t\thw_UartEnableTx(CLOSE);\r\n    \t\t\t\thw_UartEnableRxNOINT(CLOSE);\r\n    \t\t\t\tExt_interrupt_enable(OPEN);               //FOR INT FROM LOCK & ENCODER\r\n    \t\t\t\r\n    \t\t\t\tif(tUserKey->tUserTsk.Top_tsk==0x00)\r\n    \t\t\t\t{\r\n    \t\t\t\tsleep();\r\n    \t\t\t\t}\t\t\t\r\n     \r\n    gpiote functions:-\r\n    void GPIOTE_IRQHandler()\r\n    {\r\n    \tif ((NRF_GPIOTE->EVENTS_IN[0] == 1) &&\r\n            (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN0_Msk))\r\n        {\r\n           NRF_GPIOTE->EVENTS_IN[0] = 0;\r\n    \t\t\ttUserKey.tUserTsk.Top_tsk=Top_Buttontsk;\r\n    \t\t\ttUserKey.tUserTsk.Buttontsk=bt_scan;\r\n       }\r\n    \t\tif ((NRF_GPIOTE->EVENTS_IN[1] == 1) &&\r\n            (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN1_Msk))\r\n        {\t\t\t\r\n          NRF_GPIOTE->EVENTS_IN[1] = 0;\r\n          //tUserKey.Ext_int_En_flg=1;  //\t\t\t\r\n    \t\t\ttUserKey.tUserTsk.Top_tsk=Top_Buttontsk;\r\n    \t\t\ttUserKey.tUserTsk.Buttontsk=bt_scan;\r\n        }\r\n    \t\tif ((NRF_GPIOTE->EVENTS_IN[2] == 1) &&\r\n            (NRF_GPIOTE->INTENSET & GPIOTE_INTENSET_IN2_Msk))\r\n        {\r\n    \t\t\t//Ext_interrupt_enable(CLOSE);\r\n    \t\t\tNRF_GPIOTE->EVENTS_IN[2] = 0;\r\n    \t\t\ttUserKey.Ext_int_En_flg=1;\r\n    \t\t\ttUserKey.tUserTsk.Top_tsk = Top_Systsk;\r\n    \t\t\ttUserKey.tUserTsk.Systsk |= Sys_LockCharge;\r\n    \t\t\t\tnrf_delay_ms(5);\r\n        }\r\n    }\r\n    \r\n    void gpiote_init(void)\r\n    {\r\n        NRF_GPIOTE->CONFIG[0] = (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos)\r\n                                | (0 << GPIOTE_CONFIG_PSEL_Pos)\r\n                                | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\t\r\n    \t NRF_GPIOTE->CONFIG[1] = (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos)\r\n                                | (1 << GPIOTE_CONFIG_PSEL_Pos)\r\n                                | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\r\n    \tNRF_GPIOTE->CONFIG[2] = (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos)\r\n                                | (10 << GPIOTE_CONFIG_PSEL_Pos)\r\n                                | (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos);\t\r\n    NVIC_EnableIRQ(GPIOTE_IRQn);\r\n    \ttUserKey.Ext_int_En_flg=0;\r\n    }",
    "tag": "interrupt"
  },
  {
    "text": "nrf_pwm_values_individual_t  0x8000 mean? I want to have blinky orange led, \r\n\r\n0 mean on, 0x8000 is off, right? and why??\r\n\r\nI have no idea what's 0x8000 mean!\r\n\r\nso if I want have orange(full-R and half-G), how can i do?\r\n\r\nthanks!\r\n\r\n\r\nThere is the code of red led blinky,\r\nstatic nrf_pwm_values_individual_t seq0_values[]={\r\n\t{0x8000,0x8000,0\t   ,0x8000},\r\n\t{0x8000,0x8000,0         ,0x8000},\r\n\t{0x8000,0x8000,0x8000,0x8000},\r\n\t{0x8000,0x8000,0x8000,0x8000}\r\n};",
    "tag": "pwm"
  },
  {
    "text": "nrf_pwm_values_individual_t pwm RGB LED I want to have blinky orange led, \r\n\r\n0 mean on, 0x8000 is off, right? and why??\r\n\r\nI have no idea what's 0x8000 mean!\r\n\r\nso if I want have orange(full-R and half-G), how can i do?\r\n\r\nthanks!\r\n\r\n\r\nThere is the code of red led blinky,\r\nstatic nrf_pwm_values_individual_t seq0_values[]={\r\n\t{0x8000,0x8000,0\t   ,0x8000},\r\n\t{0x8000,0x8000,0         ,0x8000},\r\n\t{0x8000,0x8000,0x8000,0x8000},\r\n\t{0x8000,0x8000,0x8000,0x8000}\r\n};",
    "tag": "pwm"
  },
  {
    "text": "NVIC check if IRQ is enabled Hi,\r\n\r\nas far as I see, I can enable or disable external interrupts using `NVIC_EnableIRQ()` and `NVIC_DisableIRQ`. Is there a method to check if a specified external interrupt is currently enabled or disabled?\r\n\r\nIs this done by `NVIC_GetActive()`?\r\n\r\nThanks,\r\nTamas",
    "tag": "interrupt"
  },
  {
    "text": "[nRF52832] Unable to configure InterruptIn + PullDown on P0_1 Hello !\r\n\r\nI am currently working on a custom board on which I don't need 32.768kHz. I want to use P0_1 as an interruption pin connected to a pushbutton. The button is connected to VCC so when it's pressed it imposes a high logical level on the GPIO. I configured configured the GPIO to enable the internal pull-down so the low logical level is supposed to be forced when pushbutton is not pressed.\r\n\r\n    bool pressed = false;\r\n     \r\n    void pushbutton1_handler( void )\r\n    {\r\n       pressed = true;\r\n    }\r\n     \r\n    InterruptIn bp1( P0_1 );\r\n     \r\n    int main( void )\r\n    {\r\n       bp1.rise( &pushbutton1_handler );\r\n       bp1.mode( PullDown );\r\n     \r\n       while(1) {\r\n     \r\n          if( pressed == true ) {\r\n             LOG(\"pressed\\r\\n\");\r\n             pressed = false;\r\n          }\r\n       }\r\n    }\r\n\r\n \r\n\r\nI run this code and measure the voltage on P0_1, which is supposed to be grounded, but I measure 3.3V\r\n\r\nIs there a known issue related to this situation ?\r\n\r\nThanks",
    "tag": "interrupt"
  },
  {
    "text": "Attaching Interrupt increases power to 200uA I have a very simple test script which enables a BLE service (only the Generic Access and Attribute), advertises and waits for connection. It also sets four pins to input pins. I am using the Arduino environment and a MDBT40 raytac module.\r\n\r\nDuring that process I get rougly 10uA power consumption.\r\n\r\nUpon connection (within the connection callback) i attach an interrupt to one of those pins. When I do this the current consumption rises to 200 (ish) uA. When the interrupt fires the current consumption goes back to ~10uA.\r\n\r\nI use the following commands before going into waitForEvent mode:\r\n\r\n     NRF_POWER->DCDCEN = 0x00000001;\r\n      NRF_TIMER1->POWER = 0;\r\n      NRF_TIMER2->POWER = 0;     \r\n      NRF_UART0->POWER  = 0;\r\n      NRF_ADC->ENABLE  = (ADC_ENABLE_ENABLE_Disabled << ADC_ENABLE_ENABLE_Pos);\r\n      NRF_ADC->POWER   = 0;   \r\n      NRF_TWI0->POWER   = 0;  \r\n      NRF_TWI1->POWER   = 0; \r\n    //  NRF_GPIOTE->INTENSET = 0;\r\n    //  NRF_GPIOTE->POWER = 0;\r\n    \r\n      NRF_SPI0->ENABLE = 0;\r\n      NRF_SPI0->POWER = 0;\r\n\r\nI really dont understand why attaching an interrupt is causing the power consumption to rise, I then understand even less why when the itnerrupt fires the power consumption drops breifly back to where it is expected to be. Am I missing something obvious? \r\n\r\nEdit 1\r\nI'm using the following code to attach and detach the interrupt. It doesn't change the power if i detach the interrupt and if I never attach the itnerrupt but connect over bluetooth then the power usage does not increase to 200uA\r\n\r\n        void attachInterrupt(uint32_t pin, irqHandle_t handle, uint8_t mode)\r\n    {\r\n        PinName nrf_pin;\r\n    \r\n        nrf_pin = Pin_nRF51822_to_Arduino(pin);\r\n    \r\n        if(nrf_pin == (PinName)NC || handle == NULL )\r\n            return;\r\n    \r\n        if(mode != CHANGE && mode != FALLING && mode != RISING )\r\n            return;\r\n    \r\n        if(mode == CHANGE) {\r\n            pinHandle[(uint32_t)nrf_pin].riseHandle = handle;\r\n            pinHandle[(uint32_t)nrf_pin].fallHandle = handle;\r\n        }\r\n        else if(mode == RISING) {\r\n            pinHandle[(uint32_t)nrf_pin].riseHandle = handle;\r\n            pinHandle[(uint32_t)nrf_pin].fallHandle = NULL;\r\n        }\r\n        else {\r\n            pinHandle[(uint32_t)nrf_pin].riseHandle = NULL;\r\n            pinHandle[(uint32_t)nrf_pin].fallHandle = handle;\r\n        }\r\n    \r\n        gpio_irq_init(&pinHandle[(uint32_t)nrf_pin].gpio_irq, nrf_pin, gpio_irq_handle_cb, (uint32_t)&pinHandle[(uint32_t)nrf_pin]);\r\n        gpio_init_in(&pinHandle[(uint32_t)nrf_pin].gpio, nrf_pin);\r\n    \r\n        if(mode == CHANGE) {\r\n            gpio_irq_set(&pinHandle[(uint32_t)nrf_pin].gpio_irq, IRQ_RISE, 1);\r\n            gpio_irq_set(&pinHandle[(uint32_t)nrf_pin].gpio_irq, IRQ_FALL, 1);\r\n        }\r\n        else if(mode == RISING) {\r\n            gpio_irq_set(&pinHandle[(uint32_t)nrf_pin].gpio_irq, IRQ_RISE, 1);\r\n        }\r\n        else {\r\n            gpio_irq_set(&pinHandle[(uint32_t)nrf_pin].gpio_irq, IRQ_FALL, 1);\r\n        }\r\n    }\r\n    \r\n    \r\n    void detachInterrupt(uint32_t pin )\r\n    {\r\n        PinName nrf_pin;\r\n    \r\n        nrf_pin = Pin_nRF51822_to_Arduino(pin);\r\n    \r\n        gpio_irq_free(&pinHandle[(uint32_t)nrf_pin].gpio_irq);\r\n        memset(&pinHandle[(uint32_t)nrf_pin], 0x00, sizeof(PinHandle_t));\r\n        pinHandle[(uint32_t)nrf_pin].riseHandle = NULL;\r\n        pinHandle[(uint32_t)nrf_pin].fallHandle = NULL;\r\n    }\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "__isr_vector size Hello,\r\n\r\nI just had a look at the gcc_startup_nrf52.S file and now I wonder, what the reason might be for the huge amount of reserved interrupt slots? According to my math, there are 804 bytes reserved. If I have an application and a bootloader on a device, it would sum up to 1,608 bytes. I mean it's not terribly much, but not negligible. Is there a particular reason for this?\r\n\r\nKind regards,\r\n\r\nTorsten",
    "tag": "interrupt"
  },
  {
    "text": "how to detect simultaneous gpio interrupt without high current consumption nRF52832 has errata about gpiote as below.\r\n\r\n    3.29 [97] GPIOTE: High current consumption in System ON Idle mode\r\n\r\nSo I want to use PORT event for gpio interrupt, but PORT event cannot take multiple gpio interrupt.\r\n\r\nMultiple gpio interrupt and low current consumption are must for my product.\r\n\r\nHow can I meet both requirements?\r\n\r\nI saw below questions, but I cannot understand how I should write code.\r\n\r\nWould you show me the sample code that uses PORT event for multiple gpio interrupt?\r\n\r\n[Missing Interrupts on GPIOE PORT events](https://devzone.nordicsemi.com/question/38976/missing-interrupts-on-gpioe-port-events/)\r\n\r\n[GPIOTE handler module or GPIOTE driver for PORT interrupt](https://devzone.nordicsemi.com/question/105056/gpiote-handler-module-or-gpiote-driver-for-port-interrupt/)\r\n\r\n[Gpiote interrupt issue](https://devzone.nordicsemi.com/question/85321/gpiote-interrupt-issue/)\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Changing on_ble_evt interrupt priority Working with: `examples/ble_peripheral/ble_app_uart` . I would like to change `on_ble_evt` priority level so that UART IRQ handler has **lower** priority then softdevice event dispatching routine. \r\n\r\nSo far I checked that there are following IRQ priority levels:\r\n\r\n- UART = 6 (or APP_LOW)\r\n- on_ble_evt = 7 (or APP_LOWEST)\r\n\r\nContext:\r\nI want to synchronise UART and BLE_NUS in a way that UART sends data to NUS and is stalled (in interruption handler) waiting for BLE_NUS to complete. I assume that the completion flag will be set in `on_ble_evt`, then when event handling returns execution context is passed to UART handler.\r\n\r\nHow can I achieve that? ",
    "tag": "interrupt"
  },
  {
    "text": "GPIOTE interrupt not working with softdevice s130 I am using the template example for S130(works fine).\r\nI tried adding a simple Pin interrupt on the code but it didn't call the pin interrupt handler everytime I press the button. I believe I'm using some part of the peripherals that are restricted in S130. Below is my code, I put it before all the BLE initialization.\r\n\r\n\r\n----------\r\n> err_code = nrf_drv_gpiote_init();\r\n\r\n> APP_ERROR_CHECK(err_code);\r\n\r\n> nrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n\r\n> in_config.pull = NRF_GPIO_PIN_PULLDOWN;\r\n\r\n> err_code = nrf_drv_gpiote_in_init(BUTTON_1, &in_config, in_pin_handler);\r\n\r\n> APP_ERROR_CHECK(err_code);\t\r\n\r\n> nrf_drv_gpiote_in_event_enable(BUTTON_1, true);\r\n\r\nAm I missing something? or Is this implementation not applicable with Softdevices. \r\nBTW the code for interrupt works if no support of BLE is added.\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Adding new IRQn to vector table on NRF52/Cortex M4 Hi there,\r\n\r\nI am currently wondering if the following is possible?\r\n\r\nAs stated by the Cortex M4 reference manual states that a system can have 200+ seperate handlers within the vector table. From reading through the NRF52832 datasheet it states that 38 are actually used, this is also backed up within nrf52.h\r\n\r\nBelow can the last one can be seen.\r\n\r\n    FPU_IRQn =  38               /*!<  38  FPU\r\n\r\nNow I was wondering would it be possible for me to extend this enum and add the following:\r\n\r\n    CUSTOM_IRQn = 39\r\n\r\nI have added another handler procedure for this and adjusted the .s file so the reserved entry straight after FPU_IRQn now points to my handler procedure.\r\n\r\nTo test to see if this works I've been attempting to trigger the interrupt using software interrupts as follows:\r\n\r\n    NVIC_SetPriority(CUSTOM_IRQn, 10);\r\n    NVIC_EnableIRQ(CUSTOM_IRQn);\r\n    \r\n    NVIC->STIR = CUSTOM_IRQn;\r\n\r\n\r\nI breakpoint on my handler procedure and it is never called. Is adding custom/new interrupt vectors even possible?\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Timed interrupt Hello everyone, \r\n\r\nI am unexperienced in coding that is why I am asking for your help and oppinions on creating timed interrupt. I am using nrf51822, s110. My goal is to send microcontroler to sleep while disabling all peripherals and saving energy. After 5 minutes of sleep waking up the chip, enabling peripherals, collecting data from sensors, sending device to sleep. So, my question is how could I perform this timed interrupt with the smallest energy consumption? Could I use Timer for this task? Could you provide info how to set up this interrupt for a nrf microcontroler?\r\n\r\nThank you in advance.",
    "tag": "interrupt"
  },
  {
    "text": "Hardware event handler Hello,\r\nI need to connect an event handler (i.e. a function) to two NRF_RADIO events:\r\n-NRF_RADIO->EVENTS_ADDRESS\r\n-NRF_RADIO->EVENTS_READY\r\n\r\nI know I should use the NRF_RADIO interrupt handler, but I can't. I'm using the bluetooth and then the softdevice is running. If I try to enable the interrupts in the NRF_RADIO->INTENSET the device goes into hard fault.\r\n\r\nAnyway I've found a workaround by using PPI and GPIOTE. The PPI toggles an output pin when it receives one of the events, the output pin is externally shorted with an input pin, and this pin is configured to call the handler function.\r\nThe nice thing is that it works, but I don't like to physically short the output an input pins...\r\n\r\nIs there a better way to do it? I mean, is there a way to connect the PPI task end point to an handler function? Or maybe directly connect the NRF_RADIO->EVENTS_x to and handler function? ",
    "tag": "interrupt"
  },
  {
    "text": "RTC_example implementation in ble_app_uart Hello, \r\n\r\nAt this moment I am trying to implement RTC interupt in the ble_app_uart. I use pca10028 board, softdevice 110. My goal is to send my device to System ON sleep mode, from there device is being waken up by rtc interupt every 10 minutes. Unfortunately, I was not able to import part of the code from RTC_example to the ble_app_uart. This is the part I am pasting in ble_app_uart:\r\n\r\n        #define GPIO_TOGGLE_TICK_EVENT    (22)                                 /**< Pin number to toggle when there is a tick event in RTC. */\r\n    #define GPIO_TOGGLE_COMPARE_EVENT (21)                                 /**< Pin number to toggle when there is compare event in RTC. */\r\n    #define LFCLK_FREQUENCY           (32768UL)                               /**< LFCLK frequency in Hertz, constant. */\r\n    #define RTC_FREQUENCY             (8UL)                                   /**< Required RTC working clock RTC_FREQUENCY Hertz. Changable. */\r\n    #define COMPARE_COUNTERTIME       (3UL)                                   /**< Get Compare event COMPARE_TIME seconds after the counter starts from 0. */\r\n    #define COUNTER_PRESCALER         ((LFCLK_FREQUENCY / RTC_FREQUENCY) - 1)   /* f = LFCLK/(prescaler + 1) */\r\n    \r\n    static void rtc_config(void)\r\n    {\r\n        NVIC_EnableIRQ(RTC1_IRQn);                                  // Enable Interrupt for the RTC in the core.\r\n        NRF_RTC1->PRESCALER = COUNTER_PRESCALER;                    // Set prescaler to a TICK of RTC_FREQUENCY.\r\n        NRF_RTC1->CC[0]     = COMPARE_COUNTERTIME * RTC_FREQUENCY;  // Compare0 after approx COMPARE_COUNTERTIME seconds.\r\n    \r\n        // Enable TICK event and TICK interrupt:\r\n        NRF_RTC1->EVTENSET = RTC_EVTENSET_TICK_Msk;\r\n        NRF_RTC1->INTENSET = RTC_INTENSET_TICK_Msk;\r\n    \r\n        // Enable COMPARE0 event and COMPARE0 interrupt:\r\n        NRF_RTC1->EVTENSET = RTC_EVTENSET_COMPARE0_Msk;\r\n        NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;\r\n    }\r\n    \r\n    \r\n    /** @brief Function for Configuring PIN8 and PIN9 as outputs.\r\n     */\r\n    static void gpio_config(void)\r\n    {\r\n        nrf_gpio_cfg_output(GPIO_TOGGLE_TICK_EVENT);\r\n        nrf_gpio_cfg_output(GPIO_TOGGLE_COMPARE_EVENT);\r\n    \r\n        nrf_gpio_pin_write(GPIO_TOGGLE_TICK_EVENT, 0);\r\n        nrf_gpio_pin_write(GPIO_TOGGLE_COMPARE_EVENT, 0);\r\n    }\r\n    \r\n    /** @brief: Function for handling the RTC0 interrupts.\r\n     * Triggered on TICK and COMPARE0 match.\r\n     */\r\n    void RTC1_IRQHandler()\r\n    {\r\n        if ((NRF_RTC1->EVENTS_TICK != 0) &&\r\n            ((NRF_RTC1->INTENSET & RTC_INTENSET_TICK_Msk) != 0))\r\n        {\r\n            NRF_RTC1->EVENTS_TICK = 0;\r\n            nrf_gpio_pin_toggle(GPIO_TOGGLE_TICK_EVENT);\r\n        }\r\n        \r\n        if ((NRF_RTC1->EVENTS_COMPARE[0] != 0) &&\r\n            ((NRF_RTC1->INTENSET & RTC_INTENSET_COMPARE0_Msk) != 0))\r\n        {\r\n            NRF_RTC1->EVENTS_COMPARE[0] = 0;\r\n            nrf_gpio_pin_write(GPIO_TOGGLE_COMPARE_EVENT, 1);\r\n        }\r\n    \t\r\n    }\r\n\r\nHowever, the RTC interupt code works because LEDs are blinking if I place a delay of few seconds long before conn_params_init();. ble_app_uart project was not changed except that RTC1_IRQHandler(void) was commented in app_timer.c to not double initialize this handler. My main looks like this:\r\n\r\n    int main(void)\r\n    {\r\n    \t /*peripherial init*/\r\n        uart_init();\r\n    \t\ttwi_master_init();\r\n    \t\tLIS3DH_accelerometer_init();\r\n    \r\n              /*BlueTooth init*/\r\n    \t       ble_stack_init();  \t\t/*enable SoftDevice s110*/\r\n    \t\t    \r\n    \t\tgpio_config();\r\n    \t\trtc_config();\r\n                NRF_RTC1->TASKS_START = 1; \r\n    \t\r\n    \t\tgap_params_init(); \t\t/*Generic Access Profile lowest layer of BlueTotth stack*/\r\n        services_init();   \t\t/*Add services*/\r\n        advertising_init();\t\t/*Advertising congif*/\r\n        conn_params_init();   /*connection param config*/\r\n        sec_params_init();    /*security param config*/\r\n      \tadvertising_start();\r\n     \r\n    \t\r\n    \t while(1)\r\n    \t\t\t{  \t\t\t\r\n    //\t\tpower_manage();\r\n    \t\t  }\r\n    \t}\r\n\r\n\r\n Otherwise if enter this function while debugging the code jumps from this function to restarting the processor. I was thinking that this function uses the same RTC1 as my LED blinking part but can not find that it uses it. How could I solve this? \r\n\r\nIn addition to this, I was trying to implement app_timer functions: app_timer_create, app_timer_init, app_timer start in the same ble_app_uart code. It did not worked out aswell. I am inexperienced in developing nordic processors, especialy when using a part of code in another one. So, which ones should I use, how and in what order should I place these functions to be able have RTC interupt? I have tried to solve these problems but due to lack of experience I was not succesful. I would appreciate any kind of information or help related to these questions.\r\n\r\nThank you.",
    "tag": "interrupt"
  },
  {
    "text": "Problem with Event and Interrupt in NRF52 ! Hi Forum!\r\nI have to understand NRF52 chip for my job! I used to work with STM32 before. It has \"Interrupt\" (e.g when I receive one byte via SPI, It generates one \"SPI_Rx_Interrupt\". I can implement my code in the callback function(read this byte, toggle led....) ) .But with NRF52 chip. I can't read anything similar. NRF52 has \"Event\". This is a new concept with me! \r\n- I don't know what is \"Event\".\r\n- Do have any relation between \"Event\" and \"Interrupt\"? ( I think \"Yes\" ).\r\n- How is NRF52 chip can detect when the event occurs? ( If I receive one byte via SPI, how is nrf52 detect it?)\r\n- How can I creat \"My_Event\" myself?\r\n\r\nI hope devTeam can help me in all my question because NRF52 code example is very hard to learn. Thanks all!",
    "tag": "interrupt"
  },
  {
    "text": "How can the first interrupt be missed when BUTTON_PULL is set to NRF_GPIO_PIN_PULLDOWN? I'm using the ble_app_multilink_central example app.\r\nIn the pca10400.h I changed #define BUTTON_PULL to NRF_GPIO_PIN_PULLDOWN.\r\n\r\nThe problem is that the first pin interrupt (from low to high) is missed on all the ports. After this the interrupt works fine.\r\nDoes anyone know what this can be and how to solve this?",
    "tag": "interrupt"
  },
  {
    "text": "Nrf51822 stops handling GPIOTE->PORT interrupts Hi engineers, Here we are facing a critical problem in which the NRF51822 stops handling/processing the GPIOTE->PORT interrupts after some days good working. This problem is occurring randomly whereby our system will stop working completely. Then, we have to remove the Battery to restart it again.\r\nWe have two resources on NRF chip that are interrupting on GPIOTE: an Accelerator sensor and a Button.\r\n\r\nWe already are using this button to start advertising and also to show our connection status using LED and as well the accelerator announces the user's movement on GPIOTE->PORT.\r\n\r\nWe are handling these interrupts in low-sensitive mode, means the sensor will keep its interrupt PIN in low until we go to process it by reading the related register and as well to release the PIN in order to capture the further interrupts. \r\n\r\nThe button is connected to another PIN directly and its other side is connected to GND.\r\n\r\n      NRF_GPIO->PIN_CNF[ACC_SENSOR_INT_PIN_NUMBER] =      \\\r\n        (GPIO_PIN_CNF_SENSE_Low << GPIO_PIN_CNF_SENSE_Pos) \\\r\n      | (GPIO_PIN_CNF_DRIVE_S0S1     << GPIO_PIN_CNF_DRIVE_Pos) \\\r\n      | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)  \\\r\n      | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos) \\\r\n      | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos);\r\n      NRF_GPIO->PIN_CNF[BUTTON_0] =      \\\r\n      (GPIO_PIN_CNF_SENSE_Low << GPIO_PIN_CNF_SENSE_Pos) \\\r\n    | (GPIO_PIN_CNF_DRIVE_S0S1     << GPIO_PIN_CNF_DRIVE_Pos) \\\r\n    | (GPIO_PIN_CNF_PULL_Pullup    << GPIO_PIN_CNF_PULL_Pos)  \\\r\n    | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos) \\\r\n    | (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos);\r\n\r\n*****\r\n\r\n    void GPIOTE_IRQHandler(void)\r\n    {\r\n      NRF_GPIOTE->EVENTS_PORT = 0;\r\n      NVIC_ClearPendingIRQ(GPIOTE_IRQn);\r\n      /* Processing button interrupt */\r\n      if((NRF_GPIO->IN & (1<<BUTTON_0))?0:1)/* key pressed */\r\n      {\r\n        nrf_delay_ms(1000);\r\n        if((NRF_GPIO->IN & (1<<BUTTON_0))?0:1)/* key pressed */\r\n        {\r\n          nrf_delay_ms(1000);\r\n          if((NRF_GPIO->IN & (1<<BUTTON_0))?0:1)/* key pressed */\r\n          {\r\n            nrf_delay_ms(1000);\r\n            if((NRF_GPIO->IN & (1<<BUTTON_0))?0:1)/* key pressed */\r\n              NVIC_SystemReset(); // Bye! Use the button to reset when it has pressed down for 3 seconds.\r\n          }\r\n        }\r\n        if(m_conn_handle != BLE_CONN_HANDLE_INVALID) /* is connected */\r\n        {\r\n          InOutSetReset( LED_0, true );\r\n          nrf_delay_ms(3000);\r\n          InOutSetReset( LED_0, false );//It turns on for 3 seconds showing us the connection is active\r\n        }\r\n        else if(bsp_evt_cb)\r\n          bsp_evt_cb(ACC_EVT_WAKE_UP);//Start advertising\r\n      }\r\n      \r\n      \r\n      /* Processing sensor interrupt/registers*/\r\n      //\r\n      ///\r\n      {Sensor registers will be read here.}\r\n      //\r\n      {Sensor will be released here}\r\n    }\r\n\r\nAs a result, we are seeing that our system stops working randomly during a week/day working since we didn't get any interrupt on GPIOTE. It seems there is a similar state on each time having this problem where the Interrupt PIN of the accelerator sensor is yet low. So as we didn't get another interrupt on GPIOTE of both sensor and Button, our system has almost died. \r\n\r\nPlease consider that we are just losing the interrupts, and the NRF51 is alive as we are running a timer that turns LED with 1 minutes interval.\r\n",
    "tag": "interrupt"
  },
  {
    "text": "How to achieve low interrupt latency from sleep ? Hello, i'm using a nRF52840 on a PCA10056 and want to wake up from `__WFE()` with a minimum delay. When i'm using the debugger, i achieve a low latency but without the debugger, the latency is increased by ~14us. What should i do for achieving the same low latency with or without debugger ?",
    "tag": "interrupt"
  },
  {
    "text": "Do interrupts needs to be disabled before erasing / writing flash? The NVMC documentation states the CPU is halted while the NVMC is writing or erasing flash.  If the CPU is halted, then interrupts shouldn't need to be disabled during flash operations, correct?  I'm asking because other micros will halt the CPU during write / erase of flash, but recommend / require that interrupts are disabled.\r\n\r\nDo interrupts need to be disabled before performing flash erase or write?",
    "tag": "interrupt"
  },
  {
    "text": "Extending RTC beyond 24 bits I am looking to extend the RTC beyond 24 bits using the Overflow interrupt.\r\nThe code in the rtc handler would look like:\r\n\r\n    static void rtc_handler(nrf_drv_rtc_int_type_t int_type)\r\n    {\r\n        if (int_type == NRF_DRV_RTC_INT_OVERFLOW)\r\n        {\r\n            ticks_overflow++;\r\n        }\r\n    }\r\n\r\nAnd the code to read the extended timer would look like:\r\n\r\n    uint32_t get_rtc_count()\r\n    {\r\n       return (( ticks_overflow << 24) + nrf_drv_rtc_counter_get(&rtc);\r\n    }\r\n\r\nThis would obviously create a race condition since the overflow interrupt could interrupt the get_rtc_count in the middle of performing the extension. \r\n\r\nNow the obvious approach is to protect the get_rtc_count call with a critical region as in:\r\n\r\n    unit32_t nrf_get_rtc_count()\r\n    {\r\n    \tuint32_t ticks;\r\n    \tsd_nvic_critical_region_enter();\r\n            ticks = ((ticks_overflow<<24) + nrf_drv_rtc_counter_get(&rtc));\r\n    \tsd_nvic_critical_region_exit();\r\n    \treturn (ticks)\r\n    }\r\n\r\nHowever this seems to be overkill since the only interrupt that needs to be disabled during the extension operation is the overflow interrupt. \r\n\r\nSo my question is, can the same operation be safely performed by disabling only the overflow interrupt as in:\r\n\r\n    unit32_t nrf_get_rtc_count()\r\n    {\r\n    \tuint32_t ticks;\r\n    \tnrf_drv_rtc_overflow_disable(&rtc);\r\n        ticks = ((ticks_overflow<<24) + nrf_drv_rtc_counter_get(&rtc));\r\n    \tnrf_drv_rtc_overflow_enable(&rtc,true);\r\n    \treturn (ticks)\r\n    }\r\n\r\nWhat is not clear is, if the overflow is disabled, and an overflow condition occurs while the extension operation is performed, does the interrupt occur once the overflow interrupt is re-enabled? Or has that interrupt essentially been lost?  Thanks in advance for any help. \r\n\r\n \r\n\r\n\r\n\r\n\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Softdevice and interrupt lost Hi everyone,\r\nMy configuration:\r\n\r\n - nrf52832 microcontroller\r\n - Softdevice S132 V4.0.2\r\n - Nordic SDK 13.0\r\n - IDE: Eclipse\r\n\r\nI'm working with a \"Stand-alone can bus controller\" connected to nrf52832 with SPI interface.\r\nThe CAN controller informs nrf52 micro, via an interrupt pin, that a \u201cCAN packet\" was received on the stand-alone controller.\r\nI analyzed that interrupt events are very frequent (about 500us).\r\nInterrupt pin is configured as input interrupt pin using GPIOTE:\r\n\r\n    void can_controller_interrupt_pin_init(uint8_t pin_int)\r\n    {\r\n        ret_code_t err_code;\r\n    \r\n        err_code = nrf_drv_gpiote_init();\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(true);\r\n        in_config.pull = NRF_GPIO_PIN_NOPULL;\r\n    \r\n        err_code = nrf_drv_gpiote_in_init(pin_int, &in_config, can_controller_int_pin_handler);\r\n        APP_ERROR_CHECK(err_code);\r\n    \r\n        nrf_drv_gpiote_in_event_enable(pin_int, true); \r\n    }\r\n\r\nMy problem is:\r\n\r\n - During BT advertising, interrupt requests coming from CAN controller, are correctly detected.\r\n - During BT connection, interrupt requests coming from CAN controller, are discarded.\r\n\r\nIt seems that Softdevice gives high priority to BLE connection and ignore interrupts.\r\n\r\nHow can I resolve this problem, without using a \"polling solution\"?\r\n\r\n\r\nGATT Configuration:\r\n\r\n    #define APP_ADV_INTERVAL                64                                      /**< The advertising interval (in units of 0.625 ms. This value corresponds to 40 ms). */\r\n    #define APP_ADV_TIMEOUT_IN_SECONDS      360                                     /**< The advertising timeout (in units of seconds). */\r\n    \r\n    #define MIN_CONN_INTERVAL               MSEC_TO_UNITS(15, UNIT_1_25_MS)         /**< Minimum acceptable connection interval (20 ms), Connection interval uses 1.25 ms units. */\r\n    #define MAX_CONN_INTERVAL               MSEC_TO_UNITS(75, UNIT_1_25_MS)         /**< Maximum acceptable connection interval (75 ms), Connection interval uses 1.25 ms units. */\r\n    #define SLAVE_LATENCY                   0                                       /**< Slave latency. */\r\n    #define CONN_SUP_TIMEOUT                MSEC_TO_UNITS(6000, UNIT_10_MS)         /**< Connection supervisory timeout (4 seconds), Supervision Timeout uses 10 ms units. */\r\n    #define FIRST_CONN_PARAMS_UPDATE_DELAY  APP_TIMER_TICKS(5000)                   /**< Time from initiating event (connect or start of notification) to first time sd_ble_gap_conn_param_update is called (5 seconds). */\r\n    #define NEXT_CONN_PARAMS_UPDATE_DELAY   APP_TIMER_TICKS(30000)                  /**< Time between each call to sd_ble_gap_conn_param_update after the first call (30 seconds). */\r\n    #define MAX_CONN_PARAMS_UPDATE_COUNT    3                                       /**< Number of attempts before giving up the connection parameter negotiation. */\r\n\r\nSPI Configuration:\r\n\r\n    ret_code_t spi1_init(void)\r\n    {\r\n    \tret_code_t err_code;\r\n    \r\n    \tnrf_drv_spi_config_t spi_config = NRF_DRV_SPI_DEFAULT_CONFIG;\r\n    \r\n    \t/* SPI Parameters */\r\n    \tspi_config.ss_pin   = NRF_DRV_SPI_PIN_NOT_USED;\r\n    \tspi_config.miso_pin = SPIM1_MISO_PIN;\r\n    \tspi_config.mosi_pin = SPIM1_MOSI_PIN;\r\n    \tspi_config.sck_pin  = SPIM1_SCK_PIN;\r\n    \tspi_config.orc  \t= 0x00;\t\t\t\t\t\t\r\n    \tspi_config.frequency = NRF_DRV_SPI_FREQ_4M;\t\t\r\n    \tspi_config.mode      = NRF_DRV_SPI_MODE_0;\r\n    \tspi_config.bit_order = NRF_DRV_SPI_BIT_ORDER_MSB_FIRST;\r\n    \r\n    \tm_spi1.m_spi_instance = spi1;\r\n    \tm_spi1.m_spi_xfer_done = true;\t\t\t\t\t\r\n    \r\n    \t/* Function for initializing the SPI master driver instance. */\r\n    \terr_code = nrf_drv_spi_init(&spi1, \t\t\t\r\n    \t\t\t\t\t\t\t\t&spi_config,    \r\n    \t\t\t\t\t\t\t\tspi1_event_handler,\r\n    \t\t\t\t\t\t\t\tNULL);\r\n    \r\n    \tm_spi1.m_init = (err_code == (NRF_SUCCESS)||NRF_ERROR_INVALID_STATE)? true : false;\r\n    \r\n    \treturn err_code;\r\n    }\r\n\r\nInterrupt routine:\r\n\r\n    void can_controller_int_pin_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)\r\n    {\r\n    \tflag_can_msg = true;\r\n    }\r\n\r\n\r\nMany thanks!\r\n",
    "tag": "interrupt"
  },
  {
    "text": "Interrupt on both PWM edges Hi\r\nIm using the pwm in the NRF52 with the following function:\r\nAPP_ERROR_CHECK(nrf_drv_pwm_init(&m_pwm2, &config2, pwm2_handler));\r\n\r\nin the Interrupt function \"pwm2_handler\" I receive an Interrupt after each full PWM cycle. Is there a possibility to receive an Interrupt as soon as the Ouput goes high (rising edge) and once again if the output goes down (falling edge)?\r\n\r\nThank you",
    "tag": "interrupt"
  }
]